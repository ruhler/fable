
@ Bool@ = /Core/Bool%.Bool@;
% True = /Core/Bool%.True;

@ Char@ = /Core/Char%.Char@;
% Chars = /Core/Char%.Chars;
% IsAlNum = /Core/Char/Type%.IsAlNum;

<@>@ List@ = /Core/List%.List@;
<@>% Nil = /Core/List%.Nil;
<@>% Cons = /Core/List%.Cons;
<@>% List = /Core/List%.List;

<@>@ Maybe@ = /Core/Maybe%.Maybe@;

@ String@ = /Core/String%.String@;
% Str = /Core/String%.Str;
% Strs = /Core/String%.Strs;

@ Unit@ = /Core/Unit%.Unit@;
% Unit = /Core/Unit%.Unit;

@ Loc@ = /Fbld/Loc%.Loc@;

@ Markup@ = /Fbld/Markup%.Markup@;
@ Element@ = /Fbld/Markup%.Element@;
% Plain = /Fbld/Markup%.Plain;

<@>@ M@ = /Fbld/Parse/M%.M@;
<@>% Do = /Fbld/Parse/M%.Do;
<@>% Return = /Fbld/Parse/M%.Return;
<@>% Error = /Fbld/Parse/M%.Error;
<@>% Try_ = /Fbld/Parse/M%.Try_;
<@>% Test = /Fbld/Parse/M%.Test;
<@>% Test_ = /Fbld/Parse/M%.Test_;
% Loc = /Fbld/Parse/M%.Loc;
% Get = /Fbld/Parse/M%.Get;
% String = /Fbld/Parse/M%.String;

(Char@) { Bool@; } IsNameChar = (Char@ c) {
  c.?('_': True);
  IsAlNum(c);
};

# Parses a sequence of zero or more name characters from the start of the
# string.
M@<String@> Name = {
  Maybe@<Char@> mc <- Do(Test(Get));
  mc.?(nothing: Return(Str|''));
  IsNameChar(mc.just).?(false: Return(Str|''));

  Char@ _ <- Do(Get);
  String@ tail <- Do(Name);
  Return(Cons(mc.just, tail));
};

# Parses raw text up to and including '}' for literal args.
M@<String@> Literal = {
  Char@ head <- Do(Get);
  head.?('}': Return(Str|''));

  String@ tail <- Do(Literal);
  Return(Cons(head, tail));
};

M@<Markup@> LiteralArg = {
  Unit@ _ <- Do(String|'{');
  Loc@ l <- Do(Loc);
  String@ text <- Do(Literal);
  Return(List[Plain(l, text)]);
};

M@<Markup@> RegularArg = {
  Unit@ _ <- Do(String|'[');
  M@<Unit@> end = {
    Loc@ l <- Do(Loc);
    Char@ c <- Do(Get);
    c.?(']': Return(Unit));
    Error<Unit@>(l, Str|'Expected '']''');
  };
  Inline(end);
},

# Parses a sequence of zero or more inline args.
M@<List@<Markup@>> Args = {
  Bool@ regular <- Do(Test_(String|'['));
  regular.?(true: {
    Markup@ head <- Do(RegularArg);
    List@<Markup@> tail <- Do(Args);
    Return(Cons(head, tail));
  });

  Bool@ literal <- Do(Test_(String|'{'));
  literal.?(true: {
    Markup@ head <- Do(LiteralArg);
    List@<Markup@> tail <- Do(Args);
    Return(Cons(head, tail));
  });

  Return(Nil<Markup@>);
},

# Parses an inline command, starting just after the '@' character.
M@<Element@> Command = {
  Loc@ l <- Do(Loc);
  String@ name <- Do(Name);
  name.?(nil: Error<Element@>(l, Str|'missing command name'));

  List@<Markup@> args <- Do(Args);
  Return(/Fbld/Markup%.Command(l, name)(args));
},

# Parses inline text.
#
# @arg[end] - Something that parses the end of the inline text.
(M@<Unit@>) { M@<Markup@>; } Inline = (M@<Unit@> end) {
  Bool@ done <- Do(Try_(end));
  done.?(true: Return(Nil<Element@>));

  Loc@ l <- Do(Loc);
  Char@ c <- Do(Get);
  c.?('@': {
    Element@ command <- Do(Command);
    Markup@ tail <- Do(Inline(end));
    Return(Cons(command, tail));
  });

  Char@ h <- Do({
    c.?('\': {
      Loc@ le <- Do(Loc);
      Char@ e <- Do(Get);
      e.?(
        '@': Return(Chars.'@'),
        '[': Return(Chars.'['),
        '\': Return(Chars.'\'),
        ']': Return(Chars.']'),
        'n': Return(Chars.nl));
      Error<Char@>(le, Strs[Str|'Unsupported escape sequence: ''\', Str[e, Chars.'''']]);
    });
    Return(c);
  });
  Markup@ tail <- Do(Inline(end));

  Element@ solo = Plain(l, Str[h]);
  tail.?(nil: Return(List[solo]));
  tail.cons.head.?(plain: {
    Return(Cons(Plain(l, Cons(h, tail.cons.head.plain.text)), tail.cons.tail));
  });
  Return(Cons(solo, tail));
};

@(Inline, Name, Args);
