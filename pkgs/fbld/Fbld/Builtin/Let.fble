
@ Int@ = /Core/Int%.Int@;
% Int = /Core/Int/Lit%.Int;
% Div = /Core/Int/Div%.Div;

<@>@ List@ = /Core/List%.List@;
<@>% Length = /Core/List/Length%.Length;

@ String@ = /Core/String%.String@;
% Str = /Core/String%.Str;

@ Command@ = /Fbld/Command%.Command@;

<@>% Return = /Fbld/Fbld%.Return;
<@>% Error = /Fbld/Fbld%.Error;

@ Markup@ = /Fbld/Markup%.Markup@;
% Block = /Fbld/Markup%.Block;
% Entry = /Fbld/Markup%.Entry;

@ Map@ = /Fbld/Subst%.Map@;
% Subst = /Fbld/Subst%.Subst;
% Insert = /Fbld/Subst%.Insert;
% Empty = /Fbld/Subst%.Empty;

@ Text@ = /Fbld/Text%.Text@;
% StringOf = /Fbld/Text%.StringOf;
% LocOf = /Fbld/Text%.LocOf;

(List@<Text@>, Map@) { Text@; }
Let = (List@<Text@> args, Map@ map) {
  args.cons.tail.?(nil: {
    # This is the last argument: the body. Do the final substitution into the
    # body.
    Subst(map, args.cons.head);
  });

  String@ key = StringOf(args.cons.head);
  Text@ value = args.cons.tail.cons.head;
  List@<Text@> tail = args.cons.tail.cons.tail;
  Let(tail, Insert(map, key, Subst(map, value)));
};

Markup@ Markup = Block[
  # @let[k1][v1][k2][v2]...[kN][vN][body]
  #  Evaluates values v1 through vN as block structured text. Assigns the
  #  results to variable names k1 through kN which are substituted into the v2
  #  through vN and the body using $ syntax before evaluting v2 through vN and
  #  the body as block structured text.
  #
  #  Bindings are evaluated and substituted in sequential order. The value vi
  #  has access to variable definitions for kj where j < i.
  Entry(Str|'let', (Command@ cmd) {
    Int@ num_args = Length(cmd.args);
    /Core/Int/Eq%.Eq(Div(num_args, Int|2).r, Int|1).?(false: {
      Error<Text@>(LocOf(cmd.name), Str|'expected an odd number of arguments');
    });

    Return(Let(cmd.args, Empty));
  })
];

@(Markup);
