
@ Bool@ = /Bool%.Bool@;
% And = /Bool%.And;
% Not = /Bool%.Not;

@ Drawing@ = /Drawing%.Drawing@;
@ Color@ = /Drawing%.Color@;
@ Point@ = /Drawing%.Point@;
% Blank = /Drawing%.Blank;

@ Vec@ = /Graphics/3D%.Vec@;

@ Camera@ = /Graphics/Camera%.Camera@;
% Perspective = /Graphics/Camera%.Perspective;

@ Int@ = /Int/Int%.Int@;
% Mul = /Int/Int%.Mul;
% Le = /Int/Int/Eq%.Le;
% Gt = /Int/Int/Eq%.Gt;
% Ge = /Int/Int/Eq%.Ge;
% Int = /Int/Int/Lit%.Int;

# Draw@ --
#   A function to draw a triangle in 3D.
@ Draw@ = (Camera@, Vec@, Vec@, Vec@, Color@) { Drawing@; };

# Clipped --
#   Draw an already clipped triangle.
Draw@ Clipped = (Camera@ camera, Vec@ a, Vec@ b, Vec@ c, Color@ color) {
  Point@ a_ = Perspective(camera, a);
  Point@ b_ = Perspective(camera, b);
  Point@ c_ = Perspective(camera, c);
  /Graphics/2D%.Triangle(a_, b_, c_, color);
};

# RightOf --
#   Returns true if the point (ax, ay) is to the right of the point (bx, by),
#   or if it is aligned with point (bx, by).
(Int@, Int@, Int@, Int@) { Bool@; }
RightOf = (Int@ ax, Int@ ay, Int@ bx, Int@ by) {
  Ge(Mul(ax, by), Mul(bx, ay));
};

# LeftOf --
#   Returns true if the point (ax, ay) is to the left of the point (bx, by),
#   or if it is aligned with point (bx, by).
(Int@, Int@, Int@, Int@) { Bool@; }
LeftOf = (Int@ ax, Int@ ay, Int@ bx, Int@ by) {
  Le(Mul(ax, by), Mul(bx, ay));
};

@ Sorted@ = *(Vec@ a, Vec@ b, Vec@ c);

# Sort --
#   Sort three vectors based on the predicate p.
#
# Vectors satisfying the predicate are moved to the front and vectors not
# satisfying the predicate are moved to the back. The relative order of points
# is kept in tact to preserve clockwise/counterclockwiseness of the points.
((Vec@) { Bool@; }, Vec@, Vec@, Vec@) { Sorted@; }
Sort = ((Vec@) { Bool@; } p, Vec@ a, Vec@ b, Vec@ c) {
  And(Not(p(a)), p(b)).?(true: @(a: b, b: c, c: a));
  And(Not(p(b)), p(c)).?(true: @(a: c, b: a, c: b));
  @(a, b, c);
};

# ClipLeft --
#   Draw a triangle after clipping any bits too far to the left for the camera
#   to see.
(Draw@) { Draw@; } ClipLeft = (Draw@ draw) {
  # TODO: Actually implement clipping.
  draw;
};

# ClipRight --
#   Draw a triangle after clipping any bits too far to the right for the camera
#   to see.
(Draw@) { Draw@; } ClipRight = (Draw@ draw) {
  # TODO: Actually implement clipping.
  draw;
};

# ClipTop --
#   Draw a triangle after clipping any bits too far to the top for the camera
#   to see.
(Draw@) { Draw@; } ClipTop = (Draw@ draw) {
  # TODO: Actually implement clipping.
  draw;
};

# ClipBottom --
#   Draw a triangle after clipping any bits too far to the bottom for the
#   camera to see.
(Draw@) { Draw@; } ClipBottom = (Draw@ draw) {
  # TODO: Actually implement clipping.
  draw;
};

# ClipBehind --
#   Draw a triangle after clipping any bits behind the camera.
#
# TODO: This shouldn't be needed once the other clipping functions are
# implemented, right?
(Draw@) { Draw@; } ClipBehind = (Draw@ draw) {
  (Vec@) { Bool@; } ZGt0 = (Vec@ p) { Gt(p.z, Int|0); };
  (Camera@ camera, Vec@ a, Vec@ b, Vec@ c, Color@ color) {
    # Rotate the points [a, b, c] such that any points behind the camera are at
    # the end of the list [a, b, c].
    % l = Sort(ZGt0, a, b, c);
    Vec@ a = l.a; Vec@ b = l.b; Vec@ c = l.c;

    # Only draw the triangle if all points are in front of the camera for now.
    Le(c.z, Int|0).?(true: Blank);
    draw(camera, a, b, c, color);
  };
};

# Triangle --
#   Draw a triangle from the point of view of a camera.
#
# The input points should all be from calling /Graphics/Camera%.Vertex with
# the same camera.  That is, the input points are relative to the position and
# orientation of the camera.
(Camera@, Vec@, Vec@, Vec@, Color@) { Drawing@; }
Triangle = {
  ClipBehind(ClipTop(ClipLeft(ClipRight(ClipBottom(Clipped)))));
};

@(Triangle);
