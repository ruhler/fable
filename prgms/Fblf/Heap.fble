
@ Bool@ = /Bool%.Bool@;
% True = /Bool%.True;
% False = /Bool%.False;

@ Bit@ = /Digits%.Bit@;
% B = /Digits%.Bit;

@ Int@ = /Int/Int%.Int@;
% Add = /Int/Int%.Add;
% Sub = /Int/Int%.Sub;
% 0 = /Int/Int%.0;
% Le = /Int/Int/Eq%.Le;
% Ge = /Int/Int/Eq%.Ge;
% Div = /Int/Int/Div%.Div;

% I = /Int/Int/Lit%.I;
% D = /Int/Int/Lit%.D;

<@>@ List@ = /List%.List@;
<@>% Nil = /List%.Nil;
<@>% Cons = /List%.Cons;

<@>@ Maybe@ = /Maybe%.Maybe@;
<@>% Just = /Maybe%.Just;
<@>% Nothing = /Maybe%.Nothing;


# Heap@ --
#   A bit-addressable heap of bits.
#
# This should be treated as an opaque type externally.
#
# Fields:
#   m - The size of 'left' and the address of the first value in 'right'.
@ HeapB@ = *(Heap@ left, Int@ m, Heap@ right),
@ Heap@ = +(Bit@ value, HeapB@ binary);

# Addr@ --
#   The address of a bit on the heap.
@ Addr@ = Int@;

# Heap --
#   Create a heap of at least n uninitialized bits.
(Int@) { Heap@; } Heap = (Int@ n) {
  Le(n, I(D|1)).?(
    true: Heap@(value: B.1),
    false: {
      Int@ m = Div(n, I(D|2));
      Heap@(binary: HeapB@(Heap(m), m, Heap(Sub(n, m))));
    });
};

# Read_ --
#   Read n bits from the bit heap starting at the given address.
#
# Prepends the bits to the given list of bits.
# Behavior is undefined if there are't enough bits in the heap to get n.
(Heap@, Addr@, Int@, List@<Bit@>) { List@<Bit@>; }
Read_ = (Heap@ heap, Addr@ addr, Int@ n, List@<Bit@> tail) {
  heap.?(
    value: Le(n, 0).?(
      true: tail,
      false: Cons<Bit@>(heap.value, tail)),
    binary: {
      Int@ m = Add(addr, n);
      Le(m, heap.binary.m).?(
        true: Read_(heap.binary.left, addr, n, tail),
        false: Ge(addr, heap.binary.m).?(
          true: Read_(heap.binary.right, Sub(addr, heap.binary.m), n, tail),
          false: {
            Int@ nl = Sub(heap.binary.m, addr);
            Int@ nr = Sub(n, nl);
            Read_(heap.binary.left, addr, nl,
              Read_(heap.binary.right, I(D|0), nr, tail));
          }));
    });
};

# Read --
#   Read n bits from the bit heap starting at the given address.
#
# Behavior is undefined if there are't enough bits in the heap to get n.
(Heap@, Addr@, Int@) { List@<Bit@>; }
Read = (Heap@ heap, Addr@ addr, Int@ n) {
  Read_(heap, addr, n, Nil<Bit@>);
};

# Write_ --
#   Set n bits of the bit heap to the bits from the given value.
#
# Returns the updated heap and the list of input bits not yet consumed.
# Behavior is undefined if there are't enough bits in the heap to set n.
(Heap@, Addr@, List@<Bit@>, Int@) { *(Heap@ heap, List@<Bit@> unused); }
Write_ = (Heap@ heap, Addr@ addr, List@<Bit@> bits, Int@ n) {
  heap.?(
    value: Le(n, 0).?(
      true: @(heap: heap, unused: bits),
      false: @(heap: Heap@(value: bits.cons.head), unused: bits.cons.tail)),
    binary: {
      Int@ m = Add(addr, n);
      Le(m, heap.binary.m).?(
        true: {
          % left = Write_(heap.binary.left, addr, bits, n);
          @(heap: Heap@(binary:
                HeapB@(left.heap, heap.binary.m, heap.binary.right)),
            unused: left.unused);
        },
        false: Ge(addr, heap.binary.m).?(
          true: {
            % right = Write_(heap.binary.right, Sub(addr, heap.binary.m), bits, n);
            @(heap: Heap@(binary:
                  HeapB@(heap.binary.left, heap.binary.m, right.heap)),
              unused: right.unused);
          },
          false: {
            Int@ nl = Sub(heap.binary.m, addr);
            Int@ nr = Sub(n, nl);
            % left = Write_(heap.binary.left, addr, bits, nl);
            % right = Write_(heap.binary.right, I(D|0), left.unused, nr);
            @(heap: Heap@(binary: HeapB@(left.heap, heap.binary.m, right.heap)),
              unused: right.unused);
          }));
    });
};

# Write --
#   Assign the first n bits at ptr with the value of the given bits.
#
# Returns the updated Heap for ptr after the assignment.
#
# Behavior is undefined if there aren't n bits to assign from or to.
(Heap@, Addr@, List@<Bit@>, Int@) { Heap@; }
Write = (Heap@ heap, Addr@ addr, List@<Bit@> bits, Int@ n) {
  Write_(heap, addr, bits, n).heap;
};

# Equals_ --
#   Test for n bits worth of equality.
#
# Returns the list of unchecked bits in case of equality.
# Returns Nothing if the bits aren't equal.
#
# Behavior is undefined if there are't enough bits in the heap to set n.
(Heap@, Addr@, List@<Bit@>, Int@) { Maybe@<List@<Bit@>>; }
Equals_ = (Heap@ heap, Addr@ addr, List@<Bit@> bits, Int@ n) {
  heap.?(
    value: Le(n, 0).?(
      true: Just<List@<Bit@>>(bits),
      false: /Digits/Eq%.EqBit(heap.value, bits.cons.head).?(
        true: Just<List@<Bit@>>(bits.cons.tail),
        false: Nothing<List@<Bit@>>)),
    binary: {
      Int@ m = Add(addr, n);
      Le(m, heap.binary.m).?(
        true: Equals_(heap.binary.left, addr, bits, n),
        false: Ge(addr, heap.binary.m).?(
          true: Equals_(heap.binary.right, Sub(addr, heap.binary.m), bits, n),
          false: {
            Int@ nl = Sub(heap.binary.m, addr);
            Int@ nr = Sub(n, nl);
            Maybe@<List@<Bit@>> left = Equals_(heap.binary.left, addr, bits, nl);
            left.?(
              just: Equals_(heap.binary.right, I(D|0), left.just, nr),
              nothing: Nothing<List@<Bit@>>);
          }));
    });
};

# Copy --
#   Assign the first n bits at ptr with the value of the first n bits from val.
#
# Returns the updated Heap after the assignment.
#
# Behavior is undefined if there aren't n bits to assign from or to.
(Heap@, Addr@, Addr@, Int@) { Heap@; }
Copy = (Heap@ heap, Addr@ dest, Addr@ src, Int@ n) {
  Write(heap, dest, Read(heap, src, n), n);
};

# Equals --
#   Return true if the n bits at the given address match the first n given
#   bits.
#
# Behavior is undefined if there aren't enough bits in the heap or list to
# compare.
(Heap@, Addr@, List@<Bit@>, Int@) { Bool@; }
Equals = (Heap@ heap, Addr@ a, List@<Bit@> b, Int@ n) {
  Equals_(heap, a, b, n).?(just: True, nothing: False);
};

# Equal --
#   Return true if the n bits at a and b are the same.
#
# Behavior is undefined if there aren't n bits in a and b to compare.
(Heap@, Addr@, Addr@, Int@) { Bool@; }
Equal = (Heap@ heap, Addr@ a, Addr@ b, Int@ n) {
  Equals(heap, a, Read(heap, b, n), n);
};

@(Heap@, Addr@, Heap, Read, Write, Copy, Equals, Equal);
