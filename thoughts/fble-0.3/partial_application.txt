Partial Application
===================
See thoughts/fble-0.2/partial_application.txt for background.

The motivation is this:
* Do functions currently have to be split into (a)(b) instead of (a, b) to
  work with monadic bind.
* It would be great if we could write Do as (a, b) instead. But then bind gets
  a little wonky in terms of applying a single arg versus adding a single
  argument.
* A clean way to do this in the language we be not to distinguish between
  functions of type (a)(b) and (a, b).

So, seems like there's opportunity to improve performance and clean up the
language by not treating multi-arg functions as different from functions to
functions at the language level.

The sole reason for treating multi-arg functions as different from functions
to functions in fble is performance. Can we use a better implementation that
has comparable performance with functions to functions?

A key difference with the language based approach:
* The type system knows how the function was implemented.

Otherwise the type system doesn't know.

An interesting insight:
* The compiler could track the difference in types without preventing you from
  interchanging them.

For example, say a multi arg function is expected, you provide a function to a
function. Then the compiler automatically inserts a conversion:
   f(a, b) = g(a)(b).

Say a function to function is expected, but you provide a multiarg. Then the
compiler automatically inserts a conversion:
  f(a)(b) = g(a, b)

It worries me that how you write the code could make a difference for
performance for what otherwise should be the same thing.

The other option is to support partial/over application at runtime in an
efficient way.

I would like there to be a clear way to reason about the performance of it.

---

It's probably pretty easy to implement over and under application. I bet we
could just change FbleCall implementation. It would be something like this:

while argc >= func->num_args:
  num_args = func->num_args
  func = func(argv)
  argc -= num_args
  argv += num_args

if argc > 0:
  FblePartialFuncValue(func, argc, args)

Where FblePartialFuncValue is a helper function to allocate a partially
applied function value. We can provide a custom executable for that that
stuffs func and args in statics and knows how to apply the function when given
enough arguments.

I don't expect a big performance hit. We can support over and under
application. I think the idea would be foo(a)(b) gets rewritten to foo(a, b)
as much as possible.

To bring this up, I would want to revert aarch64 to using FbleCall. Decide
later if we want to go back and inline the code again to help with gdb
stepping through the code.

Type inference gets a little interesting. For example, f(x)(y) doesn't give us
access to the type of y for knowing how to apply f(x). But maybe f(x, y) does.

Maybe we say type inference happens at the syntactic boundary, like f(x). So
you can do type inference explicitly. Or maybe we say we always merge
application, so f(x)(y) is treated as f(x, y) and we do type inference there.

Is the type of Do still separate arguments? I think we could automatically
turn this into a multi argument function at runtime for a more efficient
implementation. A function value whose body is a function value, or a poly
of a function value can be compiled to a multi argument function.

So, there are some details to work out, but I think it's worth doing. My
intuition says we really should allow partial and over application of
functions at the fble language level. It gives more flexibility to optimize
performance later on.

I guess I'll have to come up with a clear performance model for it though.
Hmm...

Anyway, if I want to try this, steps would be:

1. Update implementation of FbleCall to support different number of args at
runtime.
2. Update type checker to allow under/over application.
3. Update language spec for details on type inference.

And go from there.

The hope is fbld should run noticeably faster because Result@ Do function is
implemented as a multi argument function instead of a function that returns a
function, so we avoid the extra function object allocation.

