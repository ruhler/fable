@ Bool@ = /Bool%.Bool@;
% True = /Bool%.True;
% Not = /Bool%.Not;
% And = /Bool%.And;

@ Drawing@ = /Drawing%.Drawing@;
% Blank = /Drawing%.Blank;
% Translate = /Drawing%.Translate;

@ Int@ = /Int/Int%.Int@;
% Add = /Int/Int%.Add;
% Neg = /Int/Int%.Neg;
% Mod = /Int/Int/Div%.Mod;
% Eq = /Int/Int/Eq%.Eq;
% Lt = /Int/Int/Eq%.Lt;
% Gt = /Int/Int/Eq%.Gt;
% Int = /Int/Int/Lit%.Int;

% Graphics = /Invaders/Graphics%;

<@>@ Maybe@ = /Maybe%.Maybe@;
<@>% Just = /Maybe%.Just;
<@>% Nothing = /Maybe%.Nothing;

# Ufo@ -- 
# 
# Fields:
#   live - true if the UFO is currently flying, false otherwise.
#   x - the x coordinate of the UFO.
#   v - the x velocity of the UFO.
#   random - the state of our random number generator.
@ Ufo@ = *(
  Bool@ live,
  Int@ x,
  Int@ v,
  Int@ random
);

Int@ MinX = Int|40;
Int@ MaxX = Int|264;

Int@ UfoY = Int|200;

Int@ Height = Int|8;
Int@ Width = Int|16;

# The number of pixels the ufo travels each tick.
Int@ Velocity = Int|1;

Ufo@ Initial = Ufo@(True, MinX, Velocity, Int|1);

# Launch --
#   Launch the UFO from a random direction.
(Ufo@) { Ufo@; } Launch = (Ufo@ ufo) {
  # The intention is to repeat the cycle: LLRLRR, which hopefully will make it
  # seem random, or at least hard for a player to remember where in the cycle
  # we are.
  Int@ state = Mod(ufo.random, Int|6);
  Bool@ from_left = And(Lt(state, Int|4), Not(Eq(state, Int|2)));
  Int@ random = Add(Int|1, ufo.random);
  from_left.?(
    true: Ufo@(True, MinX, Velocity, random),
    false: Ufo@(True, MaxX, Neg(Velocity), random));
};

(Ufo@) { Ufo@; } Tick = (Ufo@ ufo) {
  ufo.live.?(false: ufo);
  Lt(ufo.x, MinX).?(true: Launch(ufo));
  Gt(ufo.x, MaxX).?(true: Launch(ufo));
  Ufo@(True, Add(ufo.x, ufo.v), ufo.v, ufo.random);
};

@ Kill@ = *(Int@ points, Ufo@ ufo);

(Int@, Int@, Ufo@) { Maybe@<Kill@>; } Shoot = (Int@ x, Int@ y, Ufo@ ufo) {
  Lt(y, UfoY).?(true: Nothing<Kill@>);
  Gt(y, Add(UfoY, Height)).?(true: Nothing<Kill@>);
  Lt(x, ufo.x).?(true: Nothing<Kill@>);
  Gt(x, Add(ufo.x, Width)).?(true: Nothing<Kill@>);

  # TODO: vary the points.
  # TODO: wait a while before launching the alien again.
  # TODO: display the points where the alien died.
  Int@ points = Int|50;
  Ufo@ new_ufo = Launch(ufo);
  Just<Kill@>(Kill@(points, new_ufo));
};

(Ufo@) { Drawing@; } Draw = (Ufo@ ufo) {
  ufo.live.?(false: Blank);
  Translate(ufo.x, UfoY, Graphics.Ufo);
};

@(Ufo@, Kill@, Initial, Tick, Shoot, Draw);
