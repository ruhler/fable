
@ Char@ = /Core/Char%.Char@;

<@>@ Maybe@ = /Core/Maybe%.Maybe@;
<@>% Just = /Core/Maybe%.Just;
<@>% Nothing = /Core/Maybe%.Nothing;

@ String@ = /Core/String%.String@;
% Str = /Core/String%.Str;

@ Unit@ = /Core/Unit%.Unit@;
% Unit = /Core/Unit%.Unit;

@ Loc@ = /Fbld/Loc%.Loc@;

<@>@ Result@ = /Fbld/Result%.Result@;
<@>% Ok = /Fbld/Result%.Ok;
<@>% Err = /Fbld/Result%.Err;

@ Text@ = /Fbld/Text%.Text@;
% IsEmpty = /Fbld/Text%.IsEmpty;
% LocOf = /Fbld/Text%.LocOf;
% Head = /Fbld/Text%.Head;
% Tail = /Fbld/Text%.Tail;

<@>@ S@ = <@ T@> { *(Text@ in, T@ x); };

# M@ - A parser monad.
<@>@ M@ = <@ T@>(Text@) { Result@<S@<T@>>; };

# Return the given value.
<@ T@>(T@) { M@<T@>; }
Return = <@ T@>(T@ x)(Text@ in) {
  Ok(S@(in, x));
};

# Report a parse error.
<@ T@>(Text@) { M@<T@>; }
Error = <@ T@>(Text@ msg)(Text@ _) {
  Err<S@<T@>>(msg);
};

# Monadic Do for the parser monad.
<@ A@>(M@<A@>)<@ B@>((A@) { M@<B@>; }) { M@<B@>; }
Do = <@ A@>(M@<A@> ma)<@ B@>((A@) { M@<B@>; } f)(Text@ in) {
  Result@<S@<A@>> ra = ma(in);
  ra.?(err: Err<S@<B@>>(ra.err));
  f(ra.ok.x)(ra.ok.in);
};

# Returns the next character in the input stream without changing the parser
# state.
M@<Maybe@<Char@>> Peek = (Text@ in) {
  Maybe@<Char@> mc = {
    IsEmpty(in).?(true: Nothing<Char@>);
    Just(Head(in));
  };
  Ok(S@(in, mc));
};

# Returns the next two characters in the input stream without changing the
# parser state.
M@<String@> Peek2 = (Text@ in) {
  String@ s = {
    IsEmpty(in).?(true: Str|'');
    Char@ a = Head(in);
    Text@ tail = Tail(in);
    IsEmpty(tail).?(true: Str[a]);
    Str[a, Head(tail)];
  };
  Ok(S@(in, s));
};

# Returns the current location.
M@<Loc@> Loc = (Text@ in) {
  Ok(S@(in, LocOf(in)));
};

# Gets the next character in the input stream, advancing the parser state as
# appropriate.
M@<Maybe@<Char@>> Get = (Text@ in) {
  IsEmpty(in).?(true: Ok(S@(in, Nothing<Char@>)));
  Char@ c = Head(in);
  Ok(S@(Tail(in), Just(c)));
};
  
# Skips the next character in the input stream, advancing the parser state as
# appropriate.
M@<Unit@> Skip = {
  Maybe@<Char@> _ <- Do(Get);
  Return(Unit);
};

# Runs a parser monad on the given input string.
<@ T@>(M@<T@>, Text@) { Result@<T@>; }
Run = <@ T@>(M@<T@> m, Text@ in) {
  Result@<S@<T@>> r = m(in);
  r.?(err: Err<T@>(r.err));
  Ok(r.ok.x);
};

@(M@, Return, Error, Do, Peek, Peek2, Loc, Get, Skip, Run);
