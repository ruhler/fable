
@ Bool@ = /Core/Bool%.Bool@;
% True = /Core/Bool%.True;
% False = /Core/Bool%.False;

@ Int@ = /Core/Int%.Int@;
% Add = /Core/Int%.Add;
% Sub = /Core/Int%.Sub;
% Decr = /Core/Int%.Decr;
% IsZero = /Core/Int/Eq%.IsZero;
% Le = /Core/Int/Eq%.Le;
% Div = /Core/Int/Div%.Div;
% Range = /Core/Int/Iter%.Range;
% CountUpTo = /Core/Int/Iter%.CountUpTo;

<<@>@>@ Monad@ = /Core/Monad%.Monad@;

<@>% Cons = /Core/List%.Cons;
<@>% Nil = /Core/List%.Nil;
<@>% List = /Core/List%.List;
% Take = /Core/List/Length%.Take;

@ VarId@ = /SatGame/Puzzle%.VarId@;
@ Var@ = /SatGame/Puzzle%.Var@;
@ Clause@ = /SatGame/Puzzle%.Clause@;
@ Params@ = /SatGame/Puzzle%.Params@;
@ Puzzle@ = /SatGame/Puzzle%.Puzzle@;

<<@>@>@ Random@ = /SatGame/Random%.Random@;
<<@>@>% RandInt = /SatGame/Random/Int%.RandInt;
<<@>@>% Shuffle = /SatGame/Random/List%.Shuffle;

<<@>@ M@>(Monad@<M@> m, Random@<M@> rand) {
  (VarId@) { M@<VarId@>; } RandVarId = RandInt(m, rand);

  (Int@) { M@<Var@>; } RandVar = (VarId@ max) {
    Bool@ pos <- m.do(rand.bool);
    VarId@ id <- m.do(RandVarId(max));
    m.return(Var@(id, pos));
  };

  (Clause@, VarId@) { Bool@; }
  ContainsVarId = (Clause@ c, VarId@ id) {
    c.?(nil: False);
    /Core/Int/Eq%.Eq(c.cons.head.id, id).?(true: True);
    ContainsVarId(c.cons.tail, id);
  };

  # Generates a random clause with variable v.
  (Params@, Var@) { M@<Clause@>; } GenClause = (Params@ params, Var@ v) {
    # Adds N random variables with id less than v.id to the given clause.
    (Int@, Clause@) { M@<Clause@>; } AddVars = (Int@ n, Clause@ c) {
      IsZero(n).?(true: m.return(c));

      Var@ var <- m.do(RandVar(v.id));
      ContainsVarId(c, var.id).?(true: AddVars(n, c));
      AddVars(Decr(n), Cons(var, c));
    };

    Clause@ clause <- m.do(AddVars(Decr(params.num_vars_per_clause), List[v]));
    Shuffle(m, rand, clause);
  };
    
  # @func[Generate] Generates a random satgame puzzle.
  #  @arg[Params@][params] Parameters for the puzzle to generate.
  #  @returns[M@<Puzzle@>] The generated puzzle.
  (Params@) { M@<Puzzle@>; } Generate = (Params@ p) {
    Le(p.num_vars, p.num_vars_per_clause).?(true: {
      # We can't generate a puzzle unless we have more vars to work with than
      # vars per clause.
      % TooFewVars = /Core/Undef%.Undef<M@<Puzzle@>>;
      TooFewVars.undefined;
    });

    Int@ num_free_vars = Sub(p.num_vars, p.num_vars_per_clause);
    Int@ clauses_per_variable = Div(Decr(Add(num_free_vars, p.num_vars_per_clause)), p.num_vars_per_clause).q;

    Puzzle@ puzzle <- m.do(/Core/Iter%.For(
      Range(p.num_vars_per_clause, p.num_vars), m.return(Nil<Clause@>),
      (VarId@ vid, M@<Puzzle@> mp) {
        /Core/Iter%.For(CountUpTo(clauses_per_variable), mp,
          (Int@ _, M@<Puzzle@> mp) {
            Puzzle@ tail <- m.do(mp);
            Bool@ pos <- m.do(rand.bool);
            Clause@ clause <- m.do(GenClause(p, Var@(vid, pos)));
            m.return(Cons(clause, tail));
          });
      }));
    Puzzle@ shuffled <- m.do(Shuffle(m, rand, puzzle));
    m.return(Take(p.num_clauses, shuffled));
  };

  @(Generate);
};
