
<@>@ List@ = /List%.List@;
<@>@ Maybe@ = /Maybe%.Maybe@;

@ Event@ = /Pinball/Event%.Event@;
% Events = /Pinball/Event%.Events;
% BallEvent = /Pinball/Event%.BallEvent;
% TimeEvent = /Pinball/Event%.TimeEvent;

@ Num@ = /Pinball/Num%.Num@;
% Add = /Pinball/Num%.Add;
% Sub = /Pinball/Num%.Sub;
% Neg = /Pinball/Num%.Neg;
% Mul = /Pinball/Num%.Mul;
% Div = /Pinball/Num%.Div;
% Eq = /Pinball/Num%.Eq;
% Gt = /Pinball/Num%.Gt;
% Ge = /Pinball/Num%.Ge;
% Lt = /Pinball/Num%.Lt;
% Le = /Pinball/Num%.Le;
% Int = /Pinball/Num%.Int;

@ Ball@ = /Pinball/Ball%.Ball@;

@ Edge@ = /Pinball/Edge%.Edge@;
% Dir = /Pinball/Edge%.Dir;
% Length = /Pinball/Edge%.Length;

@ Paddle@ = /Pinball/Paddle%.Paddle@;

% Rotate = /Pinball/Rotate%.Rotate;

@ Linear@ = /Pinball/Quadratic%.Linear@;
@ Quadratic@ = /Pinball/Quadratic%.Quadratic@;
@ Roots@ = /Pinball/Quadratic%.Roots@;
% SubQQ = /Pinball/Quadratic%.SubQQ;
% MulLL = /Pinball/Quadratic%.MulLL;
% Roots = /Pinball/Quadratic%.Roots;

@ Vec@ = /Pinball/Vec%.Vec@;
% AddV = /Pinball/Vec%.AddV;
% SubV = /Pinball/Vec%.SubV;
% MulVS = /Pinball/Vec%.MulVS;
% RotateTo = /Pinball/Vec%.RotateTo;
% RotateFrom = /Pinball/Vec%.RotateFrom;
% Magnitude = /Pinball/Vec%.Magnitude;

# BallCollider@ --
#   Check for and return collision results between a ball and an object.
#
# Returns a time event if there is no collision within the given time.
# If there is a collision, return the ball in the state just after the
# collision at the time of collision.
<@>@ BallCollider@ = <@ T@>(Ball@, T@, Num@) { Event@; };

# BallEdge --
#   Check for and return collision results between a ball and an edge.
#
# Returns Nothing if there is no collision within the given time. If there is a
# collision, return the ball in the state just after the collision at the
# time of collision.
BallCollider@<Edge@> BallEdge = (Ball@ ball, Edge@ edge, Num@ tmax) {
  Event@ NoCollision = TimeEvent(tmax);

  # Verify the ball starts above the edge.
  Vec@ s = RotateTo(Dir(edge), SubV(ball.pos, edge.start));
  Lt(s.y, Int|0).?(true: NoCollision);

  # Verify the ball ends within radius units of the edge.
  Num@ radius = ball.radius;
  Vec@ end = AddV(ball.pos, MulVS(ball.vel, tmax));
  Vec@ e = RotateTo(Dir(edge), SubV(end, edge.start));
  Gt(e.y, radius).?(true: NoCollision);

  # Verify the ball is moving towards the edge instead of away from it.
  Vec@ v = RotateTo(Dir(edge), ball.vel);
  Ge(v.y, Int|0).?(true: NoCollision);

  # Potential collision detected.
  # r = y0 + vt ==>  t = (r-y0)/v
  Num@ t = Lt(s.y, radius).?(true: Int|0, false: Div(Sub(radius, s.y), v.y));

  # Verify the collision happens within the segment of the edge.
  Num@ x = Add(s.x, Mul(v.x, t));
  Lt(x, Int|0).?(true: NoCollision);
  Gt(x, Length(edge)).?(true: NoCollision);

  # Compute the new state just after the collision.
  Vec@ vc = Vec@(v.x, Mul(edge.restitution, Neg(v.y)));
  Vec@ pos = AddV(ball.pos, MulVS(ball.vel, t));
  Vec@ vel = RotateFrom(Dir(edge), vc);
  BallEvent(t, @(pos, vel, radius));
};

BallCollider@<List@<Edge@>>
BallEdgeS = (Ball@ ball, List@<Edge@> edges, Num@ tmax) {
  edges.?(nil: TimeEvent(tmax));
  Events[
    BallEdge(ball, edges.cons.head, tmax),
    BallEdgeS(ball, edges.cons.tail, tmax)
  ];
};

# BallPaddle --
#   Check for and return collision results between a ball and a paddle.
#
# Returns Nothing if there is no collision within the given time. If there is a
# collision, return the ball in the state just after the collision at the
# time of collision.
BallCollider@<Paddle@> BallPaddle = (Ball@ ball, Paddle@ paddle, Num@ tm) {
  # Compute time for the ball to collide with the line of the paddle.
  # We approximate the motion of the line of the paddle as the line from the
  # center of rotation to an end point that travels at constant velocity from
  # the initial paddle's end point to the final paddle's end point.
  #
  # Coordinate systems in use:
  #   a: absolute.
  #     The coordinate system of ball.pos, ball.vel, etc.
  #   p: paddle.
  #     The coordinate system relative to the paddle's resting position. The
  #     center of rotation of the paddle is at the origin. The paddle end
  #     point at paddle position 0 is given by paddle.end.
  #   c: collision.
  #     The coordinate system relative to the line of the paddle at the time
  #     of collision. The center of rotation of the paddle is at the origin.
  #     The end point of the paddle at the paddle's position of collision is
  #     on the +x axis.
  #
  # Times in use:
  #   0: t = 0
  #   h: t = time of collision.
  #   f: t = tm
  #   t: as a function of time t.
  #
  # Other abbreviations:
  #   p: paddle
  #   b: ball
  #   e: end
  #   v: velocity
  #   p: position
  Event@ NoCollision = TimeEvent(tm);
  Num@ radius = ball.radius;

  # Compute the position of the center of the ball as a linear function of
  # time, relative to the center of rotation of the paddle.
  Vec@ bp_p0 = SubV(ball.pos, paddle.center);
  Vec@ bv_p0 = ball.vel;
  Linear@ bx_pt = Linear@(bv_p0.x, bp_p0.x);
  Linear@ by_pt = Linear@(bv_p0.y, bp_p0.y);

  # Compute the position of the end point of the paddle as a linear function
  # of time, scaled by factor tm.
  Vec@ e_p0 = Rotate(paddle.end, paddle.pos);
  Vec@ e_pf = Rotate(paddle.end, Add(paddle.pos, Mul(paddle.vel, tm)));
  Linear@ ex_pt = Linear@(Sub(e_pf.x, e_p0.x), Mul(tm, e_p0.x));
  Linear@ ey_pt = Linear@(Sub(e_pf.y, e_p0.y), Mul(tm, e_p0.y));

  # Compute the distance of the center of the ball from the line of the paddle
  # as a quadratic function of time, scaled by factor tm * l, where l is the
  # length of the paddle.
  Quadratic@ d_pt = SubQQ(MulLL(ex_pt, by_pt), MulLL(ey_pt, bx_pt));

  # Our goal is to find the time when (d - radius) = 0, taking proper scaling
  # into account.
  # Radius scaled by factor tm * l
  Num@ l = Magnitude(paddle.end);
  Quadratic@ r_t = Quadratic@(Int|0, Int|0, Mul(tm, Mul(l, radius)));
  Quadratic@ q_pt = SubQQ(d_pt, r_t);

  Maybe@<Roots@> roots = Roots(q_pt);
  roots.?(nothing: NoCollision);
  Num@ t_h = {
    Lt(roots.just.first, Int|0).?(true: roots.just.second);
    roots.just.first;
  };
  Gt(t_h, tm).?(true: NoCollision);

  # Verify the collision happens within the segment of the edge.
  # We now switch to a coordinate system relative to the edge of the paddle at
  # the time of collision.
  Num@ pp_h = Add(paddle.pos, Mul(paddle.vel, t_h));
  Vec@ e_ph = Rotate(paddle.end, pp_h);
  Vec@ bp_ah = AddV(ball.pos, MulVS(ball.vel, t_h));
  Vec@ bp_ph = SubV(bp_ah, paddle.center);
  Vec@ bp_ch = RotateTo(e_ph, bp_ph);
  Lt(bp_ch.x, Int|0).?(true: NoCollision);
  Gt(bp_ch.x, l).?(true: NoCollision);

  # Verify the ball is moving towards the edge at the time of collision.
  Num@ pv_ch = Mul(bp_ch.x, paddle.vel);   # velocity of paddle
  Vec@ bv_ch = RotateTo(e_ph, bv_p0);      # velocity of ball
  Num@ vy_ch = Sub(pv_ch, bv_ch.y);        # negative relative velocity
  Le(vy_ch, Int|0).?(true: NoCollision);

  # Compute the new state just after the collision.
  Num@ vyr_ch = Mul(paddle.res, vy_ch);           # updated relative velocity
  Vec@ vr_ch = Vec@(bv_ch.x, Add(pv_ch, vyr_ch)); # updated absolute velocity.
  Vec@ v_ah = RotateFrom(e_ph, vr_ch);
  BallEvent(t_h, Ball@(bp_ah, v_ah, radius));
};

BallCollider@<List@<Paddle@>>
BallPaddleS = (Ball@ ball, List@<Paddle@> paddles, Num@ tmax) {
  paddles.?(nil: TimeEvent(tmax));
  Events[
    BallPaddle(ball, paddles.cons.head, tmax),
    BallPaddleS(ball, paddles.cons.tail, tmax)
  ];
};

# PaddleRange --
#   Check for an event where a paddle reaches the end of its range.
(Paddle@, Num@) { Event@; } PaddleRange = (Paddle@ paddle, Num@ tmax) {
  Event@ NoCollision = TimeEvent(tmax);

  Eq(Int|0, paddle.vel).?(true: NoCollision);

  Num@ t = Lt(paddle.vel, Int|0).?(
    true: Div(Sub(paddle.min, paddle.pos), paddle.vel),
    false: Div(Sub(paddle.max, paddle.pos), paddle.vel));
  Events[NoCollision, TimeEvent(t)];
};

# PaddleRangeS --
#   Check for an event where a paddle reaches the end of its range.
(List@<Paddle@>, Num@) { Event@; }
PaddleRangeS = (List@<Paddle@> paddles, Num@ tmax) {
  paddles.?(nil: TimeEvent(tmax));
  Events[
    PaddleRange(paddles.cons.head, tmax),
    PaddleRangeS(paddles.cons.tail, tmax)
  ];
};

@(BallEdge, BallEdgeS, BallPaddle, BallPaddleS, PaddleRange, PaddleRangeS);
