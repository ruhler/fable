
@ Bool@ = /Bool%.Bool@;
% And = /Bool%.And;
% Not = /Bool%.Not;

@ Drawing@ = /Drawing%.Drawing@;
@ Color@ = /Drawing%.Color@;
@ Point@ = /Drawing%.Point@;
% Blank = /Drawing%.Blank;
% Over = /Drawing%.Over;

@ Vec@ = /Graphics/3D%.Vec@;

@ Camera@ = /Graphics/Camera%.Camera@;
@ Rect@ = /Graphics/Camera%.Rect@;
% Perspective = /Graphics/Camera%.Perspective;

@ Int@ = /Int/Int%.Int@;
% Add = /Int/Int%.Add;
% Mul = /Int/Int%.Mul;
% Le = /Int/Int/Eq%.Le;
% Gt = /Int/Int/Eq%.Gt;
% Ge = /Int/Int/Eq%.Ge;
% Int = /Int/Int/Lit%.Int;

@ Unit@ = /Unit%.Unit@;
% Unit = /Unit%.Unit;

# Draw@ --
#   A function to draw a triangle in 3D.
@ Draw@ = (Camera@, Vec@, Vec@, Vec@, Color@) { Drawing@; };

# Clipped --
#   Draw an already clipped triangle.
Draw@ Clipped = (Camera@ camera, Vec@ a, Vec@ b, Vec@ c, Color@ color) {
  Point@ a_ = Perspective(camera, a);
  Point@ b_ = Perspective(camera, b);
  Point@ c_ = Perspective(camera, c);
  /Graphics/2D%.Triangle(a_, b_, c_, color);
};

# RightOf --
#   Returns true if the point (ax, ay) is to the right of the point (bx, by),
#   or if it is aligned with point (bx, by).
(Int@, Int@, Int@, Int@) { Bool@; }
RightOf = (Int@ ax, Int@ ay, Int@ bx, Int@ by) {
  Ge(Mul(ax, by), Mul(bx, ay));
};

# LeftOf --
#   Returns true if the point (ax, ay) is to the left of the point (bx, by),
#   or if it is aligned with point (bx, by).
(Int@, Int@, Int@, Int@) { Bool@; }
LeftOf = (Int@ ax, Int@ ay, Int@ bx, Int@ by) {
  Le(Mul(ax, by), Mul(bx, ay));
};

@ Sorted@ = *(Vec@ a, Vec@ b, Vec@ c);

# Sort --
#   Sort three vectors based on the predicate p.
#
# Vectors satisfying the predicate are moved to the front and vectors not
# satisfying the predicate are moved to the back. The relative order of points
# is kept in tact to preserve clockwise/counterclockwiseness of the points.
((Vec@) { Bool@; }, Vec@, Vec@, Vec@) { Sorted@; }
Sort = ((Vec@) { Bool@; } p, Vec@ a, Vec@ b, Vec@ c) {
  And(Not(p(a)), p(b)).?(true: @(a: b, b: c, c: a));
  And(Not(p(b)), p(c)).?(true: @(a: c, b: a, c: b));
  @(a, b, c);
};

# IntersectX --
#   Returns the point at the intersection of a plane parallel to the Y axis
#   going through points (0, *, 0) and (x, *, z) with the line going through
#   points a and b. Behavior is undefined if no such point exists.
(Int@, Int@, Vec@, Vec@) { Vec@; }
IntersectX = (Int@ x, Int@ z, Vec@ a, Vec@ b) {
  # TODO: Implement me.
  b;
};

# IntersectY --
#   Returns the point at the intersection of a plane parallel to the X axis
#   going through points (*, 0, 0) and (*, y, z) with the line going through
#   points a and b. Behavior is undefined if no such point exists.
(Int@, Int@, Vec@, Vec@) { Vec@; }
IntersectY = (Int@ x, Int@ z, Vec@ a, Vec@ b) {
  # TODO: Implement me.
  b;
};

# Clip --
#   Draw a triangle after clipping any bits too far out of range for the
#   camera to see.
#
# This is a common routine that can be reused for clipping left, right, top,
# or bottom edges.
@ Side@ = +(Unit@ min, Unit@ max);
@ Axis@ = +(Unit@ x, Unit@ y);
(Side@, Axis@, Draw@) { Draw@; } Clip = (Side@ side, Axis@ axis, Draw@ draw) {
  % SideOf = side.?(min: RightOf, max: LeftOf);
  % IntersectXY = axis.?(x: IntersectX, y: IntersectY);
  % Bound = (Rect@ clip) {
    side.?(
      min: axis.?(x: clip.x, y: clip.y),
      max: axis.?(x: Add(clip.x, clip.w), y: Add(clip.y, clip.h)));
  };
  % GetXY = axis.?(x: (Vec@ v) { v.x; }, y: (Vec@ v) { v.y; });

  (Camera@ camera, Vec@ a, Vec@ b, Vec@ c, Color@ color) {
    Int@ bound = Bound(camera.clip);

    (Vec@) { Bool@; } in_bounds = (Vec@ v) {
      SideOf(GetXY(v), v.z, bound, camera.focus);
    };

    % s = Sort(in_bounds, a, b, c);
    Vec@ a = s.a;
    Vec@ b = s.b;
    Vec@ c = s.c;

    in_bounds(c).?(true: {
      # All three points are in bounds. Nothing to clip.
      draw(camera, a, b, c, color);
    });

    in_bounds(b).?(true: {
      # Point c is out of bounds. We need to clip a corner of the triangle.
      Vec@ ca = IntersectXY(bound, camera.focus, c, a);
      Vec@ cb = IntersectXY(bound, camera.focus, c, b);
      Over(
        draw(camera, a, b, cb, color),
        draw(camera, a, cb, ca, color));
    });

    in_bounds(a).?(true: {
      # Points b and c are out of bounds. We need to clip a side of the
      # triangle.
      Vec@ ab = IntersectXY(bound, camera.focus, a, b);
      Vec@ ac = IntersectXY(bound, camera.focus, a, c);
      draw(camera, a, ab, ac, color);
    });

    # None of the points are in bounds. Nothing to draw.
    Blank;
  };
};

# ClipBehind --
#   Draw a triangle after clipping any bits behind the camera.
#
# TODO: This shouldn't be needed once the other clipping functions are
# implemented, right?
(Draw@) { Draw@; } ClipBehind = (Draw@ draw) {
  (Vec@) { Bool@; } ZGt0 = (Vec@ p) { Gt(p.z, Int|0); };
  (Camera@ camera, Vec@ a, Vec@ b, Vec@ c, Color@ color) {
    # Rotate the points [a, b, c] such that any points behind the camera are at
    # the end of the list [a, b, c].
    % l = Sort(ZGt0, a, b, c);
    Vec@ a = l.a; Vec@ b = l.b; Vec@ c = l.c;

    # Only draw the triangle if all points are in front of the camera for now.
    Le(c.z, Int|0).?(true: Blank);
    draw(camera, a, b, c, color);
  };
};

# Triangle --
#   Draw a triangle from the point of view of a camera.
#
# The input points should all be from calling /Graphics/Camera%.Vertex with
# the same camera.  That is, the input points are relative to the position and
# orientation of the camera.
(Camera@, Vec@, Vec@, Vec@, Color@) { Drawing@; }
Triangle = {
  ClipBehind(
  Clip(Side@(min: Unit), Axis@(x: Unit),
  Clip(Side@(min: Unit), Axis@(y: Unit),
  Clip(Side@(max: Unit), Axis@(x: Unit),
  Clip(Side@(max: Unit), Axis@(y: Unit),
  Clipped)))));
};

@(Triangle);
