
import @ { Bit@Bit; Bit1; BoolM=Bool@StdLib; };
import @ { B; Bit2X; };
import BoolM { Bool; And; };

func not(Bit2X a ; Bit2X) {
  Bit2X(not@B(a.hi), not@B(a.lo));
};

func and(Bit2X a, Bit2X b; Bit2X) {
  Bit2X(and@B(a.hi, b.hi), and@B(a.lo, b.lo));
};

func or(Bit2X a, Bit2X b; Bit2X) {
  Bit2X(or@B(a.hi, b.hi), or@B(a.lo, b.lo));
};

func xor(Bit2X a, Bit2X b; Bit2X) {
  Bit2X(xor@B(a.hi, b.hi), xor@B(a.lo, b.lo));
};

func add(Bit2X a, Bit2X b; Bit2X) fulladd(a, b, zero@Bit1()).z;

func zero(; Bit2X) {
  Bit2X(zero@B(), zero@B());
};

func iszero(Bit2X a; Bool) {
   And(iszero@B(a.hi), iszero@B(a.lo));
};

func eq(Bit2X a, Bit2X b; Bool) {
   And(eq@B(a.hi, b.hi), eq@B(a.lo, b.lo));
};

func msb(Bit2X a; Bit) msb@B(a.hi);

func clshift(Bit2X a; Bit2X) lshift(a, msb(a)).z;

struct Result(Bit2X z, Bit cout);

func fulladd(Bit2X a, Bit2X b, Bit cin; Result) {
  Result@B rlo = fulladd@B(a.lo, b.lo, cin);
  Result@B rhi = fulladd@B(a.hi, b.hi, rlo.cout);
  Result(Bit2X(rhi.z, rlo.z), rhi.cout);
};

func lshift(Bit2X a, Bit cin; Result) {
  Result@B rlo = lshift@B(a.lo, cin);
  Result@B rhi = lshift@B(a.hi, rlo.cout);
  Result(Bit2X(rhi.z, rlo.z), rhi.cout);
};
