
struct Unit();

union Bool(Unit true, Unit false);

func True( ; Bool) {
  Bool:true(Unit());
};

func False( ; Bool) {
  Bool:false(Unit());
};

func Not(Bool a; Bool) {
  ?(a; False(), True());
};

func And(Bool a, Bool b ; Bool) {
  ?(a; b, False());
};

union Digit(
    Unit 0, Unit 1, Unit 2, Unit 3, Unit 4,
    Unit 5, Unit 6, Unit 7, Unit 8, Unit 9);

struct DigitP(Digit head, DigitS tail);
union DigitS(Unit nil, DigitP cons);

func IncrD(Digit d ; Digit) {
  ?(d ;
      Digit:1(Unit()), Digit:2(Unit()), Digit:3(Unit()),
      Digit:4(Unit()), Digit:5(Unit()), Digit:6(Unit()),
      Digit:7(Unit()), Digit:8(Unit()), Digit:9(Unit()),
      Digit:0(Unit()));
};

func ZeroDP( ; DigitP) {
  DigitP(Digit:0(Unit()), DigitS:nil(Unit()));
};

# Increment the given list of digits with a carry out. The carry out is
# returned as the most significant digit of the result. It will be either '0'
# or '1'.
func IncrDS(DigitS ds ; DigitP) {
  ?(ds ;
      DigitP(Digit:1(Unit()), DigitS:nil(Unit())),
      {
        DigitP x = IncrDS(ds.cons.tail);
        ?(EqD(x.head, Digit:0(Unit()));
            DigitP(Digit:0(Unit()), DigitS:cons(DigitP(ds.cons.head, x.tail))),
            ?(EqD(ds.cons.head, Digit:9(Unit()));
                DigitP(Digit:1(Unit()), DigitS:cons(DigitP(Digit:0(Unit()), x.tail))),
                DigitP(Digit:0(Unit()), DigitS:cons(DigitP(IncrD(ds.cons.head), x.tail)))));
      });
};

func IncrDP(DigitP dp ; DigitP) {
  DigitP x = IncrDS(DigitS:cons(dp));
  ?(EqD(Digit:0(Unit()), x.head); x.tail.cons, x);
};

func EqD(Digit a, Digit b ; Bool) {
  ?(a; 
      ?(b; True(), False(), False(), False(), False(), False(), False(), False(), False(), False()),
      ?(b; False(), True(), False(), False(), False(), False(), False(), False(), False(), False()),
      ?(b; False(), False(), True(), False(), False(), False(), False(), False(), False(), False()),
      ?(b; False(), False(), False(), True(), False(), False(), False(), False(), False(), False()),
      ?(b; False(), False(), False(), False(), True(), False(), False(), False(), False(), False()),
      ?(b; False(), False(), False(), False(), False(), True(), False(), False(), False(), False()),
      ?(b; False(), False(), False(), False(), False(), False(), True(), False(), False(), False()),
      ?(b; False(), False(), False(), False(), False(), False(), False(), True(), False(), False()),
      ?(b; False(), False(), False(), False(), False(), False(), False(), False(), True(), False()),
      ?(b; False(), False(), False(), False(), False(), False(), False(), False(), False(), True()));
};

func EqDS(DigitS a, DigitS b ; Bool) {
  ?(a; ?(b; True(), False()),
       ?(b; False(), EqDP(a.cons, b.cons)));
};

func EqDP(DigitP a, DigitP b ; Bool) {
  And(EqD(a.head, b.head), EqDS(a.tail, b.tail));
};

func NeqDP(DigitP a, DigitP b ; Bool) {
  Not(EqDP(a, b));
};

# N -- Unary representation of a natural number.
union N(Unit Z, N S);

func ZeroN( ; N) {
  N:Z(Unit());
};

func OneN( ; N) {
  N:S(ZeroN());
};

func DigitN(Digit d ; N) {
  ?(d; ZeroN(), OneN(),
      N:S(DigitN(Digit:1(Unit()))),
      N:S(DigitN(Digit:2(Unit()))),
      N:S(DigitN(Digit:3(Unit()))),
      N:S(DigitN(Digit:4(Unit()))),
      N:S(DigitN(Digit:5(Unit()))),
      N:S(DigitN(Digit:6(Unit()))),
      N:S(DigitN(Digit:7(Unit()))),
      N:S(DigitN(Digit:8(Unit()))));
};

func TenN( ; N) {
  N:S(DigitN(Digit:9(Unit())));
};

func DigitsNAux(DigitS ds, N sum; N) {
  ?(ds ; sum,
         DigitsNAux(ds.cons.tail, AddN(MulN(TenN(), sum), DigitN(ds.cons.head))));
};

func DigitsN(DigitP ds ; N) {
  DigitsNAux(DigitS:cons(ds), ZeroN());
};

func ToDigitsN(N n; DigitP) {
  ?(n ; ZeroDP(), IncrDP(ToDigitsN(n.S)));
};

func AddN(N a, N b; N) {
  ?(a; b, AddN(a.S, N:S(b)));
};

func MulN(N a, N b; N) {
  ?(a; a, AddN(b, MulN(a.S, b)));
};

func EqN(N a, N b; Bool) {
  ?(a;
      ?(b; True(), False()),
      ?(b; False(), EqN(a.S, b.S)));
};

func NeqN(N a, N b; Bool) {
  Not(EqN(a, b));
};

func LtN(N a, N b; Bool) {
  ?(a;
      ?(b; False(), True()),
      ?(b; False(), LtN(a.S, b.S)));
};

# Tests
union TestName(
  Unit EqN_0_0,
  Unit EqN_3_3,
  Unit NeqN_0_3,
  Unit DigitsN_3,
  Unit DigitsN_13,
  Unit DigitsN_123,
  Unit EqDP_0_0,
  Unit EqDP_3_3,
  Unit NeqDP_0_3,
  Unit EqDP_13_13,
  Unit EqDP_123_123,
  Unit ToDigitsN_3,
  Unit ToDigitsN_13,
  Unit ToDigitsN_123,
  Unit MulN_123_321
);

struct TestFailure2N(TestName name, N a, N b);
struct TestFailure2DP(TestName name, DigitP a, DigitP b);
union TestFailure(TestFailure2N 2n, TestFailure2DP 2dp);
union TestResult(Unit passed, TestFailure failed);
struct TestFailureP(TestFailure head, TestFailureS tail);
union TestFailureS(Unit nil, TestFailureP cons);

func T(TestResult result, TestFailureS rest; TestFailureS) {
  ?(result; rest, TestFailureS:cons(TestFailureP(result.failed, rest)));
};

func T_EqN(TestName name, N a, N b; TestResult) {
  ?(EqN(a, b); TestResult:passed(Unit()),
      TestResult:failed(TestFailure:2n(TestFailure2N(name, a, b))));
};

func T_EqDP(TestName name, DigitP a, DigitP b; TestResult) {
  ?(EqDP(a, b); TestResult:passed(Unit()),
      TestResult:failed(TestFailure:2dp(TestFailure2DP(name, a, b))));
};

func T_NeqN(TestName name, N a, N b; TestResult) {
  ?(NeqN(a, b); TestResult:passed(Unit()),
      TestResult:failed(TestFailure:2n(TestFailure2N(name, a, b))));
};

func T_NeqDP(TestName name, DigitP a, DigitP b; TestResult) {
  ?(NeqDP(a, b); TestResult:passed(Unit()),
      TestResult:failed(TestFailure:2dp(TestFailure2DP(name, a, b))));
};

func Test( ; TestFailureS) {
  T({ # 0 == 0
      T_EqN(TestName:EqN_0_0(Unit()), ZeroN(), ZeroN());
    },

  T({ # 3 == 3
      N three = AddN(OneN(), AddN(OneN(), OneN()));
      T_EqN(TestName:EqN_3_3(Unit()), three, three);
    },

  T({ # 0 != 3
      N three = AddN(OneN(), AddN(OneN(), OneN()));
      T_NeqN(TestName:NeqN_0_3(Unit()), ZeroN(), three);
    },

  T({ # 3 == DigitsN("3")
      DigitP threeDP = DigitP(Digit:3(Unit()), DigitS:nil(Unit()));
      N threeN = AddN(OneN(), AddN(OneN(), OneN()));
      T_EqN(TestName:DigitsN_3(Unit()), threeN, DigitsN(threeDP));
    },

  T({ # 13 == DigitsN("13")
      DigitP thirteenDP = DigitP(Digit:1(Unit()), DigitS:cons(
                          DigitP(Digit:3(Unit()), DigitS:nil(Unit()))));
      N threeN = AddN(OneN(), AddN(OneN(), OneN()));
      N thirteenN = AddN(threeN, AddN(threeN, AddN(threeN, AddN(threeN, OneN()))));
      T_EqN(TestName:DigitsN_13(Unit()), thirteenN, DigitsN(thirteenDP));
    },

  T({ # 123 == DigitsN("123")
      DigitP 123DP = DigitP(Digit:1(Unit()), DigitS:cons(
                     DigitP(Digit:2(Unit()), DigitS:cons(
                     DigitP(Digit:3(Unit()), DigitS:nil(Unit()))))));
      N 3N = AddN(OneN(), AddN(OneN(), OneN()));
      N 10N = AddN(OneN(), AddN(3N, AddN(3N, 3N)));
      N 30N = AddN(10N, AddN(10N, 10N));
      N 90N = AddN(30N, AddN(30N, 30N));
      N 123N = AddN(90N, AddN(30N, 3N));
      T_EqN(TestName:DigitsN_123(Unit()), 123N, DigitsN(123DP));
    },

  T({ # 0 == 0 DP
      T_EqDP(TestName:EqDP_0_0(Unit()), ZeroDP(), ZeroDP());
    },

  T({ # 3 == 3 DP
      DigitP three = DigitP(Digit:3(Unit()), DigitS:nil(Unit()));
      T_EqDP(TestName:EqDP_3_3(Unit()), three, three);
    },

  T({ # 0 != 3 DP
      DigitP three = DigitP(Digit:3(Unit()), DigitS:nil(Unit()));
      T_NeqDP(TestName:NeqDP_0_3(Unit()), ZeroDP(), three);
    },

  T({ # 13 == 13 DP
      DigitP 13DP = DigitP(Digit:1(Unit()), DigitS:cons(
                           DigitP(Digit:3(Unit()), DigitS:nil(Unit()))));
      T_EqDP(TestName:EqDP_13_13(Unit()), 13DP, 13DP);
    },

  T({ # 123 == 123 DP
      DigitP 123DP = DigitP(Digit:1(Unit()), DigitS:cons(
                     DigitP(Digit:2(Unit()), DigitS:cons(
                     DigitP(Digit:3(Unit()), DigitS:nil(Unit()))))));
      T_EqDP(TestName:EqDP_123_123(Unit()), 123DP, 123DP);
    },

  T({ # "3" == ToDigitsN(3)
      DigitP three = DigitP(Digit:3(Unit()), DigitS:nil(Unit()));
      T_EqDP(TestName:ToDigitsN_3(Unit()), three, ToDigitsN(DigitsN(three)));
    },

  T({ # "13" == ToDigitsN(13)
      DigitP 13DP = DigitP(Digit:1(Unit()), DigitS:cons(
                           DigitP(Digit:3(Unit()), DigitS:nil(Unit()))));
      T_EqDP(TestName:ToDigitsN_13(Unit()), 13DP, ToDigitsN(DigitsN(13DP)));
    },

  T({ # "123" == ToDigitsN(123)
      DigitP 123DP = DigitP(Digit:1(Unit()), DigitS:cons(
                     DigitP(Digit:2(Unit()), DigitS:cons(
                     DigitP(Digit:3(Unit()), DigitS:nil(Unit()))))));
      T_EqDP(TestName:ToDigitsN_123(Unit()), 123DP, ToDigitsN(DigitsN(123DP)));
    },

  T({ # 123 * 321 == 39483
      DigitP 123DP = DigitP(Digit:1(Unit()), DigitS:cons(
                     DigitP(Digit:2(Unit()), DigitS:cons(
                     DigitP(Digit:3(Unit()), DigitS:nil(Unit()))))));
      N 123N = DigitsN(123DP);

      DigitP 321DP = DigitP(Digit:3(Unit()), DigitS:cons(
                     DigitP(Digit:2(Unit()), DigitS:cons(
                     DigitP(Digit:1(Unit()), DigitS:nil(Unit()))))));
      N 321N = DigitsN(321DP);

      DigitP 39483DP = DigitP(Digit:3(Unit()), DigitS:cons(
                       DigitP(Digit:9(Unit()), DigitS:cons(
                       DigitP(Digit:4(Unit()), DigitS:cons(
                       DigitP(Digit:8(Unit()), DigitS:cons(
                       DigitP(Digit:3(Unit()), DigitS:nil(Unit()))))))))));
      N 39483N = MulN(123N, 321N);

      T_EqDP(TestName:MulN_123_321(Unit()), 39483DP, ToDigitsN(39483N));
    },

  TestFailureS:nil(Unit()))))))))))))))));
};

