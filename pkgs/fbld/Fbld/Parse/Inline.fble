
@ Bool@ = /Core/Bool%.Bool@;
% True = /Core/Bool%.True;
% And = /Core/Bool%.And;

@ Char@ = /Core/Char%.Char@;
% Chars = /Core/Char%.Chars;
% IsAlNum = /Core/Char/Type%.IsAlNum;

@ Int@ = /Core/Int%.Int@;
% Incr = /Core/Int%.Incr;
% Decr = /Core/Int%.Decr;
% Int = /Core/Int/Lit%.Int;

<@>@ List@ = /Core/List%.List@;
<@>% Cons = /Core/List%.Cons;
<@>% Nil = /Core/List%.Nil;
<@>% List = /Core/List%.List;
<@>% Reverse = /Core/List%.Reverse;

<@>@ Maybe@ = /Core/Maybe%.Maybe@;
<@>% Just = /Core/Maybe%.Just;
<@>% Nothing = /Core/Maybe%.Nothing;

@ String@ = /Core/String%.String@;
% Str = /Core/String%.Str;

@ Unit@ = /Core/Unit%.Unit@;

@ Command@ = /Fbld/Command%.Command@;
@ Loc@ = /Fbld/Loc%.Loc@;

@ Text@ = /Fbld/Text%.Text@;
% Text = /Fbld/Text%.Text;
% IsEmpty = /Fbld/Text%.IsEmpty;
% Empty = /Fbld/Text%.Empty;
% LocOf = /Fbld/Text%.LocOf;

<@>@ M@ = /Fbld/Parse/M%.M@;
<@>% Return = /Fbld/Parse/M%.Return;
<@>% Error = /Fbld/Parse/M%.Error;
<@>% Do = /Fbld/Parse/M%.Do;
% Peek = /Fbld/Parse/M%.Peek;
% Loc = /Fbld/Parse/M%.Loc;
% Get = /Fbld/Parse/M%.Get;
% Skip = /Fbld/Parse/M%.Skip;
% ConsM = /Fbld/Parse/M%.ConsM;

# Parses plain text before the next @... command if any.
# Returns the empty string if there is no plain text before the next @...
# command.
M@<Text@> Plain = {
  (Loc@, String@) { M@<Text@>; } plain = (Loc@ l, String@ rplain) {
    Maybe@<Char@> mc <- Do(Peek);
    mc.?(nothing: Return(Text(Reverse(rplain), l)));
    mc.just.?('\': {
      Unit@ _ <- Do(Skip);
      String@ rp = Cons(mc.just, rplain);
      Maybe@<Char@> mb <- Do(Get);
      String@ rp2 = mb.?(just: Cons(mb.just, rp), nothing: rp);
      plain(l, rp2);
    });
    mc.just.?('@': Return(Text(Reverse(rplain), l)));
    Unit@ _ <- Do(Skip);
    plain(l, Cons(mc.just, rplain));
  };

  Loc@ l <- Do(Loc);
  plain(l, Str|'');
};

(Char@) { Bool@; } IsNameChar = (Char@ c) {
  c.?('_': True);
  IsAlNum(c);
};

# Parses a command name from the input, not including a leading '@'.
M@<Text@> Name = {
  (Loc@, String@) { M@<Text@>; } name = (Loc@ l, String@ rname) {
    Maybe@<Char@> mc <- Do(Peek);
    mc.?(nothing: Return(Text(Reverse(rname), l)));
    IsNameChar(mc.just).?(false: Return(Text(Reverse(rname), l)));
    Unit@ _ <- Do(Skip);  
    name(l, Cons(mc.just, rname));
  };

  Loc@ l <- Do(Loc);
  name(l, Str|'');
};

# Parses an explicit argument '[...]'.
M@<Maybe@<Text@>> Arg = {
  (Loc@, Int@) { M@<Text@>; } arg = (Loc@ start, Int@ nest) {
    Loc@ l <- Do(Loc);
    Maybe@<Char@> mc <- Do(Get);
    mc.?(nothing: Error<Text@>(Text(Str|'Unterminated argument', start)));

    Char@ c = mc.just;

    And(/Core/Int/Eq%.IsZero(nest), /Core/Char/Eq%.Eq(c, Chars.']')).?(true: {
      Return(Empty(start));
    });

    ConsM(c, l, {
      c.?('\': {
        Loc@ nl <- Do(Loc);
        Maybe@<Char@> nc <- Do(Get);
        nc.?(nothing: Error<Text@>(Text(Str|'Unterminated argument', start)));

        ConsM(nc.just, nl, arg(start, nest));
      });

      c.?('[': arg(start, Incr(nest)));
      c.?(']': arg(start, Decr(nest)));
      arg(start, nest);
    });
  };

  Maybe@<Char@> mc <- Do(Peek);
  mc.?(nothing: Return(Nothing<Text@>));
  mc.just.?('[': {
    Unit@ _ <- Do(Skip);
    Loc@ l <- Do(Loc);
    Text@ s <- Do(arg(l, Int|0));
    Return(Just(s));
  });
  Return(Nothing<Text@>);
};

# Parses a sequence of arguments.
M@<List@<Text@>> Args = {
  (List@<Text@>) { M@<List@<Text@>>; } args = (List@<Text@> rargs) {
    Maybe@<Text@> arg <- Do(Arg);
    arg.?(nothing: Return(Reverse(rargs)));
    args(Cons(arg.just, rargs));
  };

  args(Nil<Text@>);
};

# Parse a command, starting with '@'.
M@<Maybe@<Command@>> Command = {
  Maybe@<Char@> mc <- Do(Peek);
  mc.?(nothing: Return(Nothing<Command@>));
  mc.just.?('@': {
    Unit@ _ <- Do(Skip);
    Text@ name <- Do(Name);
    List@<Text@> args <- Do(Args);
    Return(Just(Command@(name, args)));
  });
  Return(Nothing<Command@>);
};

# Parse commands from inline structured text.
M@<List@<Command@>> Inline = {
  (List@<Command@>) { M@<List@<Command@>>; }
  inline = (List@<Command@> rcmds) {
    Text@ plain <- Do(Plain);
    List@<Command@> cmds = {
      IsEmpty(plain).?(true: rcmds);
      Cons(Command@(Text(Str|'.inline', LocOf(plain)), List[plain]), rcmds);
    };

    Maybe@<Command@> command <- Do(Command);
    command.?(nothing: Return(Reverse(cmds)));
    inline(Cons(command.just, cmds));
  };

  inline(Nil<Command@>);
};

@(IsNameChar, Name, Args, Inline);
