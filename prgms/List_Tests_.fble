@(Unit_, Bool_, Char_, List_, Test) {
  Unit_ { @(Unit@, Unit); };
  Bool_ { @(Bool@, True, False, And); };
  Char_ { @(Char@, Chars); };
  List_ { @(S@, P@, S0, S1, S4, S5, S6, S7, Append, SortS); };
  Test { @(TestName@, TestResult@, Test@); };

  TestName@ prefix = { Chars; S7<Char@>(S, t, d, L, i, b, period); };

  @ Elem@ = +(Unit@ A, Unit@ B, Unit@ C, Unit@ D, Unit@ E);

  (Elem@, Elem@){Bool@;} ElemLe = (Elem@ a, Elem@ b) {
    ?(a; A: ?(b; A: True,  B: True,  C: True,  D: True,  E: True),
         B: ?(b; A: False, B: True,  C: True,  D: True,  E: True),
         C: ?(b; A: False, B: False, C: True,  D: True,  E: True),
         D: ?(b; A: False, B: False, C: False, D: True,  E: True),
         E: ?(b; A: False, B: False, C: False, D: False, E: True));
  };

  (Elem@, Elem@){Bool@;} ElemEq = (Elem@ a, Elem@ b) {
    ?(a; A: ?(b; A: True,  B: False, C: False, D: False, E: False),
         B: ?(b; A: False, B: True,  C: False, D: False, E: False),
         C: ?(b; A: False, B: False, C: True,  D: False, E: False),
         D: ?(b; A: False, B: False, C: False, D: True,  E: False),
         E: ?(b; A: False, B: False, C: False, D: False, E: True));
  };

  # TODO: Move these to List_ and make it public?
  <@ T@>((T@, T@){Bool@;}, S@<T@>, S@<T@>){Bool@;} SEq =
    <@ T@>((T@, T@){Bool@;} eq, S@<T@> a, S@<T@> b) {
      ?(a; cons: ?(b; cons: PEq<T@>(eq, a.cons, b.cons), nil: False),
           nil: ?(b; cons: False, nil: True));
    },
  <@ T@>((T@, T@){Bool@;}, P@<T@>, P@<T@>){Bool@;} PEq =
    <@ T@>((T@, T@){Bool@;} eq, P@<T@> a, P@<T@> b) {
      And(eq(a.head, b.head), SEq<T@>(eq, a.tail, b.tail));
    };

  Test@ SortTest = Test@(
    Append<Char@>(prefix, { Chars; S4<Char@>(S, o, r, t); }), $({
      S@<Elem@> unsorted = S5<Elem@>
        (Elem@(D: Unit))
        (Elem@(A: Unit))
        (Elem@(B: Unit))
        (Elem@(E: Unit))
        (Elem@(C: Unit));

      S@<Elem@> wnt = S5<Elem@>
        (Elem@(A: Unit))
        (Elem@(B: Unit))
        (Elem@(C: Unit))
        (Elem@(D: Unit))
        (Elem@(E: Unit));

      S@<Elem@> got = SortS<Elem@>(ElemLe, unsorted);
      ?(SEq<Elem@>(ElemEq, wnt, got);
        true: TestResult@(pass: Unit),
        false: TestResult@(fail: { Chars; S6<Char@>(f, a, i, l, e, d); }));
  }));

  @(Tests: S1<Test@>(SortTest));
};
