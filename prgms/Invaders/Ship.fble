
@ Drawing@ = /Drawing%.Drawing@;
% Translate = /Drawing%.Translate;

@ Int@ = /Int/Int%.Int@;
% Add = /Int/Int%.Add;
% Sub = /Int/Int%.Sub;

% Lt = /Int/Int/Eq%.Lt;
% Gt = /Int/Int/Eq%.Gt;

% Int = /Int/Int/Lit%.Int;

% Graphics = /Invaders/Graphics%;

@ Unit@ = /Unit%.Unit@;
% Unit = /Unit%.Unit;

# The ships moves side to side, but not forward or backwards.
# This is the Y coordinate of the bottom edge of the ship.
Int@ ShipY = Int|22;

# The velocity of the ship when it is moving, in pixels per tick.
Int@ ShipV = Int|3;

# The range of values allowed for the left edge of the ship.
Int@ MinX = Int|96;
Int@ MaxX = Int|514;

@ Dir@ = +(
  Unit@ left,
  Unit@ right,
  Unit@ stopped
);

@ Status@ = +(
  Dir@ alive        # Which direction it is going.
);

@ Ship@ = *(
  Int@ x,           # The left edge of the ship
  Status@ status
);
  
# The initial state of the ship.
Ship@ Initial = @(
  x: MinX,
  status: Status@(alive: Dir@(stopped: Unit))
);

# Set the direction of the ship to match the given direction.
(Ship@, Dir@) { Ship@; } Input = (Ship@ s, Dir@ d) {
  @(
    x: s.x,
    status: Status@(alive: d));
};

# Advance the ship one unit of game time.
(Ship@) { Ship@; } Tick = (Ship@ s) {
  s.status.alive.?(
      left: {
        Int@ nx = Sub(s.x, ShipV);
        Lt(nx, MinX).?(
           true: @(x: MinX, status: Status@(alive: Dir@(stopped: Unit))),
           false: @(x: nx, status: s.status));
      },
      right: {
        Int@ nx = Add(s.x, ShipV);
        Gt(nx, MaxX).?(
           true: @(x: MaxX, status: Status@(alive: Dir@(stopped: Unit))),
           false: @(x: nx, status: s.status));
      },
      stopped: s);
};

# Make a drawing of the ship in its current location.
(Ship@) { Drawing@; } Draw = (Ship@ s) {
  Translate(s.x, ShipY, Graphics.Ship);
};

@(Ship@, Dir@, Initial, Input, Tick, Draw);
