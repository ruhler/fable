
@ Bool@ = /Bool%.Bool@;
% Not = /Bool%.Not;

<@>@ Maybe@ = /Maybe%.Maybe@;
<@>% Just = /Maybe%.Just;
<@>% Nothing = /Maybe%.Nothing;

<@>@ List@ = /List%.List@;
<@>% Cons = /List%.Cons;
<@>% Nil = /List%.Nil;

@ Unit@ = /Unit%.Unit@;
% Unit = /Unit%.Unit;

# VarId@ --
#   A variable identifier.
@ VarId@ = /Int/Int%.Int@;
% EqId = /Int/Int/Eq%.Eq;

# Var@ --
#   A variable in a boolean formula.
@ Var@ = *(VarId@ id, Bool@ polarity);
% EqPolarity = /Bool/Eq%.Eq;

# Clause@ --
#   A disjunction (OR) of variables.
@ Clause@ = List@<Var@>;

# Formula@ --
#   A conjunction (AND) of clauses.
@ Formula@ = List@<Clause@>;

# Assignment@ --
#   A sets of variables assigned the values True or False as specified by
#   their polarity.
@ Assignment@ = List@<Var@>;

# Result@ --
#   The result of trying to solve a sat problem.
@ Result@ = +(Assignment@ sat, Unit@ unsat, Unit@ timeout);

# SubstClause --
#   Substitute a value for a variable into the given clause.
#
# Returns the simplified clause, or Nothing if the clause is now satisfied.
(Clause@, Var@) { Maybe@<Clause@>; } SubstClause = (Clause@ c, Var@ v) {
  c.?(
    cons: {
      Var@ head = c.cons.head;
      EqId(head.id, v.id).?(
        true: EqPolarity(head.polarity, v.polarity).?(
          true: Nothing<Clause@>,                 # clause satisfied
          false: SubstClause(c.cons.tail, v)),    # variable eliminated
        false: {
          Maybe@<Clause@> tail = SubstClause(c.cons.tail, v);
          tail.?(
            just: Just<Clause@>(Cons<Var@>(head, tail.just)),
            nothing: Nothing<Clause@>);
        });
    },
    nil: Just<Clause@>(c));
};

# Subst --
#   Substitute a value for a variable into the formula.
(Formula@, Var@) { Formula@; } Subst = (Formula@ f, Var@ v) {
  f.?(
    cons: {
      Maybe@<Clause@> c = SubstClause(f.cons.head, v);
      c.?(
        just: Cons<Clause@>(c.just, Subst(f.cons.tail, v)),
        nothing: Subst(f.cons.tail, v));
    },
    nil: f);
};

# Naive --
#   Naive, brute force sat solver.
#
# Inputs:
#   f - the formula to solve
#   a - the assignments made so far
#
# Returns:
#   A satisfying assignment, or Nothing if the formula is unsatisfiable.
#
# TODO: Make this less naive by using:
#   * unit propagation:
#     prioritize assignments from single variable clauses.
#   * pure literal elimination:
#     prioritize assignments to variables that always have the same polarity.
(Formula@, Assignment@) { Result@; }
Naive = (Formula@ f, Assignment@ a) {
  f.?(
    cons: {
      f.cons.head.?(
        cons: {
          Var@ v = f.cons.head.cons.head;
          Result@ attempted = Naive(
            Subst(f, v),
            Cons<Var@>(v, a));
          attempted.?(
            sat: attempted,
            unsat: {
              Var@ nv = Var@(v.id, Not(v.polarity));
              Naive(Subst(f, nv), Cons<Var@>(nv, a));
            },
            timeout: attempted);
        },
        nil: Result@(unsat: Unit));
    },
    nil: Result@(sat: a));
};

# Solve --
#   Solve a SAT formula.
#
# Returns:
#   The result of trying to solve the sat problem.
(Formula@) { Result@; } Solve = (Formula@ f) {
  Naive(f, Nil<Var@>);
};

@(VarId@, Var@, Clause@, Formula@, Assignment@, Result@,
  EqId, Solve);
