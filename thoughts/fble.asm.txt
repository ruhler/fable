Compiling Fble to Assembly
==========================
The idea of compiling fble to llvm has come up a few times. LLVM seems like a
nice balance between supporting a variety of architectures (arm, arm64, intel,
etc.) and being a low level target. Maybe better to generate LLVM code instead
of C?

Potential advantages:
* We can use something fancier than tcc to compile generated code.
* We have more control over low level code generation, such as storing
  thread->profile in a register to reduce the overhead of disabled profiling.
* We can learn more about llvm, which seems interesting and useful in general.

I don't want to link the llvm libraries, but I would be happy to generate llvm
text IR and have users install and run llc (or whatever) on the result.

First test:
* I expect clang will take too many resources to compile our generated C code.
  Confirm that, then try compiling with clang to llvm text IR and see how much
  time it takes to compile the llvm text IR. Hopefully all the problem with
  clang on the C code goes away by the time we are running llc on the
  generated IR.

---

Results of the first test on /Md5% show that the clang part takes 10s of the
total 2m44s. The llc part takes 1m26s. So, unfortunately, it looks like the
expensive part of using llvm isn't the part we would bypass by generating the
llvm code directly. It takes 3 seconds to assemble the generated .s file.

I don't see any obvious way to make this faster. This is looking to be a
non-starter.

Could I generate arm assembly code directly instead? The main concern with
generating arm code directly is that it limits what platforms we support, but
perhaps there aren't that many to deal with and we could introduce an
abstraction to make it easy to add more?

Let's continue exploring the idea of compiling directly to assembly.

---

Switching from generating C to generating assembly code should be fun. It
gives us an opportunity to improve performance and feels more like a real
language. It's going to be a pain to maintain when I start changing data
structures and I'm going to be unhappy when I try running fble on a different
architecture though. Is it worth it?

For the fun of it and the learning, sure. Why not?

The official justification I can use is something like: gcc and clang cannot
handle the C code I'm generating. That leaves me with just tcc, which we know
produces not great code for a limited number of architectures. I may as well
change that to producing great code for a limited number of architectures.

Now then, where to start?

Concepts to work out how to do:
* Function calls.
* Field access (read and write).
* String literals.
* Loops.
* Switch for pc entry table.

I'm currently running a 32 bit arm OS: armv7l. I suppose we can start there.
First step: figure out how to implement a function:

  int foo(int x) { return x + 1; }

The arm procedure call standard says:
  r15 = pc,
  r14 = lr,
  r13 = sp,
  r12 = ip (intra procedure scratch register),
  r11, r10 = v8, v7,
  r9 = v6, sb, tr,
  r8-r4 = v5-v1,
  r3-r0 = a4-a1 (args/scratch, where r1 and r0 can also be results).

Subroutine must preserve:
 * variable registers: r4-r8, r10, r11, and r9 if used as v6
 * SP

Flags NZCVQ are undefined on entry or return.

Stack is full descending. At interface, it must be 8 byte aligned.

Looks like in my case, int will be returned in r0. And arguments are passed
starting from r0, so all I need to do is increment r0 and return. Something
like:

foo:
  incr r0
  ret
    
Next:
* What is the increment instruction?
  Maybe "add r0, r0, #1"?
* What is the return instruction?
  tcc generates an "ldm fp, {fp, sp, pc}"
  Maybe all we need is to copy lr to pc?
  Yeah, something like "move pc, lr" I bet.
  Or "bx lr" to support going between arm and thumb states.

The assembly code for foo generated by gcc is a bit more complicated.
* It saves the frame point to the stack and updates the framepointer.
* It stores the arg to the stack then reloads it.
* It does the increment on a separate register instead of in place.
* It resets the frame pointer.

But I bet my version will work. There are a bunch of attributes and other
things in the .s file. What are all those? Specifically:
  .arch
  .eabi_attribute
  .fpu
  .file
  .text
  .align
  .global
  .type
  .size 
  .ident 
  .section

Looks like "@" is being used to introduce comments.

Limiting to the following works:

  .arch armv6
  .text
  .align  2
  .global foo
  .type foo, %function
foo:
  add r0, r0, #1
  bx  lr

---
Other things learned:
* rsb r0, r0, #0  can be used for negate (it's reverse subtraction).
* Some instructions, like rsb, you add 'S' to tell it to update the condition
  flags based on the results.
* Many instructions you can append a condition code to conditionally execute
  the instruction. For example, movpl r0, r1 means move r1 to r0 in case the
  condition result is "plus".

How to properly save registers to call another instruction?
* gcc generates stmfd and ldmfd instructions

stmfd sp!, {fp, lr}
  means store multiple registers to a full descending stack.

But it just stores the registers in the list. I guess we don't need to save
caller registers unless we want to use them ourselves first, because the
callee is responsible for saving those for us.

Is that enough to get us going? Should I start trying to write the real fble
compiler to assembly and just figure out the rest from there?

Local variables that would be nice to keep in registers:
* profile, so we can easily disable profiling.
* heap
* thread->stack->locals
* thread->stack->func->statics?
* thread?

Perfect. So, use r0-r3 for scratch, r4-r8 for the five values above. We can
store 'threads' and 'io_activity' on r10, r11 I guess. Or stack if we want
more registers to work with. We can create aliases for these registers so that
it's very convenient to emit code and have them easily updated.


