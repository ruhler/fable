
@ Data@ = /Data%.Data@;
% DUnit = /Data%.Unit;
% Left = /Data%.Left;
% Right = /Data%.Right;
% Product = /Data%.Product;

<@>% Map = /Map%.Map;

<@>@ S@ = /List%.S@;
<@>% S = /List%.S;
<@,@>% ForS = /List%.ForS;

<@>@ Maybe@ = /Maybe%.Maybe@;
<@,@>% For = /Maybe%.For;
<@>% Just = /Maybe%.Just;
<@>% Nothing = /Maybe%.Nothing;

<@>@ Get@ = /Process%.Get@;
<@>@ Put@ = /Process%.Put@;

@ Unit@ = /Unit%.Unit@;
% Unit = /Unit%.Unit;

@ Board@ = /TicTacToe/Board%.Board@;
@ Player@ = /TicTacToe/Board%.Player@;
@ Position@ = /TicTacToe/Board%.Position@;
@ Result@ = /TicTacToe/Board%.Result@;
@ Square@ = /TicTacToe/Board%.Square@;
% BoardStatus = /TicTacToe/Board%.BoardStatus;
% Move = /TicTacToe/Board%.Move;

(Square@) { Data@; } DSquare = {
  Data@ x = Left(Left(DUnit));
  Data@ o = Left(Right(DUnit));
  Data@ e = Right(DUnit);
  (Square@ s) { ?(s; X: x, O: o, E: e); };
};

(Board@) { Data@; } DBoard = {
  (Data@, Data@, Data@) { Data@; } D3 = (Data@ a, Data@ b, Data@ c) {
    Product(Product(a, b), c);
  };

  (Square@, Square@, Square@) { Data@; } DRow = (Square@ a, Square@ b, Square@ c) {
    D3(DSquare(a), DSquare(b), DSquare(c));
  };

  (Board@ b) {
    D3(DRow(b.ul, b.uc, b.ur),
       DRow(b.ml, b.mc, b.mr),
       DRow(b.ll, b.lc, b.lr));
  };
};

(Position@){ Maybe@<Position@>; } NextPosition = (Position@ p) {
  ?(p; UL: Just<Position@>(Position@(UC: Unit)),
       UC: Just<Position@>(Position@(UR: Unit)),
       UR: Just<Position@>(Position@(ML: Unit)),
       ML: Just<Position@>(Position@(MC: Unit)),
       MC: Just<Position@>(Position@(MR: Unit)),
       MR: Just<Position@>(Position@(LL: Unit)),
       LL: Just<Position@>(Position@(LC: Unit)),
       LC: Just<Position@>(Position@(LR: Unit)),
       LR: Nothing<Position@>);
};

# Rotate a board 90 degrees clockwise
(Board@) { Board@; } RotateBoard = (Board@ b) {
  Board@(b.ll, b.ml, b.ul,
         b.lc, b.mc, b.uc,
         b.lr, b.mr, b.ur);
};

# Rotate a position 90 degrees clockwise
(Position@) { Position@; } RotatePosition = (Position@ p) {
  ?(p;
    UL: Position@(UR: Unit), UC: Position@(MR: Unit), UR: Position@(LR: Unit),
    ML: Position@(UC: Unit), MC: Position@(MC: Unit), MR: Position@(LC: Unit),
    LL: Position@(UL: Unit), LC: Position@(ML: Unit), LR: Position@(LL: Unit));
};

# Flip a board horizontally
(Board@) { Board@; } FlipBoard = (Board@ b) {
  Board@(b.ll, b.lc, b.lr,
         b.ml, b.mc, b.mr,
         b.ul, b.uc, b.ur);
};

# Flip a position horizontally
(Position@) { Position@; } FlipPosition = (Position@ p) {
  ?(p;
    UL: Position@(LL: Unit), UC: Position@(LC: Unit), UR: Position@(LR: Unit),
    ML: Position@(ML: Unit), MC: Position@(MC: Unit), MR: Position@(MR: Unit),
    LL: Position@(UL: Unit), LC: Position@(UC: Unit), LR: Position@(UR: Unit));
};


# Re-interpret the result from the perspective of the opposing player.
(Result@){Result@;} FlipResult = (Result@ r) {
  ?(r ; Win:  Result@(Loss: Unit),
        Draw: Result@(Draw: Unit),
        Loss: Result@(Win: Unit));
};

@ PositionResult@ = *(Position@ position, Result@ result);
@ BoardPositionResult@ = *(Board@ board, PositionResult@ pr);

(BoardPositionResult@) { BoardPositionResult@; }
RotateBPR = (BoardPositionResult@ bpr) {
  BoardPositionResult@(RotateBoard(bpr.board),
    PositionResult@(RotatePosition(bpr.pr.position), bpr.pr.result));
};

(BoardPositionResult@) { BoardPositionResult@; }
FlipBPR = (BoardPositionResult@ bpr) {
  BoardPositionResult@(FlipBoard(bpr.board),
    PositionResult@(FlipPosition(bpr.pr.position), bpr.pr.result));
};

# Produce all different symmetrically equivalent board position results of the
# given board position result.
(BoardPositionResult@) { S@<BoardPositionResult@>; }
AllSymmetries = (BoardPositionResult@ bpr) {
  BoardPositionResult@ b0 = bpr;
  BoardPositionResult@ b1 = RotateBPR(b0);
  BoardPositionResult@ b2 = RotateBPR(b1);
  BoardPositionResult@ b3 = RotateBPR(b2);
  BoardPositionResult@ f0 = FlipBPR(b0);
  BoardPositionResult@ f1 = RotateBPR(f0);
  BoardPositionResult@ f2 = RotateBPR(f1);
  BoardPositionResult@ f3 = RotateBPR(f2);
  S<BoardPositionResult@>([b0, b1, b2, b3, f0, f1, f2, f3]);
};

(PositionResult@, PositionResult@) { PositionResult@; }
ChooseBestPosition = (PositionResult@ a, PositionResult@ b) {
  Result@ ra = a.result;
  Result@ rb = b.result;
  ?(ra; Win: a,
        Draw: ?(rb; Win: b, Draw: a, Loss: a),
        Loss: b);
};

(Maybe@<PositionResult@>, Maybe@<PositionResult@>) { Maybe@<PositionResult@>; }
ChooseBestMaybePosition = (Maybe@<PositionResult@> a, Maybe@<PositionResult@> b) {
  ?(a; just:
        ?(b; just: Just<PositionResult@>(ChooseBestPosition(a.just, b.just)),
             nothing: a),
       nothing: b);
};

# Map from Board to the best next move to make on that board and the expected
# game result from playing there.
% BoardMap = Map<Board@>(DBoard);
@ MemoTable@ = BoardMap.Map@<PositionResult@>;
% Empty = BoardMap.Empty<PositionResult@>;
% Lookup = BoardMap.Lookup<PositionResult@>;
% Insert = BoardMap.Insert<PositionResult@>;

<@>@ MemoState@ = <@ T@>{ *(MemoTable@ memo, T@ data); };

# Return the expected result of the game for player 'x', assuming player 'x'
# has just moved and that both players play optimally.
(MemoTable@, Board@, Player@){MemoState@<Result@>;}
ExpectedResult = (MemoTable@ m, Board@ b, Player@ x) {
  ?(BoardStatus(b);
      X: MemoState@<Result@>(m,
          ?(x; X: Result@(Win: Unit), O: Result@(Loss: Unit))),
      O: MemoState@<Result@>(m,
          ?(x; X: Result@(Loss: Unit), O: Result@(Win: Unit))),
      D: MemoState@<Result@>(m, Result@(Draw: Unit)),
      E: {
        Player@ o = ?(x; X: Player@(O: Unit), O: Player@(X: Unit));
        MemoState@<PositionResult@> move = ChooseBestMove(m, b, o);
        MemoState@<Result@>(move.memo, FlipResult(move.data.result));
      }
   );
},

# Return the expected result of player 'x' moving at position 'p' on board
# 'b'. Returns Nothing if the player 'x' cannot move at position 'p' on board
# 'b'.
(MemoTable@, Board@, Player@, Position@){MemoState@<Maybe@<PositionResult@>>;}
MoveResult = (MemoTable@ m, Board@ b, Player@ x, Position@ p) {
  Maybe@<Board@> moved = Move(b, p, x);
  ?(moved;
    just: {
      MemoState@<Result@> result = ExpectedResult(m, moved.just, x);
      MemoState@<Maybe@<PositionResult@>>(
        result.memo,
        Just<PositionResult@>(PositionResult@(p, result.data)));
    },
    nothing: MemoState@<Maybe@<PositionResult@>>(m, Nothing<PositionResult@>));
},

# Choose the best move for player 'x' on the given board.
# The results are undefined if there are no moves left to make.
(MemoTable@, Board@, Player@){MemoState@<PositionResult@>;}
ChooseBestMove = (MemoTable@ m, Board@ b, Player@ x) {
  Maybe@<PositionResult@> cached = Lookup(m, b);
  ?(cached;
    just: MemoState@<PositionResult@>(m, cached.just),
    nothing: {
      MemoState@<Maybe@<PositionResult@>> best =
        For<Position@, MemoState@<Maybe@<PositionResult@>>>(
          Position@(UL: Unit),
          MemoState@<Maybe@<PositionResult@>>(m, Nothing<PositionResult@>),
          NextPosition,
          (Position@ p, MemoState@<Maybe@<PositionResult@>> best) {
            MemoState@<Maybe@<PositionResult@>> curr = MoveResult(best.memo, b, x, p);
            MemoState@<Maybe@<PositionResult@>>(
              curr.memo,
              ChooseBestMaybePosition(best.data, curr.data));
        });

      MemoTable@ newMemo =
        ForS<BoardPositionResult@, MemoTable@>(
          AllSymmetries(BoardPositionResult@(b, best.data.just)),
          best.memo,
          (BoardPositionResult@ bpr, MemoTable@ m) {
            Insert(m, bpr.board, bpr.pr);
        });

      MemoState@<PositionResult@>(newMemo, best.data.just);
    });
};

MemoTable@ InitialAI = {
  # TODO: It takes a couple of minute to pre-compute the AI.
  # Still too slow to enable. :(
  # ChooseBestMove(Empty, EmptyBoard, Player@(X: Unit)).memo;
  Empty;
};

@ Turn@ = *(Board@ board, Player@ player);

(MemoTable@, Get@<Maybe@<Turn@>>, Put@<Position@>){ Unit@!; }
RunAI = (MemoTable@ ai, Get@<Maybe@<Turn@>> get, Put@<Position@> put) {
  Maybe@<Turn@> mturn := get;
  ?(mturn;
     just: {
       Turn@ turn = mturn.just;
       MemoState@<PositionResult@> mpr = ChooseBestMove(ai, turn.board, turn.player);
       Unit@ _ := put(mpr.data.position);
       RunAI(mpr.memo, get, put);
     },
     nothing: $(Unit));
};

# A TicTacToe AI that will pick a position when it is the given player's turn
# to move on the given board.
@ AI@ = (Board@, Player@) { Position@!; };

# Execute a process with access to a TicTacToe AI.
<@ T@>((AI@){ T@!;}){ T@!; } WithAI = <@ T@>((AI@){ T@!;} p) {
  Maybe@<Turn@> ~ get_turn, put_turn;
  Position@ ~ get_position, put_position;

  AI@ ai = (Board@ board, Player@ player) {
    Unit@ _ := put_turn(Just<Turn@>(Turn@(board, player)));
    get_position;
  };

  Unit@ _ := RunAI(InitialAI, get_turn, put_position),
  T@ result := {
    T@ result := p(ai); 
    Unit@ _ := put_turn(Nothing<Turn@>);
    $(result);
  };
  $(result);
};

@(AI@, WithAI);
