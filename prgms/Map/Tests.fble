
@ Bool@ = /Bool%.Bool@;
% True = /Bool%.True;
% False = /Bool%.False;
% And = /Bool%.And;
% Not = /Bool%.Not;

@ Char@ = /Char%.Char@;
% Chars = /Char%.Chars;

<@>@ S@ = /List%.S@;
<@>% S = /List%.S;
<@>% S0 = /List%.S0;
<@>% ConsS = /List%.ConsS;
<@>% Append = /List%.Append;

<@>@ Maybe@ = /Maybe%.Maybe@;

@ Str@ = /String%.Str@;
% Str = /String%.Str;

@ Test@ = /Test%.Test@;
@ TestResult@ = /Test%.TestResult@;

@ Unit@ = /Unit%.Unit@;
% Unit = /Unit%.Unit;

% Product = /Data%.Product;
% Left = /Data%.Left;
% Right = /Data%.Right;
% DUnit = /Data%.Unit;

<@>% Map = /Map%.Map;

@ Bit1@ = +(Unit@ 0, Unit@ 1);
@ Bit2@ = *(Bit1@ h, Bit1@ l);

Bit2@ A = Bit2@(Bit1@(0: Unit), Bit1@(0: Unit));
Bit2@ B = Bit2@(Bit1@(0: Unit), Bit1@(1: Unit));
Bit2@ C = Bit2@(Bit1@(1: Unit), Bit1@(0: Unit));

(Bit1@, Bit1@) { Bool@; } EqBit1 = (Bit1@ a, Bit1@ b) {
  a.?(0: b.?(0: True, 1: False),
      1: b.?(0: False, 1: True));
};

(Bit2@, Bit2@) { Bool@; } EqBit2 = (Bit2@ a, Bit2@ b) {
  And(EqBit1(a.h, b.h), EqBit1(a.l, b.l));
};

% MapBit2 = Map<Bit2@>((Bit2@ x) {
  Product(
    x.h.?(0: Left(DUnit), 1: Right(DUnit)),
    x.l.?(0: Left(DUnit), 1: Right(DUnit)));
});
<@>@ Map@ = MapBit2.Map@;
<@>% Empty = MapBit2.Empty;
<@>% Lookup = MapBit2.Lookup;
<@>% Insert = MapBit2.Insert;
<@, @>% For = MapBit2.For;


S@<Test@> Tests = {
  (Str@){Str@;} name = (Str@ nm) {
    Append<Char@>(Str(Chars|'Map.'), nm);
  };

  S<Test@>([
    Test@(name(Str(Chars|'empty')), $({
      Lookup<Unit@>(Empty<Unit@>, B).?(
        just: TestResult@(fail:
          Str(Chars|'Lookup found something in an empty map')),
        nothing: TestResult@(pass: Unit));
    })),

    Test@(name(Str(Chars|'not found')), $({
      Map@<Unit@> map = Insert<Unit@>(Empty<Unit@>, C, Unit);
      Lookup<Unit@>(map, B).?(
        just: TestResult@(fail:
          Str(Chars|'Lookup found B in a map with only C')),
        nothing: TestResult@(pass: Unit));
    })),

    Test@(name(Str(Chars|'found')), $({
      Map@<Bool@> map = Insert<Bool@>(Insert<Bool@>(Insert<Bool@>(Empty<Bool@>,
        A, False),
        B, True),
        C, False);
      Maybe@<Bool@> mv = Lookup<Bool@>(map, B);
      mv.?(
        just:
          mv.just.?(
            true: TestResult@(pass: Unit),
            false: TestResult@(fail:
              Str(Chars|'Wrong value found for B.'))
          ),
        nothing: TestResult@(fail:
          Str(Chars|'Failed to find B in map.')));
    })),

    Test@(name(Str(Chars|'replace')), $({
      Map@<Bool@> map = Insert<Bool@>(Insert<Bool@>(Empty<Bool@>,
        B, False),
        B, True);
      Maybe@<Bool@> mv = Lookup<Bool@>(map, B);
      mv.?(
        just:
          mv.just.?(
            true: TestResult@(pass: Unit),
            false: TestResult@(fail:
              Str(Chars|'Wrong value found for B.'))
          ),
        nothing: TestResult@(fail:
          Str(Chars|'Failed to find B in map.')));
    })),

    Test@(name(Str(Chars|'for')), $({
      Map@<Bool@> map =
        Insert<Bool@>(
          Insert<Bool@>(
            Insert<Bool@>(Empty<Bool@>,
              B, True),
            A, True),
          B, False);
      @ Entry@ = *(Bit2@ key, Bool@ value);
      S@<Entry@> entries = For<Bool@, S@<Entry@>>(map, S0<Entry@>,
        (Bit2@ k, Bool@ v, S@<Entry@> l) {
          ConsS<Entry@>(Entry@(k, v), l);
        });

      entries.?(
        cons:
          entries.cons.tail.?(
            cons:
              entries.cons.tail.cons.tail.?(
                cons: TestResult@(fail: Str(Chars|'Too many entries.')),
                nil: {
                  % _ = EqBit2(A, entries.cons.head.key).?(
                    true: @(a: entries.cons.head, 
                            b: entries.cons.tail.cons.head),
                    false: @(a: entries.cons.tail.cons.head, 
                             b: entries.cons.head));
                  And(And(EqBit2(A, _.a.key), EqBit2(B, _.b.key)),
                        And(_.a.value, Not(_.b.value))).?(
                    true: TestResult@(pass: Unit),
                    false: TestResult@(fail: Str(Chars|'key/value mismatch'))
                  );
                }),
            nil: TestResult@(fail: Str(Chars|'Only 1 entry iterated over.'))),
        nil: TestResult@(fail: Str(Chars|'No entries iterated over.')));
    }))
  ]);
};

@(Tests);
