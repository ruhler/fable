
@ Bool@ = /Core/Bool%.Bool@;
% True = /Core/Bool%.True;
% False = /Core/Bool%.False;

@ Char@ = /Core/Char%.Char@;
% IsNewline = /Core/Char/Type%.IsNewline;

@ Int@ = /Core/Int%.Int@;
% Incr = /Core/Int%.Incr;
% Int = /Core/Int/Lit%.Int;

<@>@ Maybe@ = /Core/Maybe%.Maybe@;
<@>% Just = /Core/Maybe%.Just;
<@>% Nothing = /Core/Maybe%.Nothing;

<@>@ List@ = /Core/List%.List@;
<@>% Cons = /Core/List%.Cons;
<@>% Nil = /Core/List%.Nil;

@ String@ = /Core/String%.String@;
% Str = /Core/String%.Str;
% Strs = /Core/String%.Strs;

@ Unit@ = /Core/Unit%.Unit@;
% Unit = /Core/Unit%.Unit;

@ Loc@ = /Fbld/Loc%.Loc@;
% Advance = /Fbld/Loc%.Advance;
% Unknown = /Fbld/Loc%.Unknown;

<@>@ Result@ = /Fbld/Result%.Result@;
<@>% Ok = /Fbld/Result%.Ok;
<@>% Err = /Fbld/Result%.Err;

@ Text@ = /Fbld/Text%.Text@;
% Text = /Fbld/Text%.Text;

@ CharL@ = *(Char@ c, Loc@ l);

# S@ - State for parser monad.
@ S@ = List@<CharL@>;

# R@ - Reader for parser monad.
@ R@ = *(S@ s, Int@ indent);

# State monad for parser monad.
<@>@ SM@ = <@ T@> { *(S@ s, T@ x); };

# M@ - A parser monad.
<@>@ M@ = <@ T@>(R@) { Result@<SM@<T@>>; };

# M_@ - Variant on parser monad where we don't care about the error message.
<@>@ M_@ = <@ T@>(R@) { Maybe@<SM@<T@>>; };

<@ T@>(M_@<T@>) { M@<T@>; }
M = <@ T@>(M_@<T@> m_)(R@ r) {
  Maybe@<SM@<T@>> result = m_(r);
  result.?(just: Ok(result.just));
  Err<SM@<T@>>(Text(Unknown, Str|'unknown error'));
};

<@ T@>(M@<T@>) { M_@<T@>; }
M_ = <@ T@>(M@<T@> m)(R@ r) {
  Result@<SM@<T@>> result = m(r);
  result.?(ok: Just(result.ok));
  Nothing<SM@<T@>>;
};

# Return the given value.
<@ T@>(T@) { M@<T@>; }
Return = <@ T@>(T@ x)(R@ r) {
  Ok(SM@(r.s, x));
};

# Return the given value.
<@ T@>(T@) { M_@<T@>; }
Return_ = <@ T@>(T@ x)(R@ r) {
  Just(SM@(r.s, x));
};

# Report a parse error.
<@ T@>(Loc@, String@) { M@<T@>; }
Error = <@ T@>(Loc@ l, String@ msg)(R@ _) {
  Err<SM@<T@>>(Text(l, msg));
};

# A parse error.
<@ T@> { M_@<T@>; }
Error_ = <@ T@>(R@ _) {
  Nothing<SM@<T@>>;
};

# Monadic Do for the parser monad.
<@ A@>(M@<A@>)<@ B@>((A@) { M@<B@>; }) { M@<B@>; }
Do = <@ A@>(M@<A@> ma)<@ B@>((A@) { M@<B@>; } f)(R@ r) {
  Result@<SM@<A@>> ra = ma(r);
  ra.?(err: Err<SM@<B@>>(ra.err));
  f(ra.ok.x)(r.@(s: ra.ok.s));
};

# Monadic Do for the parser monad.
<@ A@>(M_@<A@>)<@ B@>((A@) { M_@<B@>; }) { M_@<B@>; }
Do_ = <@ A@>(M_@<A@> ma)<@ B@>((A@) { M_@<B@>; } f)(R@ r) {
  Maybe@<SM@<A@>> ra = ma(r);
  ra.?(nothing: Nothing<SM@<B@>>);
  f(ra.just.x)(r.@(s: ra.just.s));
};

# Returns the current indent level.
M@<Int@> GetIndent = (R@ r) {
  Ok(SM@(r.s, r.indent));
};

# Returns the current indent level.
M_@<Int@> GetIndent_ = (R@ r) {
  Just(SM@(r.s, r.indent));
};

# Gets the next character in the input stream, advancing the parser state as
# appropriate. Fails if there are no more characters in the input stream.
M@<CharL@> GetLRaw = (R@ r) {
  List@<CharL@> in = r.s;
  in.?(nil: Err<SM@<CharL@>>(Text(Unknown, Str|'unexpected end of input')));
  Ok(SM@(in.cons.tail, in.cons.head));
};

# Gets the next character in the input stream, advancing the parser state as
# appropriate. Fails if there are no more characters in the input stream.
M_@<CharL@> GetLRaw_ = (R@ r) {
  List@<CharL@> in = r.s;
  in.?(nil: Nothing<SM@<CharL@>>);
  Just(SM@(in.cons.tail, in.cons.head));
};

# Parse an indented block of text.
# Single space indent is used. The indent characters will be skipped over and
# end of input will be returned when the indented text ends.
<@ T@>(M@<T@>) { M@<T@>; } Indented = <@ T@>(M@<T@> mx)(R@ r) {
  mx(r.@(indent: Incr(r.indent)));
};
  
# Try running a parser. If it succeeds, return the parsed value. If it fails,
# return Nothing.
<@ T@>(M_@<T@>) { M@<Maybe@<T@>>; }
Try = <@ T@>(M_@<T@> mx)(R@ r) {
  Maybe@<SM@<T@>> rx = mx(r);
  rx.?(nothing: Ok(SM@(r.s, Nothing<T@>)));
  Ok(SM@(rx.just.s, Just(rx.just.x)));
};

# Try running a parser. If it succeeds, return the parsed value. If it fails,
# return Nothing.
<@ T@>(M_@<T@>) { M_@<Maybe@<T@>>; }
_Try = <@ T@>(M_@<T@> mx)(R@ r) {
  Maybe@<SM@<T@>> rx = mx(r);
  rx.?(nothing: Just(SM@(r.s, Nothing<T@>)));
  Just(SM@(rx.just.s, Just(rx.just.x)));
};

# Test if a parser would match at the current position, without consuming any
# input.
<@ T@>(M_@<T@>) { M@<Maybe@<T@>>; }
Test = <@ T@>(M_@<T@> mx)(R@ r) {
  Maybe@<SM@<T@>> rx = mx(r);
  rx.?(nothing: Ok(SM@(r.s, Nothing<T@>)));
  Ok(SM@(r.s, Just(rx.just.x)));
};

<@ T@>(M_@<T@>) { M_@<Maybe@<T@>>; }
_Test = <@ T@>(M_@<T@> mx)(R@ r) {
  Maybe@<SM@<T@>> rx = mx(r);
  rx.?(nothing: Just(SM@(r.s, Nothing<T@>)));
  Just(SM@(r.s, Just(rx.just.x)));
};

(Loc@, String@, List@<CharL@>) { List@<CharL@>; }
PreProcessInput = (Loc@ l, String@ s, List@<CharL@> tail) {
  s.?(nil: tail);
  Char@ c = s.cons.head;
  Cons(CharL@(c, l), PreProcessInput(Advance(l, c), s.cons.tail, tail));
};

(List@<Text@>, List@<CharL@>) { List@<CharL@>; }
PreProcessInputs = (List@<Text@> inputs, List@<CharL@> tail) {
  inputs.?(nil: tail);
  PreProcessInput(inputs.cons.head.loc, inputs.cons.head.text,
    PreProcessInputs(inputs.cons.tail, tail));
};

# Runs a parser monad on the given input string.
<@ T@>(M@<T@>, List@<Text@>) { Result@<T@>; }
Run = <@ T@>(M@<T@> m, List@<Text@> input) {
  List@<CharL@> s = PreProcessInputs(input, Nil<CharL@>);
  Result@<SM@<T@>> r = m(R@(s, Int|0));
  r.?(err: Err<T@>(r.err));
  Ok(r.ok.x);
};

# Gets the next character in the input stream, advancing the parser state as
# appropriate. Fails if there are no more characters in the input stream.
# Takes account of the current indent level.
M@<CharL@> GetL = {
  CharL@ cl <- Do(GetLRaw);
  Int@ indent <- Do(GetIndent);

  /Core/Int/Eq%.Le(cl.l.col, indent).?(true: {
    IsNewline(cl.c).?(true: Return(cl));
    cl.c.?(' ': GetL);
    Error<CharL@>(cl.l, Str|'end of indented block');
  });

  Return(cl);
};

# Gets the next character in the input stream, advancing the parser state as
# appropriate. Fails if there are no more characters in the input stream.
# Takes account of the current indent level.
M_@<CharL@> GetL_ = {
  CharL@ cl <- Do_(GetLRaw_);
  Int@ indent <- Do_(GetIndent_);

  /Core/Int/Eq%.Le(cl.l.col, indent).?(true: {
    IsNewline(cl.c).?(true: Return_(cl));
    cl.c.?(' ': GetL_);
    Error_<CharL@>;
  });

  Return_(cl);
};

# Returns the location of the next input character.
M@<Loc@> Loc = {
  Maybe@<CharL@> mc <- Do(Test(GetL_));
  Return(mc.?(just: mc.just.l, nothing: Unknown));
};

# Returns the location of the next input character.
M_@<Loc@> Loc_ = {
  Maybe@<CharL@> mc <- Do_(_Test(GetL_));
  Return_(mc.?(just: mc.just.l, nothing: Unknown));
};

# Gets the next character in the input stream, advancing the parser state as
# appropriate. Fails if there are no more characters in the input stream.
M@<Char@> Get = {
  CharL@ cl <- Do(GetL);
  Return(cl.c);
};

M_@<Char@> Get_ = {
  CharL@ cl <- Do_(GetL_);
  Return_(cl.c);
};

# Same as Try, but discards the result of a successful match.
<@ T@>(M_@<T@>) { M@<Bool@>; }
Try_ = <@ T@>(M_@<T@> mx) {
  Maybe@<T@> r <- Do(Try(mx));
  Return(r.?(just: True, nothing: False));
};

# Same as Try, but discards the result of a successful match.
<@ T@>(M_@<T@>) { M_@<Bool@>; }
_Try_ = <@ T@>(M_@<T@> mx) {
  Maybe@<T@> r <- Do_(_Try(mx));
  Return_(r.?(just: True, nothing: False));
};

# Parses either of the given arguments, returning the result of the first to
# pass. Fails if both parsers fails.
(M_@<Unit@>, M@<Unit@>) { M@<Unit@>; }
Or = (M_@<Unit@> ma, M@<Unit@> mb) {
  Bool@ a <- Do(Try_(ma));
  a.?(true: Return(Unit));
  mb;
};

# Parses either of the given arguments, returning the result of the first to
# pass. Fails if both parsers fails.
(M_@<Unit@>, M_@<Unit@>) { M_@<Unit@>; }
Or_ = (M_@<Unit@> ma, M_@<Unit@> mb) {
  Bool@ a <- Do_(_Try_(ma));
  a.?(true: Return_(Unit));
  mb;
};

# Test if a parser would match at the current position, without consuming any
# input, and ignoring the result of parsing.
<@ T@>(M_@<T@>) { M@<Bool@>; }
Test_ = <@ T@>(M_@<T@> mx) {
  Maybe@<T@> r <- Do(Test(mx));
  Return(r.?(just: True, nothing: False));
};

# Test if a parser would match at the current position, without consuming any
# input, and ignoring the result of parsing.
<@ T@>(M_@<T@>) { M_@<Bool@>; }
_Test_ = <@ T@>(M_@<T@> mx) {
  Maybe@<T@> r <- Do_(_Test(mx));
  Return_(r.?(just: True, nothing: False));
};

# Parse end of input. Fails if we have not reached the end of the input.
M@<Unit@> EndOfInput = {
  Loc@ l <- Do(Loc);
  Maybe@<Char@> mc <- Do(Test(Get_));
  mc.?(nothing: Return(Unit));
  Error<Unit@>(l, Str|'expected end of input');
};

# Parse end of input. Fails if we have not reached the end of the input.
M_@<Unit@> EndOfInput_ = {
  Maybe@<Char@> mc <- Do_(_Test(Get_));
  mc.?(nothing: Return_(Unit));
  Error_<Unit@>;
};

# Parse a specific string from the input stream. Fails if the input string
# does not match that string.
(String@) { M@<Unit@>; }
String = (String@ s) {
  s.?(nil: Return(Unit));
  CharL@ c <- Do(GetL);
  /Core/Char/Eq%.Eq(s.cons.head, c.c).?(
    true: String(s.cons.tail),
    false: Error<Unit@>(c.l, Strs[
      Str|'Expected ''', Str[s.cons.head], Str|'''']));
};

# Parse a specific string from the input stream. Fails if the input string
# does not match that string.
(String@) { M_@<Unit@>; }
String_ = (String@ s) {
  s.?(nil: Return_(Unit));
  CharL@ c <- Do_(GetL_);
  /Core/Char/Eq%.Eq(s.cons.head, c.c).?(
    true: String_(s.cons.tail),
    false: Error_<Unit@>);
};

@(
  M@, CharL@,
  Return, Error, Do, Loc, Get, GetL, GetIndent, EndOfInput, Indented,
  Try, Try_, Test, Test_, Or, String,
  Run,
  M_@, M, M_, Error_, Do_, Return_, Or_, Get_, String_, Loc_, GetIndent_,
  EndOfInput_, _Try_, _Test_
);
