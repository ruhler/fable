
import @ { Bit@Bit; Bit1; BitNI; BoolM=Bool@StdLib; };

struct Bit2(Bit hi, Bit lo);

module BitN(BitNI<Bit2>) {
  import @ { Bit2; B = Bit1; Bit; BoolM; };
  import BoolM { Bool; And; };

  func not(Bit2 a ; Bit2) {
    Bit2(not@B(a.hi), not@B(a.lo));
  };

  func and(Bit2 a, Bit2 b; Bit2) {
    Bit2(and@B(a.hi, b.hi), and@B(a.lo, b.lo));
  };

  func or(Bit2 a, Bit2 b; Bit2) {
    Bit2(or@B(a.hi, b.hi), or@B(a.lo, b.lo));
  };

  func xor(Bit2 a, Bit2 b; Bit2) {
    Bit2(xor@B(a.hi, b.hi), xor@B(a.lo, b.lo));
  };

  func add(Bit2 a, Bit2 b; Bit2) fulladd(a, b, zero@B()).z;

  func zero(; Bit2) {
    Bit2(zero@B(), zero@B());
  };

  func iszero(Bit2 a; Bool) {
     And(iszero@B(a.hi), iszero@B(a.lo));
  };

  func eq(Bit2 a, Bit2 b; Bool) {
     And(eq@B(a.hi, b.hi), eq@B(a.lo, b.lo));
  };

  func clshift(Bit2 a; Bit2) lshift(a, a.hi).z;

  struct Result(Bit2 z, Bit cout);

  func fulladd(Bit2 a, Bit2 b, Bit cin; Result) {
    Result@B rlo = fulladd@B(a.lo, b.lo, cin);
    Result@B rhi = fulladd@B(a.hi, b.hi, rlo.cout);
    Result(Bit2(rhi.z, rlo.z), rhi.cout);
  };

  func lshift(Bit2 a, Bit cin; Result) {
    Result@B rlo = lshift@B(a.lo, cin);
    Result@B rhi = lshift@B(a.hi, rlo.cout);
    Result(Bit2(rhi.z, rlo.z), rhi.cout);
  };
};
