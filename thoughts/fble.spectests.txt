Fble Spec Tests
===============
Question: can we change how we specify fble language tests?

Currently they are specified using tcl with a funny mechanism for specifying
module hierarchy. Question is, could we write .fble files directly, like as a
separate fble library package with no other fble library dependencies? I think
that could be nicer.

We just need a way to indicate the metadata for each test:
 fble-test
 fble-test-compile-error <loc>
 fble-test-runtime-error <loc>
 fble-test-memory-constant
 fble-test-memory-growth

Advantages of what I'm envisioning:
* No need for special tcl syntax for modules.
* We know the name of the top level test module.
* We write .fble files directly, so we get syntax highlighting and direct line
  numbers for errors.
* We avoid an extra extraction step to get .fble files, which should simplify
  the build system notably.
* Hopefully more easily reused by hypothetical other fble implementations.
* We can compile Nat.fble just once and easily reuse it.

All I have to do is figure out a reasonable way to do the metadata.

Seems something like checktest from llvm, but I don't really like that, and I
certainly don't want a dependency on llvm.

Most natural thing to do is add a comment to the code. Some syntax tests will
be out of reach, like the ones involving comments, but that's such a basic
thing I don't think we need to test that using a separate test.

Note that the top level for the test case may be different from where the
error occurs. I suggest putting a metadata line only at the top level of the
test case?

So it's pretty straight forward, right? First line of the file for a test case
should be:

# fble-test-* <loc>

Or, maybe, because we aren't using tcl, we can use different names. Like:

# TEST
# TEST_COMPILE_ERROR <..>
# TEST_RUNTIME_ERROR <..>
# TEST_MEMORY_CONSTANT
# TEST_MEMORY_GROWTH

Or, like, have assertions? I dunno. I don't think it's hard, it's just
arbitrary.

We could do double comment:

## NO_ERROR
## COMPILE_ERROR 8:3
## RUNTIME_ERROR 8:3
## MEMORY_CONSTANT
## MEMORY_GROWTH

If it isn't annotated, it isn't as separate test case.

How will the test runner work? How will it integrate with the build system
where we want to compile?

We could run a single grep command over all modules in the directory. That
gives us a mapping from filename (hence module name) to test case. We can then
do a loop over those lines. Maybe we can generate that using a build rule and
have build.ninja depend on it and build.ninja.tcl read it? With a slight
bootstrapping process to generate it initially I suppose? That's unnecessary
though.

Then we can parse the entry easy enough in tcl.

So, I just need some metadata easy to locate with grep, and easy to parse from
tcl. Let's explore options.

For prefix, we want something that is a comment and is unlikely to occur by
accident. It may be nice if it indicates to readers of the code what it is,
instead of being some magic. If we have text, we don't need magic symbols
aside from the comment character. I like 'test' and 'fble' in the name.

# FBLE-TEST no-error 
# FBLE-TEST compile-error 8:3
# FBLE-TEST runtime-error 8:3
# FBLE-TEST memory-constant
# FBLE-TEST memory-growth

Say it has to be the first line in the file, because why not? Or is that too
picky and too easy to accidentally not be applied? No. I think anywhere should
be okay. Allow any amount of whitespace between tokens. How to prevent
accidental uses of 'FBLE-TEST' in a document? I think we want some special
symbols for it.

Okay, how about this, a line of the form:

# @@fble-test@@ <type> <msg>

<type> is one of:
  no-error
  compile-error
  runtime-error
  memory-constant
  memory-growth

<msg> is an arbitrary string expected to be included in the error message,
primarily used to identify the location of the error.

There should be at most one @@fble-test@@ line per file. I'm not sure who
enforces that though.

Clearly it has some special meaning. Simple to detect with grep. Clearly
related to fble and testing. Simple to parse. I say go with it. No need for a
name, the current module path should be fine?

Good. What do you think? Shall I try doing this cleanup?

---

What are the next steps here? I need to come up with a plan for how to
implement this.

So we have the .fble code already extracted.
We get a list of tests from build.ninja.tcl using glob and/or grep.
We parse the test type from within build.ninja.tcl and call the appropriate
spec-test-compile, fble-test, fble-test-compile-error, etc. functions.

I'll want to migrate slowly to the new scheme. So duplicate and modify in
build.ninja.tcl to start. Start with just a handful of tests, get that
working, and slowly migrate.

What directory structure do I want for the spec tests? Put them in spec
directory maybe? spec/SpecTests/... I would say the tests are part of the
spec. 'lang' versus 'spec'? I think 'spec' is more specific. Do we want an
'fble' prefix? Or is everything okay to be fble based now?

Let's try 'spec/SpecTests', where spec is the -I value and tests go under
/SpecTests/...%

Immediate next steps:
* Port the langs/fble/0... tests to new format.
* Set up build.ninja.tcl infra for running tests in the new format.

---

The easy way to build the new test format is:
* For every file under SpecTests directory, create a spec test rule that calls
  a script to run the file. The script reads the metadata, verifies it is a
  test (trivially passing otherwise), and executes the commands necessary to
  run the test.

That way we don't have to read the contents of any of the spec tests to
generate the build.ninja. The downside is we don't know at build time whether
the test depends on fble-test, fble-compile, fble-mem-test, etc, so we'll end
up adding a dependency on all of those, which could trigger unnecessary test
reruns in some (rare?) cases.

The slightly harder way is to parse the test file in build.tcl and generate
rules depending on the test. Let's start with the easy way. Once we have the
easy way, we can decide if we want to migrate to the hard way, which needs all
the same code, just a bit more and in different places.

First steps for implementing script to execute:
* Pass an include directory and a module path? Or include directory and .fble
  file name. Either way, want the info necessary for the .fble file name, the
  include directory, and the module path.
* Read the file, search for and parse the @@fble-test@@ metadata.

