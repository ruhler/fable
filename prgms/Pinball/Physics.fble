
<@>@ List@ = /List%.List@;

<@>@ Maybe@ = /Maybe%.Maybe@;
<@>% Just = /Maybe%.Just;

@ Ball@ = /Pinball/Ball%.Ball@;

@ BallT@ = /Pinball/Collide%.BallT@;
% BallEdgeS = /Pinball/Collide%.BallEdgeS;
% BallPaddleS = /Pinball/Collide%.BallPaddleS;
% First = /Pinball/Collide%.First;

@ Edge@ = /Pinball/Edge%.Edge@;

@ Paddle@ = /Pinball/Paddle%.Paddle@;

@ Num@ = /Pinball/Num%.Num@;
% Sub = /Pinball/Num%.Sub;
% Div = /Pinball/Num%.Div;
% Le = /Pinball/Num%.Le;
% Int = /Pinball/Num%.Int;

@ Vec@ = /Pinball/Vec%.Vec@;
% AddV = /Pinball/Vec%.AddV;
% MulVS = /Pinball/Vec%.MulVS;

@ World@ = *(
  Vec@ gravity,      # acceleration due to gravity
  Ball@ ball,
  List@<Edge@> edges,
  List@<Paddle@> paddles
);

# Move --
#   Move the ball and paddles by the given amount of time, assuming velocity
#   stays constant.
#
# In case of collision, we break down the time period into smaller bits. The
# assumption that velocity is constant is intended to prevent the case where
# we break down the time period into smaller and smaller bits and end up never
# reaching the end of the time period as a result. This also assumes we
# don't have any super tight corners that would cause us to collide an
# excessive number of times in a single time period.
(World@, Num@) { World@; } Move = (World@ w, Num@ t) {
  Le(t, Int|0).?(true: w);

  Maybe@<BallT@> if_nohit = Just<BallT@>({
    Vec@ end_pos = AddV(w.ball.pos, MulVS(w.ball.vel, t));
    BallT@(Ball@(end_pos, w.ball.vel, w.ball.radius), t);
  });
  Maybe@<BallT@> if_edged = BallEdgeS(w.ball, w.edges, t);
  Maybe@<BallT@> if_paddled = BallPaddleS(w.ball, w.paddles, t);

  BallT@ ball = First(if_nohit, First(if_edged, if_paddled)).just;
  Num@ ct = ball.time;
  List@<Paddle@> paddles = /List%.Map<Paddle@, Paddle@>(w.paddles, (Paddle@ p) {
    /Pinball/Paddle%.Move(p, ct);
  });
  World@ moved = World@(w.gravity, ball.ball, w.edges, paddles);
  Move(moved, Sub(t, ct));
};

# Tick --
#   Advance the world by one unit of time.
(World@) { World@; } Tick = (World@ w) {
  # Compute average expected ball velocity over the time period.
  Vec@ half_gravity = MulVS(w.gravity, Div(Int|1, Int|2));
  Vec@ v_avg = AddV(w.ball.vel, half_gravity);
  World@ updated = World@(w.gravity, Ball@(w.ball.pos, v_avg, w.ball.radius), w.edges, w.paddles);

  # Move the ball assuming constant velocity.
  World@ moved = Move(updated, Int|1);

  # Compute final ball velocity.
  Vec@ v = AddV(moved.ball.vel, half_gravity);
  World@(w.gravity, Ball@(moved.ball.pos, v, moved.ball.radius), moved.edges, moved.paddles);
};

@(World@, Tick);
