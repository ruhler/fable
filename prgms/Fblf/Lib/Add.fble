
% BitStr = /Digits/String%.BitStr;

@ Addr@ = /Fblf/Program%.Addr@;
@ Program@ = /Fblf/Program%.Program@;
@ Value@ = /Fblf/Program%.Value@;
% Assign = /Fblf/Program%.Assign;
% Eq = /Fblf/Program%.Eq;
% IfElse = /Fblf/Program%.IfElse;
% Seq = /Fblf/Program%.Seq;
% Noop = /Fblf/Program%.Noop;
% Const = /Fblf/Program%.Const;
% Ref = /Fblf/Program%.Ref;

<@>@ Module@ = /Fblf/Module%.Module@;
<@>% AllocM = /Fblf/Module%.AllocM;
<@>% PureM = /Fblf/Module%.PureM;

@ Int@ = /Int/Int%.Int@;
% Add = /Int/Int%.Add;
% Sub = /Int/Int%.Sub;
% Le = /Int/Int/Eq%.Le;

% Int = /Int/Int/Lit%.Int;

% CountDownFrom = /Int/Int/Iter%.CountDownFrom;

<@,@>% For = /Iter%.For;

<@>% List = /List%.List;

# Add1P --
#   A pure 1-bit adder.
#
# Inputs:
#   a - The address of the first operand.
#   b - The address of the second operand.
#   c - The address of carry bit in.
#   x - The address of the carry bit out.
#   z - The address of where to store the result of the addition.
#
# Results:
#   A program that sets x and z based on the one bit addition a + b + c.
(Addr@, Addr@, Addr@, Addr@, Addr@) { Program@; }
Add1P = (Addr@ a, Addr@ b, Addr@ c, Addr@ x, Addr@ z) {
  Int@ n1 = Int|1;
  Value@ b0 = Const(BitStr|0);
  Value@ b1 = Const(BitStr|1);

  IfElse(Eq(Ref(a), b0, n1),
    IfElse(Eq(Ref(b), b0, n1),
      Seq(List<Program@>[Assign(z, Ref(c), n1), Assign(x, b0, n1)]),
      IfElse(Eq(Ref(c), b0, n1),
        Seq(List<Program@>[Assign(z, b1, n1), Assign(x, b0, n1)]),
        Seq(List<Program@>[Assign(z, b0, n1), Assign(x, b1, n1)]))),
    IfElse(Eq(Ref(b), b0, n1),
      IfElse(Eq(Ref(c), b0, n1),
        Seq(List<Program@>[Assign(z, b1, n1), Assign(x, b0, n1)]),
        Seq(List<Program@>[Assign(z, b0, n1), Assign(x, b1, n1)])),
      Seq(List<Program@>[Assign(z, Ref(c), n1), Assign(x, b1, n1)])));
};

# AddM -- 
#   An n-bit adder, with most significant bit first.
#
# Inputs:
#   n - The number of bits to add together.
#   a - The address of the first operand.
#   b - The address of the second operand.
#   z - The address of where to store the result of the addition.
(Int@, Addr@, Addr@, Addr@) { Module@<Program@>; }
AddM = (Int@ n, Addr@ a, Addr@ b, Addr@ z) {
  # We need a single bit of internal state to store the carry bit as we do
  # the addition.
  Addr@ carry <- AllocM<Program@>(Int|1);

  Value@ b0 = Const(BitStr|0);
  PureM<Program@>(For<Int@, Program@>(CountDownFrom(n), Assign(carry, b0, Int|1),
    (Int@ i, Program@ s) {
      Program@ add1 = Add1P(Add(a, i), Add(b, i), carry, carry, Add(z, i));
      Seq[s, add1]; 
    }));
};

# IncP --
#   Increment an n-bit number by 1.
#
# Inputs:
#   n - The number of bits of the number to increment.
#   a - The address of the value to increment. The value is most significant
#       bit first.
(Int@, Addr@) { Program@; }
IncP = (Int@ n, Addr@ a) {
  Le(n, Int|0).?(
    true: Noop,
    false: {
      Int@ nm1 = Sub(n, Int|1);
      Addr@ lsb = Add(a, nm1);
      IfElse(Eq(Ref(lsb), Const(BitStr|0), Int|1),
        Assign(lsb, Const(BitStr|1), Int|1),
        Seq(List<Program@>[Assign(lsb, Const(BitStr|0), Int|1), IncP(nm1, a)]));
    });
};

# IncM --
#   Increment an n-bit number by 1.
#
# Inputs:
#   n - The number of bits of the number to increment.
#   a - The address of the value to increment. The value is most significant
#       bit first.
(Int@, Addr@) { Module@<Program@>; } IncM = (Int@ n, Addr@ a) {
  PureM<Program@>(IncP(n, a));
};

# DecP --
#   Decrement an n-bit number by 1.
#
# Inputs:
#   n - The number of bits of the number to decrement.
#   a - The address of the value to decrement. The value is most significant
#       bit first.
(Int@, Addr@) { Program@; }
DecP = (Int@ n, Addr@ a) {
  Le(n, Int|0).?(
    true: Noop,
    false: {
      Int@ nm1 = Sub(n, Int|1);
      Addr@ lsb = Add(a, nm1);
      IfElse(Eq(Ref(lsb), Const(BitStr|1), Int|1),
        Assign(lsb, Const(BitStr|0), Int|1),
        Seq(List<Program@>[Assign(lsb, Const(BitStr|1), Int|1), DecP(nm1, a)]));
    });
};

# DecM --
#   Increment an n-bit number by 1.
#
# Inputs:
#   n - The number of bits of the number to decrement.
#   a - The address of the value to decrement. The value is most significant
#       bit first.
(Int@, Addr@) { Module@<Program@>; } DecM = (Int@ n, Addr@ a) {
  PureM<Program@>(DecP(n, a));
};

@(AddM, IncP, IncM, DecP, DecM);
