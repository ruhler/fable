
@ Unit@ = /Unit%.Unit@;
% Unit = /Unit%.Unit;

@ Int@ = /Int/Int%.Int@;
% Add = /Int/Int%.Add;

<@>@ S@ = /List%.S@;
<@>% S = /List%.S;
<@,@>% MapS = /List%.MapS;

@ Color@ = +(
    Unit@ black,
    Unit@ red,
    Unit@ green,
    Unit@ yellow,
    Unit@ blue,
    Unit@ magenta,
    Unit@ cyan,
    Unit@ white
    );

@ Point@ = *(Int@ x, Int@ y);

@ Drawing@ = +(
  # A blank (transparent) drawing.
  Unit@ blank,
  
  # A filled path.
  #
  # The path is implicitly closed. For example, to draw a rectangle, give the
  # four corner points in order, such as: [(0, 0), (2, 0), (2, 2), (0, 2)].
  *(S@<Point@> points, Color@ color) path,

  # Draw one drawing over another.
  *(Drawing@ below, Drawing@ above) over
);

Drawing@ Blank = Drawing@(blank: Unit);

# Draw a rectangle filled solid with the given color.
(Int@, Int@, Int@, Int@, Color@) { Drawing@; }
Rect = (Int@ x, Int@ y, Int@ w, Int@ h, Color@ color) {
  Drawing@(path: @(
    points: S<Point@>([
      Point@(x, y),
      Point@(Add(x, w), y),
      Point@(Add(x, w), Add(y, h)),
      Point@(x, Add(y, h))]),
    color: color));
};

# Compose two drawings together by drawing one over another.
(Drawing@, Drawing@) { Drawing@; } Over = (Drawing@ below, Drawing@ above) {
  Drawing@(over: @(below, above));
};

# Transform all of the coordinates in the given drawing.
((Point@) { Point@; }, Drawing@) { Drawing@; }
Transform = ((Point@) { Point@; } f, Drawing@ d) {
  ?(d; blank: d,
       path: Drawing@(path: @(
           points: MapS<Point@, Point@>(d.path.points, f),
           color: d.path.color)),
       over: {
         Over(Transform(f, d.over.below), Transform(f, d.over.above));
       });
};

@(Color@, Drawing@, Point@, Blank, Rect, Over, Transform);
