
@ Drawing@ = /Drawing%.Drawing@;
@ Color@ = /Drawing%.Color@;
@ Point@ = /Drawing%.Point@;
% Blank = /Drawing%.Blank;
% Over = /Drawing%.Over;
% Rect = /Drawing%.Rect;

@ Int@ = /Int/Int%.Int@;
% Add = /Int/Int%.Add;
% Sub = /Int/Int%.Sub;
% Mul = /Int/Int%.Mul;
% Int = /Int/Int/Lit%.Int;
% Le = /Int/Int/Eq%.Le;
% Max = /Int/Int/Eq%.Max;
% Min = /Int/Int/Eq%.Min;
% Div = /Int/Int/Div%.Div;
% Range = /Int/Int/Iter%.Range;

<@,@>% For = /Iter%.For;

@ Sorted@ = *(Point@ 0, Point@ 1, Point@ 2);

(Point@, Point@, Point@) { Sorted@; }
SortByY = (Point@ a, Point@ b, Point@ c) {
  Le(a.y, b.y).?(
    true: Le(b.y, c.y).?(
      true: Sorted@(a, b, c),
      false: Le(a.y, c.y).?(
        true: Sorted@(a, c, b),
        false: Sorted@(c, a, b))),
    false: Le(a.y, c.y).?(
      true: Sorted@(b, a, c),
      false: Le(b.y, c.y).?(
        true: Sorted@(b, c, a),
        false: Sorted@(c, b, a))));
};

# XFromY --
#   Given a line from point a to point b, and a value y
#   in the range [a.y, b.y), compute the value of x on the line cooresponding
#   to that value y.
#
# Requirement: a.y < b.y.
(Point@, Point@)(Int@) { Int@; } XFromY = (Point@ a, Point@ b) {
  # Our goal is to compute the value of 'x' as a function of 'y' in such a
  # way that:
  # * We factor out common terms used for different values of y, to improve
  #   performance of repeated calls to this function.
  # * We do one big division at the end, so that rounding is independent
  #   of whatever frame of reference we use.
  #
  # In other words, we compute:
  #   x = (d*y + e)/f 
  # With appropriate choice of constants d, e, and f.
  Int@ d = Sub(b.x, a.x);
  Int@ e = Sub(Mul(a.x, b.y), Mul(a.y, b.x));
  Int@ f = Sub(b.y, a.y);

  (Int@ y) {
    Div(Add(Mul(d, y), e), f);
  };
};

# Triangle --
#   Draw a filled triangle between the points a, b, and c.
(Point@, Point@, Point@, Color@) { Drawing@; }
Triangle = (Point@ a, Point@ b, Point@ c, Color@ color) {
  Sorted@ s = SortByY(a, b, c);
  Point@ a = s.0;
  Point@ b = s.1;
  Point@ c = s.2;

  Drawing@ bottom = For<Int@, Drawing@>(Range(a.y, b.y), Blank, { 
    (Int@) { Int@; } Fxb = XFromY(a, b);
    (Int@) { Int@; } Fxc = XFromY(a, c);

    (Int@ y, Drawing@ d) {
      Int@ xb = Fxb(y);
      Int@ xc = Fxc(y);
      Int@ xmin = Min(xb, xc);
      Int@ xmax = Max(xb, xc);
      Over(d, Rect(xmin, y, Sub(xmax, xmin), Int|1, color));
    };
  });

  Drawing@ top = For<Int@, Drawing@>(Range(b.y, c.y), Blank, {
    (Int@) { Int@; } Fxa = XFromY(a, c);
    (Int@) { Int@; } Fxb = XFromY(b, c);

    (Int@ y, Drawing@ d) {
      Int@ xa = Fxa(y);
      Int@ xb = Fxb(y);
      Int@ xmin = Min(xa, xb);
      Int@ xmax = Max(xa, xb);
      Over(d, Rect(xmin, y, Sub(xmax, xmin), Int|1, color));
    };
  });

  Over(bottom, top);
};

@(Triangle);
