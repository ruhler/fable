De-RefValue
===========
Goal is to remove the need for calling StrictValue every time we access a
value. The primary motivation is to simplify access logic so we can easily
inline it into backends at the call sites. It will be nice to get a little
performance improvement from not having to do the check all the time as well.

It's not rocket science I don't think. A few approaches we could consider:
1. Have FbleAssignRefValue traverse the value, replacing any references to the
original ref value.
2. Any time we take a reference to a RefValue, add it to a list tracked by the
RefValue. In FbleAssignRefValue, traverse that list.
3. Use some crazy signal handler and memory protection to detect access to ref
values and replace them on the fly with their use.
4. Preallocate a large enough space for the allocated value and overwrite the
   contents of the RefValue on assignment.

Note that we need some way still to check for undefined values. Whatever
approach we use should ideally work with undef expressions and, if necessary,
stack unwinding.

Where ref values happen most often in practice is the definition of recursive
functions. Can I think of any other places? Certainly we could make up things
like infinite lists, but I think that's very rare in practice.

Which means, in the normal use case, we would only have to traverse the static
fields of a struct value to do the assignment. Approach (1) sounds like the
way to go. Don't worry about the rare pathological case. Sure someone can
create a really long circular list, and that would be expensive to traverse.
So what?

Sketch of proposal:
* Change RefValue to a new kind of packed value, with least significant bits
  10. The most significant bits are a unique id for the ref value.
* To assign: traverse the value and update references to the RefValue in
  place. GC should have enough info to avoid traversing previously allocated
  objects. We should only have to traverse new allocated objects.
* Check for RefValue in data access. If we see it, it's undefined. Throw an
  error.

I don't think we can get away without some kind of check during data access.
Not unless we want to do silly things with signal handlers. My proposal sounds
reasonable.

Concerns:
* Today we use ref value to know when to merge frames. We won't have that info
  anymore.
* Does anywhere in the code rely on there being ref values to detect cycles? I
  think it shouldn't, but I wouldn't be surprised if it did.

That means the first step is to remove use of ref value for deciding when to
merge frames. Either make something more explicit to detect recursive
functions, or find some other scheme.

I want to think a little bit about proposal (4). Could we pre-allocate
for the RefValue assignment and simply overwrite the RefValue on assignment? I
think not. It's possible we have no type information about the RefValue. For
example:

 <@ T@>((T@) { T@; } f) {
   T@ x = f(x);
   x;
 };

We need a RefValue for x in this case, but we have no idea what the type is.

Okay, let's continue on with proposal (1). First step: find an alternate to
RefValue for deciding on frame merges.

I probably want to have a more comprehensive benchmark suite when evaluating
this change. md5sum for sure, to cover the case of deep non-recursive
functions.

---

We are no longer using RefValue for deciding on frame merges.

Let's proceed with the update to RefValue. Here's how it will work:
* RefValue becomes packed {<id>, 'b10}
  We'll need some way to generate unique ids for RefValues. Needs thought.
* StrictValue turns all ref values to NULL (as a first step).
* FbleAssignRefValue does a traversal of value, replacing references to the
  ref value with the actual value. Check for vacuous value here still.

I think that's it. Even if we just do that, I'm hoping we'll see a noticeable
performance improvement.

How to assign ids for ref values? It should be a proper stack, right? I always
do assignment for the most recent ref value? Close. Double check the ordering
logic when we have multiple ref values defined in the same statement.

Assuming that's the case, we can have a single counter which keeps track of
the number of ref values allocated so far. Assert when we do a ref value
assignment it's of the top counter value, then decrement that top counter
value.

---

I need to change the API for ref values, because we need to do the
substitution in all values of a let. For example, if we have 3 recursively
defined variables, we have 3 ref values, we have 3 values to assign to, and we
have 3 values to traverse to do all 3 substitutions.

Proposal:
* void FbleNewRefValues(FbleValueHeap* heap, size_t n, FbleValue** dest);
  Allocates n new ref values, storing them continuously in dest.
* bool FbleAssignRefValues(FbleValueHeap* heap, size_t n, FbleValue** refs, FbleValue** values);
  Assigns n ref values at once. The ref values are stored continuously and the
  values to assign them to are stored continuously.

If we have this API, it's also easier to require ref values are assigned in
last in first out order, which is convenient for assigning unique ids to ref
values.

I can do the implementation in phases:
1. Switch to the new API.
2. Implement the traverse and replace on existing RefValue datatype.
3. Allocate and manage unique ids for ref values.
4. Pack ref values.

This idea of allocating continuous values in the compiler is new. I don't
think it's too hard, but something different. Let's review where and how we
use ref values today.

In let, we allocate n ref values in a row. Then we compute n definitions in a
row. Then we do n assignments in a row and call SetVar to update the
definitions.

Shouldn't be too hard? The most awkward part is having continuous allocations
for things. It means we may have to move memory around we otherwise wouldn't
need to. Is there a better way?

Struct value takes FbleVarV args. Let's do the same?

FbleNewRefValues can take an FbleLocalIndexV. It fills in each of the
individual indices. FBLE_REF_DEF can take FbleVarV and FbleLocalIndexV. That's
easy. That should be quite doable. Okay? Let's try that.

---

We don't need to change FbleNewRefValue to start. That's fine to split up.
We'll end up inlining that anyway. We just need to change FbleAssignRefValue
to do it all at once.

The annoying part is that we need to report vacuous value errors per
assignment. A vacuous value is currently defined as a variable being set to
itself.

For example:

a = b, b = a;

We can assign a = b. But then when we try b = a, we'll see it a vacuous. Do we
need location at the specific variable, or is the let in general okay? The
specific variable is probably important information.

Sigh. For now, let's include a list of locations with the instruction. Really,
I think best to have a vector of: loc, ref, value. Okay? First step is to get
the instruction updated. Second step is to change FbleAssignRefValue to
FbleAssignRefValues.

