
@ Int@ = /Core/Int%.Int@;
% Add = /Core/Int%.Add;

<@>@ List@ = /Core/List%.List@;
<@>% Cons = /Core/List%.Cons;
<@>% Nil = /Core/List%.Nil;

@ Profile@ = /Pprof/Profile%.Profile@;
@ Sample@ = /Pprof/Profile%.Sample@;
@ Sequence@ = /Pprof/Profile%.Sequence@;

% IsSuffixOf = /Pprof/Profile/Sequence%.IsSuffixOf;
% IsSubsequenceOf = /Pprof/Profile/Sequence%.IsSubsequenceOf;

# @struct[Result@] Result of a profile count.
#  @field[List@<Int@>][self]
#   The count of metric values for samples where the sequence in question is a
#   suffix.
#  @field[List@<Int@>][total]
#   The count of metric values for samples where the sequence in question
#   appears anywhere in the sample.
@ Count@ = *(
  List@<Int@> self,
  List@<Int@> total
);

(List@<Int@>, List@<Int@>) { List@<Int@>; }
AddMetrics = (List@<Int@> a, List@<Int@> b) {
  a.?(nil: b);
  b.?(nil: a);
  Cons(Add(a.cons.head, b.cons.head), AddMetrics(a.cons.tail, b.cons.tail));
};

(Count@, Count@) { Count@; }
AddCount = (Count@ a, Count@ b) {
  @(self: AddMetrics(a.self, b.self), total: AddMetrics(a.total, b.total));
};

(Sequence@, Sample@) { Count@; }
CountSample = (Sequence@ seq, Sample@ s) {
  @(self: IsSuffixOf(seq, s.path).?(true: s.metrics, false: Nil<Int@>),
    total: IsSubsequenceOf(seq, s.path).?(true: s.metrics, false: Nil<Int@>));
};

(Sequence@, List@<Sample@>) { Count@; }
CountSamples = (Sequence@ seq, List@<Sample@> samples) {
  samples.?(nil: Count@(Nil<Int@>, Nil<Int@>));
  Count@ tail = CountSamples(seq, samples.cons.tail);
  AddCount(CountSample(seq, samples.cons.head), tail);
};

(Sequence@, Profile@) { Count@; }
Count = (Sequence@ s, Profile@ p) {
  CountSamples(s, p.samples);
};

@(Count@, Count);
