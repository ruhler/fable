
@ Bool@ = /Core/Bool%.Bool@;
% True = /Core/Bool%.True;
% False = /Core/Bool%.False;

@ Char@ = /Core/Char%.Char@;

<@>@ List@ = /Core/List%.List@;

@ String@ = /Core/String%.String@;
% Str = /Core/String%.Str;

@ Loc@ = /Fbld/Loc%.Loc@;
% Advance = /Fbld/Loc%.Advance;

@ _@ = %(/Fbld/Text%);

@ Str@ = *(String@ str, Loc@ loc);

@ Append@ = *(Text_@ a, Text_@ b),
@ Text_@ = +(Str@ str, Append@ append);

# Abstract string type that supports location tracking and fast concatenation.
@ Text@ = _@<Text_@>;

(String@, Loc@) { Text_@; }
Text_ = (String@ str, Loc@ loc) {
  Text_@(str: Str@(str, loc));
};

(String@, Loc@) { Text@; } Text = _@.<@<Text>>(Text_);

(Text_@, String@) { String@; }
StringOf_ = (Text_@ text, String@ r) {
  text.?(str: /Core/List%.Append(text.str.str, r));
  StringOf_(text.append.a, StringOf_(text.append.b, r));
};

# StringOf --
#   Extracts the contents of the text into a String@.
#
# Note: This may be an expensive operation. Avoid duplicate calls where
# possible.
(Text@) { String@; }
StringOf = _@.<@<StringOf>>((Text_@ text) {
  StringOf_(text, Str|'');
});

(Text_@) { Loc@; }
LocOf_ = (Text_@ text) {
  text.?(str: text.str.loc);
  LocOf_(text.append.a);
};

# LocOf --
#   Gets the location of the start of the text.
(Text@) { Loc@; } LocOf = _@.<@<LocOf>>(LocOf_);

(Text_@) { Bool@; }
IsEmpty_ = (Text_@ text) {
  text.?(str: {
    text.str.str.?(nil: True);
    False;
  });
  False;
};

(Text@) { Bool@; } IsEmpty = _@.<@<IsEmpty>>(IsEmpty_);

(Loc@) { Text@; }
Empty = (Loc@ l) {
  Text(Str|'', l);
};

(Text_@, Text_@) { Text_@; }
Append_ = (Text_@ a, Text_@ b) {
  IsEmpty_(a).?(true: b);
  IsEmpty_(b).?(true: a);
  Text_@(append: Append@(a, b));
};

(Text@, Text@) { Text@; } Append = _@.<@<Append>>(Append_);

(Text_@) { Char@; }
Head_ = (Text_@ text) {
  text.?(
    str: text.str.str.cons.head,
    append: Head_(text.append.a));
};

# Returns the first character of text.
# Behavior is undefined if the text is empty.
(Text@) { Char@; } Head = _@.<@<Head>>(Head_);

(Text_@) { Text_@; }
Tail_ = (Text_@ text) {
  text.?(str: {
    Text_(text.str.str.cons.tail, Advance(text.str.loc, text.str.str.cons.head));
  });
  Append_(Tail_(text.append.a), text.append.b);
};

(Text@) { Text@; } Tail = _@.<@<Tail>>(Tail_);

(Loc@, List@<Text@>) { Text@; }
Concat = (Loc@ l, List@<Text@> x) {
  x.?(nil: Empty(l));
  Append(x.cons.head, Concat(l, x.cons.tail));
};

@(Text@, Text, StringOf, LocOf, IsEmpty, Empty, Head, Tail, Append, Concat);
