
{ /App%; @(App@, Event@); };
{ /Bool%; @(Bool@, And, True, False); };
{ /Draw%; @(Draw@, Color@); };
{ /GameOfLife%; @(World@, Coord@, World, ForWorld, Step); };
{ /Int/Int%; @(Int@, 0, 1, 2, 3, 4, 5, 6, Dec); };
{ /Int/IntP%; @(IntP@); };
{ /Int/Int/Eq%; @(IsZero, Ge, Lt); };
{ /Int/Int/Lit%; @(I, D); };
{ /List%; @(S@, S, S0, ConsS); };
{ /Maybe%; @(Maybe@, Just, Nothing, MapMaybe); };
{ /Process%; @(Get@, Put@); };
{ /Unit%; @(Unit@, Unit); };

(Int@, Int@) { Coord@; } C = (Int@ x, Int@ y) { Coord@(x, y); };

# The snake API uses a 60 x 20 grid. Center the acorn around that.
World@ acorn = World([
  C(I(D|10), I(D|31)),

  C(I(D|11), I(D|33)),

  C(I(D|12), I(D|30)),
  C(I(D|12), I(D|31)),
  C(I(D|12), I(D|34)),
  C(I(D|12), I(D|35)),
  C(I(D|12), I(D|36))
]);


Int@ MaxRow = I(D|20);
Int@ MaxCol = I(D|60);

(World@) { S@<Draw@>; } DrawWorld = (World@ w) {
  Draw@ clear = Draw@(0, 0, MaxCol, MaxRow, Color@(black: Unit));
    
  # 2. For each live cell in range, draw a green unit square.
  S@<Draw@> cells = ForWorld<S@<Draw@>>(w, S0<Draw@>, (Coord@ coord, Unit@ _, S@<Draw@> d) {
    Int@ r = coord.row;
    Int@ c = coord.col;
    ?(And(And(Ge(r, 0), Ge(c, 0)),
          And(Lt(r, MaxRow), Lt(c, MaxCol)));
       true: ConsS<Draw@>(Draw@(c, r, 1, 1, Color@(green: Unit)), d),
       false: d);
  });

  ConsS<Draw@>(clear, cells);
};

(Get@<Event@>, Put@<S@<Draw@>>, Int@, World@) { Unit@!; }
StepUI = (Get@<Event@> in, Put@<S@<Draw@>> out, Int@ n, World@ w) {
  Unit@ _ := out(DrawWorld(w));
  Event@ x := in;
  ?(x;
      tick: ?(IsZero(n); true: $(Unit), false: StepUI(in, out, Dec(n), Step(w))),
      key: ?(x.key; Q: $(Unit), : StepUI(in, out, n, w)));
};

App@ Main = (Get@<Event@> in, Put@<S@<Draw@>> out) {
  Unit@ _ := StepUI(in, out, I(D|100), acorn);

  Unit@! WaitForKeyPress = {
    Event@ e := in;
    ?(e; tick: WaitForKeyPress, key: $(Unit));
  };
  WaitForKeyPress;
};

Main;
