Fable E
=======
Richard Uhler <ruhler@degralder.com>

1. Introduction
---------------
Fble is a general purpose, Turing-complete functional programming language
with support for concurrent processes, polymorphism, and modularity.

1.1 Goals
---------
The primary design goals of fble are:

* Fble should be as simple a language as possible while still being useful.
  A simple language will hopefully be simple to specify, simple to learn,
  simple to understand, simple to program, powerful, and low cost to develop
  high quality tools for.

* Fble should support high performance, low overhead computing. This is
  achieved by using a static type system and having a very clear performance
  model that a developer can optimize for.

* Fble should be a joy to program in. It should be easy to describe the
  majority of programs we want to describe, not tediously difficult. To
  accomplish this, fble allows functions to be declared locally with access to
  variables in the context where they are declared, and fble supports
  polymorphic types and functions.

* Fble should support programming at scale. That is, namespace control and
  composition of modules developed by different individual developers or
  organizations.

1.2 Overview
------------
Fble is based around the primitive data types of structs, unions, functions,
and processes. It is a strongly and statically typed language supporting
polymorphic types and values. Recursive types and values are supported through
a recursive let construct. Types are treated as another kind of value in fble,
which allows us to reuse the constructs of variables, lets, polymorphism, and
structs for types in addition to normal values. Additional syntax is provided
to make structs suitable for describing and manipulating namespaces.

2. Types, Kinds, and Variables
------------------------------
2.1 Types
---------
Data values and the expressions that describe them are strongly typed. A
value's type describes the kinds of operations that can legally be performed
on that value. Types are used to check that an fble program is well formed
statically. Types do not take meaningful part in the dynamic execution of an
fble program after it has been statically checked.

Types are themselves treated as data values in fble, which allows us to reuse
variables, lets, polymorphism, and structs for types in addition to
normal values. This means an expression can be used to describe either a
normal value or a type and that types themselves have types.

To ensure all type information is available at compile time, there is a
one-to-one mapping between a type and the type of that type. As a consequence,
you can determine the value of a type if you know the type of that type.

For example, the boolean value 'True' is a normal value. The type of 'True' is
the type 'Bool@', which is a union type. 'Bool@' is a type value. The type of
'Bool@' is known only as the type of Bool@, expressed using the syntax:
'@<Bool@>'. '@<Bool@>' is also a type value, and the type of that value is
'@<@<Bool@>>'. If you have an expression of type '@<Bool@>', you know
statically that the value of that expression must be 'Bool@', so the
expression need not be evaluated at runtime.

Type information is stripped away at runtime. The value of a type at runtime
is a special unit value. Without the type information, there is no way to
distinguish between the special unit value for different types. For this
reason we say types do not take meaningful part in the dynamic execution of an
fble program after it has been statically checked, though the special unit
value for types may exist at runtime when using an fble native interface.

2.2 Kinds
---------
Abstract Syntax:
  Kind ::= normal_kind
  Kind ::= type_kind

Concrete Syntax:
  kind ::= '%'    (* normal_kind *)
  kind ::= '@'    (* type_kind *)

Examples:
  %
  @

Kinds are used to classify whether a value is a normal value, a type value, or
something else. Using the example in the previous section:

* True is a normal value. It is of normal kind.
* Bool@ is a type value. It is of type kind.
* @<Bool@> is a type of a type value. It is of higher kind.
* @<@<Bool@>> is also of higher kind.

Kinds are analogous to types in that they describe what operations are
supported by a particular value, but they are much more restricted in the
operations they allow. A value of normal kind cannot be used where a type is
expected, for example. Unlike types, kinds do not act as values and cannot be
described using expressions.

The kind of a value is uniquely determined by the type of the value.

It is useful to be able to recognize immediately whether a variable refers to
a normal value, a type value, or something else. For that reason, we require
different namespaces be used for different kinds of values. In the concrete
syntax, names of normal variables are unadorned, while names of type variables
must end with the character '@'. So, for example, 'True' is a normal value,
and 'Bool@' is a type value.

You are not allowed to use a variable to refer to a higher kinded value, because
then using '@' in variable names to distinguish between normal variables and
type variables would be insufficient. In practice this should not be a
significant limitation because you should be able to use a type variable for
the value of the type and use the typeof operator to get the type of the type
as needed. For this reason, there is no syntax for describing a higher
kind, though it is possible to describe types and expressions of higher kind.

2.3 Typeof
----------
Abstract Syntax:
  Type ::= typeof (expr :: Expr)

Concrete Syntax:
  type ::= '@' '<' expr '>'

Example:
  @<x>

Evaluates to the type of the expression, without evaluating the expression
itself. This is primarily useful for explicitly describing the type of a
struct that has type fields.

Runtime is O(1).

2.4 Variables
-------------
Abstract Syntax:
  Expr ::= var (name :: Name)

Concrete Syntax:
  expr ::= name

Example:
  x

Variables allow data values to be reused multiple times within a program. In
conjunction with let expressions, variables allow data values to be used
recursively.

Expressions are evaluated in a context that maps variable names to values,
along with their types and kinds. The value, type, and kind of the variable
expression is the value, type, and kind associated with the variable name in
the context.

In general it is legal to declare a new variable with the same name as an
existing variable in scope. In this case, the new variable shadows the
existing variable for as long as the new variable is in scope. The existing
variable is not visible or accessible as long as the new variable is in scope.

The rationale for allowing variables to shadow other variables is for
modularity: it allows you to re-use a self-contained block of code in any
context. Otherwise self-contained blocks of code could not be reused in
contexts that happen to declare a variable with the same name as some variable
in the self-contained block.

Runtime is O(log(N)), where N is the number of variables in scope. In the case
of delayed evaluation of functions and processes, the number of variables in
scope is limited by the number of variables captured by the function or
process when it is created.

2.5 Let
-------
Abstract Syntax:
  Spec ::= kind_spec (kind :: Kind)
  Spec ::= type_spec (type :: Type) ;
  Expr ::= let (bindings :: [(Spec, Name, Expr)]) (body :: Expr)

Concrete Syntax:
  spec ::= kind ;
  spec ::= type ;
  stmt ::= spec name '=' expr [',' spec name = expr [...]] ';' stmt

Example:
  Int@ x = mul(3, 3); mul(x, x)
  @ Bool@ = +(Unit@ true, Unit@ false); ...

Let expressions can be used to define local variables that allow values to be
reused in multiple places in a program. Let expressions support recursive
definitions of variables, which makes it possible to define recursive values.

The let expression is used to define variables. For each binding, a new
variable is defined. The value of the variable is the result of evaluating the
expression for the variable's binding.

The defined variables are visible in the body of the let expression. To
support self and mutually recursive values, the defined variables
are also visible in all of the bindings expressions.

While a variable can be referenced in the bindings where the variable is
defined, the value of the variable is undefined until after the binding
expressions have completed evaluation.

The value of the let expression is the value of its body. The type of the let
expression is the type of its body.

When defining a variable, ether a kind or a type can be used to specify
the operations supported by the value of the variable. If a kind is used, the
type of the variable is abstract in the bindings expressions. The actual type
of the variable will be inferred from its definition for use in the body of
the let expression. If a type is used when defining a variable, that type is
used for the type of the variable in the binding expressions. It must match
the type of the variable inferred from the variable's definition.

It is recommended that a type specifications be preferred over kind
specifications for normal values whose types are relatively easy to describe,
to better document types for readers of the code.

Recursively defined values must not be vacuously recursive. For example, the
following definitions are not allowed:
   
   @ T@ = T@; ...
   <@>@ F@ = <@ T@>{ F@<T@>; }; ...

But it is okay to define recursive types and values that involve a constructor
somewhere, such as:

   @ T@ = +(T@ x);
   <@>@ F@ = <@ T@>{ *(F@<F@<T@>> x); }

TODO: Clarify what we mean by "must not be". Is it that vacuous types are
reported as compile errors and vacuous values reported as runtime errors?
Because I don't think we can detect vacuous values in general at compile time.
Or do we want to require the compiler to do conservative analysis to say any
code path (reachable or unreachable) that could lead to a vacuous value gets
flagged as a compile time error?

Bindings are allowed to define variables with the same name as variables
already in scope, thus shadowing the variable already in scope. Except that
the variables defined in a single let expression must have distinct names.

Implementations are encouraged to emit warnings for unused variables, with the
convention that no warnings should be produced for variables starting with '_'
in their name. This allows the programmer to annotate a variable as
intentionally unused, which is occasionally useful in practice.

Runtime is O(N log(M)) plus the runtimes of the bindings and the runtime of
the body, where N is the number of bindings and M is the number of variables
in scope.

3. Structs
----------
A struct value is a grouping of other values. The items of a struct are
organized into a finite number of fields. Each field has a name, used to
identify the field, and a type, specifying the type of value for that field.

Struct values are constructed by supplying values for all fields of the
struct. Individual components of a struct can be accessed by field name.

Struct values can be used for namespaces, by grouping together a collection of
types and normal values. Syntax is provided for creating struct values with
implicit types to facilitate this use case.

3.1 Struct Type
---------------
Abstract Syntax:
  Expr ::= struct_type (fields :: [(Type, Name)])

Concrete Syntax:
  expr ::= '*(' [type name [',' type name [...]]] ')'

Examples:
  *()                 is the Unit type
  *(Int@ x, Int@ y)   is the type of a pair of ints x, y.

Struct types are considered equal if their fields are equal, including field
types, field names, and the order of the fields.

Runtime is O(1).

3.2 Struct Value Explicit Type
------------------------------
Abstract Syntax:
  Expr ::= struct_value_explicit_type (type :: Type) (args :: [Expr])

Concrete Syntax:
  expr ::= type '(' [expr [',' expr [...]]] ')'

Example:
  Coord@(3, 5)

The type of the struct value is the explicit type provided, which must be a
struct type. The number of arguments provided must match the number of fields
in the provided type, and the type of each argument must match the type of the
field of the struct type in the same position.

The expression is evaluated by evaluating all arguments and creating a struct
value with the results. The arguments may be evaluated in any order,
sequentially or in parallel.

Runtime is O(N) plus the runtimes of the arguments, where N is the number of
arguments.

3.3 Struct Value Implicit Type
------------------------------
Abstract Syntax:
  Expr ::= struct_value_implicit_type (args :: [(Name, Expr)])

Concrete Syntax:
  expr ::= '@' '(' [name [':' expr] [',' ...]] ')'

Example:
  @(x: 3, y: 5)
  @(Bool@, True, False, Not: NotInternal)

Allows you to construct a struct value with an implicit type. When defining
structs used as namespaces, it is tedious to have to repeat the types of the
entities being defined and to worry about what order they are defined in. The
anonymous struct value makes it more convenient to define structs used as
namespaces.

As a syntactic sugar, if no value for a field is provided, its value is
assumed to be the variable with same name as the field. For example, the above
example is equivalent to:

  @(Bool@: Bool@, True: True, False: False, Not: NotInternal)

The type of the struct value is a struct type with fields defined in the same
order as the implicit value struct: the name of the field is the name provided
and the type of the field is the type of the argument provided.

The expression is evaluated by evaluating all arguments and creating a struct
value with the results. The arguments may be evaluated in any order,
sequentially or in parallel.

Runtime is O(N) plus the runtimes of the arguments, where N is the number of
arguments.

3.4 Struct Access
-----------------
Abstract Syntax:
  Expr ::= struct_access (object :: Expr) (field :: Name)

Concrete Syntax:
  expr '.' name

Example:
  x.first

Returns the value passed to the struct at the corresponding field position
when the struct was constructed.

The object must be a struct value. The field must refer to a field of that
struct value. The type of the expression is the type of the field being
accessed.

The expression is evaluated by evaluating the object, then accessing its field
value.

Runtime is O(log(N)) plus the runtime of the struct object, where N is the
number of fields in the struct.

4. Unions
---------
A union value is a particular value chosen from a group of possible values.
The possible choices are organized into a finite number of fields. Each field
has a name, used to identify the field, and a type, specifying the type of
value for that field.

Union values are constructed by supplying a value for a particular field of
the union. The particular value for the union can be accessed by field name,
and the union can be used to select among other values and expressions based
on the field present in the union value.

4.1 Union Type
--------------
Abstract Syntax:
  Type ::= union_type (fields :: [(Type, Name)])

Concrete Syntax:
  type ::= '+(' type name [',' type name [...]] ')'

Example:
  +(Unit@ true, Unit@ false)

Union types are considered equal if their fields are equal, including field
types, field names, and the order of the fields.

Runtime is O(1).

4.2 Union Value
---------------
Abstract Syntax:
  Expr ::= union_value (type :: Type) (field :: Name) (arg :: Expr)

Concrete Syntax:
  expr ::= type '(' name ':' expr ')'

Example:
  Maybe@(Just: 3)

The type of the union value is the type provided, which must be a union type.
The supplied argument name must be of a field in the union type, and the type
of the argument must match the type of that field.

The expression is evaluated by evaluating the argument and creating a union
value with the result.

Runtime is O(log(N)) plus the runtime of the arg, where N is the number of
fields in the union.

4.3 Union Access
----------------
Abstract Syntax:
  Expr ::= union_access (object :: Expr) (field :: Name)

Concrete Syntax:
  expr ::= expr '.' name

Example:
  x.just

Returns the value passed to the union at the corresponding field position when
the union was constructed. Behavior is undefined if the union tag does not
match the field being accessed.

The object must be a union value. The field must refer to a field of that
union value. The type of the expression is the type of the field being
accessed.

The expression is evaluated by evaluating the object, then accessing its field
value.

Runtime is O(log(N)) plus the runtime of the object, where N is the number of
fields in the union.

4.4 Union Select
----------------
Abstract Syntax:
  Expr ::= union_select (condition :: Expr) (choices :: [(Name, Expr)]) (default :: Expr)

Concrete Syntax:
  expr ::= expr '.?(' name ':' expr [',' name ':' expr [...]] [',' ':' expr]')'
  stmt ::= expr '.?(' name ':' expr [',' name ':' expr [...]] ')' ';' stmt

Example:
  mfoo.?(Just: mfoo.Just, Nothing: 3)
  char.?(a: True, b: True, : False)
  { char.?(a: True, b: True); False; }

The condition must be a union value. Returns the value of the choice selected
by the tag of the condition, without causing any other choices to be
evaluated. The type of all choices must be the same.

If no default is provided, a choice must be present for each field of the
condition's union type. If a default is provided, the default value will be
used for any fields not explicitly listed. The fields must be listed in the
same order as they are declared in the union type, regardless of whether or
not a default value is provided. At least one non-default choice must be
provided.

A default branch may be specified even if all fields have explicit branches.
This allows new fields to be added to the union type, defaulting to the
default branch instead of having to update all union select expressions on
that type. Any errors in compilation of the default branch are considered
errors in the program, even if the default branch is unused.

The expression is evaluated by evaluating the condition, then evaluating the
choice selected by the condition. No other choices are evaluated.

Runtime is O(log(N)) plus the runtimes of the condition and selected argument,
where N is the number of fields in the union.

The stmt form of syntax is an alternate syntax to reduce syntactic overhead of
nested union select expressions. In this syntax the body of the default branch
is specified in the statement following the union select.

For example, the following union select expression:
 
  x.?(
    true: y.?(
      true: A,
      : B),
    false: y.?(
      true: C,
      : D));

Is equivalent to the following statement based form:

  {
    x.?(true: { y.?(true: A); B; });
    y.?(true: C);
    D;
  }

5. Functions
------------
A function is a mapping from one or more argument values to a result value.
Each argument has a name, used to identify the argument in the body of the
function, and a type, specifying the type of value that can be supplied for
that argument. A function has a return type, specifying the type of value that
will result when applying the function.

Functions are described using the fble expression language. A function can be
applied to arguments of appropriate type to produce a value with the return
type of the function.

5.1 Function Type
-----------------
Abstract Syntax:
  Type ::= func_type (args :: [Type]) (return :: Type)

Concrete Syntax:
  block ::= '(' type [',' type [...]] ')' block

Examples:
  (Int@, Int@){ Bool@; }

The function type describes the type of a function value by specifying the
function's argument and return types.

Function arguments can be any kind of value, including types, structs, unions,
functions, or processes.

Two function types are equal if their argument and return types are equal.

Curried function types are not considered equal. For example, the following
two expressions describe different types:

 (a, b) { c; }
 (a) { (b) { c;}; }
  
We distinguish between these types because in practice there are performance
implications for which type you choose.

Runtime is O(1);

5.2 Function Value
------------------
Abstract Syntax:
  Expr ::= func_value (args :: [(Type, Name)]) (body :: Expr)

Concrete Syntax:
  block ::= '(' type name [',' type name [...]] ')' block

Example:
  (Bool@ a, Bool@ b) { a.?(true: b, false: False); }

The function value expression is used to describe a primitive function value
given the arguments and the body of the function. The return type of
the function is inferred to be the type of the body of the function. The
argument names chosen when defining a function have no effect on the type of
the function.

Arguments to multi-argument functions must have distinct names, because it's
more likely you gave multiple arguments the same name accidentally than on
purpose.

Runtime is O(N log(M)), where N is the number of variables in scope that are
captured by the function and M is the number of variables in scope. Only
variables referenced in the body of the function are captured by the function.

5.3 Function Application
------------------------
Abstract Syntax:
  Expr ::= apply (func :: Expr) (args :: [Expr])

Concrete Syntax:
  expr ::= expr '(' expr [',' expr [...]] ')'

Example:
  foo(x, y)

The application expression is used to apply a function to some arguments. The
supplied arguments must match the type of arguments specified for the
function. The application expression evaluates to the value of the body of the
function in the context of the supplied arguments.

Runtime is O(log(N + M)) plus the runtime of func, the runtimes of each of the
arguments, and the runtime of the body, where N is the number of arguments to
the function and M is the number of variables captured by the function.

6 Processes
-----------
A process is a computation with side effects that produces a value. Side
effects take the form of getting and putting values to and from links that can
be accessed by other running processes.

There are primitive processes for getting a value from a link, putting a value
to a link, and creating and using a new link. Processes can be combined by
executing them in parallel and serial.

We make a distinction between when a process is evaluated and when a process
is executed. Evaluating a process means evaluating the fble expression that
describes the process, producing a process value. Executing a process means
executing the process described by a process value, producing the result of
the process.

6.1 Process Type
----------------
Abstract Syntax:
  Type ::= proc_type (return :: Type)

Concrete Syntax:
  type ::= type '!'

Example:
  Int@!

Runtime is O(1).

6.2 Process Eval
----------------
Abstract Syntax:
  Expr ::= proc_eval (body :: Expr)

Concrete Syntax:
  expr ::= '!(' expr ')'

Example:
  !(3)

A process that evaluates body and returns its value without performing any
other actions. The body is not evaluated until the eval process is executed.

Runtime to evaluate is O(N log(M)), where N is the number of variables
captured by the body and M is the number of variables in scope.

Runtime to execute is O(log(N)) plus the runtime of the body, where N is the
number of variables captured by the body.

6.3 Process Link
----------------
Abstract Syntax:
  Expr ::= proc_link (type :: Type) (get :: Name) (put :: Name) (body :: Expr)

Concrete Syntax:
  stmt ::= type '~' name ',' name ';' stmt

Example:
  Int@ ~ input, output; f(input, output)

A link is an unbounded, unidirectional, first-in-first-out pipe for
transferring typed data from one process to another. The primitive side
effecting actions that a process can perform are putting a value onto a link
and getting a taking a value off of a link.

The body of the link process must have type process_type. When executed,
a link process for link of type T@ creates a new link, then evaluates and
executes the body with get and put processes of type T@! and (T@){*();}!
respectively added to the context.

The get process can be used to get the next value from the link, blocking the
process until a value becomes available if necessary.

The put process can be used to put a value onto the link.

Runtime to evaluate is O(N log(M)), where N is the number of variables
captured by the body and M is the number of variables in scope.

Runtime to execute is O(log(N)) plus the runtime of the body, where N is the
number of variables captured by the body.

The runtime to execute a get or a put is O(1).

6.4 Process Exec
----------------
Abstract Syntax:
  Expr ::= proc_exec (bindings :: [(Type, Name, Expr)]) (body :: Expr)

Concrete Syntax:
  stmt ::= type name ':=' expr [',' type name ':=' expr [...]] ';' stmt

Example:
  Int@ x := getx, Int@ y := gety; !(add(x, y))

Evaluates and executes each process in parallel, then evaluates and executes
the body with the results of the processes assigned to variables in scope. The
binding processes are not evaluated until the process is executed.

Runtime to evaluate is the sum of O(N log(M)) for each binding and the body,
where N is the number of variables captured by the binding or body and M is
the number of variables in scope.

Runtime to execute is the sum of O(N log(M)) for each binding and the body
plus the runtime to evaluate and execute the bindings and the body, where N is
the number of variables captured by the binding or body and M is the number
of variables in scope of the binding or body.

7. Polymorphism
---------------
Polymorphism allows expressions to be parameterized by abstract types.

7.1 Poly Kind
-------------
Abstract Syntax:
  Kind ::= poly_kind (arg :: Kind) (return :: Kind)

Concrete Syntax:
  kind ::= '<' kind [',' kind [...]] '>' kind

Examples:
  <@>@
  <@, @>%

A poly kind describes the kind of a polymorphic value. It describes what kinds
of values can be used as arguments to polymorphic values.

Two poly kinds are equal if they have the same argument and return kinds.

A poly kind is considered a normal kind if its result kind is a normal kind,
and a type kind of its result kind is a type kind.

The argument kind of a poly kind must be a type kind.

The concrete syntax allows you to specify multiple arguments in a poly kind.
This is syntactic sugar for nested single argument poly kinds. For
example, the following two expressions describe the same kind:
  <@, @, @>@
  <@><@><@>@

7.2 Poly Value
--------------
Abstract Syntax:
  Expr ::= poly_value (arg :: (Kind, TypeName)) (body :: Expr)

Concrete Syntax:
  block ::= '<' kind type_name [',' kind type_name [...] '>' block
 
Examples:
  <@ T@> { +(T@ just, Unit@ nothing); }
  <@ T@>(T@ x){ Maybe@<T@>(just: x); }

A polymorphic value is a value that is parameterized by one or more abstract
types. Poly arguments must be of type kind, not normal kind. The type of a
polymorphic value depends on the value of the poly arguments, but
the runtime value does not. Use a function instead of a poly if you want a
runtime value that changes depending on the value of its arguments.

The type of a poly value is a poly type value with the same arguments as the
poly value whose body describes the type of the poly body. For example, the
type of the poly value:

  <@ T@> { Maybe@<T@>(nothing: Unit@); }

Is the poly type:

  <@ T@> { Maybe@<T@>; }

The body of a poly is evaluated as part of evaluation of the poly value. The
runtime is the runtime of the body.

7.3 Poly Application
--------------------
Abstract Syntax:
  Expr ::= poly_apply (poly :: Expr) (arg :: Type)

Concrete Syntax:
  expr ::= expr '<' type [',' type [...]] '>'

Examples:
  Maybe@<Int@>
  fromJust<Int@>(3)

Poly application is used to specialize a poly value for a specific type.

The type of a poly application is the type of the body of the poly value, with
the abstract type variables substituted for the corresponding concrete type
values provided as argument to the poly application.

The runtime of a poly application is linear in the number of arguments plus
the runtime of the poly. Unlike function application, poly application does
not cause the body of the poly to be re-evaluated.

7.4 Poly Inference
------------------
Abstract syntax:
  Expr ::= poly_infer (poly :: Expr) (args :: [Expr])

Concrete syntax:
  expr ::= expr '(' expr [',' expr [...]] ')'

Examples:
  fromJust(3)

Poly inference is a function application where the type arguments of the poly
are inferred by the compiler based on the types of the function arguments.
Using the example above, where the type of fromJust is:

  <@ T@>(T@) { Maybe@<T@>; }

Assuming the type of 3 is Int@, the expression fromJust(3) is rewritten by the
compiler to fromJust<Int@>(3).

The motivation for supporting type inference is to prevent cluttering the code
with types that are otherwise straight forward to infer. This is particularly
important when used in combination with function bind, where the common use
case requires specifying the return type repeatedly for each call in a
function bind chain.
  
It is a type error if the compiler is unable to unambiguously infer all the
type parameters to the poly based on the arguments. For example, it would be
impossible to infer type arguments to a poly with either of the following
types:
  <@ T@>(Unit@) { T@; }
  <@ T@, @ M@>(M@<T@>) { M@<T@>; }

The type and runtime behavior of a poly inference expression is the same as
the type and runtime behavior of the target combined poly application and
function application expressions.

8. Syntactic Sugar
------------------
We introduce syntax for describing lists and literals to make it less tedious
to write code involving sequences of elements of the same type and raw
sequences of data without the overhead of punctuation between data elements.

We introduce bind syntax to facilitate calling a function with an anonymous
function as its only argument. This is useful for using reusable glue logic to
compose operations in a monadic style.

8.1 List
--------
Abstract Syntax:
  Expr ::= list (func :: Expr) (args :: [Expr])
  
Concrete Syntax:
  expr ::= expr '['[expr [',' expr [...]]] ']'

Examples: 
  List<Int@>[]
  List<Int@>[x]
  List<Int@>[x, f(y), z]

A list expression describes a sequence of one or more values of the same type
that are combined together according to a user supplied function. It is
syntactic sugar for constructing a list value and passing it as a single
argument to a function.

The list expression can be used with any function that has a single argument
of list type. A list type is any type matching the structure of the following
type L@:

  @ L@ = +(*(E@ head, L@ tail) cons, *() nil);

The fields can be named anything, but the order of the fields must match that
shown above. Any type E@ of list elements may be used.

The list expression f[a, b, c], assuming the type of f is (L@) { V@; } for
some type V@, is desugared to:

  f(L@(cons: @(head: a, tail:
    L@(cons: @(head: b, tail:
    L@(cons: @(head: c, tail:
    L@(nil: *()()))))))));

Each argument to the list expression must have a type E@ matching the element
type of the list type L@ expected by the function f.

The motivation for requiring a function to be supplied as part of the list
expression, instead of having stand alone list expressions like [a, b, c], is:
* It allows the user to specify what type of list to build instead of assuming
  a single builtin list type.
* It make it possible to specify the type for empty lists.
* For consistency with literal expressions, which require a user defined
  letter type to be supplied.

8.2 Literal
-----------
Abstract Syntax:
  Expr ::= literal (func :: Expr) (letters :: word)

Concrete Syntax:
  expr ::= expr '|' word

Example:
  Octal|177
  Str|'hello there!'

The literal expression is syntax that allows you to express a raw sequence of
data without the overhead of punctuation between data elements. It is
syntactic sugar for a list expression with a separate list element for each
individual letter of the literal expression's word.

As with the list expression, the literal expression is used with a function
that has a single argument of list type. The element type of the list must be
a union type with fields of type *() for each letter in the word.

For example, the element type for an octal literal might look like:

  @OctalLetters = +(*() 0, *() 1, *() 2, *() 3, *() 4, *() 5, *() 6, *() 7);

The literal expression f|abc, assuming the element type for the list argument
to f is E@, is desugared to:

  f[E@(a: *()()), E@(b: *()()), E@(c: *()())];

It is a type error if the word contains a letter for which there is no
corresponding field in the element type E@.

8.2.1 Example
-------------
To better illustrate the intended use of list and literal expressions, imagine
we want to define a binary integer literal.

The type of letter is a bit:

  @ Unit@ = *();
  @ Bit@ = +(Unit@ 0, Unit@ 1);

The literal will be formed of lists of bits:

  @ Bits@ = +(*(Bit@ head, Bits@ tail) cons, Unit@ nil);

The function specifies how to transform a list of bits into an integer,
assuming some int type Int@:

  (Int@, Bits@) { Int@; } Helper = (Int@ n, Bits@ bits) {
    bits.?(
      cons: {
        Int@ m = Add(Mul(2, n), bits.cons.head.?(0: 0, 1: 1))
        Helper(m, bit.cons.tail);
      } ,
      nil: n);
  };

  (Bits@) { Int@; } Binary = (Bits@ bits) {
    Helper(0, bits);
  };

Now we can form binary literals using list or literal expressions. For
example:

 Int@ 6 = Binary|110;
 Int@ x = Binary[first_bit, second_bit, third_bit];

8.3 Bind
--------
Abstract Syntax:
  Expr ::= bind (args :: [(Type, Name)]) (func :: Expr) (body :: Expr)

Concrete Syntax:
  stmt ::= type name [',' type name [...]] '<-' expr ';' stmt

Example:
  Int@ x <- Map(l);
  f(x, y)

Bind is syntactic sugar for calling a function with an anonymous function as
its only argument. It is equivalent to:

  apply func (func_value args [body])

For example, the expression:

  Int@ x <- Map(l);
  f(x, y)

Desugars to:

  map(l)((Int@ x) { f(x, y); });

Bind is particularly suited for abstracting glue logic that manipulates how
program statements are combined. For example, it can be used to hide error
propagation based on a Maybe monad.

Instead of:
  Maybe@ a = f(x);
  a.?(
    just: {
      Maybe@ b = g(a.just);
      b.?(just: h(b.just), nothing: Nothing);
    },
    nothing: Nothing);

And instead of the slightly better:

  (Maybe@, (X@) { Maybe@; }) { Maybe@; }
  Maybe = (Maybe@ m, (X@) { Maybe@; } f) {
    m.?(just: f(x.just), nothing: Nothing);
  };

  Maybe(f(x), (X@ a) {
    Maybe(g(a), (X@ b) {
      h(b);
    };
  };

You can write:
  
  (Maybe@)((X@) { Maybe@; }) { Maybe@; }
  Maybe = (Maybe@ m)((X@) { Maybe@; } f) {
    m.?(just: f(x.just), nothing: Nothing);
  };

  X@ a <- Maybe(f(x));
  X@ b <- Maybe(g(x));
  h(b);

Which more clearly separates the glue logic from the meat of the program.

Bind works at the level of concrete syntax. It can be used for any expression
that has the same form as function application, including poly inference,
explicit type struct value, and abstract value.

9. Modules
----------
Fble code is organized into a hierarchy of reusable modules. Each module
describes a value that may depend on the value of other modules. A program is
formed by combining a module with all of its direct and indirect dependencies.

9.1 Organization
----------------
Modules are organized into a tree structure. The purpose of the tree structure
is to group modules together that are developed by the same organization to
help avoid name conflicts.

Each node in the tree is a module. Each module has a value and zero or more
named child nodes.

A module's value may be trivial if the module is intended primarily for
organizational purposes. A module need not contain any children if it is
intended primarily for providing a useful module value.

The module hierarchy is described in a platform dependant manner. On a
platform with standard file system, the following is suggested:

The hierarchy of modules is expressed using a directory hierarchy. The value
of a module Foo is described in the file Foo.fble as an fble expression using
the 'stmt' concrete syntactic term. The child modules of Foo are placed in a
directory Foo/. The absence of a file Foo.fble implies the value of the module
Foo is *()(). The absence of a subdirectory Foo implies the module Foo has no
children.

For example, you might have the following directory structure:

  root/
   StdLib/
     Unit.fble
     List.fble
     List/
       Tests.fble
   Md5.fble
   Md5/
     Tests.fble

9.2 Path
--------
Modules may depend on other modules independent of the tree hierarchy of
modules. A program can include a module without having to depend on any
descendants of that module. The only restrictions on module dependencies are
that there must not be any cyclic dependencies and module visibility rules
must be obeyed. A module may not reference itself, as that is considered a
form of cyclic dependency.

A module is referred to using an absolute path, which describes a path of
named children from the root of the module hierarchy.

Abstract Syntax:
  Path ::= abs_path (name :: [Name])
  Expr ::= module_path (ref :: Path)

Concrete Syntax:
  path ::= '/' name ['/' name [...]] '%'
  expr ::= path ;

Examples:
  /StdLib/List%
  /Unit%
  /Md5/ImplA%

9.3 Program
-----------
A program is an fble expressions that creates a value that is used however is
deemed suitable by whoever is executing the program. Commonly this could be:

* struct: evaluate and output the value
* union: evaluate and output the value
* function: apply the function to arguments provided on the command line,
  evaluate and output the resulting value
* process: run the process, evaluate and output the resulting value.

A program is formed of a module and all of its direct and indirect
dependencies. For example, consider the following module hierarchy:

  StdLib/
    Unit
    List/
      Tests
  Md5/
    Tests

With the following dependency graph:

  /StdLib/List% -> StdLib/Unit%
  /StdLib/List/Tests% -> /StdLib/List%, /StdLib/Unit%
  /Md5% -> /StdLib/Unit%, /StdLib/List%
  /Md5/Tests% -> /StdLib/Unit%, /Md5%

The module /Md5/Tests% can be turned into a program to run Md5 tests
conceptually by forming a let expression in topological sort dependency order:

  StdLib_Unit = </StdLib/Unit%>;
  StdLib_List = </StdLib/List%>;
  Md5 = </Md5%>;
  </Md5/Tests%>;

Where </Foo%> is the fble expression describing the value of module /Foo% and
we assume references to a module /Foo/Bar% in the expression are replaced with
variables named Foo_Bar.

Notice in this case that the value of /StdLib/List/Tests% is not used.

The modules may be combined in any order that satisfies their dependencies.

The same module hierarchy can be used for a program to run List tests:
 
  StdLib_Unit = </Stdlib/Unit%>;
  StdLib_List = </StdLib/List%>;
  </StdLib/List/Tests%>;

10. Abstract Types
------------------
Abstract types provide a mechanism to define types of values that can only be
accessed by modules in the same package. This makes it possible to hide
implementation details from users and enforce invariants on how values are
constructed.

By default, anyone can use any operation supported by the type of a value,
including construction, field access, conditional access, function
application, and so on. Abstract types introduce the concept of a package
type that can be used to restrict access to types based on module path.
Modules that do not have restricted access can only interact with a type using
publicly available functions.

10.1 Package Type
-----------------
Abstract Syntax:
  Type ::= package_type (path :: Path)

Concrete Syntax:
  type ::= '%(' path ')'

Example:
  @ FooBar@ = %(/Foo/Bar%);
  ...

The package type describes the set of modules whose module path prefix matches
the given path. For example, the type %(/Foo/Bar%) includes modules /Foo/Bar%,
/Foo/Bar/Sludge%, and /Foo/Bar/A/B%, but not /Foo% or /Bar%.

The path for a package type need not refer to an existing module. There need
not be any modules that satisfy the package path. A module need not be a
member of whatever package type it constructs.

TODO: Can you pass an empty path, with the interpretation of the value is
accessible to all modules? Do we allow empty path in general? It seems
unnecessary to make an abstract type that every module can access, but maybe
it's useful to have for uniformity of interaction with the type?

A package type has kind @. Two package types are considered equal if they have the same path.

10.2 Abstract Type
------------------
Abstract Syntax:
  Type ::= abstract_type (package :: Type) (type :: Type)

Concrete Syntax:
  type ::= type '<' type '>'

Example:
  @ FooBar@ = %(/Foo/Bar%);
  @ AbstractBool = FooBar@<Bool@>;
  
Forms an abstract type by combining the given package type with an underlying
type. Abstract types are considered equal if both their package type and
underlying types are equal.

The package type must be a package type. The underlying type can be any type
of any kind. The resulting abstract type has kind @.

10.3 Abstract Cast
------------------
Abstract Syntax:
  Expr ::= abstract_cast (package :: Type) (target :: Type) (value :: Expr)

Concrete Syntax:
  expr ::= type '.' '<' type '>' '(' expr ')'

Example:
  @ FooBar@ = %(/Foo/Bar%);
  @ AbstractBool@ = FooBar@<Bool@>;
  AbstractBool@ AbstractTrue = FooBar@.<AbstractBool@>(True);
  Bool@ OriginalTrue = FooBar@.<Bool@>(AbstractTrue);

Casts a value between two types that are equal under the assumption that for
all types T@, the type FooBar@<T@> is equal to T@.

The type of the resulting value is the target type. It is a type error if the
current module is not a member of the package described by the package type.

10.4 Abstract Value
-------------------
Abstract Syntax:
  Expr ::= abstract_value (package :: Type) (value :: Expr)

Concrete Syntax:
  expr ::= type '(' expr ')'

Example:
  @ FooBar@ = %(/Foo/Bar%);
  @ AbstractBool@ = FooBar@<Bool@>;
  AbstractBool@ AbstractTrue = FooBar@(True);

Casts a value of type T@ to type FooBar@<T@>. This is a convenience syntax
equivalent to:

  abstract_cast package (abstract_type package type) value

It is a type error if the current module does not belong to the package
described by the package type.

This special syntax is provided to simplify the syntax for the common case of
casting directly to an abstract value. It's not possible in general to use a
standard function for this case given the package restriction applies to where
the cast operation occurs.

10.5 Abstract Access
--------------------
Abstract Syntax:
  Expr ::= abstract_access (value :: Expr)

Concrete Syntax:
  expr ::= expr '.' '%'

Example:
  @ FooBar@ = %(/Foo/Bar%);
  @ AbstractBool@ = FooBar@<Bool@>;
  AbstractBool@ AbstractTrue = FooBar@(True);
  Bool@ true = AbstractTrue.%;

Casts a value of type FooBar@<T@> to type T@. This is a convenience syntax
equivalent to:

  abstract_cast package type value

It is a type error if the current module does not belong to the package
described by the package type.

This special syntax is provided to simplify the syntax for the common case of
casting directly from an abstract value. It's not possible in general to use a
standard function for this case given the package restriction applies to where
the cast operation occurs.

10.6 Abstract Type Example
--------------------------
The follow example shows how to define a three element enum type that can only
be accessed externally using the provided methods.

  @ Impl@ = +(Unit@ a, Unit@ b, Unit@ c);

  @ Pkg@ = %(/MyPackage%);
  @ Enum@ = Pkg@<Impl@>;

  Enum@ A = Pkg@.<Enum@>(Impl@(a: Unit));
  Enum@ B = Pkg@.<Enum@>(Impl@(b: Unit));
  Enum@ C = Pkg@.<Enum@>(Impl@(c: Unit));

  (Enum@) { Bool@; } IsA = Pkg@.<@<IsA>>((Impl@ e) { e.?(a: True, : False); });
  (Enum@) { Bool@; } IsB = Pkg@.<@<IsB>>((Impl@ e) { e.?(b: True, : False); });
  (Enum@) { Bool@; } IsC = Pkg@.<@<IsC>>((Impl@ e) { e.?(c: True, : False); });

  @(Enum@, A, B, C, IsA, IsB, IsC);

The Pkg@ type restricts asscess to the internals of the Enum@ type to modules
starting with /MyPackage in their path. Other users are unable to construct or
access fields of the Enum@ type directly; they can only use the provided
values A, B, C and functions IsA, IsB, and IsC.

10.7 Private Module Example
---------------------------
Abstract types can be used to effectively mark modules or parts of modules
private. For example, consider a module /Foo/Internal%:

  @ Pkg@ = %(/Foo%);
  
  @ X@ = ...;
  @ Y@ = ...;
  X@ X = ...;
  Y@ Y = ...;

  Pkg@(@(X@, Y@, X, Y));

Users can import the module with:
 
 % M = /Foo/Internal%.%;

This will result in a type error if the user does not belong to the package
/Foo%.

The same approach can be used to restrict access to individual fields of a
module. For example, consider a module /Foo%:

  @ Pkg@ = %(/Foo%);
  
  @ X@ = ...;
  @ Y@ = ...;
  X@ X = ...;
  Y@ Y = ...;

  @(X@, Y@, X, Pkg@(Y));

In this case, the 'X' field is publicly accessible. The 'Y' field can only be
accessed by modules in the package /Foo%. For example:

  % Y = /Foo%.Y.%;

This will result in a type error if the user does not belong to the package
/Foo%.

11. Abstract Syntax Reference
----------------------------
NormalName ::= (* A string of characters *)
TypeName ::= (* A string of characters *)

Name ::=
   normal_name (name :: NormalName)
 | type_name (name :: TypeName)
 ;

Path ::=
   abs_path (name :: [Name])
 ;

Kind ::=
   basic_normal_kind
 | basic_type_kind
 | poly_kind (arg :: Kind) (result :: Kind)
 ;

Type ::= (* synonym for Expr where a type is expected *)

Spec ::=
   kind_spec (kind :: Kind)
 | type_spec (type :: Type)
 ;
     
Expr ::=
   typeof (expr :: Expr)
 | var (name :: Name)
 | let (bindings :: [(Spec, Name, Expr)]) (body :: Expr)
 | module_path (path :: Path)

 | struct_type (fields :: [(Type, Name)])
 | struct_value_explicit_type (type :: Type) (args :: [Expr])
 | struct_value_implicit_type (args :: [(Name, Expr)])
 | struct_access (object :: Expr) (field :: Name)

 | union_type (fields :: [(Type, Name)])
 | union_value (type :: Type) (field :: Name) (arg :: Expr)
 | union_access (object :: Expr) (field :: Name)
 | union_select (condition :: Expr) (choices :: [(Name, Expr)]) (default :: Expr)

 | func_type (args :: [Type]) (result :: Type)
 | func_value (args :: [(Type, Name)]) (body :: Expr)
 | func_apply (func :: Expr) (args :: [Expr])

 | proc_type (result :: Type)
 | proc_eval (body :: Expr)
 | proc_link (type :: Type) (get :: Name) (put :: Name) (body :: Expr)
 | proc_exec (bindings :: [(Type, Name, Expr)]) (body :: Expr)

 | poly_value (arg :: (Kind, Name)) (body :: Expr)
 | poly_apply (poly :: Expr) (arg :: Expr)
 | poly_infer (poly :: Expr) (args :: [Expr])

 | package_type (path :: Path)
 | abstract_type (package :: Type) (type :: Type)
 | abstract_cast (package :: Type) (target :: Type) (value :: Expr)
 | abstract_value (package :: Type) (value :: Expr)
 | abstract_access (package :: Type) (value :: Expr)

 | list (func :: Expr) (args :: [Expr])
 | literal (func :: Expr) (letters :: word)
 | bind (args :: [(Type, Name)]) (func :: Expr) (body :: Expr)
 ;

Module ::= (value :: Expr) (public :: [Module]) (private :: [Module])

12. Concrete Syntax
-------------------
12.1 Lexical Syntax
-------------------
We have the following categories of characters:
1. whitespace: Any whitespace character, as traditionally classified.
2. The comment character '#'.
3. punctuation: Any of the following characters:
  (){};,:?=.<>+*-!$@~'\[]%/
4. normal: any other character.

The lexical syntax is used to interpret a string of arbitrary characters as a
sequence of punctuation characters and words.

Whitespace is treated as a delimiter of words. The comment character and any
following characters on the same line are treated as a delimiter of words.
Whitespace and comments are otherwise ignored.

A sequence of continuous normal characters is grouped together into a word.

A sequence of characters surrounded by single quotes is treated as a sequence
of normal characters, regardless of what class the characters come from. This
makes it possible to specify words containing whitespace, comment, and
punctuation characters. For example, 'Foo,Bar' is treated as a single word
where the fourth character of the word is a comma.

Within a single quoted word, a single quote character can be expressed by
using two adjacent single quote characters. For example, 'Foo''Bar' is treated
as a single word where the fourth character of the word is a single quote.

Single quotes act as word delimiters. For example, Foo'.'Bar is treated as
three separate words: 'Foo', '.', and 'Bar', not as a single word 'Foo.Bar'.
The only exception is when consecutive single quote characters are used to
embed a single quote character in a word.

12.2 Reference
--------------
word ::= (* word as described in the section on lexical syntax *)
normal_name ::= word
type_name ::=   word '@'

name ::= 
   normal_name
 | type_name
 ;

path ::= '/' name ['/' name [...]] '%' ;

kind ::=
   '%'                                             (* normal_kind *)
 | '@'                                             (* type_kind *)
 | '<' kind [',' kind [...]] '>' kind              (* poly_kind *)
 ;

type ::= expr ;

spec ::= 
   kind                                            (* kind_spec *)
 | type                                            (* type_spec *)
 ;

expr ::= 
   '@' '<' expr '>'                                (* typeof *)
 | name                                            (* var *)
 | path                                            (* module_path *)

 | '*(' [type name [',' type name [...]]] ')'      (* struct_type *)
 | type '(' [expr [',' expr [...]]] ')'            (* struct_value_explicit_type *)
 | '@(' [name [':' expr] [',' ...]] ')'            (* struct_value_implicit_type *)
 | expr '.' name                                   (* struct_access *)

 | '+(' type name [',' type name [...]] ')'        (* union_type *)
 | type '(' name ':' expr ')'                      (* union_value *)
 | expr '.' name                                   (* union_access *)
 | expr '.?(' name ':' expr                        (* union_select *)
           [',' name ':' expr [...]]
           [',' ':' expr ] ')'   

 | expr '(' expr [',' expr [...]] ')'              (* func_apply, poly_infer *)

 | type '!'                                        (* proc_type *)
 | '!(' expr ')'                                   (* proc_eval *)

 | expr '<' type [',' type [...]] '>'              (* poly_apply *)

 | '%' '(' path ')'                                (* package_type* )
 | type '<' type '>'                               (* abstract_type *) 
 | type '.' '<' type '>' '(' expr ')'              (* abstract_cast *) 
 | type '(' expr ')'                               (* abstract_value *) 
 | expr '.' '%'                                    (* abstract_access *) 

 | expr '['[expr [',' expr [...]] ']'              (* list *)
 | expr '|' word                                   (* literal *)

 | block
 ;

block ::=
   '{' stmt '}'
 | '(' type [',' type [...]] ')' block               (* func_type *)
 | '(' type name [',' type name [...]] ')' block     (* func_value *)
 | '<' tkind name [',' tkind name [...]] '>' block   (* poly_value *)
 ;

stmt ::=
   expr ';'
 | spec name '=' expr [',' spec name '=' expr [...]] ';' stmt        (* let *)
 | expr '.?(' name ':' expr [',' name ':' expr [...]] ')' ';' stmt   (* union_select *)
 | type '~' name ',' name ';' stmt                                   (* proc_link *)
 | type name ':=' expr [',' type name ':=' expr [...]] ';' stmt      (* proc_exec *)
 | type name [',' type name [...]] '<-' expr ';' stmt                (* bind *)
 ;

module ::= stmt                                                      (* module_value *)
 ;

Notes:
* struct and union access share the same form. The type of the object is used
  to distinguish between the two kinds of expressions.
* explicit type struct value, function apply, poly inference, and abstract
  value share the same form. The type of the expr is used to distinguish
  between the four kinds of expressions. Each of these kinds of expressions
  can be the target of a bind expression.
* Polymorphic application and abstract type share the same form. The type of
  the argument is used to distinguish between the three kinds of expressions.
* The module value for module /Foo/Bar% is stored in Foo/Bar.fble.
