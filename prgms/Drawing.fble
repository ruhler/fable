
@ Unit@ = /Unit%.Unit@;
% Unit = /Unit%.Unit;

@ Int@ = /Int/Int%.Int@;
% Add = /Int/Int%.Add;
% Mul = /Int/Int%.Mul;

<@>@ List@ = /List%.List@;
<@>% List = /List%.List;
<@,@>% Map = /List%.Map;

@ Color@ = +(
  Unit@ black,
  Unit@ red,
  Unit@ green,
  Unit@ yellow,
  Unit@ blue,
  Unit@ magenta,
  Unit@ cyan,
  Unit@ white);

@ Point@ = *(Int@ x, Int@ y);

@ Drawing@ = +(
  # A blank (transparent) drawing.
  Unit@ blank,
  
  # A filled path.
  #
  # The path is implicitly closed. For example, to draw a rectangle, give the
  # four corner points in order, such as: [(0, 0), (2, 0), (2, 2), (0, 2)].
  *(List@<Point@> points, Color@ color) path,

  # Draw one drawing over another.
  *(Drawing@ below, Drawing@ above) over
);

Drawing@ Blank = Drawing@(blank: Unit);

# Draw a path filled solid with the given color.
#
# The path is implicitly closed. For example, to draw a rectangle, give the
# four corner points in order, such as: [(0, 0), (2, 0), (2, 2), (0, 2)].
(List@<Point@>, Color@) { Drawing@; } Path = (List@<Point@> points, Color@ color) {
  Drawing@(path: @(points, color));
};

# Draw a rectangle filled solid with the given color.
(Int@, Int@, Int@, Int@, Color@) { Drawing@; }
Rect = (Int@ x, Int@ y, Int@ w, Int@ h, Color@ color) {
  Drawing@(path: @(
    points:
      List<Point@>[
        Point@(x, y),
        Point@(Add(x, w), y),
        Point@(Add(x, w), Add(y, h)),
        Point@(x, Add(y, h))],
    color: color));
};

# Compose two drawings together by drawing one over another.
(Drawing@, Drawing@) { Drawing@; } Over = (Drawing@ below, Drawing@ above) {
  Drawing@(over: @(below, above));
};

# Combing a list of drawings into a single drawing by drawing each subsequent
# drawing on top of the previous drawing.
(List@<Drawing@>) { Drawing@; } Drawings = (List@<Drawing@> drawings) {
  drawings.?(
    cons: Over(drawings.cons.head, Drawings(drawings.cons.tail)),
    nil: Blank);
};

# Transform all of the coordinates in the given drawing.
((Point@) { Point@; }, Drawing@) { Drawing@; }
Transform = ((Point@) { Point@; } f, Drawing@ d) {
  d.?(blank: d,
    path:
      Drawing@(
        path: @(
          points: Map<Point@, Point@>(d.path.points, f),
          color: d.path.color)),
       over: {
         Over(Transform(f, d.over.below), Transform(f, d.over.above));
       });
};

# Transform the drawing using an affine transform. Each point p will be
# transformed to (a.x*p.x + b.x, a.y*p.y + b.y).
(Point@, Point@, Drawing@) { Drawing@; }
Affine = (Point@ a, Point@ b, Drawing@ d) {
  (Point@) { Point@; } f = (Point@ p) {
    @(x: Add(Mul(a.x, p.x), b.x), 
      y: Add(Mul(a.y, p.y), b.y));
  };

  Transform(f, d);
};

# Translate the drawing by the given x and y amounts.
(Int@, Int@, Drawing@) { Drawing@; }
Translate = (Int@ dx, Int@ dy, Drawing@ d) {
  Transform((Point@ p) { Point@(Add(dx, p.x), Add(dy, p.y)); }, d); 
};

@(Color@, Drawing@, Point@,
  Blank, Path, Rect, Over, Drawings, Affine, Translate);
