
import @ { HexM=Hex; Bit4M=Bit4; Bit@Bit; Bit1; BitNI; BoolM=Bool@StdLib; };
import HexM { 0; Hex; };
import Bit4M { Bit4; };

struct Bit8(Bit4 hi, Bit4 lo);

module BitN(BitNI<Bit8>) {
  import @ { Bit8; B = BitN@Bit4M; Bit1; Bit; BoolM; };
  import BoolM { Bool; And; };

  func not(Bit8 a ; Bit8) {
    Bit8(not@B(a.hi), not@B(a.lo));
  };

  func and(Bit8 a, Bit8 b; Bit8) {
    Bit8(and@B(a.hi, b.hi), and@B(a.lo, b.lo));
  };

  func or(Bit8 a, Bit8 b; Bit8) {
    Bit8(or@B(a.hi, b.hi), or@B(a.lo, b.lo));
  };

  func xor(Bit8 a, Bit8 b; Bit8) {
    Bit8(xor@B(a.hi, b.hi), xor@B(a.lo, b.lo));
  };

  func add(Bit8 a, Bit8 b; Bit8) fulladd(a, b, zero@Bit1()).z;

  func zero(; Bit8) {
    Bit8(zero@B(), zero@B());
  };

  func iszero(Bit8 a; Bool) {
     And(iszero@B(a.hi), iszero@B(a.lo));
  };

  func eq(Bit8 a, Bit8 b; Bool) {
     And(eq@B(a.hi, b.hi), eq@B(a.lo, b.lo));
  };

  func clshift(Bit8 a; Bit8) lshift(a, a.hi.hi.hi).z;

  struct Result(Bit8 z, Bit cout);

  func fulladd(Bit8 a, Bit8 b, Bit cin; Result) {
    Result@B rlo = fulladd@B(a.lo, b.lo, cin);
    Result@B rhi = fulladd@B(a.hi, b.hi, rlo.cout);
    Result(Bit8(rhi.z, rlo.z), rhi.cout);
  };

  func lshift(Bit8 a, Bit cin; Result) {
    Result@B rlo = lshift@B(a.lo, cin);
    Result@B rhi = lshift@B(a.hi, rlo.cout);
    Result(Bit8(rhi.z, rlo.z), rhi.cout);
  };
};

func H1(Hex x; Bit8) {
  H2(0(), x);
};

# Constructs a byte from 2 hex digits.
func H2(Hex hi, Hex lo; Bit8) {
  Bit8(H1@Bit4M(hi), H1@Bit4M(lo));
};
