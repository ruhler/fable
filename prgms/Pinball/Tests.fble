
<@>% List = /List%.List;
<@>% Nil = /List%.Nil;

@ Num@ = /Pinball/Num%.Num@;
% Neg = /Pinball/Num%.Neg;
% Int = /Pinball/Num%.Int;
% Sub = /Pinball/Num%.Sub;
% Div = /Pinball/Num%.Div;

@ Ball@ = /Pinball/Ball%.Ball@;

@ Edge@ = /Pinball/Edge%.Edge@;
% Edge = /Pinball/Edge%.Edge;

@ Paddle@ = /Pinball/Paddle%.Paddle@;
% Paddle = /Pinball/Paddle%.Paddle;

@ World@ = /Pinball/World%.World@;
% Tick = /Pinball/World%.Tick;

@ Vec@ = /Pinball/Vec%.Vec@;

% Str = /String%.Str;

@ Test@ = /Test%.Test@;
% Test = /Test%.Test;
% TestSuite = /Test%.TestSuite;
<@>% AssertEquals = /Test%.AssertEquals;

Test@ Tests = TestSuite(Str|'Pinball', List<Test@>[
  /Pinball/Rotate/Tests%.Tests,
  /Pinball/Quadratic/Tests%.Tests,

  Test(Str|'Move Ball No Collision', !({
    # The ball moves freely to the right 10 units per tick.
    World@ start = @(
      gravity: Vec@(Int|0, Int|0),
      ball: Ball@(Vec@(Int|0, Int|0), Vec@(Int|10, Int|0), Int|1),
      edges: Nil<Edge@>,
      paddles: Nil<Paddle@>);
    World@ end = Tick(start);
    Ball@ want = @(
      pos: Vec@(Int|10, Int|0),
      vel: Vec@(Int|10, Int|0),
      radius: Int|1);
    Ball@ got = end.ball;
    AssertEquals<Ball@>(/Pinball/Ball%.Eq, /Pinball/Ball%.Show, want, got);
  })),
  
  Test(Str|'Move Ball Collision', !({
    # The ball moves to the right, hits a wall, then bounces back.
    World@ start = @(
      gravity: Vec@(Int|0, Int|0),
      ball: Ball@(Vec@(Int|0, Int|0), Vec@(Int|10, Int|0), Int|1),
      edges: List<Edge@>[
        Edge(Vec@(Int|6, Neg(Int|4)), Vec@(Int|6, Int|4), Int|1)
      ],
      paddles: Nil<Paddle@>);
    World@ end = Tick(start);

    Ball@ want = @(
      pos: Vec@(Int|0, Int|0),
      vel: Vec@(Neg(Int|10), Int|0),
      radius: Int|1);
    Ball@ got = end.ball;
    AssertEquals<Ball@>(/Pinball/Ball%.Eq, /Pinball/Ball%.Show, want, got);
  })),

  Test(Str|'Move Ball Avoid Collision', !({
    # The ball moves to the right, passing beneath a wall.
    # Regression test for when we failed to check collision happens within the
    # bounds of a wall.
    World@ start = @(
      gravity: Vec@(Int|0, Int|0),
      ball: Ball@(Vec@(Int|0, Int|0), Vec@(Int|10, Int|0), Int|1),
      edges: List<Edge@>[
        Edge(Vec@(Int|5, Int|3), Vec@(Int|5, Int|11), Int|1)
      ],
      paddles: Nil<Paddle@>);
    World@ end = Tick(start);
    Ball@ want = @(
      pos: Vec@(Int|10, Int|0),
      vel: Vec@(Int|10, Int|0),
      radius: Int|1);
    Ball@ got = end.ball;
    AssertEquals<Ball@>(/Pinball/Ball%.Eq, /Pinball/Ball%.Show, want, got);
  })),

  Test(Str|'Stationary Paddle Collision', !({
    # The ball moves down at constant velocity onto a stationary paddle.
    World@ start = @(
      gravity: Vec@(Int|0, Int|0),
      ball: @(
        pos: Vec@(Int|2, Int|2),
        vel: Vec@(Int|0, Neg(Int|2)),
        radius: Int|1),
      edges: Nil<Edge@>,
      paddles: List<Paddle@>[
        Paddle(Vec@(Int|0, Int|0), Vec@(Int|4, Int|0), Int|0, Int|0,
          Neg(Int|1), Int|1, Int|1)
      ]);
    World@ end = Tick(start);
    Ball@ want = @(
      pos: Vec@(Int|2, Int|2),
      vel: Vec@(Int|0, Int|2),
      radius: Int|1);
    Ball@ got = end.ball;
    AssertEquals<Ball@>(/Pinball/Ball%.Eq, /Pinball/Ball%.Show, want, got);
  })),

  Test(Str|'Stationary Paddle Collision Restitution', !({
    # Test that restitution of the paddle is taken into account during
    # collision.
    World@ start = @(
      gravity: Vec@(Int|0, Int|0),
      ball: @(
        pos: Vec@(Int|2, Int|2),
        vel: Vec@(Int|0, Neg(Int|2)),
        radius: Int|1),
      edges: Nil<Edge@>,
      paddles: List<Paddle@>[
        Paddle(Vec@(Int|0, Int|0), Vec@(Int|4, Int|0), Int|0, Int|0,
          Neg(Int|1), Int|1, Div(Int|1, Int|2))
      ]);
    World@ end = Tick(start);
    Ball@ want = @(
      pos: Vec@(Int|2, Div(Int|3, Int|2)),
      vel: Vec@(Int|0, Int|1),
      radius: Int|1);
    Ball@ got = end.ball;
    AssertEquals<Ball@>(/Pinball/Ball%.Eq, /Pinball/Ball%.Show, want, got);
  })),

  Test(Str|'Stationary Ball With Paddle', !({
    # Regression test for a divide by zero that happens if the ball is
    # stationary relative to the paddle.
    World@ start = @(
      gravity: Vec@(Int|0, Int|0),
      ball: @(
        pos: Vec@(Int|2, Int|2),
        vel: Vec@(Int|0, Int|0),
        radius: Int|1),
      edges: Nil<Edge@>,
      paddles: List<Paddle@>[
        Paddle(Vec@(Int|0, Int|0), Vec@(Int|4, Int|0), Int|0, Int|0,
          Neg(Int|1), Int|1, Int|1)
      ]);
    World@ end = Tick(start);
    Ball@ want = start.ball;
    Ball@ got = end.ball;
    AssertEquals<Ball@>(/Pinball/Ball%.Eq, /Pinball/Ball%.Show, want, got);
  })),

  Test(Str|'End-Stationary Paddle Collision', !({
    # The ball moves down at constant velocity onto a paddle that becomes
    # stationary before the ball hits it.
    # This is a regression test for a case where velocity of the paddle was
    # being treated as non-zero in this case.
    World@ start = @(
      gravity: Vec@(Int|0, Int|0),
      ball: @(
        pos: Vec@(Int|2, Int|2),
        vel: Vec@(Int|0, Neg(Int|2)),
        radius: Int|1),
      edges: Nil<Edge@>,
      paddles: List<Paddle@>[
        Paddle(Vec@(Int|0, Int|0), Vec@(Int|4, Int|0), Int|1,
          Neg(Div(Int|1, Int|4)),
          Neg(Int|1), Int|0, Int|1)
      ]);
    World@ end = Tick(start);
    Ball@ want = @(
      pos: Vec@(Int|2, Int|2),
      vel: Vec@(Int|0, Int|2),
      radius: Int|1);
    Ball@ got = end.ball;
    AssertEquals<Ball@>(/Pinball/Ball%.Eq, /Pinball/Ball%.Show, want, got);
  })),

  Test(Str|'Stationary Paddle Non-Collision', !({
    # The ball moves up at constant velocity away from a stationary paddle.
    # The ball starts just within range of the paddle, but that should not be
    # considered a collision because the ball is moving away from the
    # paddle.
    Num@ e = Div(Int|1, Int|64);
    World@ start = @(
      gravity: Vec@(Int|0, Int|0),
      ball: @(
        pos: Vec@(Int|2, Sub(Int|1, e)),
        vel: Vec@(Int|0, Int|2),
        radius: Int|1),
      edges: Nil<Edge@>,
      paddles: List<Paddle@>[
        Paddle(Vec@(Int|0, Int|0), Vec@(Int|4, Int|0), Int|0, Int|0,
          Neg(Int|1), Int|1, Int|1)
      ]);
    World@ end = Tick(start);
    Ball@ want = @(
      pos: Vec@(Int|2, Sub(Int|3, e)),
      vel: Vec@(Int|0, Int|2),
      radius: Int|1);
    Ball@ got = end.ball;
    AssertEquals<Ball@>(/Pinball/Ball%.Eq, /Pinball/Ball%.Show, want, got);
  })),

  Test(Str|'Moving Paddle Stationary Ball Collision', !({
    # The paddle moves into a stationary ball.
    World@ start = @(
      gravity: Vec@(Int|0, Int|0),
      ball: @(
        pos: Vec@(Int|2, Int|1),
        vel: Vec@(Int|0, Int|0),
        radius: Int|1),
      edges: Nil<Edge@>,
      paddles: List<Paddle@>[
        Paddle(Vec@(Int|0, Int|0), Vec@(Int|4, Int|0),
          Div(Int|1, Int|2),      # w = 1/2, v = 2w = 1
          Neg(Div(Int|1, Int|4)), # pos = -1/4, so it gets to 0 at time t=1/2
          Neg(Int|1), Int|1, Int|1)
      ]);
    World@ end = Tick(start);
    Ball@ want = @(
      pos: Vec@(Int|2, Int|1),
      vel: Vec@(Int|0, Int|2),
      radius: Int|1);
    Ball@ got = end.ball;
    # TODO: Fix this failing test case.
    /Test%.ExpectFails(
      AssertEquals<Ball@>(/Pinball/Ball%.Eq, /Pinball/Ball%.Show, want, got),
      Str|'');
  }))
]);

@(Tests);
