Sat Game
========
Making sure we have enough experience programming in fble this release, let's
implement a sat game.

First step: have a nicer Random@ interface. Because I'd like to reuse code for
things like random integers and shuffling lists.

The current interface for Random is LFSR@. You can shift out a Bit@. I'd like
something monadic. Like:

<<@>@>@ Random@ = <<@>@ M@> { *(
  M@<Bit@> bit
);

Something like that. Build on top of that:

<<@>@ M@> {
  (Random@<M@>) { M@<Bool@>; } Bool;
  (Random@<M@>) { M@<Int@>; } Int;
  (Random@<M@>)<@ A@>(List@<A@>) { M@<List@<A@>>; } Shuffle;
  ...
};

---

The key to start is I don't want to have to reference LFSR@ or Shifted@.

Maybe start by defining Random@ as part of SatGame package. We can move it to
core if it turns out to be useful.

---

Draft of puzzle generation is done. It compiles, but crashes in a bad way at
runtime.

Three issues to investigate:
1. How it's getting tag 2 for a List@ value. This should be impossible. It's
not a bug in the satgame implementation. It must be a bug in the fble
implementation somewhere.

2. Why the stack trace for (1) says undefined function in multiple places.

3. Why number of clauses is 3 when asked for 6 using params 6 6 3 0.

Let's deal with the easy one first.

Clauses added should be:

num_free_vars = num_vars - num_vars_per_clause = 6 - 3 = 3.
clauses_per_variable = (3 + 3 - 1) / 3 = 1.

That's clearly wrong. We didn't even ask how many clauses we wanted here. It
should be: num_clauses / num_free_vars rounded up.

Let's add a test suite and then fix this.

---

(3) is fixed.

Here's the stack trace:

@[SatGame.Generate.Length]: ../pkgs/satgame/SatGame/Random/List.fble:28:7:
error: union field access undefined: wrong tag
../pkgs/satgame/SatGame/Random/List.fble:30:25: error: callee aborted
../pkgs/satgame/SatGame/Random/List.fble:19:22: error: callee aborted
../pkgs/satgame/SatGame/Random/List.fble:29:22: error: callee aborted
../pkgs/satgame/SatGame/Random/List.fble:30:25: error: callee aborted
../lib/value.c:1400:5: error: called undefined function
../pkgs/core/Core/Monad/State.fble:17:19: error: callee aborted
../pkgs/core/Core/Monad/State.fble:17:19: error: callee aborted
../pkgs/core/Core/Monad/State.fble:17:19: error: callee aborted
../pkgs/core/Core/Monad/State.fble:17:19: error: callee aborted
../pkgs/core/Core/Monad/State.fble:17:19: error: callee aborted
../pkgs/core/Core/Monad/State.fble:17:19: error: callee aborted
../pkgs/core/Core/Monad/State.fble:17:19: error: callee aborted
../pkgs/satgame/SatGame/Random/PureLFSR.fble:35:3: error: callee aborted
../pkgs/satgame/SatGame/Tests.fble:31:22: error: callee aborted
../pkgs/core/Core/Test/Run.fble:36:28: error: callee aborted
../lib/value.c:1400:5: error: called undefined function

Does that make any sense at all?

Maybe. We are returning a function, we return NULL when we abort, that creates
an 'undefined' function value. But why would I call that function?

Okay. I bet the case is: we do an overapplication or something to a function
that returns NULL. We should do something smarter there.

Also: why '../' for all the paths. Isn't that strange?


