Fble Release
============
It seems like we have made enough progress on fble to consider trying to make
a release of it.

Goals:
* Put fble in releasable form.
* Gain experience trying to use fble in a released form, in particular around
  version control of various components of fble.
* Clean up separation of things that are better separated.
* Revisit APIs between components, clean up, and document.

When I say release, I'm thinking some tarballs that someone could download
from a website and install on their own computer in traditional fashion.

Implications:
* There is not one fixed environment that we can assume. We need to be more
  flexible.
* Things that don't belong together should be split up. For example, fble
  language spec doesn't belong together with a draft pinball game.
* Separate pieces will want separate build systems.
* Separate pieces will want separate test suites.

Brainstorm of components to release:
* Language specification, spec tests, tutorials, style guide, syntax file.
* fble reference implementation: libfble.
* fble packages, each separate.
  - Libraries: Core, Stdio, App, Map, 
  - Apps: GameOfLife, Invaders, Md5, Primes, Sat, Snake, Sudoku, TicTacToe

I think the biggest challenges are going to be around the interfaces between
these components:
* How to decouple native interface from reference implementation?
* How to build an app against a set of 'installed' fble packages?
 - Given that a package could include native code as well as fble code.

---

If we assume the libfble interface is fixed, it's not too hard to think about
packages. We can do interpreted or compiled code, mixed together, by
generating an elf file with the executable code to run using the standard
calling convention for an fble module.

A package is a collection of modules that we can compile all together into a
single elf file. The package dependency graph is an abstraction of the module
dependency graph. The module dependency graph is still useful, primary for
limiting what module code gets run at runtime. The package dependency graph is
useful for limiting what packages need to be available at compile time.

Conceptually we want to be able to compile a module in the presence of other
packages, listed explicitly. Then from the compiler point of view a package
needs to list for each module path in the package, the type of the module.
That should be enough info for the compiler. We can think about embedding the
type of a module in the elf file for the package so all you have to do is pass
around the library file.

There is a question of user documentation versus module interface. The
compiler wants to know the raw type of a module. The user wants to have
abstractions for types, like a module hierarchy, and comments in code. Which
is slightly different from the full source code, where ideally the user
doesn't get to see the implementation, just the type. That's an open question
that perhaps doesn't matter too much conceptually. Bottom line is, the
compiler needs a way to know what the modules and their types are in a
package.
 
If we allow different incompatible implementations of libfble, then that's
going to be harder. Unless a package is compiled for a particular
implementation of fble and you combine things that way. I'm not sure if it's
worth trying to standardize the native interface for all implementations,
focus on just libfble for the time being, try to make an alternative
implementation to see what the issues are in practice, or something else.

I suppose either the different implementations of libfble can be intermixed,
in which case there is a standard interface we can use for linking, or they
can't be intermixed, in which case we have to generate separate elf files per
implementation anyway, so we can use the specific implementation interface for
linking.

In short, I'm suggesting we package fble packages as elf files containing the
code for all the modules in the package and supplementary information
describing the types of modules in the package, assuming that's a convenient
format for the compile to consume.

Then the fble compile command should take a list of include packages when
compiling a module, and we should organize modules into packages using a
separate directory for each package. One question: should the package
directory be part of the module path or not? Why not? Otherwise we risk having
multiple packages defining the same module name, which is no good. It will be
slightly inconvenient in the sense of having longer module paths. There's also
the question of whether package versions should be in the module path. I feel
like users should be able to set up their own redirects: any time you use
package "/foo/...", rename it to, for example, "/foo-3.4.1/...". That's at
compile time.

---

Another big consideration for release is that different people have different
goals in how they interact with building, testing, and installing:
* developers probably want/ought to build and test as much as they can.
* users may only want to build and install the bits they care about,
  especially if it means they can avoid installing dependencies they otherwise
  don't want to.

How can we organize it so that users can easily specify what dependencies they
have where? Some kind of configure script, right?

I see 4 classes of things that a user may want to build:
1. Everything, including things not necessarily buildable on a single computer.
   This would be for developers testing their changes to break anything.
   Including compilation to other architectures.
2. Everything that can be done on a single computer. This would also be for
   developers testing their changes don't break things, but with the more
   realistic restriction that you can, in theory, do everything on one
   computer.
3. Some subset of things. For those who don't want to install dependencies for
   bits they don't care about. This would be configure time options. Assume
   you still want to run all possible tests.
4. Install. For those who don't want to run all the tests, for example. Or
   don't want to build everything even if all the dependencies are satisfied.

The difference between (1) and (2) is perhaps academic at this point. The
difference between (3) and (4) doesn't seem worth worrying about: just build
and test everything you can, it doesn't take that long.

That suggests the first focus should be on a mechanism to support (3), aka a
configure script.

How I can test in an automated fashion that the configure script works is
beyond me.

Another approach for optional dependencies is to pull them out into different
packages. In other words, we say no individual package has any optional
dependencies. It's up to the user to decide which packages they want to
download and install. This seems a bit inflexible to me.

Let's start down the configure route. Follow up in
thoughts/fble.configure.txt.

---

Now we have support for compiling to C code as well as aarch64, I want to
revisit the idea of a release again. There are lots of things to work out in a
release. Here's a brainstorm of things to think about.

* Configuration: what are we installing where.
 - Currently the only dependency I think we want to make optional is libsdl.
 - We may want to make it optional to install or not install certain fble
   library packages.
* Version numbering systems.
 - Release implies compatibility guarantees. What should those be?
 - Do we version all the components separately, or all under one number?
 - Components are: language spec (and spec tests), libfble, each separate fble
   library package.
* Post-install build/search path
 - After installing, how will users build fble programs?
 - Is there a standard search path we use, or it's up to users to specify
   that?
 - Do we do something with pkg-config to find installed fble packages?
 - Do we share any of the build.tcl infrastructure to help build fble
   packages?
* libfble interface cleanup
 - Clean up odds and ends in the libfble API.
 - In particular, create a cleaner interface between libfble and compiled fble
   code.
 - Think about potentially upcoming changes for packing values based on known
   types.
* Modular/compiled fble package release
 - Do we have to release fble programs as source?
 - Should we add support for releasing an fble package entirely as a .so file?
 - Should we add support for .fble.@ header files?
* Documentation
 - Clean up existing documentation. Make sure it's up to date.
 - Add getting started / tutorial guides.
 - Add man pages.
* TODOs
 - How much of the existing TODOs do I want to tackle before making the
   release? It's not feasible to do them all.
* Fble libraries
 - I suggest not worrying about having clean APIs for .fble libraries for the
   first release. That's too big a scope. Focus on language specification and
   reference implementation (interpreter/compiler) for the first release.
 - But do I want to change Stdio@ to use a File@ interface? Perhaps to avoid
   need for gnu getline?
 
That's a pretty good summary list of things to tackle. Shall we go one by one?

---

Version numbering systems

The goal of version numbering is to communicate compatibility. The language
itself is independent of reference implementation and libraries. In theory it
could be versioned separately. I think three components: A.B.C
C - No change to language spec, but could be improvements in spec tests or
    description of the language.
B - Backwards compatible changes to the language spec. Existing programs
    should continue to work, but adds some new features that won't work on
    older implementations
A - Incompatible changes to the language spec. Old programs will no longer
    work.

Next is the reference implementation. In theory there could be multiple
implementations for a given language version. Any A or B change to the
language spec will require a new libfble to support that change. Other changes
you could make without a change to the language spec, let's call them: D.E.F
F - No change to interface. Maybe cleanup, bug fixes, performance
    improvements.
E - Backwards compatible change to API. Old programs should still work. New
    ones may take advantage of features not supported on older releases.
D - Incompatible change to API.

There is the question whether we are talking about source level compatibility
or binary compatibility at this point.

If we include language spec version in libfble version, we get a version
string like: A.B.D.E.F. That's a bit ridiculous.

Next is per fble package version numbers. Again we have a triple for bug
fixes, backwards compatible changes, or incompatible changes. These will
depend on language version certain, and also possibly libfble version for any
use of those APIs. A.B.D.E.G.H.I?

Is there a single versioning scheme that makes sense to bundle together all
these components under a single version number? Maybe an: A.B.C.D, for
A: incompatible language change.
B: incompatible libfble change.
C: incompatible library package change.
D: internal/compatible change.

We could consider a backwards compatible language change as an incompatible
libfble change? And consider a backwards compatible libfble change as a
library incompatible change?

Honestly, my expectation to begin is that we change the language hopefully
fairly rarely. We change the libfble API a little less rarely. In practice we
are pretty likely to change the fble library. The goal of having a versioning
number, besides uniquely identifying a release, is to say something like, if
my code works on X.Y, then it also works on X.Z for all Z > Y. I suspect
pretty much all code would be written against the fble library to start, in
which case, in practice, nothing will be compatible release to release early
on. In that case, why bother? How about let's just have 0.1, 0.2, ... where
'0' means too early in the project lifecycle to have any compatibility
guarantees, and 1, 2, ... identify unique releases ordered in time. We can
target a major release bump to 1.* when things are stable enough that we can
have a useful breakdown after that where releases are less likely to break
things.

Another point to make:

Ideally libfble works with any of the previous language versions. For example,
you could put it in language 1.* mode, language 2.* mode, etc. and it would,
restrict the language settings to match that given mode. That way, in a sense,
libfble is independent of language version. Version X of libfble supports all
language versions Y that were released up until the date when libfble X is
released. The main goal, I think, would be to be able to write older language
compatible programs where libfble enforces that you aren't relying on any
newer language features.

I don't want to start versioning fble libraries yet. I don't want to have to
worry about compatible changes. They are too early for that. Long term,
ideally each different library package has its own version and release
cadence. They each target their preferred language version. They work with any
libfble with required libfble API and supported language version.

So, in summary, for now just stick with version 0.1, 0.2, ... Later on, plan
to have more flexibility in versioning support. The first release is like a
preview release. The goal is to let people try it easily. Not to promise there
won't be breaking changes.

---

What do we install where? And how to we build against that?

$bindir
  fble-test
  fble-compile
  fble-md5
  fble-stdio
  fble-invaders
  ...

$includedir:
  fble-alloc.h
  fble-arg-parse.h
  ...

$libdir:
  libfble.a
  libfble-md5.a
  ...

man pages, etc. All of this is straight forward.

The real question is: where do we install the .fble files? Maybe datarootdir,
which is /usr/local/share, for example? So:
 /usr/local/share/fble/core/Core/...
 /usr/local/share/fble/md5/Md5/...

It would be a pain to have to manually add -I options for each of these
directories, on the one hand. On the other hand, maybe that's the whole point:
to specify explicitly everything you depend on. It's kind of like how I need
to add a -I option to compile against libsdl. In that case, I think that's
fine. -I /usr/share/fble/md5 is reasonable.
  
That's all fairly straight forward. The more interesting question is about
configure. I think I should have a configure script. I think it should give
options for standard include directory settings. I think it should work as in
thoughts/fble.configure.txt. I think we should have an option to enable or
disable any of the fble library packages.

---

Post-install build/search path

As above, I think no need to specify a default search path. We don't really
have a standard library yet.

Should we use pkg-config? That gave me trouble in the past I feel like,
because it doesn't support a separate language very easily. I think fine to
use it for c parts of the packages, but not the include paths for the fble
parts of the packages.

Should we expose parts of build.tcl? I don't want to enforce any sort of build
system on users, much less a funny one like build.tcl. My vote is not to
supply any build scripts for the initial release. Just make it clear to users
how they can do things their own way.

---

Review of steps to release:
* Generate man pages for library functions via fbld.
* Remove doxygen.
* Burn down TODOs.
* Make SDL dependency optional.
* Figure out how to make a release tarball.

Things not to worry about this release:
* Fbld cleanup.
* libfble API cleanup or tutorials.
* Packed data types.
* Module header file support.
* Or really any big thing.

---

Let's jump right to the heart of what we need for release. Everything else is
just cleanup/polish:

How to generate a release tarball.

First place to look: standard make targets for this?
* distclean - clean up everything include stuff generated by configure.
* maintainer-clean
 Deletes more than distclean. Including source files produced by Bison, info
 files, and so on. That suggests we should include the bison-generated source
 as part of the release tarball?
* Info files should be present in the source directory, make should update
  them in the source directory.
* dist - Create a distribution tar file for the program.

   The easiest way to do this is to create a subdirectory appropriately
   named, use ln or cp to install the proper files in it, and then tar that
   subdirectory.

   Compress the tar file with gzip. For example, the actual distribution file
   for GCC version 1.40 is called gcc-1.40.tar.gz. It is ok to support other
   free compression formats as well.

   The dist target should explicitly depend on all non-source files that are
   in the distribution, to make sure they are up to date in the distribution.
   See [15]Making Releases in GNU Coding Standards.

Making Releases Documentation:
* Need a major and minor version number. Let's say "0" and "1" for example.
* fable-0.1.tar.gz should unpack to fable-0.1
* Can include source and non-source files.
  - non-source files must be up to date with the source and machine
  independent. Including outputs of Bison to reduce dependencies.
  - Don't include non-source files that would be modified by building and
    installing the program.
* All files world readable (755), directories world writeable (777).

Anything ninja supports?
* Not that I see.

So, conceptually, it's clear. We want a build target that knows how to package
everything up. 

The question is what non-source files we want to include in the distribution
and where/how that all works out.

Let's go by dependency:
  expect - can be skipped without running check target.
  binutils - needed at build time (architecture specific).
  bison - can generate the parser c file at distribution time.
  gcc - needed at build time.
  gdb - only for tests.
  diffutils, grep - for tests.
  groff-base - can be done at distribution time.
  source-highlight - could be done at distribution time.
  ninja-build - needed at runtime.
  libgl-dev, libsdl2-dev - needed at runtime, can be skipped.
  tcl8.6 - needed for configure.

So, let's review the non-source files we may want to include in the dist:
* Docs, including man pages and www.
* parse.tab.c
* *.usage.h files.

That's pretty straight forward.

What mechanism to use for this, given that source directory is different from
build directory?

The suggestion from the gnu docs is to generate and use those from the source
directory. Add a 'maintainer-clean' option to remove those files.

Note: we don't want to include .git/ metadata in the release tarball.

I suggest the following:
* Update those 'dist-non-source' files to be built in $::s instead of $::b.
* Add 'clean', 'dist-clean', and 'maintainer-clean' targets.
  clean: cleans up non-config generated files.
  distclean: clean + remove config.tcl and build.ninja.
  maintainer-clean: distclean + remove dist-non-source files.
* Add a dist target that copies all source and dist-non-source files into a
  build subdirectory and packages up a tarball for it.
* Clearly document in README which dependencies are needed for which things.
* Add a TAGS file to dist-non-source.
* Add .gitignore for dist-non-source files.

That all sounds straight forward, but I fear the build.tcl files aren't
organized in a way currently to make this easily modular and correct. Some
better cleanup and structure to those will help.

Hey, this means we can add a TAGS file as part of dist-non-source. That would
be convenient. 

---

How to organize build files:
* source files: files checked into git.
* install: files installed into the install directory.
* dist-non-source: generated files included in release tarball.
   - Anything generated, not installed, that doesn't depend on the
     architecture.
* build-non-source: generated files not included in release tarball.
   - Anything generated that does depend on the architecture.

Categories of non-source files:
* dist: things for the dist tarball
* www: things for the generated www
* test: things needed for test

Build targets:
* all: all non-source files needed for install.
  This is the default.
* install: all install files.
* dist: makes the release tarball
* www: makes the website.
* test: makes the tests.
* cov: generated code coverage output.
* check: everything except install, includes all, test, dist, www, cov.
* clean/distclean/maintainer-clean, depending on what ninja supports.
  To clean appropriate pieces.

Each build.tcl file should identify it's:
* source files: need to be copied to dist.
* dist-non-source
* install targets
* install sources: what gets made by all.
* tests.
* www.

Build files to have:
build.tcl - top level, includes sub-build files.
  include
  lib
  bin
  fbld
  test
  spec
  tutorials
  www
  pkgs/*

Some questions around:
* Should we have a separate www directory? Who generates the www?
  For example, tutorials go to www. Who should be responsible for saying that?
  I think treat www similar to install. Separate build.tcl files mark things
  as www. Either the www/build.tcl file defines the top level and tcl procs to
  help with that, or just move that to the top level build.tcl file.
* spec tests rules separate from test directory?
  I think, don't worry too much about it. Whatever is easiest. Fine to keep
  things organized as is, but we will want to add a spec/build.tcl file.

I would like to separate the top level build.tcl build target parts from the
build infrastructure/library. But that's not too important. We can always do
it later however feels right. I think do try to move helper functions into sub
build.tcl files where it makes sense, such as fbleobj.

In terms of implementing targets, let's have procs to identify things as
follows:
* dist - anything to include in the release tarball, including source and
  dist-non-source.
* install - marks the source of the thing to install.
* www - anything for generated www.
* test - tests.

That should be enough for the targets:
* all: any install source
* install: any install target
* dist: any dist
* test: tests.
* www: www.
* check: all, dist, test, www

To implement 'clean', I guess we could have:
  clean: clean all
  distclean: clean -g all 
  maintainer-clean: clean -g

Assuming I figure out how to mark the generator rule so config doesn't have to
be re-run.

In general, I think it's fine to have higher level abstractions responsible
for calling test, install, dist, etc. As long as its clear you would always
want to do that. To reduce clutter.

That's the high level vision. Let's see if we can get there little by little.

I feel like having a separate build/ directory with the build library, and
maybe a readme file would help with clarity and cleanliness. Not sure. Maybe
we just need to document build.tcl very clearly. Yeah. Let's document
build.tcl very clearly, from the top. And then work at a single build.tcl file
at a time with cleanup until we end up with the above proposed structure.

For out directory, have:
* Something corresponding to each build.tcl directory.
* dist/fble-0.1/...
  dist/fble-0.1.tar.gz
* www/...

And add a $::d directory for dist-non-source files. Which will be set to the
same as $::s, but gives us more flexibility/documentation over what is what.

---

Top level build directory:
bin/ book/ fbld/ include/ lib/ pkgs/ spec/ test/ thoughts/ tutorials/ vim/ www/
build.tcl configure deps.tcl README.fbld TODO.txt

Listing all the files explicitly, like thoughts/*, is going to be tedious I
fear. And error prone. Hmm...

---

How to clean up organization of test target?

::tests
proc tests
proc testsuite
phony test
directory test/

Tests depend on the contents of the test/ directory. So we could define it
there. But I want all phony targets in build.tcl, which suggests we define it
there.

Or maybe we have tests/detail.tr and tests/summary.tr, all described in the
test/ directory, and put the phony in the top level build?

Again, the reason to do this is to hopefully simplify the top level build.tcl
file. I guess it's a question about our assumptions of what's defined where.
Before it was:

* Shared things go into build.tcl
 - Except things like app, stdio, etc.

This is suggesting:
* Shared things go where their dependencies are built.

It's a question about who assumes what is built where.

It would at least be nice for all the phony targets to be defined in the top
level build.tcl, so it's clear what the different targets are. How about... I
don't know.

Maybe let's skip that and clean up www first.

1. Add helper functions for building fbld files.
2. Move stuff out of www/build.tcl 
  - Each subdirectory is responsible for its own part of www
  - top level build.tcl is responsible for putting it all together.

---

For www, do I want to generate directly into 'www', or do I want to generate
into the current directory and copy to www?

Seems like a waste to make copies. So I guess we go straight to www. And have
a proc www to mark something as www? If we want, we could define a $www var to
say where www is.

Or... make www part of ::html_*?

---

Clean up of globs?

Uses:
* [glob $::s/bin/*.c]
* [glob $::s/include/fble/*.h]
* [glob $::s/tutorials/*.fbld]
* [glob $::s/test/fble-*.c]
* [glob -tails -directory $::s/pkgs/$name -nocomplain -type f $dir/*.fble]
* [glob -tails -directory $root -nocomplain -type d $dir*]
* [glob -tails -directory $::s/lib *.c]
* [glob -tails -directory $::s/spec -nocomplain -type f $dir/*.fble]

So, two use cases. Maybe I can shift them into one. I want to be able to
extract the directory. Something like:

build_glob { dir args } {
}

Cool. That sounds good.

---

Okay. I think the initial cleanup of build.tcl is done. Next step is to
prepare for the 'dist' target.

We want to include two things in dist. source and non-source dist. So...

Either two separate procs:
  dist_src
  dist_non_src

Or one:
  dist

Why distinguish between them?

I remember. We need to figure out what directory they belong to. If we have
dist_src, we can imply relative to the source directory.

So, how about: dist_s, dist_d, and use $::d for generated source directory.

For example, to mark $::s/README.fbld as source, use:

dist_s README.fbld

The behavior will be to copy $::s/$target to $::b/fble-0.1/$target for the
'dist' command.

