
@ Bool@ = /Bool%.Bool@;

@ Int@ = /Int/Int%.Int@;
% Dec = /Int/Int%.Dec;
% 0 = /Int/Int%.0;
% Le = /Int/Int/Eq%.Le;

<@,@>@ Lit@ = /Literal%.Lit@;

<@>@ List@ = /List%.List@;
<@>% List = /List%.List;
<@>% Nil = /List%.Nil;
<@>% Cons = /List%.Cons;
<@>% Concat = /List%.Concat;
<@,@>% Map = /List%.Map;

@ Bit@ = /Digits%.Bit@;
@ Hex@ = /Digits%.Hex@;
% B = /Digits%.Bit;

# Heap@ --
#   A bit-addressable heap of bits.
#
# This should be treated as an opaque type externally.
@ Heap@ = List@<Bit@>;

# Addr@ --
#   The address of a bit on the heap.
@ Addr@ = Int@;

# Ptr@ --
#   A pair of heap and address that identifies a particular sequence of bits.
@ Ptr@ = *(Heap@ heap, Addr@ addr);

# Heap --
#   Create a heap of n uninitialized bits.
(Int@) { Heap@; } Heap = (Int@ n) {
  # We simulate uninitialized by using a bit pattern 010101010101010...
  n.?(
    n: Nil<Bit@>,
    0: Nil<Bit@>,
    p: {
      List@<Bit@> tail = Heap(Dec(n));
      tail.?(
        cons: tail.cons.head.?(0: Cons<Bit@>(B.1, tail), 1: Cons<Bit@>(B.0, tail)),
        nil: Cons<Bit@>(B.0, tail));
    }); 
};

# HeapFromBits --
#   Create a preinitialized heap of bits.
(List@<Bit@>) { Heap@; } HeapFromBits = (List@<Bit@> bits) {
  bits;
};

# HeapFromBitStr --
#   Create a preinitialized heap of bits.
(Lit@<Bit@>) { Heap@; } HeapFromBitStr = (Lit@<Bit@> bits) {
  HeapFromBits(List<Bit@>(bits));
};

# HeapFromHexStr --
(Lit@<Hex@>) { Heap@; } HeapFromHexStr = (Lit@<Hex@> hex) {
  List@<Hex@> l = List<Hex@>(hex);
  List@<Bit@> bits = Concat<Bit@>(Map<Hex@, List@<Bit@>>(l, (Hex@ h) {
    List<Bit@>(h.?(
      0: B|0000, 1: B|0001, 2: B|0010, 3: B|0011,
      4: B|0100, 5: B|0101, 6: B|0110, 7: B|0111,
      8: B|1000, 9: B|1001, A: B|1010, B: B|1011,
      C: B|1100, D: B|1101, E: B|1110, F: B|1111));
  }));
  HeapFromBits(bits);
};

# GetBits --
#   Get n bits from the bit heap.
#
# Behavior is undefined if there are't enough bits in the heap to get n.
(Ptr@, Int@) { List@<Bit@>; }
GetBits = (Ptr@ ptr, Int@ n) {
  Le(ptr.addr, 0).?(
    true: Le(n, 0).?(
      true: Nil<Bit@>,
      false: Cons<Bit@>(
        ptr.heap.cons.head,
        GetBits(Ptr@(ptr.heap.cons.tail, ptr.addr), Dec(n)))),
    false: GetBits(Ptr@(ptr.heap.cons.tail, Dec(ptr.addr)), n));
};

# HeapFromPtr --
#   Create a heap initialized with the bits pointed to by ptr.
(Ptr@, Int@) { Heap@; } HeapFromPtr = GetBits;

# Equals --
#   Return true if the n bits referred to by pointers a and b are equal.
#
# Behavior is undefined if there aren't n bits in a and b to compare.
(Ptr@, Ptr@, Int@) { Bool@; } Equals = (Ptr@ a, Ptr@ b, Int@ n) {
  /List/Eq%.Eq<Bit@>(/Digits/Eq%.EqBit)(GetBits(a, n), GetBits(b, n));
};

# Assign --
#   Assign the first n bits at ptr with the value of the first n bits from val.
#
# Returns the updated Heap for ptr after the assignment.
#
# Behavior is undefined if there aren't n bits to assign from or to.
(Ptr@, Ptr@, Int@) { Heap@; } Assign = (Ptr@ ptr, Ptr@ val, Int@ n) {
  Le(n, 0).?(
    true: ptr.heap,
    false: Le(ptr.addr, 0).?(
      true: Le(val.addr, 0).?(
        true: Cons<Bit@>(
          val.heap.cons.head,
          Assign(
            Ptr@(ptr.heap.cons.tail, ptr.addr),
            Ptr@(val.heap.cons.tail, val.addr),
            Dec(n))),
        false: Assign(ptr, Ptr@(val.heap.cons.tail, Dec(val.addr)), n)),
      false: Cons<Bit@>(
        ptr.heap.cons.head,
        Assign(Ptr@(ptr.heap.cons.tail, Dec(ptr.addr)), val, n))));
};

@(Heap@, Ptr@, Heap, HeapFromBits, HeapFromBitStr, HeapFromHexStr, HeapFromPtr, Equals, Assign);
