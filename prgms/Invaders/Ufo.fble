@ Bool@ = /Bool%.Bool@;
% True = /Bool%.True;
% False = /Bool%.False;

@ Drawing@ = /Drawing%.Drawing@;
% Blank = /Drawing%.Blank;
% Translate = /Drawing%.Translate;

@ Int@ = /Int/Int%.Int@;
% Add = /Int/Int%.Add;
% Neg = /Int/Int%.Neg;
% Lt = /Int/Int/Eq%.Lt;
% Gt = /Int/Int/Eq%.Gt;
% Int = /Int/Int/Lit%.Int;

% Graphics = /Invaders/Graphics%;

<@>@ Maybe@ = /Maybe%.Maybe@;
<@>% Just = /Maybe%.Just;
<@>% Nothing = /Maybe%.Nothing;

@ Unit@ = /Unit%.Unit@;
% Unit = /Unit%.Unit;

# DirState@ --
#   State keeping track of which direction the ufo will fly in from.
#
# The intention is to repeat the cycle: LLRLRR, which hopefully will make it
# seem random, or at least hard for a player to remember where in the cycle
# we are.
@ DirState@ = +(Unit@ 0, Unit@ 1, Unit@ 2, Unit@ 3, Unit@ 4, Unit@ 5);

DirState@ InitialDirState = DirState@(0: Unit);

(DirState@) { DirState@; } Next = (DirState@ ds) {
  ds.?(0: DirState@(1: Unit), 1: DirState@(2: Unit), 2: DirState@(3: Unit),
    3: DirState@(4: Unit), 4: DirState@(5: Unit), 5: DirState@(0: Unit));
};

(DirState@) { Bool@; } FromLeft = (DirState@ ds) {
  ds.?(0: True, 1: True, 2: False, 3: True, 4: False, 5: False);
};

# Ufo@ -- 
# 
# Fields:
#   live - true if the UFO is currently flying, false otherwise.
#   x - the x coordinate of the UFO.
#   v - the x velocity of the UFO.
#   dir - the state of the direction to fly in from next.
@ Ufo@ = *(
  Bool@ live,
  Int@ x,
  Int@ v,
  DirState@ dir
);

Int@ MinX = Int|40;
Int@ MaxX = Int|264;

Int@ UfoY = Int|200;

Int@ Height = Int|8;
Int@ Width = Int|16;

# The number of pixels the ufo travels each tick.
Int@ Velocity = Int|1;

Ufo@ Initial = Ufo@(True, MinX, Velocity, InitialDirState);

# Launch --
#   Launch the UFO from a random direction.
(Ufo@) { Ufo@; } Launch = (Ufo@ ufo) {
  Bool@ from_left = FromLeft(ufo.dir);
  DirState@ dir = Next(ufo.dir);
  from_left.?(
    true: Ufo@(True, MinX, Velocity, dir),
    false: Ufo@(True, MaxX, Neg(Velocity), dir));
};

(Ufo@) { Ufo@; } Tick = (Ufo@ ufo) {
  ufo.live.?(false: ufo);
  Lt(ufo.x, MinX).?(true: Launch(ufo));
  Gt(ufo.x, MaxX).?(true: Launch(ufo));
  Ufo@(True, Add(ufo.x, ufo.v), ufo.v, ufo.dir);
};

@ Kill@ = *(Int@ points, Ufo@ ufo);

(Int@, Int@, Ufo@) { Maybe@<Kill@>; } Shoot = (Int@ x, Int@ y, Ufo@ ufo) {
  Lt(y, UfoY).?(true: Nothing<Kill@>);
  Gt(y, Add(UfoY, Height)).?(true: Nothing<Kill@>);
  Lt(x, ufo.x).?(true: Nothing<Kill@>);
  Gt(x, Add(ufo.x, Width)).?(true: Nothing<Kill@>);

  # TODO: vary the points.
  # TODO: wait a while before launching the alien again.
  # TODO: display the points where the alien died.
  Int@ points = Int|50;
  Ufo@ new_ufo = Launch(ufo);
  Just<Kill@>(Kill@(points, new_ufo));
};

(Ufo@) { Drawing@; } Draw = (Ufo@ ufo) {
  ufo.live.?(false: Blank);
  Translate(ufo.x, UfoY, Graphics.Ufo);
};

@(Ufo@, Kill@, Initial, Tick, Shoot, Draw);
