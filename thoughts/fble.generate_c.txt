Fble Generate C
===============
It's been a while since we tried generating c code for fble compilation. Now
that we're considering cross platform support, seems like it's worth trying
again.

The problem we had with generating C before was that it took too much memory
(>1GB) to compile the generated C code. A lot of things have changed in fble
since then. Perhaps most importantly, we pass list and literals all the way
through the compiler instead of desugaring them first. Also, we are single
threaded now and have a standard way of supporting tail recursion at the C
level.

The benefits of generating C code are:
* Support all platforms we can build fble for without any extra dependencies.

The potential disadvantages of C code, compared to custom assembly:
* Compile time memory and performance costs.
* Runtime performance costs.

My vote is to give it a try, again. See if we can get past the compile time
memory costs and how close we can get to runtime performance. This will help a
lot for cross platform support.

How about I do it from scratch, ish. Based of generate_aarch64.

Initial thoughts looking over generate_aarch64:
* I think there's a lot of code we can reuse from aarch64. My vote is reuse by
  copy-paste, under the assumption we keep either one or the other in the end,
  but likely not both.
* Function args: heap, thread, locals, statics, profile
* Don't worry about debug info to start.

There will be some tricky parts, but for the most part, I think it should be
straight forward.

First step: wire up some stub code and make it so I can run it.

---

How can we do debug info? Like, what does bison do in its generated code?

We have pragmas like:

#line 3 "fble/lib/parse.y"

Let's start with that then.

---

I'm getting close. Some observations:
* The #line pragmas are making debug the code generation logic annoying. Can I
  get rid of them for now? I don't think they work the way I think either. I
  think we need a separate way to get dwarf.
* I'm getting real mixed up on what GenerateCMain and GenerateCExport should
  do.

GenerateCMain:
int main(int argc, const char** argv) {
  return <main>(argc, argv, <compiled module>);
}

Type of <compiled module> is FbleCompiledModuleFunction.

That looks fine.

Next, GenerateCExport: it should take a heap as input. What does it do? I
guess it should call the module function, passing the heap argument?

Maybe my comment in the documentation is wrong? The assembly code is literally
branching to the module function and returning the result. It must be passing
all the arguments directly.

Uh... I'm lost.

FbleCompiledModuleFunction is a function that, given a program, adds the
module to that program. That's what we define. What's what we call to ensure
dependencies are loaded, right? That's what we pass to a main function to be
able to instantiate a program. Export 'main' invokes main function on that,
and that's what we generate code for. That all makes sense.

What I don't understand is the CExport function. What type is that supposed to
have? I assume it's supposed to be a wrapper something or other?

According to docs, the exported function should return a zero argument fble
function that can be executed to compute the value of the given module. How
does it work? I don't understand what generate_aarch64 is doing. That can't be
correct, can it?

Step back. How would I generate the FbleValue in the first place?

I think the documentation is wrong. That must be out of date. It should just
give a nice name to the FbleCompiledModuleFunction with the internal name,
that is: void X(FbleExecutableProgram* program), right? Yeah. That makes
sense.

Next issue: Need to generate prototypes for all Run and Abort functions up
front.

Notes:
* Double check if spec tests are using the c target or aarch64. I think it may
  be different.
* Will want to clean up includes of execute.h, value.h at some point.
* Memory use for compiling the generated c code is looking not too bad so far?
* Runtime for compiling the generated code isn't great.

Actually, we're starting to hit issues with gcc memory use to compile the
generated code. Let's see if I can find out which one it is.

  out/pkgs/md5/Md5/Rounds.fble.c

It's 100K lines of C code. Ugh.

Well, something to dig into next:
* Why is Rounds.fble.c so big. Anything we can do to cut that down by an order
  of magnitude?
* Try running just the spec tests with -c target, see if everything passes.
* Try running some program manually that's compiled, just to convince myself
  it actually works.

One thing that stands out scanning through Rounds.fble.c is a whole lot of
struct accesses, each of which has an error case. And a function with a lot of
instructions, which leads to a pretty big case statement and per-instruction
overhead.

---

Seeing if I can add c code generation to spec tests at least. Looks like they
expose some more bugs. A couple of bugs fixed. All the spec tests pass with
the compiler. Let me figure out how to do both aarch64 and c tests in the spec
tests in a hopefully clean way.

Yeah. This works well. We can abstract away all the different targets and make
sure we test them all in spec tests. Or, at least, all of the available ones.

It might be fun to try compiling everything with generate_c on my windows
computer, which is x86_64 and has lots of memory. Just to see if it works and
maybe try running some benchmarks to compare interpreted, aarch64, and c.

---

The compiler appears to work fine on my windows computer. Max memory use I see
for compilation is around 500MB, which suggests perhaps we're close to being
able to do it on my Raspberry pi. Things that need to change to be able to
check this in:
* Distinguish better between hand written c code and generated c. In
  particular, we need different names for object files in both cases, e.g.
  Stdio/stdio.fble.o could be from Stdio/stdio.fble.c or Stdio/Stdio.fble.
  Don't assume case is sufficient to distinguish them.
* Use fbleobj instead of manual invocation to fble-compile where possible.
* Figure out how to decide which approach to build with: one, the other, or
  both.

It would be great to set up some benchmarks to understand how performance is
looking on c versus aarch64 target.

The path to getting rid of aarch64 target:
* Check in cleaned up changes to avoid name conflict in stdio.fble.o file and
  friends.
* Get it to compile on low memory.
* Setup benchmarks, check if they are within, say, 20% of aarch64.
* Figure out how to emit debugging info via C approach.

---

Goal: See how close we are to being able to compile everything with 1GB RAM,
and what we could do to get us closer.

Let's see how much memory it actually takes on what files.

Part of the challenge is, even the ones that don't take a ton of memory can
take multiple minutes to compile. Any way I can profile that? Maybe ninja -d
stats?

There are 4 culprits:

/Md5/Rounds%
/Sat/Aim%
/Invaders/Graphics%
/Graphics/Camera/SinCos%

Let me let them run for longer and see if any come close to finishing.

I clearly can't run all four at the same time. Let's try one at a time:

/Md5/Rounds%: Goes up to 60% memory and then completes okay.
/Sat/Aim%: Goes up to 72% memory and then completes okay.
/Invaders/Graphics%: Goes up to 45% memory then completes okay.
/Graphics/Camera/SinCos%: Goes up to 40% memory then completes okay.

So we're close. If I could get an order of magnitude better. Or even just
compile all of these one at a time, I maybe could swing it.

Let's see if number of lines of C code correlates here. It would be nice if we
could use that as a metric to try and improve.

Yes. That's shows it pretty clearly:

   108797 out/pkgs/md5/Md5/Rounds.fble.c
   105934 out/pkgs/sat/Sat/Aim.fble.c
    76723 out/pkgs/invaders/Invaders/Graphics.fble.c
    60029 out/pkgs/graphics/Graphics/Camera/SinCos.fble.c
    34514 out/pkgs/graphics/Graphics/Triangle/Tests.fble.c
    22824 out/pkgs/core/Core/Int/Tests.fble.c
    22319 out/pkgs/pinball/Pinball/Tests.fble.c

The top four. Looks like 40K lines maybe a good target to shoot for.

Where are all these lines coming from? Let's review the modules and see what
they do.

Rounds:
* Lots of hex literals.
* Lots of big structs.
* Lots of deep chains of struct accesses.
* C code shows lots of struct access instructions, including check for
  FbleStrictValue and corresponding error message.
* Some functions with 5K or more instructions.

Aim:
* Lots of int literals.
* Long nested list literals. There are no struct accesses at all.
* Some functions with 5K or more instructions.
* Lots of aborts and error messages.

Invaders Graphics:
* Lots of int literals and list literals.
* Some functions with 5K or more instructions.
* Lots of error messages.

Graphics SinCos:
* Lots of int literals.
* Long list literal.
* Some functions with 5K or more instructions.
* Lots of error messages.

Note: none of the fble files are particularly large. I expect all of these
should compile just fine.

Brainstorm of things to try:
* abort on error instead of have error handling.
* Remove 'abort' function implementations.
* Remove profiling code at every instruction.
* Use different options to gcc to optimize for memory somehow?
* Use initializer list instead of assignments for literal instructions.
 - Also for "statics".

What sticks out to me is:
* From fble side: lots of literals. See if I can improve code generation for
  that.
* They all have 5K+ instruction functions with lots of abort cases.

Let me start with something easy and noncontroversial: Generate as many arrays
using initializers as I can rather than separate assignment statements. It
won't reduce lines of code, but hopefully it helps with something inside. I'm
not sure if I expect much, but it's worth a try.

I don't see any memory improvement from this change. I like it anyway though,
so I'll keep it.
