
@ Bool@ = /Bool%.Bool@;
% True = /Bool%.True;
% False = /Bool%.False;
% Or = /Bool%.Or;

@ IntP@ = /Int/IntP%.IntP@;

@ Int@ = /Int/Int%.Int@; 
% Inc = /Int/Int%.Inc;

<@>@ Maybe@ = /Maybe%.Maybe@;

% UnitS = /Structure%.UnitS;
% LeftS = /Structure%.LeftS;
% RightS = /Structure%.RightS;
% PairS = /Structure%.PairS;
<@>@ Structured@ = /Structured%.Structured@;

@ Unit@ = /Unit%.Unit@;
% Unit = /Unit%.Unit;

@ Coord@ = *(Int@ row, Int@ col);
Structured@<IntP@> NatS = (IntP@ n) {
  n.?(1: UnitS, 2p0: LeftS(NatS(n.2p0)), 2p1: RightS(NatS(n.2p1)));
};
Structured@<Int@> IntS = (Int@ n) {
  n.?(n: LeftS(NatS(n.n)), 0: UnitS, p: RightS(NatS(n.p)));
};
Structured@<Coord@> CoordS = (Coord@ c) {
  PairS(IntS(c.row), IntS(c.col));
};

@ Data@ = +(Unit@ 0, Unit@ 1);
Data@ 0 = Data@(0: Unit);
Data@ 1 = Data@(1: Unit);

@ PortSpec@ = +(Unit@ input, Unit@ output, Unit@ unused);
PortSpec@ InputPort = PortSpec@(input: Unit);
PortSpec@ OutputPort = PortSpec@(output: Unit);
PortSpec@ UnusedPort = PortSpec@(unused: Unit);

<@>@ Ports@ = <@ T@> { *(T@ ul, T@ ur, T@ ll, T@ lr); };

# GateFunction@ --
#   Describes the behavior of a gate when it is triggered. The input is the
#   data value for each port, where 0 is passed for any non-input port. The
#   output is a new data value for each port, where values for non-output
#   ports are ignored. This allows us to have a uniform gate function
#   specification regardless of how the gate's ports are configured as
#   input/output/unused ports.
@ GateFunction@ = (Ports@<Data@>) { Ports@<Data@>; };

@ Gate@ = *(Ports@<PortSpec@> ports, GateFunction@ function);

@ Cells@ = /Map%.Map@<Coord@, Data@>;
@ Gates@ = /Map%.Map@<Coord@, Gate@>;
@ Layout@ = *(Cells@ cells, Gates@ gates);

# Empty -- 
#  An empty hardware layout with no data or gates set.
Layout@ Empty = Layout@(/Map%.Empty<Coord@, Data@>, /Map%.Empty<Coord@, Gate@>);

# GetData --
#   Get the data of a particular cell.
(Layout@, Coord@) { Maybe@<Data@>; } GetData = {
  (Cells@, Coord@) { Maybe@<Data@>; } LookupData
    = /Map%.Lookup<Coord@>(CoordS)<Data@>;

  (Layout@ layout, Coord@ coord) {
    LookupData(layout.cells, coord);
  };
};

# SetData --
#   Set the data value of the given cell.
(Layout@, Coord@, Data@) { Layout@; } SetData = {
  % Insert = /Map%.Insert<Coord@>(CoordS)<Data@>;

  (Layout@ layout, Coord@ coord, Data@ data) {
    Cells@ ncells = Insert(layout.cells, coord, data);
    Layout@(ncells, layout.gates);
  };
};

# ClearData --
#   Clear the data value of the given cell, leaving the cell empty.
(Layout@, Coord@) { Layout@; } ClearData = {
  % Delete = /Map%.Delete<Coord@>(CoordS)<Data@>;

  (Layout@ layout, Coord@ coord) {
    Cells@ ncells = Delete(layout.cells, coord);
    Layout@(ncells, layout.gates);
  };
};

# SetGate --
#   Configure the gate whose upper left corner is at the given coordinates of
#   the layout.
(Layout@, Coord@, Gate@) { Layout@; } SetGate = {
  % Insert = /Map%.Insert<Coord@>(CoordS)<Gate@>;

  (Layout@ layout, Coord@ coord, Gate@ gate) {
    Gates@ ngates = Insert(layout.gates, coord, gate);
    Layout@(layout. cells, ngates);
  };
};

# Step --
#   Run a single step of the hardware.
@ B@ = *(Layout@ layout, Bool@ updated);
(Layout@) { B@; } Step = {
  (PortSpec@, Maybe@<Data@>) { Bool@; } Blocked = (PortSpec@ ps, Maybe@<Data@> d) {
    ps.?(
      input: d.?(just: False, nothing: True),
      output: d.?(just: True, nothing: False),
      unused: False);
  };

  (PortSpec@, Maybe@<Data@>) { Data@; } InputData = (PortSpec@ ps, Maybe@<Data@> d) {
    ps.?(
      input: d.?(just: d.just, nothing: 0),
      output: 0,
      unused: 0);
  };

  (B@, Coord@, PortSpec@, Data@) { B@; } UpdateResult = (B@ b, Coord@ c, PortSpec@ ps, Data@ d) {
    ps.?(
      input: @(layout: ClearData(b.layout, c), updated: True),
      output: @(layout: SetData(b.layout, c, d), updated: True),
      unused: b);
  };

  (Layout@ layout) {
    /Map%.ForEach<Coord@, Gate@, B@>(layout.gates, B@(layout, False),
      (Coord@ c, Gate@ g, B@ b) {
        Ports@<Coord@> coords = Ports@<Coord@>(
          Coord@(c.row, c.col),
          Coord@(c.row, Inc(c.col)),
          Coord@(Inc(c.row), c.col),
          Coord@(Inc(c. row), Inc(c.col)));

        Ports@<Maybe@<Data@>> cells = Ports@<Maybe@<Data@>>(
          GetData(b.layout, coords.ul), GetData(b.layout, coords.ur),
          GetData(b.layout, coords.ll), GetData(b.layout, coords.lr));

        Bool@ blocked_ul = Blocked(g.ports.ul, cells.ul);
        Bool@ blocked_ur = Or(blocked_ul, Blocked(g.ports.ur, cells.ur));
        Bool@ blocked_ll = Or(blocked_ur, Blocked(g.ports.ll, cells.ll));
        Bool@ blocked_lr = Or(blocked_ll, Blocked(g.ports.lr, cells.lr));

        blocked_lr.?(
          true: b,
          false: {
            Ports@<Data@> inputs = Ports@<Data@>(
              InputData(g.ports.ul, cells.ul),
              InputData(g.ports.ur, cells.ur),
              InputData(g.ports.ll, cells.ll),
              InputData(g.ports.lr, cells.lr));

            Ports@<Data@> outputs = g.function(inputs);
            B@ b_ul = UpdateResult(b, coords.ul, g.ports.ul, outputs.ul);
            B@ b_ur = UpdateResult(b_ul, coords.ur, g.ports.ur, outputs.ur);
            B@ b_ll = UpdateResult(b_ur, coords.ll, g.ports.ll, outputs.ll);
            B@ b_lr = UpdateResult(b_ll, coords.lr, g.ports.lr, outputs.lr);
            b_lr;
          });
      });
  };
};

# Run --
#   Run the given hardware layout as long as any gates are enabled.
(Layout@) { Layout@; } Run = (Layout@ layout) {
  B@ b = Step(layout);
  b.updated.?(true: Run(b.layout), false: layout);
};

@(Layout@, Coord@, Data@, Gate@, Ports@, PortSpec@,
  0, 1, InputPort, OutputPort, UnusedPort,
  Empty, GetData, SetData, ClearData, SetGate, Run);
