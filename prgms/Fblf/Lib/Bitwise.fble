% B = /Digits%.Bit;

@ Addr@ = /Fblf/Program%.Addr@;
@ Program@ = /Fblf/Program%.Program@;
% Assign = /Fblf/Program%.Assign;
% Eq = /Fblf/Program%.Eq;
% If = /Fblf/Program%.If;
% IfElse = /Fblf/Program%.IfElse;
% Seq = /Fblf/Program%.Seq;
% Noop = /Fblf/Program%.Noop;
% Const = /Fblf/Program%.Const;
% Ref = /Fblf/Program%.Ref;

@ Module@ = /Fblf/Module%.Module@;
% PureM = /Fblf/Module%.PureM;

@ Int@ = /Int/Int%.Int@;
% Add = /Int/Int%.Add;
% Sub = /Int/Int%.Sub;
% Lt = /Int/Int/Eq%.Lt;

% D = /Int/Int/Lit%.D;
% I = /Int/Int/Lit%.I;

<@>@ Maybe@ = /Maybe%.Maybe@;
<@>% Just = /Maybe%.Just;
<@>% Nothing = /Maybe%.Nothing;

<@,@>% For = /Loop%.For;

# Bitwise --
#   Helper function for describing modules that implement bitwise computation.
#
# Inputs:
#   n - the number of bits.
#   f - the program to execute to compute the ith bit.
#
# Results:
#   A module that computes each bit in sequence.
(Int@, (Int@) { Program@; }) { Module@; }
Bitwise = (Int@ n, (Int@) { Program@; } f) {
  (Int@) { Maybe@<Int@>; } next = (Int@ i) {
    /Int/Int/Eq%.Le(i, I(D|0)).?(
      true: Nothing<Int@>,
      false: Just<Int@>(Sub(i, I(D|1))));
  };

  PureM(For<Int@, Program@>(next(n), next, Noop, (Int@ i, Program@ s) {
    Seq([s, f(i)]);
  }));
};

# AndF --
#   n-bit bitwise AND.
#
# Inputs:
#   n - The number of bits in each operand.
#   a - The address of the first operand.
#   b - The address of the second operand.
#   z - The address of the result.
(Int@, Addr@, Addr@, Addr@) { Module@; }
AndF = (Int@ n, Addr@ a, Addr@ b, Addr@ z) {
  Bitwise(n, (Int@ i) {
    Addr@ ai = Add(a, i);
    Addr@ bi = Add(b, i);
    Addr@ zi = Add(z, i);

    IfElse(Eq(Ref(ai), Const(B|0), I(D|1)),
      Assign(zi, Const(B|0), I(D|1)),
      Assign(zi, Ref(bi), I(D|1)));
  });
};

# OrF --
#   n-bit bitwise OR.
#
# Inputs:
#   n - The number of bits in each operand.
#   a - The address of the first operand.
#   b - The address of the second operand.
#   z - The address of the result.
(Int@, Addr@, Addr@, Addr@) { Module@; }
OrF = (Int@ n, Addr@ a, Addr@ b, Addr@ z) {
  Bitwise(n, (Int@ i) {
    Addr@ ai = Add(a, i);
    Addr@ bi = Add(b, i);
    Addr@ zi = Add(z, i);

    IfElse(Eq(Ref(ai), Const(B|1), I(D|1)),
      Assign(zi, Const(B|1), I(D|1)),
      Assign(zi, Ref(bi), I(D|1)));
  });
};

# XorF --
#   n-bit bitwise XOR.
#
# Inputs:
#   n - The number of bits in each operand.
#   a - The address of the first operand.
#   b - The address of the second operand.
#   z - The address of the result.
(Int@, Addr@, Addr@, Addr@) { Module@; }
XorF = (Int@ n, Addr@ a, Addr@ b, Addr@ z) {
  Bitwise(n, (Int@ i) {
    Addr@ ai = Add(a, i);
    Addr@ bi = Add(b, i);
    Addr@ zi = Add(z, i);

    # TODO: The caller better not alias a and z, or this won't work!
    # Switch to IfElse to fix that?
    Seq([
      Assign(zi, Const(B|0), I(D|1)),
      If(Eq(Ref(ai), Const(B|0), I(D|1)),
        Assign(zi, Ref(bi), I(D|1))),
      If(Eq(Ref(bi), Const(B|0), I(D|1)),
        Assign(zi, Ref(ai), I(D|1)))]);
  });
};

# NotF --
#   n-bit bitwise NOT.
#
# Inputs:
#   n - The number of bits in the operand.
#   a - The address of the operand.
#   z - The address of the result.
(Int@, Addr@, Addr@) { Module@; }
NotF = (Int@ n, Addr@ a, Addr@ z) {
  Bitwise(n, (Int@ i) {
    Addr@ ai = Add(a, i);
    Addr@ zi = Add(z, i);

    IfElse(Eq(Ref(ai), Const(B|1), I(D|1)),
      Assign(zi, Const(B|0), I(D|1)),
      Assign(zi, Const(B|1), I(D|1)));
  });
};

# ClsF --
#   n-bit circular left shift.
#
# Inputs:
#   n - The number of bits in the operand.
#   s - The number of bits to shift left.
#   a - The address of the operand.
#   z - The address of the result.
(Int@, Int@, Addr@, Addr@) { Module@; }
ClsF = (Int@ n, Int@ s, Addr@ a, Addr@ z) {
  Bitwise(n, (Int@ i) {
    Addr@ ai = Add(a, i);
    Int@ offset = Lt(i, s).?(
      true: Sub(Add(n, i), s),
      false: Sub(i, s));
    Addr@ zi = Add(z, offset);

    Assign(zi, Ref(ai), I(D|1));
  });
};

@(AndF, OrF, XorF, NotF, ClsF);
