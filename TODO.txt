* Experiment with revision to fble literals.
 - Update implementation for updated spec.
 - Add test for wrong order list fields.
 - Add test for different name list fields. 
 - Add test that list literal doesn't need to consist of letters.
 - Add tests to increase code coverage.
 - Add spec tests to expand coverage of literal compilation code.

Fblf:
* Set up fblf compilation test infrastructure.
 - Set up build files to generate and run the compiled fblf tests.
 - Add nicer summary and error messages in compiled test runner.
* Rewrite fblf compiler to use abstraction that lets us output one line at a
  time instead of having to build up the program all in one string?
* Figure out how to deal with the memory issues for fblf md5.
 - It's because we duplicate the same exact program repeatedly when fully
   inlining, leading to a sort of exponential blowup of logic.
 - But what's a good approach to solving it?
* Rewrite tests for /Fblf/Heap%.
* Come up with a better name for SeqL?
* Factor out common code for converting Hex lits to Bit lits.
* Figure out how to replace fblf integer arithmetic with a native c
  implementation at compile time.
  - See how much faster it is now.
* Implement space invaders in fblf.
  - Do whatever is necessary to make it easier to write the program as I go
    along with regards to types and syntax.
* Add test cases for aliasing for things in general?
* Replace /Loop%.For and /Loop%.DoWhile with /Iter%.For?
 - Because the /Iter%.For is a nicer API I think.

Invaders:
* It's way way way too slow. Figure out how to make it go much faster.
 - Profile the benchmark to see what's up.
 - Figure out if this is a problem with the code written in fble or if it's a
   problem with the fble implementation.
* The aliens look like they are too far down the screen to start. Double check
  their initial coordinates.
* Once it is fast enough to be reasonable to develop, finish writing the game.

Hwdg:
* Improve the API for describing a bunch of gates with modules.
* Have an easier way to set a bunch of cells at once?
* Add test case for nondeterministic/conflicting gates case.

Exec:
* How about using locals.size to store the capacity and func->code->locals to
  store the relevant size, to avoid reallocating over and over again when
  alternating between small and large stack frames?
 - profiling suggests the performance benefits are probably pretty small,
   though I don't see any harm at all.

* It looks like a lot of thunks are sticking around in the graph for GC. Can
  we get rid of them by more eagerly unpeeling them? May be that improves GC
  performance?

* Separate eval.c into two different files, threading and instruction
  execution.

* Can we merge FBLE_FUNC_VALUE_TC and FBLE_COMPILED_FUNC_VALUE_TC?
 - by separating out a notion of FBLE_COMPILED_VALUE_TC and using FBLE_VAR_TC
   for the scope?
* Clean up doc comments in typecheck.h, typecheck.c, compile.c.
 - Now that we are passing value heaps around instead of arenas.

* Test use of undefined values in case, access, and func apply.
* Check if it's okay to add new blocks to a profile in progress.
 - if so, pass the profile to FbleSymbolicCompile so we can get profiling
   blocks from elaborated code too?
 - either way, document that clearly.
* For things like FbleValueAddRef, is it okay if dst is NULL?
 - It would be convenient for constructing things in case of error.
 - I'm not sure if there's any performance implications.
 - It would be nice to specify explicitly and be consistent with this kind of
   thing.
* Change FbleFuncValueTc scope to be FbleTcV? Isn't that more natural?
* Clarify when FbleFuncValueTc is expected versus FbleCompiledFuncValueTc.
 - Ideally they can be used interchangeably?

* Clarify in spec: is it okay to retain a local variable until a function
  exits, even if that means retaining it longer than its lexical scope?

* Implement symbolic elaboration needed for Md5 DoBlock.
 By fixing failing elaborate tests. 
 Hopefully at this point we are capable of doing elaboration for Md5 DoBlock.
* Add to spec and test that elaborate doesn't lose sharing in values.
 - for example: y = Y(x, x); z = Z(y, y) should not make 4 copies of x.
* Add to spec and test that elaborate doesn't rebuild non-symbolic values from
  scratch every time the elaborated function is called.
 - for example: \a -> Y(a, b) should reuse 'b' from scope instead of
   reconstructing it.
* Figure out how to keep track of locations for symbolic computation.
 - in particular for getting meaningful profiles out of symbolic compiled
   code.
* Be more consistent in FbleTc about use of vector versus FbleTc*[].

* Add test for nested elaborate expressions.
 - In particular, we need to make sure argument variables don't get mixed up
   when elaborating multiple functions at the same time.

* Rename 4.3-union-access/basic/* tests, because they seem to have wrong
  names?

* Any way to improve memory growth tests?
 It feels wrong to me to have to do a full gc for the tests to pass. It feels
 too specific to the implementation of garbage collection. Anything we can do?

* Proof of concept fblf
 - Implement N bit addition, run on evaluator and compile via llvm to c code
   and run.

* Check that switch statements are in enum order as appropriate
  - FBLE_DATA_ACCESS_EXPR, and FBLE_DATA_ACCESS_TC in particular.

* Follow style guide in fble.txt
  In particular, union field names should be lowercase: just, true, false, not
  Just, True, False.

* Clean up fble library
 - Separate modules as appropriate to reduce false dependencies.
 - Document all functions.
 - Add tests for full code coverage of all functions.
 - Rename Str to String? Or to S?
 - Only support Int@ officially, not IntP@ and IntS@ too?
 - Consider pulling ForEach and Map out into their own class?
 - Reuse Lit@ in the type for the ForEach function?

* Sat solver
 - Optimize the solver.
 - Implement dimacs cnf parser.

* Clean up fble test framework
 - Use AssertEquals for more of the tests.
 - Properly test the test infra.

* Figure out why we need an extra print in RunTest and other Stdio apps.
 Does the program end before we have a chance to put all the output?

* Figure out memory leak when 3 Bool Or tests were set to failing.

* Use PushAnonVar in typecheck.c for elaborate expression instead of accessing
  scope->vars.size directly.

* Improve type error in case of this?
  <@ T@>{ Maybe@<T@>; } Nothing = <@ T@> { Maybe@<T@>(nothing: Unit@()); };
  True.?(true: Nothing<Bool@>, false: True);

  We get: expected type <@ T@> { Maybe@<T@>; }<Bool@>
  Should we instead get: expected type Maybe@<Bool@>? 

* Make VLIW like instructions to reduce overhead of dispatching instructions?
 - RETURN + RELEASES
 - CALL + RELEASES
 - REF_VALS 
 - REF_DEFS

* Store function pointer in FbleInstr instead of tag
 - Requires we also store functions for disassembly and freeing of
   instructions.

* Pull out definition of architectural state and instruction functions.
 - Would be nice to separate them from the evaluator I think.

* Avoid setting local values to NULL when done?
 - It helps debugging, but otherwise we shouldn't rely on it?

* Should 'exec' be a flag passed to compile expression?
 That way we could distinguish between normal let and exec let while reusing a
 lot of the same code: change the body from CompileExpr to CompileExec.
 Otherwise we create a process function only to immediately apply it, when we
 could inline the body of the process directly.
 - I would guess this is low impact to performance, given how rarely we do let
   of process inside a process?

* Should we do function inlining in the compiler?
 - At least when the function being called is known and the call is not behind
   a condition?
 - How to make the tradeoff between runtime performance and program size?

* Should we avoid capturing an unused 'type' as a static?
  For example, if we have Unit@() in a function body.
  Proposal: whenever we look up a variable, if the kind is a type kind, return
  a special FBLE_TYPE_VAR type and don't mark the variable as accessed.
  Eliminate all let bindings of type kind.

  The trouble is:
  - This is such a small fraction of runtime, I don't expect any significant
    performance improvement in practice.
  - It feels sketchy to me to remove code that could contain errors. For
    example: ??? is there an example?

* Consistently document ownership of args to functions?
 Borrowed: no transfer of ownership.
 Consumed: ownership transferred from caller to callee.
 Outlives: caller responsible for keeping alive as long as returned result is.

* Move FblePrintName and FbleNamesEqual to fble-name.h?
  The question is if they should be public or private.
  If they should be private, they should go into name.h rather than syntax.h,
  right?

* We don't get a warning about an unused self recursive function.
  More generally, we don't get warnings about variables that are referenced
  only by unused variables.

* Fix broken vacuous_value test.
 - is this feasible to fix, now that we no longer allow errors in compile.c? 
 - is this feasible to fix in general? Try adding a more complicated test
   where we define a function and apply it to get a vacuous value?
 - Make the test more obviously failing, by trying to use the resulting value?

* Add coverage for parse destructors
 - names, module_ref, kinds, tagged_kinds, tagged_type, tagged_expr

* Move implementations corresponding to fble-name.h to name.c?

* [eval] Would it improve performance to merge statics into the locals array?
  We don't have to own them. Just copy them all over when we push a frame.
  Then we avoid the need to switch when looking up a value, and we can store a
  frame index in a single word. FrameGet goes away.

* [eval] Have option to turn off checking for nulls and other runtime errors?

* Clean up how we track io activity?

* [profile] Cleanup
 - Switch to convention that caller is responsible for enter block?
 - Replace AutoExitBlock with ReplaceBlock?

* [type] Inline fields and args data into FbleType objects?

* [gc] Implement generational gc?
 - Low priority, because experiments suggest at best we save like, 8 seconds
   on fble bench.

* [eval] Thread management cleanup
 - Use fair thread traversal by starting over from root when yield occurs.

* [app] Change App% back to drawing over the previous screen?
 - It can figure out how to double buffer appropriately on the implementation
   side, for example by drawing the last two updates to the buffer.
 - Because presumably, if not much has changed, that can be much more
   efficient? And if a lot has changed, we can optimize 'Over' to throw away
   the previous frame entirely if you start with a blank screen?

   Maybe more accurate is, if your point of view isn't changing, delta is
   better. If your point of view is changing, you probably have to redraw
   everything regardless and it would be nice to avoid drawing a bunch of
   stuff and then covering it up right away.


* [compile] Figure out why Normal is called so often
 - See if we can fix that to reduce the now annoyingly long compile times.
 - Profiling said its all in TypeEquals. Maybe something pathological?

* [cc] Implement .fble -> .o compiler
 - Goal is to significantly increase performance by removing the instruction
   fetch decode logic.

* [snake] Switch to a target 60 FPS?
* [snake] Test and fix bug when snake eats its tail.
* [snake] Ignore moves that aren't orthogonal to current snake direction.
* [snake] Keep track of and report score.
* [snake] Figure out why the background box gets lost some times.
* [pingpong] Render a static 3D table tennis scene.
* [gameoflife] Switch to a target 60 FPS?
* [invaders] Optimize space invaders game.
 - Figure out how I'm going to get to 60 FPS.
   Maybe try getting 60 FPS on the C implementation to see if it's reasonable?
 - Implement and test Alien simulation

* [lib] Add test coverage for the Int routines.
 - In particular, test Div and Mod.

* [api] Can fble-stdio check that the function has the right type?

* [compile] Test and fix error message for type of anonymous type let values.
 - The type should be the computed type for the value, not the introduced
   abstract type?

* [eval] Make child thread execution fair.
  Children should be time multiplexed, where priority is assigned based on how
  far down the family tree the child belongs. The amount of time a family gets
  to spend evaluating should be independent of the number of children in the
  family.

* [lang] Add support for abstract types?
* [lang] Document the runtime memory model,
  - Including that tail recursive functions should not smash the stack.
* [lang] Document and test that put ports don't retain link values.

* [release] Better error messages on types that have the same name but different values?
* [release] Quote funny names in types. For example, the field ',' should have
  quotes in type error messages.
* [release] Write man pages for fble and friends?
* [release] Better error message for importing something from a module that
  is not defined in the module?

* [debugger] Implement an fble debugger. Features:
 - Set a breakpoint at a line in a file.
 - Step through code line by line.
 - Evaluate expressions in the context of the current scope and print the
   results.
 - Auto breakpoint at undefined behavior?
 - Any way we could do this just by using dwarf + gdb?
 
 Use cases:
 - Debug why sudoku solver isn't working properly by stepping through a line
   at a time and printing intermediate values.

   Turns out it wasn't too hard to figure out the problem in this case without
   a debugger.

 - Debug why snake AI wasn't working.

   It turns out we were using the wrong direction. A debugger to step through
   code and print variable values would have found this more quickly than my
   guess and check approach, which was pretty tedious.

 - Debug why sat solver test is failing.
   Manual code inspection doesn't reveal the issue. I really want to trace the
   code to see which unexpected branch is being taken.

   Manually tracing through the code by profiling block led straight to the
   problem: bad implementation of boolean Eq.

 - Debug why List Eq test is failing. I want to step through again.
   Sigh. I definitely need a debugger.

   Turns out False was being defined as True instead of False. I figured that
   out by changing the body of ListEq to always return False and being
   surprised when the result was as if it returned True.

 - Debug why map equality is failing when show shows identical maps
   { (1,1) => 1; } vs. { (1,1) => 1; }

   Turns out it was a bug in map quality, not too hard to find by code
   inspection.

