Fble Syntactic Sugar
--------------------
Things that are clunky to do in fble syntax today:

1. String and integer literals
------------------------------
For example, we have from Md5:
  Bit32@ t01 = H8(d, 7, 6, a, a, 4, 7, 8);

I haven't even started using strings, because I assume the same:
  String@ hello = S5(h, e, l, l, o);

Ideally we have something more like:
  Bit32@ t01 = 0xd76aa478;
  String@ hello = "hello";

Note:
* ideal syntax supports arbitrary length. Today we have to define a
  constructor for every different length, which is not reasonable.
* ideal syntax has no separator between characters in the raw literal.
* elements of the literal are raw characters, not fble expressions.

Actual Uses:
* Md5 for Bit32 literals.
* String names and output descriptions for tests.

More generally: any densely packed raw information of arbitrary length where
explicit separators between units of information would lead to a significant
amount of overhead.

Proposal:
* Allow any kind of name with '...' and '...'@
Where ... is any sequence of characters aside from single quote. But we can
escape single quote with single quote using ''

For example:  'don''t use single quote'
And that becomes an atomic name.
* Allow string literal "...", which is any character except double quote. But
  we can escape double quote using "".

For example: "The double quote, "", is good to avoid"

You specify a struct s for decoding the string literal. The mapping is as
follows. For each character c in the string, you use the value of the field
s.'c'. Then you have two special pre-named operations:
s.cons, s.nil.

Thus: s"do, not." is desugared to:
  s.cons(s.'d',
  s.cons(s.'o',
  s.cons(s.',',
  s.cons(s.' ', 
  s.cons(s.'n', 
  s.cons(s.'o', 
  s.cons(s.'t', 
  s.cons(s.'.', 
  s.nil))))))))

Sounds good to me. Only questions are: the precise syntax to use, and whether
'cons' and 'nil' are the right names to use for the combination.

Fundamentally we want a way to describe an atomic sequence of characters in
the input program that may contain funny characters. These sequences of
characters are used for names and for string literals. Some, possibly nicer
ways of doing this:

* Allow raw escapes in the program:
    Foo\.bar
* Allow quotes, like in bash:
    'Foo.bar'
    Foo'.'bar
    ''

Using quotes is nice, because it lets you describe the empty sequence, and to
give a dense specification of some kinds of funny characters. We probably want
some form of escape characters regardless, for things like newline and other
non-printable characters. Perhaps it makes sense to just allow a combination
of the two. Then we have the following categories:

* printable non-syntax characters: [a-z_A-Z0-9], etc.
* printable syntax characters: [@[],{}+-()], etc.
* non-printable characters: \n, \xXXX, etc.

Then we add escape sequences for printable syntax characters: precede them
with a \. Then an escaped printable syntax character is treated just like a
printable non-syntax character. An escaped non-printable character is treated
just like a printable non-syntax character. And, within single quotes, a
non-escaped printable syntax character is treated like a printable non-syntax
character. And maybe we want a way to have non-escaped non-printable
characters be treated like printable non-syntax characters (like you can in
tcl using {} instead of ""), but who knows.

Then we could introduce a special syntax for string literals. Perhaps:
Concrete Syntax:  '~' name

Then you could do something like:
    { StrLit; ~'hello there';}
    { IntLit; ~1149;}

2. Lists
--------
Today we have:
    S9(a, b, c, d, e, f, g, h, i);
or: A(a, A(b, A(c, A(d, ...))))

Ideally we have something more like:
  [a, b, c, d, e, f, g, h, i]

Note:
* ideal syntax supports arbitrary length.
* ideal syntax lets you add something in the middle of the list without having
  to change anything at the beginning or end of the list specification.
* elements of the list are expressions.

Actual Uses:
* When forming lists of test cases for a test.

Proposal:
* Ideally we get something for free when we work out the proposal for monadic
  syntactic sugar. But unfortunately, I fear something like:
  {T a; T b; T c; T d; T e; T f; T g;} is a bit too tedious still.

* Or, hard code a list literal for a specific type and let people convert from
  lists? I'd rather avoid hard coding anything for a specific type if
  possible, because presumably there are more general and flexible ways of
  doing such things.

  Perhaps something more fundamental is something based on induction. You
  provide an inductive case and some base cases, and it matches whatever it
  can for inductive and base cases. Maybe we want to allow the base case to
  require 4, or 3, or 2, or 1 args rather than assume the base case works with
  0 args. For example, for a non-empty list literal.

3. Traversals
-------------
Today we have:

func ChooseBestMove(Board b, Player x; Position) {
  MaybePositionResult ul = MoveResult(b, x, Position:UL(Unit()));
  MaybePositionResult uc = MoveResult(b, x, Position:UC(Unit()));
  MaybePositionResult ur = MoveResult(b, x, Position:UR(Unit()));
  MaybePositionResult ml = MoveResult(b, x, Position:ML(Unit()));
  MaybePositionResult mc = MoveResult(b, x, Position:MC(Unit()));
  MaybePositionResult mr = MoveResult(b, x, Position:MR(Unit()));
  MaybePositionResult ll = MoveResult(b, x, Position:LL(Unit()));
  MaybePositionResult lc = MoveResult(b, x, Position:LC(Unit()));
  MaybePositionResult lr = MoveResult(b, x, Position:LR(Unit()));
  MaybePositionResult best = 
    ChooseBestMaybePosition(
      ChooseBestMaybePosition(
        ChooseBestMaybePosition(
          ChooseBestMaybePosition(ul, uc),
          ChooseBestMaybePosition(ur, ml)),
        ChooseBestMaybePosition(
          ChooseBestMaybePosition(mc, mr),
          ChooseBestMaybePosition(ll, lc))),
      lr);
  best.Just.position;
};
 
Nicer would have been:
  Best $ do
    Pos@ p <- positions();
    MaybePositionResult pr <- MoveResult(b, x, p);
    ...

Or for sudoku we have:
    InitialRowConstraints(s1(), input.s1,
    InitialRowConstraints(s2(), input.s2,
    InitialRowConstraints(s3(), input.s3,
    InitialRowConstraints(s4(), input.s4,
    InitialRowConstraints(s5(), input.s5,
    InitialRowConstraints(s6(), input.s6,
    InitialRowConstraints(s7(), input.s7,
    InitialRowConstraints(s8(), input.s8,
    InitialRowConstraints(s9(), input.s9,
      S0<Constraint>())))))))));
  };

We want:
    row <- AllSymbols();
    col <- AllSymbols();
    cell <- input[row][col];  # guards on Maybe type
    EqConstraint(CellId(row, col), cell);

Or:
    for (row : AllSymbols) {
      for (col : AllSymbols) {
        for (cell : input[row][col]) {
          ...

Proposed syntax today is bind:
  Foo@ x <- f;
  body;

Which is sugar for f((Foo@ x) { body; })

Note some alternatives:
* Monads in haskell: you don't specify the combining function on each line,
  but have a single combining function for a sequence of statements. This way
  you could easily describe a list: List { a; b; c; d; e;}

  But we know there are issues with monad composition. So maybe that's not the
  best approach.
  
  
Practical Uses:
* tictactoe, sudoku, etc.

