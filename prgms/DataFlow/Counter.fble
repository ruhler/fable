
# Implementation of a counter in data flow
#
% True = /Bool%.True;

% Chars = /Char%.Chars;

@ DataFlow@ = /DataFlow%.DataFlow@;
<@>@ In@ = /DataFlow%.In@;
<@>@ Out@ = /DataFlow%.Out@;
<@>@ End@ = /DataFlow%.End@;
<@>% Data = /DataFlow%.Data;
<@>% End = /DataFlow%.End;
% Compose = /DataFlow%.Compose;
<@>% Once = /DataFlow%.Once;
<@>% Forward = /DataFlow%.Forward;
<@>% Const = /DataFlow%.Const;
<@>% Copy = /DataFlow%.Copy;
<@>% Input = /DataFlow%.Input;
<@>% Output = /DataFlow%.Output;
% Run = /DataFlow%.Run;

<@>@ Maybe@ = /Maybe%.Maybe@;

<@>@ Get@ = /Process%.Get@;
<@>@ Put@ = /Process%.Put@;

@ Stdio@ = /Stdio%.Stdio@;

@ String@ = /String%.String@;
% Str = /String%.Str;

@ Unit@ = /Unit%.Unit@;
% Unit = /Unit%.Unit;
 
@ Count@ = +(Unit@ 1, Unit@ 2, Unit@ 3);

(In@<Count@>, Out@<Unit@>, Out@<Unit@>, Out@<Unit@>) { DataFlow@; }
Select = (In@<Count@> in, Out@<Unit@> on1, Out@<Unit@> on2, Out@<Unit@> on3) {
  End@<Count@> i := in;
  i.?(
    data: {
      Unit@ _ := i.data.?(
        1: on1(Data<Unit@>(Unit)),
        2: on2(Data<Unit@>(Unit)),
        3: on3(Data<Unit@>(Unit)));
      Select(in, on1, on2, on3);
    },
    end: {
      Unit@ _ := on1(End<Unit@>);
      Unit@ _ := on2(End<Unit@>);
      Unit@ _ := on3(End<Unit@>);
      !(Unit);
    });
};

# Count --
#   A module that outputs 1, 2, 3, 1, 2, 3, ...
#
# For each input tick.
(In@<Unit@>, Out@<Count@>) { DataFlow@; }
Count = (In@<Unit@> in, Out@<Count@> out) {
  End@<Count@> ~ prev_get, prev_put;
  End@<Count@> ~ next_get, next_put;
  End@<Count@> ~ sel_get, sel_put;
  End@<Unit@> ~ on1_get, on1_put;
  End@<Unit@> ~ on2_get, on2_put;
  End@<Unit@> ~ on3_get, on3_put;

  Compose([
    Once<Count@>(Count@(3: Unit), prev_put),
    Forward<Count@>(in, prev_get, sel_put),
    Select(sel_get, on1_put, on2_put, on3_put),
    Const<Count@>(Count@(2: Unit), on1_get, next_put),
    Const<Count@>(Count@(3: Unit), on2_get, next_put),
    Const<Count@>(Count@(1: Unit), on3_get, next_put),
    Copy<Count@>(next_get, [prev_put, out])]);
};

(Get@<End@<Unit@>>, Put@<End@<Count@>>) { DataFlow@; }
Main = (Get@<End@<Unit@>> in, Put@<End@<Count@>> out) {
  End@<Unit@> ~ in_get, in_put;
  End@<Count@> ~ out_get, out_put;

  Compose([
    Input<Unit@>(in, in_put),
    Count(in_get, out_put),
    Output<Count@>(out, out_get)]);
};

(Put@<End@<Unit@>>) { Unit@!; } Drive = (Put@<End@<Unit@>> input) {
  Unit@ _ := input(Data<Unit@>(Unit));
  Unit@ _ := input(Data<Unit@>(Unit));
  Unit@ _ := input(Data<Unit@>(Unit));
  Unit@ _ := input(Data<Unit@>(Unit));
  Unit@ _ := input(Data<Unit@>(Unit));
  input(End<Unit@>);
};

Stdio@ Stdio = (Get@<Maybe@<String@>> in, Put@<String@> out) {
  Put@<End@<Count@>> result = (End@<Count@> x) {
    x.?(
      data: x.data.?(
        1: out(Str(Chars|1)),
        2: out(Str(Chars|2)),
        3: out(Str(Chars|3))),
      end: out(Str(Chars|E)));
  };

  End@<Unit@> ~ get, put;
  Unit@ _ := Drive(put),
  Unit@ _ := Run(Main(get, result));
  !(True);
};

@(Stdio);
