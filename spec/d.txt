
Brainstorm for 'D', a language on top of Calvisus designed for humans to
write, with a bunch of descriptive features.

Modules
-------
Modules are a way of organizing code. They serve the following purposes:

* Ability to split source code across files.
Related code can be grouped into the same file, and unrelated code can be
separated. This is primarily so the person working on the code can more easily
focus on the code they are working on without being distracted by other code.
It also could have benefits for incremental and modular compilation, by
specifying a compilation unit where changes within the unit are likely to
effect many things inside the unit, but not as many without.

* Namespace support.
With enough code, there are bound to be collisions in naming of types and
functions. Namespace support makes it possible to disambiguate entities with
the same name declared in different modules. It also often allows having a
module context that names are resolved with respect to, so short names can be
used and disambiguated based on the context rather than every use. Often
namespace support allows some form of renaming entities so disambiguation can
be defined local. Java messed this up, for example, requiring the full package
name to be used to disambiguate names rather than allowing you to import a
package under a different (shorter) name.

* Hiding implementation details.
Modules typically have a notion of an interface and an implementation. They
allow code to be written solely for the implementation that is not exposed
externally. This makes it easier to change the internal implementation code,
because all of the uses occur inside the module. This is like 'static' vs not
static in C, public or private in C++ or Java, or exported or not exported in
Haskell.

* Sharing code.
In a large program, the same "module" may be useful in multiple, independent
locations. Modules serve as units of sharing. A large program can bring in
each module once, and reuse it in every place that it is used, rather than
copying it. This can sort of work because the module has a notion of an
interface separate from its implementation, so the module can be changed
without effecting its users as long as the interface doesn't change.

* Versioning?
Modules have specifications, so maybe this is also a good place to have
versioning support? Not sure. Typically I see versioning at the level of
shared libraries (think .so files), but not so much at the level of modules in
languages like C++, Java, or Haskell. This is like the difference between a
package and a module, but I'm not sure they should be treated as different
things.

* Hierarchical Modules (more a thought than a purpose)
Ideally modules are hierarchical and can be composed. Most importantly, you
can have a notion of an 'internal' module, that provides a specification that
can be reused, but only inside a module. This further restricts the users of a
specification, and makes it easier to change the specification of the module
in the future. In practice, I don't see this in C, C++, or Java. Things tend
to be "private" or "public", but not "public with respect to XXX and private
with respect to YYY".

* Short hand for mixed union/struct types where internal types don't need
  names? For example, currently in fblc two types must be defined for a list:
    List(Unit nil, ListNode cons);
    ListNode(foo x, List tail);
  It's annoying to have to come up with the two separate names.

Proposal
--------
Fbld is a meta language built on top of fblc. Its purpose is to provide
zero-cost, statically resolved abstraction for developers. The key concepts of
fbld are interfaces and modules.

An interface is a collection of types and methods used to interact with a
module. Interfaces are parameterized by type variables. The following kinds of
declarations are allowed within an interface:

1. Opaque type. An opaque type is the name of a type that will be declared
within the module implementing the interface. It will refer to a different
type for each different implementation of the interface. The only way to
interact with an opaque type's data is using interface methods provided for
that purpose.

For example, in a list interface, there will be an opaque type representing
the list type.

2. Data type. A data type declaration. The data type declaration may refer to
the type variable parameters of the interface and other opaque types declared
in the interface.

For example, a list interface may have a 'head' method to return the first
element of the list. This method may return the first element of the list, or
'nothing' to indicate the list is empty. The 'maybe' type returned by this
method could be declared as a data type in the interface.

3. Function prototype. A function declaration with no body supplied.

For example, a list interface may have a 'head' method. A function prototype
is used to declare the method.

4. Sub interface. A named subinterface. This is used to allow composition of
interfaces.

For example, a list interface may have a 'collection' sub-interface, which
allows the user to view the list as a more general collection.

Here is a concrete example of a possible list interface demonstating these
different features of an interface.

interface Collection(type t) {
  opaque C;
  func size(C ; int);
}

interface List(type t) {
  opaque L;

  union maybe_t(Unit() nothing, t just);
  
  func head(L list; maybe_t);
  func tail(L list; L);
  func empty( ; L);
  func cons(t x, L l; L);

  Collection collection(t); // TODO: How do we indicate that L = collection.C?
}


 idecl ::= 'interface' tname '(' ['type' tname [',' 'type' tname [...]]] ')' ifc ';'
