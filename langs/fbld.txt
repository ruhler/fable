Damocrates is a meta-language built on top of Androcles, Bathylus, and Calvisus
designed to be programmed by human, with features for modularity and
development. These features facilitate reuse of code across multiple programs,
expanding the scale of programs that can be developed by individuals and
larger organizations in practice.

A core philosophy of Damocrates is that it can be statically compiled into
Androcles/Bathylus/Calvisus. The abstractions introduced by the Damocrates
language are zero-cost in the sense that they have no overhead at runtime
after compiling the program down to Androcles/Bathylus/Calvisus. The developer
need not have to make a tradeoff between modularity/abstraction and runtime
performance.

Overview of Damocrates
----------------------
Damocrates adds support for modularity and polymorphism on top of the
Calvisus language.

Modularity
^^^^^^^^^^
A module is a collection of declarations with an abstract interface. The
benefits of modules are:
* They allow common functionality to be reused across many different programs.
* That common functionality can be understood and used solely based on its
  abstract interface, separate from any complex implementation details.
* Modules act as namespaces for declarations, which helps to avoid name
  conflicts when assembling programs using code from different developers.

For example, many programs make use of some form of integer arithmetic. Rather
than reimplement and retest integer arithmetic for each program, a single
integer arithmetic module can be developed and reused. The integer arithmetic
module can be defined with an abstract interface so that users need only know
there is some type Int and an operation to add two Ints together, without
having to worry about whether the Int type is implemented using a unary,
binary, 2s-complement or other representation. Here is what the interface
definition and an implementation based on a unary representation might look
like in Damocrates:

  interf IntegerI {
    type Int;
    func Add(Int a, Int b; Int);
  };

  module IntegerM(IntegerI) {
    struct Unit();
    union Int(Unit 0, Int S);

    func Add(Int a, Int b; Int) {
      ?(a; b, Int:S(Add(a.S, b)));
    };
  };

The Int type and Add function can then be referenced from other modules using
qualified references Int@IntegerM and Add@IntegerM, or they can be imported
and referred to under local names with the 'using' statement. Both of these
appropaches are demonstrated in this contrived main module that defines
operations on pairs of integers:

  module MainM(MainI) {
    using IntegerM { Int; };

    struct IntPair(Int a, Int b);
    func AddPair(IntPair x ; Int) {
      Add@IntegerM(x.a, x.b);
    };
  };

Polymorphism 
^^^^^^^^^^^^
Polymorphism makes it possible to reuse the same code in different type and
behavioral contexts. For example, with polymorphism it is possible to provide
one implementation of a list type and associated functions that work for lists
of any arbitrary type of element. Polymorphism is introduced in Damocrates by
allowing declarations to be parameterized by type and module.

A generic list type and 'Last' function could be defined by introducing a type
parameter T as follows:

  struct ListP<T>(T head, ListS<T> tail);
  union ListS<T>(Unit nil, ListP<T> cons);

  func Last<T>(ListP<T> list ; T) {
    ?(list.tail; list.head, Last<T>(list.tail.cons));
  };

We can also define a generic 'Contains' function to check if a list contains a
specific element, but only if we also provide a module parameter to define
what it means for two elements to be equal:
  
  interf Eq<T> {
    func Equals(T a, T b; Bool);
  };

  func Contains<T; Eq<T> eq>(ListS<T> list, T elem; Bool) {
    ?(list;
        False(),                                    # The list is empty.
        ?(eq.Equals(elem, list.cons.head);
          True(),                                   # head matches.
          Contains<T, eq>(list.cons.tail, elem)));  # check the tail.
  };
 
Top Level Declarations
----------------------
The fbld language as proposed is incomplete. It does not have a good story for
composing modules together into higher level libraries that can themselves be
composed together into much larger programs. This is a work in progress that
will develop as more experience is gained developing complex fbld programs.

In the mean time, the following is advised:

Code is organized into top level interf and module declarations. These
declarations belong to a single global namespace. The dependency graph between
top level declarations must form a directed acyclic graph, which implies a
module can be understood by first understanding its dependencies, then
understanding the module itself in isolation.

An fbld program is made up of the module containing its main entry point and
all other modules and interfaces that the main module depends on directly or
indirectly.

To avoid the need to parse a large number of top level declarations unused in
most programs, it is suggested to organize top level declarations by putting
each declaration in its own file called Foo.fbld, where Foo is the name of the
top level declaration.

Interfaces and modules must not recursively reference any other modules. In
other words, the graph of interface and module dependencies should be a
directed acyclic graph. The reason for this is to avoid complex and confusing
module dependencies that would make it difficult to reason about or understand
a module in isolation.

Qualified References
--------------------
A module serves as a namespace. Entities defined in different modules can
have the same name. In order to reference an entity from an external module,
both the name of the entity and the name of the external module must be
supplied using a qualified reference taking the form <name>@<mref>. For
example, to refer to a function 'True' in a module named BoolM:
   True@BoolM

Using Declarations
^^^^^^^^^^^^^^^^^^
The 'using' declaration provides a syntactic sugar to make it easier to refer
to entities declared within another module. Each 'using' declaration creates
a simple local alias for one or more entities from an another module.

By default entities are imported using the same name they are declared with,
but it is possible to specify an alternate name when importing an entity in
order to avoid name conflicts.

For example:
  using BoolM { Bool; true=True; false=False; };

The above statement imports three entities from the BoolM module.

Following the module is a list of entities to give local names to, each entity
terminated with a semicolon. The entity can either be a single name,
indicating that entity from the module is being imported under its same name,
and can be referred to elsewhere by that simple name. Or the entity can have
the form 'name' = 'name', where the first name is the name the entity is
imported under, and the second name is the name of the entity as declared in
the module it is being imported from.

Type and module parameters do not need to be supplied in the using statement
for imported polymorphic entities. The locally imported names will refer to
polymorphic entities that can be used with different type and module
parameters within the local name space. For example, a List type could be
imported once from the List module, then used locally as List<Int>,
List<Bool>, or any other kind of list.

It is legal to have multiple using statements for the same concrete module and
to import the same external entity multiple times under the same or different
names, either within a single using statement or spanning across multiple
using statements for the same concrete module. It is not required to have a
using statement for all references to external entities.

Polymorphism
------------
Declarations can be parameterized by zero or more type and module parameters.
The general syntax for defining a polymorphic entity is to use angle brackets
after the entities name with the syntax:

params ::= ['<' [tparam [',' tparam [...]]] [';' [mparam [',' mparam [...]]]] '>'] ;
mparam ::= iref params mname ;
tparam ::= tname params ;

If nothing is given after the entity name, the entity is assumed to take no
type or module parameters. If the angle brackets do not include a semicolon
followed by type parameters, the entity is assumed to take no module
parameters. In any case, it is acceptable to use the explicit syntax with zero
or more type and module parameters.

Type parameters introduce abstract type declarations of the corresponding name
into the context of the entity being declared. Type parameters can themselves
be parameterized to indicate a higher kinded type. For example, a monadic list
function could be defined by using a type parameter M that itself is
parameterized by element type T:

   func mapM<M<T>; Function<A, B> function, Monad<M> monad>(List<M<A>> list; List<M<B>>);

In this case the type variable T is not visible outside the declaration M<T>.
In more complex cases, the type variable can be referenced in additional
module parameters.

Interface Specification
-----------------------
interf <interface_name> ['<' <type_parameters> '>'] {
  <interface_declarations>
};

An interface is an abstraction of a module that includes only type, function,
process and submodule declarations, without their implementations. For a
module to properly implement an interface, every type, function, and process
declared in the interface must have a corresponding implementation supplied by
the module.

Interfaces are named. They take zero or more type parameters and contain zero
or more interface_declaration elements. Type parameters, if present, are
specified using a comma-separated list of simple names. These names can be
used within the interface_declarations to refer to the types passed to the
interface when the interface is instantiated.

Angle brackets are used to denote interface and module parameters, analogous to
how parentheses are used to denote function parameters.

There are 8 kinds of interface_declaration items: using, type, struct, union,
func, proc, interf, and module.

Struct and Union Declarations
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Struct and union declarations are as in fblc, except that they now support
polymorphic type parameters and can reference qualified types from other
modules.

For example, a generic Maybe type can be declared using a polymorphic struct
declaration:

   struct Maybe<T>(T just, Unit nothing);

To refer to a concrete instance of the Maybe type, a type argument must be
supplied. For example, Maybe<Bool> could be used for an optional Bool and
Maybe<Int> could be used for an optional Int.

Struct and union declarations may refer to types from other modules. For
example, if the Int type is declared in a separate Integer module, a
Coord type could be defined:
   
   struct Coord(Int@Integer x, Int@Integer y); 

Struct and union declarations can appear in both module interfaces and module
definitions. If a struct or union declaration appears in a module interface,
it must appear verbatim in any module definition that implements that
interface. This can be interpreted as saying the struct declaration in the
interface specifies the interface for constructing and deconstructing the
type, while the corresponding declaration in the module definition is a
unique definition of the type. If two different modules ModuleA and ModuleB
implement the same interface Interface, and that interface includes a struct
or union declaration Foo, then Foo@ModuleA is considered a different type from
Foo@ModuleB.

An abstract type declaration can be used in an interface rather than a struct
or type declaration to represent an abstract type without providing module
users with an interface to construct or deconstruct the type. See the section
on abstract type declarations for more information.

Abstract Type Declarations
^^^^^^^^^^^^^^^^^^^^^^^^^^
The 'type' declaration is used to declare an abstract type that is defined
internally by modules implementing the interface. For example:

   type Int;

Defines an abstract Int type. The 'Int' type can be used anywhere a type is
expected. Values of abstract types cannot be used as objects of member access
or arguments to conditional expressions or processes.

Abstract types may be parameterized by types. For example, an abstract
implementation of a list type could be declared as:
   type List<T>;

Module Specification
--------------------
module <module_name> ['<' <type_parameters> ; <module_parameters> '>'] '(' <interface> ')' {
  <module_declarations>
};

Module are named. Modules have zero or more type parameters and module
parameters. The type parameters are as in interfaces, a comma separate list of
simple names of types that can be referred to from within the module.

Module names belong to a different namespace than interface names. It is
acceptable to have a module with the same name as an interface. This is common
practice for interfaces that are expected to have a single implementation.

Each module parameter is specified as an interface and a module parameter
name. The module parameter can be used by providing any concrete module that
implements the given interface. Module parameters may refer to the type
parameters of the module.

Every module implements a specific interface. This means the module will
provide definitions for all components declared in the interface. The
concrete interface specification can refer to type parameters and module
parameter types.

TODO: Give a range of interesting concrete examples here.

Following the module declaration is a list of module declaration items. These
include 'using', 'struct', 'union', 'func', 'proc' , 'interf' and 'module'
declarations. The 'using' declaration is as for module interfaces. The
'union', 'func', and 'proc' declarations are as for fblc with additional
support for qualified references to external entities.

Syntax Reference
----------------
  interf ::= 'interf' iname ['<' [tname [',' tname [...]]] '>'] '{'
                [interf_decl [interf_decl [...]]] '}' ';' ;

  module ::= 'module' mname ['<'[tname [',' tname [...]]] ';'
                              [iref mname [',' iref mname [...]]] '>']
                          '(' iref ')' '{'
                [module_decl [module_decl [...]]] '}' ';' ;

  iref ::= iname ['<' [qref [',' qref [...]]] '>'] ;
         | iref '@' mref

  mref ::= mname ['<' [qref [',' qref [...]]] '; [mref [',' mref [...]]] '>']
         | mref '@' mref
         ;
          

  qref ::= tname ['@' mref] ;
  
  interf_decl ::= 'using' mref '{' [tname ['=' tname]; [tname ['=' tname]; [...]]] '}' ';'
              |  'type' tname ';'
              |  'struct' tname '(' [qref fname [',' qref fname [...]]] ')' ';'
              |  'union' tname '(' [qref fname [',' qref fname [...]]] ')' ';'
              |  'func' tname '(' [qref vname [',' qref vname [...]]] ';' qref ')' ';'
              |  'proc' tname '('
                    [qref polarity pname [',' qref polarity pname [...]]] ';'
                    [qref vname [',' qref vname [...]]] ';' qref ')' ';'
              |  interf
              |  'module' mname ['<'[tname [',' tname [...]]] ';'
                                   [iref mname [',' iref mname [...]]] '>']
                              '(' iref ')' ';'
              ;

  module_decl ::= 'using' mref '{' [tname ['=' tname]; [tname ['=' tname]; [...]]] '}' ';'
              |  'struct' tname '(' [qref fname [',' qref fname [...]]] ')' ';'
              |  'union' tname '(' [qref fname [',' qref fname [...]]] ')' ';'
              |  'func' tname '(' [qref vname [',' qref vname [...]]] ';' qref ')' expr ';'
              |  'proc' tname '('
                    [qref polarity pname [',' qref polarity pname [...]]] ';'
                    [qref vname [',' qref vname [...]]] ';' qref ')' proc ';'
              |  interf
              |  module
              ;

  iname ::= name ;  (* A name referring to an interface *)
  mname ::= name ;  (* A name referring to a module *)

  expr ::= ... (* as in fblc, with qref in place of tname *)
  proc ::= ... (* as in fblc, with qref in place of tname *)

  polarity ::= ... (* as in fblc *)
  fname ::= ... (* as in fblc *)
  pname ::= ... (* as in fblc *)
  tname ::= ... (* as in fblc *)
  vname ::= ... (* as in fblc *)

TODO
----
* Finish this spec!
 - Talk about how polymorphism works for types, funcs, processes
 - Talk about what it means to have submodules, what the restrictions are on
   recursion, and what entities are visible.
 - Give interesting examples for polymorphic and submodules.

Open Questions
--------------
* Can you import the same entity multiple times under a different name in the
  same using statement?
* Can you have multiple using statements for the same (concrete) module?
* Can you import the same entity multiple times under a different name in
  different using statements?
* Can you import public entities from your own module in using statements?
* Can you import private entities from your own module in using statements?
* Can you import funcs or procs in an interf's using statement, or only
  types?
* Can you use an imported type in the import's module parameter?
  For example, something like: using Maybe(T) { T=Maybe };
* There's no good way to partially apply or reorder type arguments to a type.
  If fear this will cause problems once we start doing advanced use of
  different kinded type parameters. I think we need either a way to have a
  polymorphic typedef, or type lambdas of some kind. Note that this is a
  problem particular to types, modules and interfaces, because those we need
  to compare against other types, modules, and interfaces for equality.
  For functions and processes you can just define a wrapper - the compiler
  doesn't care if they're the same or not.

Wish List
---------
* Some way to create a variable sized object that doesn't require O(N) 
  open-paren/close-paren pairs. For example, have a 'list' literal or varargs
  function. This would be useful when defining a list of test cases, for
  example.

* Builtin support for arrays? For example, it's pretty daunting to think about
  how to define a large 2D array. Or how to define an array for a HashTable
  implementation. Use case and alternatives not fully explored yet.
