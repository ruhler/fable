
@ Decimal@ = /Digits%.Decimal@;
% Decimal = /Digits%.Decimal;

@ Int@ = /Int/Int%.Int@;
% 0 = /Int/Int%.0;
% 1 = /Int/Int%.1;
% 2 = /Int/Int%.2;
% 3 = /Int/Int%.3;
% 4 = /Int/Int%.4;
% 5 = /Int/Int%.5;
% 6 = /Int/Int%.6;
% 7 = /Int/Int%.7;
% 8 = /Int/Int%.8;
% 9 = /Int/Int%.9;
% 10 = /Int/Int%.10;
% Add = /Int/Int%.Add;
% Mul = /Int/Int%.Mul;

<@,@,@,@>@ Literal@ = /Literal%.Literal@;

(Decimal@) { Int@; } DtoI = (Decimal@ d) { 
  d.?(0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9);
};

# MkInt@ -- 
#   Helper type for constructing integer literals.
#
# TODO: Figure out a decent way to describe how this works.
@ MkInt@ = (Int@) { Int@; };

# Int --
#   Create an Int@ from a positive decimal integer literal.
#
# For example: Int@ 42 = Int|42;
Literal@<Decimal@, MkInt@, Int@, @<Decimal>> Int = @(
  '|': (MkInt@ mk) { mk(0); },
  ',': (Decimal@ d, MkInt@ mk)(Int@ msb) {
         mk(Add(Mul(10, msb), DtoI(d)));
       },
  '': (Int@ msb) { msb; },
  '?': Decimal
);

@(Int);
