
import @ { Bit32M=Bit32; Bit@Bit; Bit1; BitNI; BoolM=Bool@StdLib; };
import Bit32M { Bit32; };

struct Bit64(Bit32 hi, Bit32 lo);

module BitN(BitNI<Bit64>) {
  import @ { Bit64; B = BitN@Bit32M; Bit1; Bit; BoolM; };
  import BoolM { Bool; And; };

  func not(Bit64 a ; Bit64) {
    Bit64(not@B(a.hi), not@B(a.lo));
  };

  func and(Bit64 a, Bit64 b; Bit64) {
    Bit64(and@B(a.hi, b.hi), and@B(a.lo, b.lo));
  };

  func or(Bit64 a, Bit64 b; Bit64) {
    Bit64(or@B(a.hi, b.hi), or@B(a.lo, b.lo));
  };

  func xor(Bit64 a, Bit64 b; Bit64) {
    Bit64(xor@B(a.hi, b.hi), xor@B(a.lo, b.lo));
  };

  func add(Bit64 a, Bit64 b; Bit64) fulladd(a, b, zero@Bit1()).z;

  func zero(; Bit64) {
    Bit64(zero@B(), zero@B());
  };

  func iszero(Bit64 a; Bool) {
     And(iszero@B(a.hi), iszero@B(a.lo));
  };

  func eq(Bit64 a, Bit64 b; Bool) {
     And(eq@B(a.hi, b.hi), eq@B(a.lo, b.lo));
  };

  func clshift(Bit64 a; Bit64) lshift(a, a.hi.3.7).z;

  struct Result(Bit64 z, Bit cout);

  func fulladd(Bit64 a, Bit64 b, Bit cin; Result) {
    Result@B rlo = fulladd@B(a.lo, b.lo, cin);
    Result@B rhi = fulladd@B(a.hi, b.hi, rlo.cout);
    Result(Bit64(rhi.z, rlo.z), rhi.cout);
  };

  func lshift(Bit64 a, Bit cin; Result) {
    Result@B rlo = lshift@B(a.lo, cin);
    Result@B rhi = lshift@B(a.hi, rlo.cout);
    Result(Bit64(rhi.z, rlo.z), rhi.cout);
  };
};
