
% B = /Digits%.Bit;
% Hex = /Digits%.Hex;

@ Int@ = /Int/Int%.Int@;
% Add = /Int/Int%.Add;
% Sub = /Int/Int%.Sub;
% Mul = /Int/Int%.Mul;
% Exp2 = /Int/Int%.Exp2;
% D = /Int/Int/Lit%.D;
% I = /Int/Int/Lit%.I;

@ Program@ = /Fblf/Program%.Program@;
@ Addr@ = /Fblf/Program%.Addr@;
@ Value@ = /Fblf/Program%.Value@;
% Assign = /Fblf/Program%.Assign;
% Eq = /Fblf/Program%.Eq;
% IfElse = /Fblf/Program%.IfElse;
% Const = /Fblf/Program%.Const;
% Ref = /Fblf/Program%.Ref;
% Seq = /Fblf/Program%.Seq;
% Noop = /Fblf/Program%.Noop;
% H = /Fblf/Program%.ConstHex;

<@>@ Module@ = /Fblf/Module%.Module@;
<@>% AllocM = /Fblf/Module%.AllocM;
<@>% PureM = /Fblf/Module%.PureM;
% SeqM = /Fblf/Module%.SeqM;

% AddM = /Fblf/Lib/Add%.AddM;
% AndM = /Fblf/Lib/Bitwise%.AndM;
% OrM = /Fblf/Lib/Bitwise%.OrM;
% XorM = /Fblf/Lib/Bitwise%.XorM;
% NotM = /Fblf/Lib/Bitwise%.NotM;
% ClsM = /Fblf/Lib/Bitwise%.ClsM;

Int@ 32 = I(D|32);

<@>@ BlockOf@ = <@ T@> {
  *(T@ 00, T@ 01, T@ 02, T@ 03,
    T@ 04, T@ 05, T@ 06, T@ 07,
    T@ 08, T@ 09, T@ 10, T@ 11,
    T@ 12, T@ 13, T@ 14, T@ 15);
};

# Addr32@ --
#   An fblf Addr@ that points to a 32 bit value.
#
# For now this is only for documentation purposes. It isn't enforced at the
# type level.
@ Addr32@ = Addr@;

# Value32@ --
#   An fblf Value@ that has 32 bits.
#
# For now this is only for documentation purposes. It isn't enforced at the
# type level.
@ Value32@ = Value@;

BlockOf@<Value32@> T1 = BlockOf@<Value32@>(
  H(Hex|D76AA478), H(Hex|E8C7B756), H(Hex|242070DB), H(Hex|C1BDCEEE),
  H(Hex|F57C0FAF), H(Hex|4787C62A), H(Hex|A8304613), H(Hex|FD469501),
  H(Hex|698098D8), H(Hex|8B44F7AF), H(Hex|FFFF5BB1), H(Hex|895CD7BE),
  H(Hex|6B901122), H(Hex|FD987193), H(Hex|A679438E), H(Hex|49B40821)
);

BlockOf@<Value32@> T2 = BlockOf@<Value32@>(
  H(Hex|F61E2562), H(Hex|C040B340), H(Hex|265E5A51), H(Hex|E9B6C7AA),
  H(Hex|D62F105D), H(Hex|02441453), H(Hex|D8A1E681), H(Hex|E7D3FBC8),
  H(Hex|21E1CDE6), H(Hex|C33707D6), H(Hex|F4D50D87), H(Hex|455A14ED),
  H(Hex|A9E3E905), H(Hex|FCEFA3F8), H(Hex|676F02D9), H(Hex|8D2A4C8A)
);

BlockOf@<Value32@> T3 = BlockOf@<Value32@>(
  H(Hex|FFFA3942), H(Hex|8771F681), H(Hex|6D9D6122), H(Hex|FDE5380C),
  H(Hex|A4BEEA44), H(Hex|4BDECFA9), H(Hex|F6BB4B60), H(Hex|BEBFBC70),
  H(Hex|289B7EC6), H(Hex|EAA127FA), H(Hex|D4EF3085), H(Hex|04881D05),
  H(Hex|D9D4D039), H(Hex|E6DB99E5), H(Hex|1FA27CF8), H(Hex|C4AC5665)
);

BlockOf@<Value32@> T4 = BlockOf@<Value32@>(
  H(Hex|F4292244), H(Hex|432AFF97), H(Hex|AB9423A7), H(Hex|FC93A039),
  H(Hex|655B59C3), H(Hex|8F0CCC92), H(Hex|FFEFF47D), H(Hex|85845DD1),
  H(Hex|6FA87E4F), H(Hex|FE2CE6E0), H(Hex|A3014314), H(Hex|4E0811A1),
  H(Hex|F7537E82), H(Hex|BD3AF235), H(Hex|2AD7D2BB), H(Hex|EB86D391)
);

# X@ -- 
#   The type of functions F, G, H, I.
#
# Inputs: x, y, z, r
#   Computes r = X(x, y, z)
@ X@ = (Addr32@, Addr32@, Addr32@, Addr32@) { Module@<Program@>; };

# XX@ --
#   The type of functions FF, GG, HH, II.
#
# Inputs: a, b, c, d, x, s, t, r
#
#   Computes r = X(a, b, c, d, x, s, t);
@ XX@ = (Addr32@, Addr32@, Addr32@, Addr32@, Addr32@, Int@, Value32@, Addr32@) { Module@<Program@>; };

(X@) { XX@; }
XX = (X@ xf)(Addr32@ a, Addr32@ b, Addr32@ c, Addr32@ d, Addr32@ x, Int@ s, Value32@ t, Addr32@ r) {
  # r = add(b, cls(add(add(a, xf(b, c, d)), add(x, t)), s));
  Addr32@ tv <- AllocM<Program@>(32);
  Addr32@ xtv <- AllocM<Program@>(32);
  Addr32@ xfv <- AllocM<Program@>(32);
  Addr32@ axfv <- AllocM<Program@>(32);
  Addr32@ axfxtv <- AllocM<Program@>(32);
  Addr32@ clsv <- AllocM<Program@>(32);
  SeqM([
    PureM<Program@>(Assign(tv, t, 32)),
    AddM(32, x, tv, xtv),
    xf(b, c, d, xfv),
    AddM(32, a, xfv, axfv),
    AddM(32, axfv, xtv, axfxtv),
    ClsM(32, s, axfxtv, clsv),
    AddM(32, b, clsv, r)
  ]);
};

XX@ FF = XX((Addr32@ x, Addr32@ y, Addr32@ z, Addr32@ r) {
  # r = or(and(x, y), and(not(x), z));
  Addr32@ nx <- AllocM<Program@>(32);
  Addr32@ anxz <- AllocM<Program@>(32);
  Addr32@ xy <- AllocM<Program@>(32);
  SeqM([
    NotM(32, x, nx),
    AddM(32, nx, z, anxz),
    AndM(32, x, y, xy),
    OrM(32, xy, anxz, r)]);
});

XX@ GG = XX((Addr32@ x, Addr32@ y, Addr32@ z, Addr32@ r) {
  # r = or(and(x, z), and(y, not(z)));
  Addr32@ nz <- AllocM<Program@>(32);
  Addr32@ aynz <- AllocM<Program@>(32);
  Addr32@ xz <- AllocM<Program@>(32);
  SeqM([
    NotM(32, z, nz),
    AddM(32, y, nz, aynz),
    AndM(32, x, z, xz),
    OrM(32, xz, aynz, r)]);
});

XX@ HH = XX((Addr32@ x, Addr32@ y, Addr32@ z, Addr32@ r) {
  # r = xor(x, xor(y, z));
  Addr32@ yz <- AllocM<Program@>(32);
  SeqM([
    XorM(32, y, z, yz),
    XorM(32, x, yz, r)]);
});

XX@ II = XX((Addr32@ x, Addr32@ y, Addr32@ z, Addr32@ r) {
  # r = xor(y, or(x, not(z)));
  Addr32@ nz <- AllocM<Program@>(32);
  Addr32@ xnz <- AllocM<Program@>(32);
  SeqM([
    NotM(32, z, nz),
    OrM(32, x, nz, xnz),
    XorM(32, y, xnz, r)]);
});

# Round@ --
#   A Round module.
#
# Inputs:
#   a, b, c, d - The 32 bit words of ABCD
#   block - The input block.
#
# Updates values of ABCD in place based on the input block.
@ Round@ = (Addr32@, Addr32@, Addr32@, Addr32@, BlockOf@<Addr32@>) { Module@<Program@>; };

# RoundX --
#   Returns the round module based on the given parameters.
#
# Inputs:
#   xx - The FF, GG, HH, or II function to use for the round.
#   s0, s1, s2, s3 - The four shift values used in the round.
#   t - The T constants to use in the round.
#   permute - How to permute the input block.
(XX@, Int@, Int@, Int@, Int@, BlockOf@<Value32@>, (BlockOf@<Addr32@>) { BlockOf@<Addr32@>; }) { Round@; }
RoundX = (XX@ xx, Int@ s0, Int@ s1, Int@ s2, Int@ s3, BlockOf@<Value32@> t, (BlockOf@<Addr32@>) { BlockOf@<Addr32@>; } permute)
(Addr32@ a, Addr32@ b, Addr32@ c, Addr32@ d, BlockOf@<Addr32@> block) {
  BlockOf@<Addr32@> permuted = permute(block);
  SeqM([
    xx(a, b, c, d, permuted.00, s0, t.00, a),
    xx(d, a, b, c, permuted.01, s1, t.01, d),
    xx(c, d, a, b, permuted.02, s2, t.02, c),
    xx(b, c, d, a, permuted.03, s3, t.03, b),
    xx(a, b, c, d, permuted.04, s0, t.04, a),
    xx(d, a, b, c, permuted.05, s1, t.05, d),
    xx(c, d, a, b, permuted.06, s2, t.06, c),
    xx(b, c, d, a, permuted.07, s3, t.07, b),
    xx(a, b, c, d, permuted.08, s0, t.08, a),
    xx(d, a, b, c, permuted.09, s1, t.09, d),
    xx(c, d, a, b, permuted.10, s2, t.10, c),
    xx(b, c, d, a, permuted.11, s3, t.11, b),
    xx(a, b, c, d, permuted.12, s0, t.12, a),
    xx(d, a, b, c, permuted.13, s1, t.13, d),
    xx(c, d, a, b, permuted.14, s2, t.14, c),
    xx(b, c, d, a, permuted.15, s3, t.15, b)]);
};

Round@ Round1 = RoundX(FF, I(D|7), I(D|12), I(D|17), I(D|22), T1, (BlockOf@<Addr32@> b) {
  b;
});

Round@ Round2 = RoundX(GG, I(D|5), I(D|9), I(D|14), I(D|20), T2, (BlockOf@<Addr32@> b) {
  BlockOf@<Addr32@>(
    b.01, b.06, b.11, b.00,
    b.05, b.10, b.15, b.04,
    b.09, b.14, b.03, b.08,
    b.13, b.02, b.07, b.12);
});

Round@ Round3 = RoundX(HH, I(D|4), I(D|11), I(D|16), I(D|23), T3, (BlockOf@<Addr32@> b) {
  BlockOf@<Addr32@>(
    b.05, b.08, b.11, b.14,
    b.01, b.04, b.07, b.10,
    b.13, b.00, b.03, b.06,
    b.09, b.12, b.15, b.02);
});

Round@ Round4 = RoundX(II, I(D|6), I(D|10), I(D|15), I(D|21), T4, (BlockOf@<Addr32@> b) {
  BlockOf@<Addr32@>(
    b.00, b.07, b.14, b.05,
    b.12, b.03, b.10, b.01,
    b.08, b.15, b.06, b.13,
    b.04, b.11, b.02, b.09);
});

(Addr32@, Addr32@, Addr32@, Addr32@, BlockOf@<Addr32@>) { Module@<Program@>; }
DoBlock = (Addr32@ a, Addr32@ b, Addr32@ c, Addr32@ d, BlockOf@<Addr32@> block) {
  Addr32@ save_a <- AllocM<Program@>(32);
  Addr32@ save_b <- AllocM<Program@>(32);
  Addr32@ save_c <- AllocM<Program@>(32);
  Addr32@ save_d <- AllocM<Program@>(32);
  SeqM([
    PureM<Program@>(Assign(save_a, Ref(a), 32)),
    PureM<Program@>(Assign(save_b, Ref(b), 32)),
    PureM<Program@>(Assign(save_c, Ref(c), 32)),
    PureM<Program@>(Assign(save_d, Ref(d), 32)),
    Round1(a, b, c, d, block),
    Round2(a, b, c, d, block),
    Round3(a, b, c, d, block),
    Round4(a, b, c, d, block),
    AddM(32, a, save_a, a),
    AddM(32, b, save_b, b),
    AddM(32, c, save_c, c),
    AddM(32, d, save_d, d)]);
};

@ Addr8@ = Addr@;
@ Addr64@ = Addr@;

# Md5@ -- 
#   Interface to an Md5 compute module.
#
# To use the Md5 compute module:
# 1. Run the 'reset' program
# 2. For each byte of the input in order, 
#   Set the 'byte' register to the value of the byte.
#   Run the 'feed' program.
# 3. Run the 'finish' program.
#
# The result of the Md5 computation will be in the 'abcd' register.
# The module can be reused for multiple Md5 computations by rerunning the
# above instructions for each computation.
@ Md5@ = *(Program@ reset, Program@ feed, Program@ finish);

# Store --
#   Stores a single word in a 2^k-element array of n-bit words.
#
# When run, the program does:
#   memory[addr] = value;
(Int@, Int@, Addr@, Addr@, Addr@) { Program@; }
Store = (Int@ k, Int@ n, Addr@ memory, Addr@ addr, Addr@ value) {
  /Int/Int/Eq%.Eq(k, I(D|0)).?(
    true: Assign(memory, Ref(value), n),
    false: {
      Int@ sk = Sub(k, I(D|1));
      Addr@ saddr = Add(addr, I(D|1));
      IfElse(Eq(Ref(addr), Const(B|0), I(D|1)),
        Store(sk, n, memory, saddr, value),
        Store(sk, n, Add(memory, Mul(n, Exp2(sk))), saddr, value));
    });
};

# Md5 -- 
#   The Md5 computation.
#
# Inputs:
#   a - The address of the 'A' value of the computed Md5.
#   b - The address of the 'B' value of the computed Md5.
#   c - The address of the 'C' value of the computed Md5.
#   d - The address of the 'D' value of the computed Md5.
#   byte - The address of the input byte passed to the feed program.
(Addr32@, Addr32@, Addr32@, Addr32@, Addr8@) { Module@<Md5@>; }
Md5 = (Addr32@ a, Addr32@ b, Addr32@ c, Addr32@ d, Addr8@ byte) {

  # Count of the number of bytes bytes of input that have been processed.
  Addr64@ length <- AllocM<Md5@>(I(D|64));

  # Space to assemble the next 32 bit word of input.
  Addr32@ word <- AllocM<Md5@>(32);

  # Space to assemble the next block of 16 32-bit words of input.
  Addr@ block <- AllocM<Md5@>(Mul(I(D|16), I(D|32)));

  # Note: the spec lists the initial values for A, B, C, and D low-order byte
  # first, but H takes high order byte first.
  Program@ reset = Seq([
    Assign(length, H(Hex|0000000000000000), I(D|64)),
    Assign(a, H(Hex|67452301), 32),
    Assign(b, H(Hex|EFCDAB89), 32),
    Assign(c, H(Hex|98BADCFE), 32),
    Assign(d, H(Hex|10325476), 32)]);

  Program@ feed = Noop; # TODO

  Program@ finish = Noop; # TODO

  PureM<Md5@>(Md5@(reset, feed, finish));
};

@(Md5);

