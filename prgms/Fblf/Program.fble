
@ Bit@ = /Digits%.Bit@;
@ Hex@ = /Digits%.Hex@;
% HexToBits = /Digits/String%.HexToBits;

@ Int@ = /Int/Int%.Int@;

<@>@ List@ = /List%.List@;
<@>% Nil = /List%.Nil;

@ Unit@ = /Unit%.Unit@;
% Unit = /Unit%.Unit;

# Bits@ --
#   A sequence of bits.
@ Bits@ = List@<Bit@>;

# Addr@ --
#   A reference to a bit on the bit heap.
@ Addr@ = Int@;

# Value@ --
#   A value that is specified as either a reference to a sequence of bits on
#   the heap or a literal sequence of bits.
@ Value@ = +(Addr@ ref, Bits@ const);

(Addr@) { Value@; } Ref = (Addr@ x) {
  Value@(ref: x);
};

# Const --
#   A constant value.
#
# Example Use:
#   Value@ v = Const(Bit|01110001);
(List@<Bit@>) { Value@; } Const = (List@<Bit@> bits) {
  Value@(const: bits);
};

# ConstHex --
#   A constant value from Hex.
#
# Example Use:
#   Value@ v = Const(Bit|A71);
(List@<Hex@>) { Value@; } ConstHex = (List@<Hex@> l) {
  Const(HexToBits(l));
};

# ConditionOp@ --
#   A conditional operator.
#
# Fields:
#   eq - The condition is satisfied if the arguments are equal.
#   ne - The condition is satisfied if the arguments are not equal.
@ ConditionOp@ = +(Unit@ eq, Unit@ ne);

# Condition@ --
#   A conditional expression: a == b or a != b
#
# Fields:
#   op - The operation to use.
#   a - The first operand.
#   b - The second operand.
#   n - The number of bits to compare.
@ Condition@ = *(ConditionOp@ op, Value@ a, Value@ b, Int@ n);

(Value@, Value@, Int@) { Condition@; } Eq = (Value@ a, Value@ b, Int@ n) {
  Condition@(ConditionOp@(eq: Unit), a, b, n);
};

(Value@, Value@, Int@) { Condition@; } Ne = (Value@ a, Value@ b, Int@ n) {
  Condition@(ConditionOp@(ne: Unit), a, b, n);
};

# ProgramId@ --
#   Identifies a program in the context of an environment of programs.
@ ProgramId@ = Int@;

# Assign@ --
#   Set the contents of ref to the given value.
#
# If value is a reference, behavior is undefined of the sequences of bits of
# the ref and value are overlapping.
#
# Fields:
#   ref - Reference to the sequence of bits to be assigned to.
#   value - The value of the bits to set.
#   n - The number of bits to be assigned.
@ Assign@ = *(Addr@ ref, Value@ value, Int@ n);

# Sequence@ -- 
#   Executes a sequence of zero or more programs in order.
@ Sequence@ = List@<Program@>,

# IfElse@ --
#   Executes the if_body if the condition is satisfied, the else_body
#   otherwise.
@ IfElse@ = *(Condition@ condition, Program@ if_body, Program@ else_body),

# While@ --
#   Executes the body repeatedly for as long as the condition is satisfied.
@ While@ = *(Condition@ condition, Program@ body),

# Shared@ --
#   Execute the program with the given id in the context of a program
#   environment.
@ Shared@ = ProgramId@,

# Program@ --
#   A program that performs computation on the bit heap.
@ Program@ = +(
  Assign@ assign,
  Sequence@ sequence,
  IfElse@ ifelse,
  While@ while,
  Shared@ shared
);

# Env@ --
#   A program environment mapping program id to program.
@ Env@ = /Map%.Map@<ProgramId@, Program@>;

# EmptyEnv --
#   An empty program environment.
Env@ EmptyEnv = /Map%.Empty<ProgramId@, Program@>;

# GetProgram --
#   Gets the program with given id from the program environment.
#
# Behavior is undefined if there is no program in the environment with that
# id.
(Env@, ProgramId@) { Program@; } GetProgram = {
  % Lookup = /Map%.Lookup<ProgramId@>(/Int/Int/Structured%.Structured)<Program@>;
  (Env@ env, ProgramId@ id) {
    Lookup(env, id).just;
  };
};

# PutProgram --
#   Puts the program with given id into the program environment.
(Env@, ProgramId@, Program@) { Env@; }
PutProgram = /Map%.Insert<ProgramId@>(/Int/Int/Structured%.Structured)<Program@>;

# ForEachProgram --
#   Iterate over all the programs in the given program environment.
#
# Conceptually:
#   B@ b = base
#   foreach (id, prog) in map:
#     b = body(id, prog, b)
#   return b
<@ B@>(Env@, B@, (ProgramId@, Program@, B@) { B@; }) { B@; }
ForEachProgram = <@ B@> { /Map%.ForEach<ProgramId@, Program@, B@>; };

(Addr@, Value@, Int@) { Program@; } Assign = (Addr@ x, Value@ v, Int@ n) {
  Program@(assign: Assign@(x, v, n));
};

(Condition@, Program@, Program@) { Program@; }
IfElse = (Condition@ p, Program@ if_body, Program@ else_body) {
  Program@(ifelse: IfElse@(p, if_body, else_body));
};

(List@<Program@>) { Program@; } Seq = (List@<Program@> prgms) {
  Program@(sequence: prgms);
};

Program@ Noop = Program@(sequence: Nil<Program@>);

(Condition@, Program@) { Program@; } If = (Condition@ p, Program@ body) {
  IfElse(p, body, Noop);
};

(Condition@, Program@) { Program@; } While = (Condition@ p, Program@ body) {
  Program@(while: While@(p, body));
};

(ProgramId@) { Program@; } Shared = (ProgramId@ id) {
  Program@(shared: id);
};

@(
  Bit@, Bits@, Addr@, Env@, ProgramId@, Value@, ConditionOp@, Condition@,
  Assign@, Sequence@, IfElse@, While@, Program@, Shared@,
  Const, ConstHex, Ref, Eq, Ne, Assign, If, IfElse, Seq, Noop, While, Shared,
  EmptyEnv, GetProgram, PutProgram, ForEachProgram
);
