
struct Unit();

# A square is either filled with an 'X', filled with an 'O', 
# or is 'E'mpty.
union Square(Unit X, Unit O, Unit E);

# A board is a 3x3 grid of squares.
struct Board(
    Square ul, Square uc, Square ur,    # Upper row.
    Square ml, Square mc, Square mr,    # Middle row.
    Square ll, Square lc, Square lr     # Lower row.
);

func EmptyBoard( ; Board) {
  Board(Square:E(Unit()), Square:E(Unit()), Square:E(Unit()),
        Square:E(Unit()), Square:E(Unit()), Square:E(Unit()),
        Square:E(Unit()), Square:E(Unit()), Square:E(Unit()));
};

# Position can be used to identify a specific square in the 3x3 grid.
union Position(
    Unit UL, Unit UC, Unit UR,
    Unit ML, Unit MC, Unit MR,
    Unit LL, Unit LC, Unit LR
);

# Returns the value of the square at position 'p' in board 'b'.
func GetSquare(Board b, Position p; Square) {
  ?(p; .ul(b), .uc(b), .ur(b), .ml(b), .mc(b), .mr(b), .ll(b), .lc(b), .lr(b));
};

# Sets the square at position 'p' in board 'b' to value 's'.
func SetSquare(Board b, Position p, Square s ; Board) {
  ?(p;
      Board(     s, .uc(b), .ur(b), .ml(b), .mc(b), .mr(b), .ll(b), .lc(b), .lr(b)),
      Board(.ul(b),      s, .ur(b), .ml(b), .mc(b), .mr(b), .ll(b), .lc(b), .lr(b)),
      Board(.ul(b), .uc(b),      s, .ml(b), .mc(b), .mr(b), .ll(b), .lc(b), .lr(b)),
      Board(.ul(b), .uc(b), .ur(b),      s, .mc(b), .mr(b), .ll(b), .lc(b), .lr(b)),
      Board(.ul(b), .uc(b), .ur(b), .ml(b),      s, .mr(b), .ll(b), .lc(b), .lr(b)),
      Board(.ul(b), .uc(b), .ur(b), .ml(b), .mc(b),      s, .ll(b), .lc(b), .lr(b)),
      Board(.ul(b), .uc(b), .ur(b), .ml(b), .mc(b), .mr(b),      s, .lc(b), .lr(b)),
      Board(.ul(b), .uc(b), .ur(b), .ml(b), .mc(b), .mr(b), .ll(b),      s, .lr(b)),
      Board(.ul(b), .uc(b), .ur(b), .ml(b), .mc(b), .mr(b), .ll(b), .lc(b),      s));
};

union MaybeBoard(Board Just, Unit Nothing);

union Player(Unit X, Unit O);

union Bool(Unit True, Unit False);

# Returns true if the square 's' is empty.
func IsEmpty(Square s ; Bool) {
  ?(s; Bool:False(Unit()), Bool:False(Unit()), Bool:True(Unit()));
};

# Returns the board resulting from player 'x' making a play at position 'p'
# of board 'b'. Returns Nothing if the square at position 'p' of board 'b' is
# not empty.
func Move(Board b, Position p, Player x; MaybeBoard) {
  ?(IsEmpty(GetSquare(b, p)) ; 
     MaybeBoard:Just(SetSquare(b, p, ?(x; Square:X(Unit()), Square:O(Unit())))),
     MaybeBoard:Nothing(Unit()));
};

# The status of a (valid) board is one of:
#  X: The player X has won.
#  O: The player O has won.
#  D: There is a draw.
#  E: The board has empty squares.
union Status(Unit X, Unit O, Unit D, Unit E);

# Return the status of a single square.
func SquareStatus(Square a ; Status) {
  ?(a ; Status:X(Unit()), Status:O(Unit()), Status:E(Unit()));
};

# Combine two Status using an 'and' operation.
func AndStatus(Status a, Status b; Status) {
  ?(a ;
      ?(b ; a, Status:D(Unit()), b, b), 
      ?(b ; Status:D(Unit()), a, b, b),
      ?(b ; a, a, a, b),
      a);
};

# Combine two Status using an 'or' operation.
func OrStatus(Status a, Status b; Status) {
  ?(a ; a, a, b, ?(b ; b, b, a, a));
};

# Compute the status for a given row of squares.
func RowStatus(Square a, Square b, Square c; Status) {
  AndStatus(SquareStatus(a), AndStatus(SquareStatus(b), SquareStatus(c)));
};

# Compute the status for a board.
func BoardStatus(Board a ; Status) {
  OrStatus(
      OrStatus(
        OrStatus(RowStatus(.ul(a), .uc(a), .ur(a)), RowStatus(.ml(a), .mc(a), .mr(a))),
        OrStatus(RowStatus(.ll(a), .lc(a), .lr(a)), RowStatus(.ul(a), .ml(a), .ll(a)))),
      OrStatus(
        OrStatus(RowStatus(.uc(a), .mc(a), .lc(a)), RowStatus(.ur(a), .mr(a), .lr(a))),
        OrStatus(RowStatus(.ul(a), .mc(a), .lr(a)), RowStatus(.ur(a), .mc(a), .ll(a)))));
};

union Result(Unit Win, Unit Draw, Unit Loss);

# Re-interpret the result from the perspective of the opposing player.
func FlipResult(Result r; Result) {
  ?(r ; Result:Loss(Unit()), Result:Draw(Unit()), Result:Win(Unit()));
};

# Return the expected result of the game for player 'x', assuming player 'x'
# has just moved and that both players play optimally.
func ExpectedResult(Board b, Player x; Result) {
  ?(BoardStatus(b);
      ?(x; Result:Win(Unit()), Result:Loss(Unit())),
      ?(x; Result:Loss(Unit()), Result:Win(Unit())),
      Result:Draw(Unit()),
      {
        Player o = ?(x; Player:O(Unit()), Player:X(Unit()));
        Position move = ChooseBestMove(b, o);
        FlipResult(ExpectedResult(.Just(Move(b, move, o)), o));
      }
   );
};

struct PositionResult(Position position, Result result);

func ChooseBestPosition(PositionResult a, PositionResult b; PositionResult) {
  Result ra = .result(a);
  Result rb = .result(b);
  ?(ra; a, ?(rb; b, a, a), b);
};

func ChooseBestMaybePosition(MaybePositionResult a, MaybePositionResult b;
    MaybePositionResult) {
  ?(a; ?(b; MaybePositionResult:Just(ChooseBestPosition(.Just(a), .Just(b))), a), b);
};

union MaybePositionResult(PositionResult Just, Unit Nothing);

# Return the expected result of player 'x' moving at position 'p' on board
# 'b'. Returns Nothing if the player 'x' cannot move at position 'p' on board
# 'b'.
func MoveResult(Board b, Player x, Position p; MaybePositionResult) {
  MaybeBoard moved = Move(b, p, x);
  ?(moved;
      MaybePositionResult:Just(PositionResult(p, ExpectedResult(.Just(moved), x))),
      MaybePositionResult:Nothing(Unit()));
};

# Choose the best move for player 'x' on the given board.
# The results are undefined if there are no moves left to make.
func ChooseBestMove(Board b, Player x; Position) {
  MaybePositionResult ul = MoveResult(b, x, Position:UL(Unit()));
  MaybePositionResult uc = MoveResult(b, x, Position:UC(Unit()));
  MaybePositionResult ur = MoveResult(b, x, Position:UR(Unit()));
  MaybePositionResult ml = MoveResult(b, x, Position:ML(Unit()));
  MaybePositionResult mc = MoveResult(b, x, Position:MC(Unit()));
  MaybePositionResult mr = MoveResult(b, x, Position:MR(Unit()));
  MaybePositionResult ll = MoveResult(b, x, Position:LL(Unit()));
  MaybePositionResult lc = MoveResult(b, x, Position:LC(Unit()));
  MaybePositionResult lr = MoveResult(b, x, Position:LR(Unit()));
  MaybePositionResult best = 
    ChooseBestMaybePosition(
      ChooseBestMaybePosition(
        ChooseBestMaybePosition(
          ChooseBestMaybePosition(ul, uc),
          ChooseBestMaybePosition(ur, ml)),
        ChooseBestMaybePosition(
          ChooseBestMaybePosition(mc, mr),
          ChooseBestMaybePosition(ll, lc))),
      lr);
  .position(.Just(best));
};

union GameStatus(Player Move, Player Win, Unit Draw); 
struct Output(Board board, GameStatus status);

func GameIsOver(GameStatus status ; Bool) {
  ?(status; Bool:False(Unit()), Bool:True(Unit()), Bool:True(Unit()));
};

# position: Make a move at the given position for the current player.
# computer: Have the computer make a move for the current player.
# reset: Reset the game.
union Input(Position position, Unit computer, Unit reset);

func InputIsReset(Input input; Bool) {
  ?(input; Bool:False(Unit()), Bool:False(Unit()), Bool:True(Unit()));
};

func InputIsPosition(Input input; Bool) {
  ?(input; Bool:True(Unit()), Bool:False(Unit()), Bool:False(Unit()));
};

proc NewGame(Input <~ input, Output ~> output; ; Unit) {
  PlayGame(input, output; EmptyBoard(), Player:X(Unit()));
};

proc PlayGame(Input <~ input, Output ~> output; Board board, Player x; Unit) {
  GameStatus status = $(?(BoardStatus(board);
                          GameStatus:Win(Player:X(Unit())),
                          GameStatus:Win(Player:O(Unit())),
                          GameStatus:Draw(Unit()),
                          GameStatus:Move(x)));
  Output ignored = ~output(Output(board, status));
  Input in = ~input();
  ?(GameIsOver(status) ; 
      ?(in ; PlayGame(input, output; board, x),
             PlayGame(input, output; board, x),
             NewGame(input, output; )),
      ?(InputIsReset(in) ; NewGame(input, output; ),
        {
          Position pos = $(?(InputIsPosition(in) ; .position(in), ChooseBestMove(board, x)));
          MaybeBoard nboard = $(Move(board, pos, x));
          ?(nboard ;
              PlayGame(input, output; .Just(nboard), ?(x; Player:O(Unit()), Player:X(Unit()))),
              PlayGame(input, output; board, x));
        }));
};

union TestResult(Unit Passed, Unit Failed);

func TestBoardStatus( ; TestResult) {
  Status status = BoardStatus(Board(
        Square:X(Unit()), Square:O(Unit()), Square:O(Unit()),
        Square:E(Unit()), Square:O(Unit()), Square:X(Unit()),
        Square:O(Unit()), Square:X(Unit()), Square:X(Unit())));
  ?(status ;
      TestResult:Failed(Unit()),
      TestResult:Passed(Unit()),
      TestResult:Failed(Unit()),
      TestResult:Failed(Unit()));
};

union PositionTestResult(Unit Passed, Position Failed);

func TestChooseBestMoveWin( ; PositionTestResult) {
  Position position = ChooseBestMove(Board(
        Square:X(Unit()), Square:X(Unit()), Square:E(Unit()),
        Square:O(Unit()), Square:O(Unit()), Square:E(Unit()),
        Square:E(Unit()), Square:E(Unit()), Square:E(Unit())), Player:X(Unit()));
  ?(position ;
      PositionTestResult:Failed(position), PositionTestResult:Failed(position), PositionTestResult:Passed(Unit()),
      PositionTestResult:Failed(position), PositionTestResult:Failed(position), PositionTestResult:Failed(position),
      PositionTestResult:Failed(position), PositionTestResult:Failed(position), PositionTestResult:Failed(position));
};

func TestChooseBestMoveNoLose( ; PositionTestResult) {
  Position position = ChooseBestMove(Board(
        Square:E(Unit()), Square:E(Unit()), Square:E(Unit()),
        Square:X(Unit()), Square:X(Unit()), Square:O(Unit()),
        Square:E(Unit()), Square:E(Unit()), Square:O(Unit())), Player:X(Unit()));
  ?(position ;
      PositionTestResult:Failed(position), PositionTestResult:Failed(position), PositionTestResult:Passed(Unit()),
      PositionTestResult:Failed(position), PositionTestResult:Failed(position), PositionTestResult:Failed(position),
      PositionTestResult:Failed(position), PositionTestResult:Failed(position), PositionTestResult:Failed(position));
};

func BenchmarkChooseBestMove( ; Position) {
  ChooseBestMove(Board(
        Square:E(Unit()), Square:E(Unit()), Square:E(Unit()),
        Square:E(Unit()), Square:E(Unit()), Square:E(Unit()),
        Square:E(Unit()), Square:E(Unit()), Square:E(Unit())), Player:X(Unit()));
};

# TODO:
# * Better way of expressing maybe monad
# * Be able to easily combine multiple test cases
# * Use PositionEquals for test result, and report position when failed.

