
@ Char@ = /Char%.Char@;
% Chars = /Char%.Chars;

@ Bit@ = /Digits%.Bit@;
% Bit = /Digits%.Bit;

@ Output@ = /Fblf/Compile/Output%.Output@;
% Line = /Fblf/Compile/Output%.Line;
% Do = /Fblf/Compile/Output%.Do;
% Return = /Fblf/Compile/Output%.Return;

@ Var@ = /Fblf/Program%.Var@;
@ Proc@ = /Fblf/Program%.Proc@;
@ ProcId@ = /Fblf/Program%.ProcId@;
@ Stmt@ = /Fblf/Program%.Stmt@;
@ Assign@ = /Fblf/Program%.Assign@;
@ Cond@ = /Fblf/Program%.Cond@;
@ IfElse@ = /Fblf/Program%.IfElse@;
@ Sequence@ = /Fblf/Program%.Sequence@;
@ While@ = /Fblf/Program%.While@;
@ Call@ = /Fblf/Program%.Call@;
@ Value@ = /Fblf/Program%.Value@;
@ Program@ = /Fblf/Program%.Program@;
% Offset = /Fblf/Program%.Offset;
% Var = /Fblf/Program%.Var;

@ Int@ = /Int/Int%.Int@;
% Sub = /Int/Int%.Sub;
% Eq = /Int/Int/Eq%.Eq;
% Le = /Int/Int/Eq%.Le;
% Mod = /Int/Int/Div%.Mod;
% Int = /Int/Int/Lit%.Int;

% CountUpTo = /Int/Int/Iter%.CountUpTo;
<@,@>% For = /Iter%.For;

<@>@ List@ = /List%.List@;
<@>% Nil = /List%.Nil;
<@>% Cons = /List%.Cons;
<@,@>% ForEach = /List%.ForEach;
<@,@>% Map = /List%.Map;

<@>% Drop = /List/Length%.Drop;
<@>% Length = /List/Length%.Length;
<@>% Take = /List/Length%.Take;

@ String@ = /String%.String@;
% Str = /String%.Str;
% Strs = /String%.Strs;

@ Unit@ = /Unit%.Unit@;

Int@ BitsPerWord = Int|64;

(Var@) { String@; } CompileVar = (Var@ v) {
  Strs[Str|'(x', /Int/Int/Show%.Show(v.id),
    Str|' + ', /Int/Int/Show%.Show(v.offset), Str|')'];
};

# Compile a constant that is assumed to fit within BitsPerWord.
(List@<Bit@>) { String@; } 
CompileSmallConstant = {
  # Convert a list of bits to hex string, assuming the number of elements on
  # the list is a multiple of 4.
  (List@<Bit@>) { String@; } ToHex = (List@<Bit@> l) {
    l.?(
      cons: {
        Bit@ a = l.cons.head;
        Bit@ b = l.cons.tail.cons.head;
        Bit@ c = l.cons.tail.cons.tail.cons.head;
        Bit@ d = l.cons.tail.cons.tail.cons.tail.cons.head;
        String@ tail = ToHex(l.cons.tail.cons.tail.cons.tail.cons.tail);
        Char@ h = a.?(
          0: b.?(
            0: c.?(0: d.?(0: Chars.0, 1: Chars.1), 1: d.?(0: Chars.2, 1: Chars.3)),
            1: c.?(0: d.?(0: Chars.4, 1: Chars.5), 1: d.?(0: Chars.6, 1: Chars.7))),
          1: b.?(
            0: c.?(0: d.?(0: Chars.8, 1: Chars.9), 1: d.?(0: Chars.A, 1: Chars.B)),
            1: c.?(0: d.?(0: Chars.C, 1: Chars.D), 1: d.?(0: Chars.E, 1: Chars.F))));
        Cons<Char@>(h, tail);
      },
      nil: Nil<Char@>);
  };

  (List@<Bit@> c) {
    Int@ length = Length<Bit@>(c);
    Eq(Mod(length, Int|4), Int|0).?(
      true: Strs[Str|'0x', ToHex(c)],
      false: {
        # TODO: We could improve performance by adding just the right number
        # of bits here, instead of having to recompute the length of the list
        # each time.
        CompileSmallConstant(Cons<Bit@>(Bit.0, c));
      });
  };
};

# Compile an equals condition into an atomic boolean expression in C, where
# the number of bits is assumed to fit within BitsPerWord.
(Value@, Value@, Int@) { String@; }
CompileSmallEquals = (Value@ a, Value@ b, Int@ n) {
  a.?(
    var: b.?(
      var: Strs[
        Str|'FblfHeapEqual(heap, ',
        CompileVar(a.var), Str|', ',
        CompileVar(b.var), Str|', ',
        /Int/Int/Show%.Show(n), Str|')'],
      const: Strs[
        Str|'FblfHeapEquals(heap, ',
        CompileVar(a.var), Str|', ',
        CompileSmallConstant(b.const), Str|', ',
        /Int/Int/Show%.Show(n), Str|')']),
    const: b.?(
      var: Strs[
        Str|'FblfHeapEquals(heap, ',
        CompileVar(b.var), Str|', ',
        CompileSmallConstant(a.const), Str|', ',
        /Int/Int/Show%.Show(n), Str|')'],
      const: Strs[
        Str|'(',
        CompileSmallConstant(a.const),
        Str|' == ',
        CompileSmallConstant(b.const),
        Str|')']));
};

# Split the first n bits off of the given value, returning the n most
# significant bits of the value as 'hi', and the remaining least significant
# bits of the value in 'lo'.
(Value@, Int@) { *(Value@ hi, Value@ lo); } Split = (Value@ v, Int@ n) {
  v.?(
    var: @(
      hi: v,
      lo: Var(Offset(v.var, n))),
    const: @(
      hi: Value@(const: Take<Bit@>(n, v.const)),
      lo: Value@(const: Drop<Bit@>(n, v.const))));
};

# Compile an equals condition into an atomic boolean expression in C.
(Value@, Value@, Int@) { String@; }
CompileEquals = (Value@ a, Value@ b, Int@ n) {
  Le(n, BitsPerWord).?(
    true: CompileSmallEquals(a, b, n),
    false: {
      % as = Split(a, BitsPerWord);
      % bs = Split(b, BitsPerWord);
      String@ hi = CompileSmallEquals(as.hi, bs.hi, BitsPerWord);
      String@ lo = CompileEquals(as.lo, bs.lo, Sub(n, BitsPerWord));
      Strs[Str|'(', hi, Str|' && ', lo, Str|')'];
    });
};

# Compile a condition into an expression suitable for use in the condition of
# an if or while statement in C.
(Cond@) { String@; } CompileCondition = (Cond@ cond) {
  String@ equals = CompileEquals(cond.a, cond.b, cond.n);
  cond.op.?(
    eq: equals,
    ne: Cons<Char@>(Chars.'!', equals));
};

# Compile an assignment statement assuming the number of bits fits within
# BitsPerWord.
(String@, Assign@) { Output@; }
CompileSmallAssign = (String@ indent, Assign@ assign) {
  assign.value.?(
    var: Line(Strs[
      indent,
      Str|'FblfHeapCopy(heap, ',
      CompileVar(assign.var),
      Str|', ',
      CompileVar(assign.value.var),
      Str|', ',
      /Int/Int/Show%.Show(assign.n),
      Str|');']),
    const: Line(Strs[
      indent,
      Str|'FblfHeapWrite(heap, ',
      CompileVar(assign.var),
      Str|', ',
      CompileSmallConstant(assign.value.const),
      Str|', ',
      /Int/Int/Show%.Show(assign.n),
      Str|');']));
};

# CProcName --
#   The C function name used for the implementation of the procedure with given
#   id.
(ProcId@) { String@; } CProcName = (ProcId@ id) {
  # TODO: Sanitize the function name in a way that ensures we end up with a
  # unique name for each ProcId.
  Strs[Str|'__proc_', Map<Char@, Char@>(id, (Char@ c) {
    /Char/Type%.IsAlNum(c).?(true: c, false: Chars.'_');
  })];
};

(String@, Call@) { Output@; } CompileCall = (String@ indent, Call@ call) {
  String@ args = Strs(Map<Var@, String@>(call.args, (Var@ v) {
    Strs[Str|', ', CompileVar(v)];
  }));

  Line(Strs[indent, CProcName(call.proc), Str|'(heap', args, Str|');']);
};

# Compile an assignment statement into a sequence of statements in C.
(String@, Assign@) { Output@; } CompileAssign = (String@ indent, Assign@ assign) {
  Le(assign.n, BitsPerWord).?(
    true: CompileSmallAssign(indent, assign),
    false: {
      % vs = Split(assign.value, BitsPerWord);
      Unit@ _ <- Do(CompileSmallAssign(indent, Assign@(assign.var, vs.hi, BitsPerWord)));
      Unit@ _ <- Do(CompileSmallAssign(indent, Assign@(Offset(assign.var, BitsPerWord), vs.lo, Sub(assign.n, BitsPerWord))));
      Return;
    });
};

(String@, Sequence@) { Output@; } CompileSequence = (String@ indent, Sequence@ seq) {
  seq.?(
    cons: {
      Unit@ _ <- Do(CompileStmt(indent, seq.cons.head));
      Unit@ _ <- Do(CompileSequence(indent, seq.cons.tail));
      Return;
    },
    nil: Return);
},

(String@, IfElse@) { Output@; } CompileIfElse = (String@ indent, IfElse@ ifelse) {
  String@ nested = Strs[indent, Str|'  '];
  Unit@ _ <- Do(Line(Strs[indent, Str|'if (', CompileCondition(ifelse.condition), Str|') {']));
  Unit@ _ <- Do(CompileStmt(nested, ifelse.if_body));
  Unit@ _ <- Do(Line(Strs[indent, Str|'} else {']));
  Unit@ _ <- Do(CompileStmt(nested, ifelse.else_body));
  Unit@ _ <- Do(Line(Strs[indent, Str|'}']));
  Return;
},

(String@, While@) { Output@; } CompileWhile = (String@ indent, While@ while) {
  String@ nested = Strs[indent, Str|'  '];
  Unit@ _ <- Do(Line(Strs[ indent, Str|'while (', CompileCondition(while.condition), Str|') {']));
  Unit@ _ <- Do(CompileStmt(nested, while.body));
  Unit@ _ <- Do(Line(Strs[indent, Str|'}']));
  Return;
},

(String@, Stmt@) { Output@; } CompileStmt = (String@ indent, Stmt@ prgm) {
  prgm.?(
    assign: CompileAssign(indent, prgm.assign),
    sequence: CompileSequence(indent, prgm.sequence),
    ifelse: CompileIfElse(indent, prgm.ifelse),
    while: CompileWhile(indent, prgm.while),
    call: CompileCall(indent, prgm.call));
};

# Proto --
#   Generates the prototype for an fblf function with given name and number of
#   arguments.
(String@, Int@) { String@; } Proto = (String@ name, Int@ argc) {
  String@ args = For<Int@, String@>(CountUpTo(argc), Str|'',
    (Int@ i, String@ s) {
      Strs[s, Str|', int x', /Int/Int/Show%.Show(i)];
    });

  Strs[Str|'void ', name, Str|'(FblfHeap* heap', args, Str|')'];
};

# CompileProc --
#   Compile an fblf statement to a C function with the given name.
#
# The signature of a function named 'Foo' will be:
#   void Foo(FblfHeap* heap, int x0, int x1, ...);
(String@, Int@, Stmt@) { Output@; }
CompileProc = (String@ name, Int@ argc, Stmt@ stmt) {
  Unit@ _ <- Do(Line(Proto(name, argc)));
  Unit@ _ <- Do(Line(Str|'{'));
  Unit@ _ <- Do(CompileStmt(Str|'  ', stmt));
  Unit@ _ <- Do(Line(Str|'}'));
  Return;
};

# Compile --
#   Compile an fblf program to C function.
(Program@) { Output@; } Compile = (Program@ prog) {
  Unit@ _ <- Do(ForEach<Proc@, Output@>(prog, Return, (Proc@ proc, Output@ o) {
    Unit@ _ <- Do(o);
    Unit@ _ <- Do(Line(Strs[Proto(CProcName(proc.id), proc.argc), Str|';']));
    Return;
  }));

  Unit@ _ <- Do(ForEach<Proc@, Output@>(prog, Return, (Proc@ proc, Output@ o) {
    Unit@ _ <- Do(o);
    Unit@ _ <- Do(CompileProc(CProcName(proc.id), proc.argc, proc.body));
    Return;
  }));

  Return;
};

@(Compile);

