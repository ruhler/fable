
@ Bool@ = /Bool%.Bool@;
% True = /Bool%.True;
% False = /Bool%.False;

@ Char@ = /Char%.Char@;
% Chars = /Char%.Chars;

@ Int@ = /Int/Int%.Int@;
% Sub = /Int/Int%.Sub;

<@>@ List@ = /List%.List@;
<@>% Nil = /List%.Nil;
<@>% List = /List%.List;
<@>% Append = /List%.Append;
<@>% Concat = /List%.Concat;
<@>% Cons = /List%.Cons;
<@,@>% ProcessEach = /List%.ProcessEach;
<@,@>% Map = /List%.Map;
<@>% Length = /List/Length%.Length;

<@,@>@ Lit@ = /Literal%.Lit@;

<@>@ Put@ = /Process%.Put@;

@ String@ = /String%.String@;
<@>@ CharLit@ = /String%.CharLit@;
% Str = /String%.Str;

@ Unit@ = /Unit%.Unit@;
% Unit = /Unit%.Unit;

@ TestResult@ = +(Unit@ pass, String@ fail);
@ Test@ = *(String@ name, TestResult@! test);
@ TestSuite@ = List@<Test@>;

# Test --
#   Creates a test.
#
# In particular, this is more convenient to use than Test@(...) if you want to
# specify the name of the test using a CharLit@ instead of a String@.
#
# Inputs:
#   name - the name of the test
#   test - a process that returns the result of the test
(CharLit@, TestResult@!) { Test@; } Test = (CharLit@ name, TestResult@! test) {
  Test@(Str(name), test);
};

# TestSuite --
#   Creates a suite of tests.
#
# Inputs:
#   name - the name of the test suite.
#   tests - the list of tests in the test suite.
(CharLit@, Lit@<Test@>) { TestSuite@; }
TestSuite = (CharLit@ name, Lit@<Test@> tests) {
  String@ prefix = Append<Char@>(Str(name), Str(Chars|'.'));
  Map<Test@, Test@>(List<Test@>(tests), (Test@ test) {
    Test@(Append<Char@>(prefix, test.name), test.test);
  });
};

<@ T@>((T@, T@) { Bool@; }, (T@) { String@; }, T@, T@) { TestResult@; }
AssertEquals = <@ T@>(/Eq%.Eq@<T@> eq, /Show%.Show@<T@> show, T@ expected, T@ actual) {
  eq(expected, actual).?(
    true: TestResult@(pass: Unit),
    false: TestResult@(fail: Concat<Char@>(List<String@>([
          Str(Chars|'expected: '),
          show(expected),
          Str(Chars|', but got: '),
          show(actual)]))));
};

# Print a string to the given output stream.
(Put@<String@>, String@) { Unit@!; } Print = (Put@<String@> out, String@ str) {
  out(str);
};

# Print a string and newline to the given output stream.
(Put@<String@>, String@) { Unit@!; } PrintLn = (Put@<String@> out, String@ str) {
  out(Append<Char@>(str, Str([Chars.nl])));
};

# Returns True if the tests all pass, false otherwise.
(Put@<String@>, TestSuite@) { Bool@!; } RunTests = (Put@<String@> out, TestSuite@ tests) {
  @ Failure@ = *(String@ name, String@ msg);

  # Run all the tests, given a list of tests that failed so far.
  # Returns the list of failing tests.
  (TestSuite@, List@<Failure@>) { List@<Failure@>!; }
  Run = (TestSuite@ ts, List@<Failure@> failed) {
    ts.?(
      cons: {
        Test@ t = ts.cons.head;
        TestResult@ tr := t.test;
        String@ status = Str(tr.?(pass: Chars|'.', fail: Chars|'F'));
        Unit@ _ := out(status);
        List@<Failure@> nfailed = tr.?(
          pass: failed,
          fail: Cons<Failure@>(Failure@(t.name, tr.fail), failed));
        Run(ts.cons.tail, nfailed);
      },
      nil: !(failed));
  };

  List@<Failure@> failures := Run(tests, Nil<Failure@>);

  Unit@ _ := PrintLn(out, Nil<Char@>);
  Unit@ _ := ProcessEach<Failure@, Unit@>(failures, Unit, (Failure@ f, Unit@ _) {
    PrintLn(out, Concat<Char@>(List<String@>([f.name, Str(Chars|': FAILED: '), f.msg])));
  });
  Unit@ _ := PrintLn(out, Nil<Char@>);

  Int@ num_total = Length<Test@>(tests);
  Int@ num_failed = Length<Failure@>(failures);
  Int@ num_passed = Sub(num_total, num_failed);
  Unit@ _ := PrintLn(out, Concat<Char@>(List<String@>([
    Str(Chars|'Test Summary: '),
    /Int/Int/Show%.Show(num_passed),
    Str(Chars|' passed, '),
    /Int/Int/Show%.Show(num_failed),
    Str(Chars|' failed, '),
    /Int/Int/Show%.Show(num_total),
    Str(Chars|' total')
  ])));

  # TODO: Why do we need this extra output?
  Unit@ _ := PrintLn(out, Nil<Char@>);

  !(failures.?(cons: False, nil: True));
};

# Returns True if the tests all pass, false otherwise.
(Put@<String@>, TestSuite@) { Bool@!; } RunTestsVerbose = (Put@<String@> out, TestSuite@ tests) {
  ProcessEach<Test@, Bool@>(tests, True, (Test@ test, Bool@ passing) {
    Unit@ _ := Print(out, test.name);
    TestResult@ tr := test.test;
    tr.?(
      pass: {
        Unit@ _ := PrintLn(out, Nil<Char@>);
        !(passing);
      },
      fail: {
        Unit@ _ := PrintLn(
          out,
          Concat<Char@>(List<String@>([
            Str(Chars|': FAILED: '),
            tr.fail])));
        !(False);
      });
  });
};

@(
  String@, TestResult@, Test@, TestSuite@,
  AssertEquals, Test, TestSuite, RunTests, RunTestsVerbose);
