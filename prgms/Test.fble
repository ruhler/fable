
@ Bool@ = /Bool%.Bool@;
% True = /Bool%.True;
% False = /Bool%.False;

@ Char@ = /Char%.Char@;
% Chars = /Char%.Chars;

@ Int@ = /Int/Int%.Int@;
% 0 = /Int/Int%.0;
% Inc = /Int/Int%.Inc;
% Sub = /Int/Int%.Sub;

<@>@ List@ = /List%.List@;
<@>% Nil = /List%.Nil;
<@>% List = /List%.List;
<@>% Append = /List%.Append;
<@>% Concat = /List%.Concat;
<@>% Cons = /List%.Cons;
<@,@>% ProcessEach = /List%.ProcessEach;
<@>% Length = /List/Length%.Length;

<@>@ Put@ = /Process%.Put@;

@ String@ = /String%.String@;
% Str = /String%.Str;

@ Unit@ = /Unit%.Unit@;
% Unit = /Unit%.Unit;

@ TestResult@ = +(Unit@ pass, String@ fail);
@ TestCase@ = *(String@ name, TestResult@! test);
@ TestSuite@ = *(String@ name, List@<Test@> tests),
@ Test@ = +(TestCase@ case, TestSuite@ suite);

# Test --
#   Creates an individual test.
#
# Inputs:
#   name - the name of the test
#   test - a process that returns the result of the test
(String@, TestResult@!) { Test@; } Test = (String@ name, TestResult@! test) {
  Test@(case: TestCase@(name, test));
};

# TestSuite --
#   Creates a suite of tests.
#
# Inputs:
#   name - the name of the test suite.
#   tests - the list of tests in the test suite.
(String@, List@<Test@>) { Test@; }
TestSuite = (String@ name, List@<Test@> tests) {
  Test@(suite: TestSuite@(name, tests));
};

<@ T@>((T@, T@) { Bool@; }, (T@) { String@; }, T@, T@) { TestResult@; }
AssertEquals = <@ T@>(/Eq%.Eq@<T@> eq, /Show%.Show@<T@> show, T@ expected, T@ actual) {
  eq(expected, actual).?(
    true: TestResult@(pass: Unit),
    false: TestResult@(fail: Concat<Char@>(List<String@>[
      Str|'expected: ', show(expected),
      Str|', but got: ', show(actual)])));
};

# Print a string to the given output stream.
(Put@<String@>, String@) { Unit@!; } Print = (Put@<String@> out, String@ str) {
  out(str);
};

# Print a string and newline to the given output stream.
(Put@<String@>, String@) { Unit@!; } PrintLn = (Put@<String@> out, String@ str) {
  out(Append<Char@>(str, Str[Chars.nl]));
};

# Returns True if the test passes, false otherwise.
(Put@<String@>, Test@) { Bool@!; } RunTests = (Put@<String@> out, Test@ test) {
  @ Failure@ = *(String@ name, String@ msg);

  # Run all the tests, given a list of tests that failed so far.
  # Returns the number of total tests executed and the list of failing tests.
  @ Status@ = *(Int@ total, List@<Failure@> failures);
  (Test@, String@, Status@) { Status@!; }
  Run = (Test@ test, String@ prefix, Status@ status) {
    test.?(
      case: {
        TestCase@ t = test.case;
        TestResult@ tr := t.test;
        String@ short = tr.?(pass: Str|'.', fail: Str|'F');
        Unit@ _ := out(short);
        List@<Failure@> nfailed = tr.?(
          pass: status.failures,
          fail: Cons<Failure@>(Failure@(Append<Char@>(prefix, t.name), tr.fail), status.failures));
        !(Status@(Inc(status.total), nfailed));
      },
      suite: {
        String@ nprefix = Concat<Char@>(List<String@>[
            prefix, test.suite.name, Str|'.']);
        ProcessEach<Test@, Status@>(test.suite.tests, status,
          (Test@ t, Status@ s) {
            Run(t, nprefix, s);
          });
      });
  };

  Status@ status := Run(test, Nil<Char@>, Status@(0, Nil<Failure@>));
  List@<Failure@> failures = status.failures;

  Unit@ _ := PrintLn(out, Nil<Char@>);
  Unit@ _ := ProcessEach<Failure@, Unit@>(failures, Unit, (Failure@ f, Unit@ _) {
    PrintLn(out, Concat<Char@>(List<String@>[f.name, Str|': FAILED: ', f.msg]));
  });
  Unit@ _ := PrintLn(out, Nil<Char@>);

  Int@ num_total = status.total;
  Int@ num_failed = Length<Failure@>(failures);
  Int@ num_passed = Sub(num_total, num_failed);
  Unit@ _ := PrintLn(out, Concat<Char@>(List<String@>[
    Str|'Test Summary: ',
    /Int/Int/Show%.Show(num_passed), Str|' passed, ',
    /Int/Int/Show%.Show(num_failed), Str|' failed, ',
    /Int/Int/Show%.Show(num_total), Str|' total'
  ]));

  !(failures.?(cons: False, nil: True));
};

# Returns True if the tests all pass, false otherwise.
(Put@<String@>, Test@) { Bool@!; } RunTestsVerbose = (Put@<String@> out, Test@ test) {

  (Test@, String@, Bool@) { Bool@!; }
  Run = (Test@ test, String@ prefix, Bool@ passing) {
    test.?(
      case: {
        Unit@ _ := Print(out, Append<Char@>(prefix, test.case.name));
        TestResult@ tr := test.case.test;
        tr.?(
          pass: {
            Unit@ _ := PrintLn(out, Nil<Char@>);
            !(passing);
          },
          fail: {
            Unit@ _ := PrintLn(
              out,
              Concat<Char@>(List<String@>[Str|': FAILED: ', tr.fail]));
            !(False);
          });
      },
      suite: {
        String@ nprefix = Concat<Char@>(List<String@>[
            prefix, test.suite.name, Str|'.']);
        ProcessEach<Test@, Bool@>(test.suite.tests, passing,
          (Test@ test, Bool@ passing) {
            Run(test, nprefix, passing);
          });
      });
  };

  Run(test, Nil<Char@>, True);
};

@(
  String@, TestResult@, Test@, TestSuite@, TestCase@,
  AssertEquals, Test, TestSuite, RunTests, RunTestsVerbose);
