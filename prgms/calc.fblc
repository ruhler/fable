
struct Unit();
union Bool(Unit true, Unit false);

func True( ; Bool) {
  Bool:true(Unit());
};

func False( ; Bool) {
  Bool:false(Unit());
};

# The following type is used to represent (unbounded) integers.
# Note that this representation allows multiple ways of representing each
# integer, because 2*0 = 0 and 2*(-1)+1 = -1.
# Functions that operate on integers should work for all the representations
# of various numbers. They should not assume the smallest representation for
# a number and in general need not produce the smallest representation for a
# number, though they should if all the arguments are in their most compact
# form.
union Integer(
   Unit 0,
   Unit m1,
   Integer 2x,
   Integer 2xp1
);

func Eq(Integer a, Integer b; Bool) {
  # For now, just assume the args are both in canonical form.
  ?(a ;
      0:    ?(b ; 0: True(),  m1: False(), 2x: False(),        2xp1: False()),
      m1:   ?(b ; 0: False(), m1: True(),  2x: False(),        2xp1: False()),
      2x:   ?(b ; 0: False(), m1: False(), 2x: Eq(a.2x, b.2x), 2xp1: False()),
      2xp1: ?(b ; 0: False(), m1: False(), 2x: False(),        2xp1: Eq(a.2xp1, b.2xp1)));
};

# The integer 0
func Zero( ; Integer) {
  Integer:0(Unit());
};

# The integer (-1)
func Minus1( ; Integer) {
  Integer:m1(Unit());
};

# 2 * x
func Double(Integer x; Integer) {
  Integer doubled = Integer:2x(x);
  ?(x ; 0: Zero(), m1: doubled, 2x: doubled, 2xp1: doubled);
};

# 2 * x + 1
func DoublePlus1(Integer x; Integer) {
  Integer doubled_plus_1 = Integer:2xp1(x);
  ?(x ; 0: doubled_plus_1, m1: Minus1(), 2x: doubled_plus_1, 2xp1: doubled_plus_1);
};

# a + 1
func Add1(Integer a; Integer) {
  ?(a ; 
      0:    DoublePlus1(Zero()),      # 0 + 1 = 2*0+1
      m1:   Zero(),                   # -1 + 1 = 0
      2x:   DoublePlus1(a.2x),        # 2*d + 1 = 2d*+1
      2xp1: Double(Add1(a.2xp1)));    # 2*d+1 + 1 = 2*(d+1)
};

# a - 1
func Sub1(Integer a; Integer) {
  ?(a ;
      0:    Minus1(),                 # 0-1 = -1
      m1:   Double(Minus1()),         # -1-1 = 2*(-1)
      2x:   DoublePlus1(Sub1(a.2x)),  # 2*d-1 = 2*(d-1)+1
      2xp1: Double(a.2xp1));          # 2*d+1-1 = 2*d
};

# a + b
func Add(Integer a, Integer b; Integer) {
  ?(a ;
     0: b,                                     # 0 + b = b
     m1: ?(b;
       0:    a,                                # a + 0 = a
       m1:   Double(Minus1()),                 # -1 + -1 = 2*(-1)
       2x:   DoublePlus1(Add(b.2x, Minus1())), # -1 + 2*d = 2*(d-1)+1
       2xp1: Double(b.2xp1)),                  # -1 + (2*d+1) = 2*d
     2x: ?(b;
       0:    a,                                # a + 0 = a
       m1:   DoublePlus1(Add(a.2x, Minus1())), # 2*d + -1 = 2*(d-1)+1
       2x:   Double(Add(a.2x, b.2x)),          # 2*d + 2*e = 2*(d+e)
       2xp1: DoublePlus1(Add(a.2x, b.2xp1))),  # 2*d + 2*e+1 = 2*(d+e)+1
     2xp1: ?(b;
       0:    a,                                    # a + 0 = a
       m1:   Double(a.2xp1),                       # 2*d+1 + -1 = 2*d
       2x:   DoublePlus1(Add(a.2xp1, b.2x)),       # 2*d+1 +2*e = 2*(d+e)+1
       2xp1: Double(Add1(Add(a.2xp1, b.2xp1)))));  # 2*d+1 + 2*e+1 = 2*((d+e)+1)
};

# -a 
func Negate(Integer a; Integer) {
  ?(a ;
    0:    Zero(),                          # -0 = 0
    m1:   DoublePlus1(Zero()),             # -(-1) = 2*0+1
    2x:   Double(Negate(a.2x)),            # -(2*d) = 2*(-d)
    2xp1: Sub1(Double(Negate(a.2xp1))));   # -(2*d+1) = 2*(-d)-1
};

# a - b 
func Sub(Integer a, Integer b; Integer) {
  # a - b = a + (-b)
  Add(a, Negate(b));
};

# a * b
func Mul(Integer a, Integer b; Integer) {
  ?(a ; 
    0:  Zero(),       # 0 * b = 0
    m1: Negate(b),    # -1 * b = -b
    2x: ?(b ; 
      0:    Zero(),                           # 2*x * 0 = 0
      m1:   Double(Negate(a.2x)),             # 2*x * -1 = 2*(-x)
      2x:   Double(Double(Mul(a.2x, b.2x))),  # 2*x * 2*y = 2*(2*(x*y))
      2xp1: Add(Double(Double(Mul(a.2x, b.2xp1))), Double(a.2x))), # 2*x * (2*y+1) = 2*2*x*y + 2*x
    2xp1: ?(b ;
      0:    Zero(),                        # (2*x+1) * 0 = 0
      m1:   Sub1(Double(Negate(a.2xp1))),  # (2*x+1) * -1 = 2*(-x) - 1
      2x:   Add(Double(Double(Mul(a.2xp1, b.2x))), Double(b.2x)),  # (2*x+1) * 2*y = 2*2*x*y + 2*y
      2xp1: Add(   # (2*x+1) * (2*y+1) = 2*2*x*y + 2*x + (2*y +1)
              Add(
               Double(Double(Mul(a.2xp1, b.2xp1))),
               Double(a.2xp1)),
              b)));
};

# The Calculator machine has a stack of operands.
# Initially the stack is empty. The following instructions can be used to
# modify the stack.
union CalcInstr(
    # Pop the top two operands from the stack, add them together, and push
    # the result to the stack. If there are not enough operands on the stack,
    # 0 is used in place of the missing operands.
    Unit add,

    # Pop the top two operands from the stack. Subtract what was the top
    # operand on the stack from what was the operand just beneath the top
    # operand on the stack. Push the result to the stack. If there are not
    # enough operands on the stack, 0 is used in place of the missing
    # operands.
    Unit sub,

    # Pop the top two operands from the stack, multiply them together, and
    # push the result to the stack. If there are not enough operands on the
    # stack, 0 is used in place of the missing operands.
    Unit mul,

    # Clear the stack of all operands.
    Unit clear,

    # Push the given integer on top of the stack.
    Integer push
);

union CalcStack(Unit empty, CalcOperands nonempty);
struct CalcOperands(Integer top, CalcStack rest);

func Push(CalcStack stack, Integer operand; CalcStack) {
  CalcStack:nonempty(CalcOperands(operand, stack));
};

struct Pop1Result(Integer top, CalcStack rest);
func Pop1(CalcStack stack; Pop1Result) {
  ?(stack ; empty: Pop1Result(Zero(), CalcStack:empty(Unit())),
            nonempty: Pop1Result(stack.nonempty.top, stack.nonempty.rest));
};

struct Pop2Result(Integer top1, Integer top2, CalcStack rest);
func Pop2(CalcStack stack; Pop2Result) {
  Pop1Result p1 = Pop1(stack);
  Pop1Result p2 = Pop1(p1.rest);
  Pop2Result(p1.top, p2.top, p2.rest);
};

# Execute the given calculator instruction.
func ExecCalcInstr(CalcStack stack, CalcInstr instr; CalcStack) {
  ?(instr ;
      add: { Pop2Result p2 = Pop2(stack); Push(p2.rest, Add(p2.top2, p2.top1)); },
      sub: { Pop2Result p2 = Pop2(stack); Push(p2.rest, Sub(p2.top2, p2.top1)); },
      mul: { Pop2Result p2 = Pop2(stack); Push(p2.rest, Mul(p2.top2, p2.top1)); },
      clear: { CalcStack:empty(Unit()); },
      push: { Push(stack, instr.push); });
};

union CalcProgram(Unit empty, CalcInstrs nonempty);
struct CalcInstrs(CalcInstr instr, CalcProgram next);

# Execute a sequence of calculator instructions.
func ExecCalcInstrs(CalcStack stack, CalcProgram prg; CalcStack) {
  ?(prg ; empty: stack,
          nonempty:
            ExecCalcInstrs(ExecCalcInstr(stack, prg.nonempty.instr), prg.nonempty.next));
};

# Run the calculator program and return the result on top of the stack. If
# the final stack is empty, the value 0 is returned.
func RunCalc(CalcProgram prg; Integer) {
  Pop1(ExecCalcInstrs(CalcStack:empty(Unit()), prg)).top;
};


# ************ TESTS ****************
union TestName(
    Unit add_pos_pos,
    Unit add_pos_neg,
    Unit sub_gt_lt,
    Unit sub_lt_gt,
    Unit negate_pos,
    Unit negate_neg,
    Unit mul_pos_pos,
    Unit calc_prg_simple
);
union TL(Unit pass, FailedTestResult fail);
struct FailedTestResult(
    TestName name,
    Integer want,
    Integer got,
    TL rest
);

func Test(TestName name, Integer want, Integer got, TL list; TL) {
  ?(Eq(want, got) ; true: list, false: TL:fail(FailedTestResult(name, want, got, list)));
};

func main( ; TL) {
  Integer minus_five = DoublePlus1(DoublePlus1(Double(Minus1())));
  Integer minus_two = Double(Minus1());
  Integer two = Double(DoublePlus1(Zero()));
  Integer three = DoublePlus1(DoublePlus1(Zero()));
  Integer five = DoublePlus1(Double(DoublePlus1(Zero())));
  Integer fifteen = DoublePlus1(DoublePlus1(DoublePlus1(DoublePlus1(Zero()))));

  TL l0 = TL:pass(Unit());
  TL l1 = Test(TestName:add_pos_pos(Unit()), five, Add(two, three), l0);
  TL l2 = Test(TestName:add_pos_neg(Unit()), minus_two, Add(three, minus_five), l1);
  TL l3 = Test(TestName:sub_gt_lt(Unit()), two, Sub(five, three), l2);
  TL l4 = Test(TestName:sub_lt_gt(Unit()), minus_two, Sub(three, five), l3);
  TL l5 = Test(TestName:negate_pos(Unit()), minus_two, Negate(two), l4);
  TL l6 = Test(TestName:negate_neg(Unit()), two, Negate(minus_two), l5);
  TL l7 = Test(TestName:mul_pos_pos(Unit()), fifteen, Mul(three, five), l6);

  CalcProgram prg8 = CalcProgram:nonempty(
     CalcInstrs(CalcInstr:push(five), CalcProgram:nonempty(
     CalcInstrs(CalcInstr:push(five), CalcProgram:nonempty(
     CalcInstrs(CalcInstr:add(Unit()), CalcProgram:nonempty(
     CalcInstrs(CalcInstr:push(five), CalcProgram:nonempty(
     CalcInstrs(CalcInstr:add(Unit()), CalcProgram:empty(Unit())))))))))));
  TL l8 = Test(TestName:calc_prg_simple(Unit()),
      fifteen, RunCalc(prg8), l7);
  l8;
};
