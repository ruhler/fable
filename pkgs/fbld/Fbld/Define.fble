
@ Bool@ = /Core/Bool%.Bool@;
% False = /Core/Bool%.False;

@ Char@ = /Core/Char%.Char@;
% Chars = /Core/Char%.Chars;
% IsNewline = /Core/Char/Type%.IsNewline;

@ Int@ = /Core/Int%.Int@;

<@>@ List@ = /Core/List%.List@;
<@>% Cons = /Core/List%.Cons;
<@>% Append = /Core/List%.Append;
<@>% Reverse = /Core/List%.Reverse;
<@>% Drop = /Core/List/Length%.Drop;
<@>% Length = /Core/List/Length%.Length;

<@>@ Maybe@ = /Core/Maybe%.Maybe@;
<@>% Just = /Core/Maybe%.Just;
<@>% Nothing = /Core/Maybe%.Nothing;

@ String@ = /Core/String%.String@;
% Str = /Core/String%.Str;
% Strs = /Core/String%.Strs;
% StartsWith = /Core/String/Eq%.StartsWith;

@ Command@ = /Fbld/Command%.Command@;

<@>@ Fbld@ = /Fbld/Fbld%.Fbld@;
@ Invoke@ = /Fbld/Fbld%.Invoke@;
<@>% Do = /Fbld/Fbld%.Do;
<@>% Return = /Fbld/Fbld%.Return;
<@>% Error = /Fbld/Fbld%.Error;

@ Loc@ = /Fbld/Loc%.Loc@;
% Start = /Fbld/Loc%.Start;

% Run = /Fbld/Run%;

@ Text@ = /Fbld/Text%.Text@;
% Text = /Fbld/Text%.Text;
% StringOf = /Fbld/Text%.StringOf;
% LocOf = /Fbld/Text%.LocOf;

@ Map@ = /Core/Map%.Map@<String@, String@>;
% Empty = /Core/Map%.Empty<String@, String@>;
% Insert = /Core/Map%.Insert<String@>(/Core/String/Ord%.Ord)<String@>;
% Lookup = /Core/Map%.Lookup<String@>(/Core/String/Ord%.Ord)<String@>;

# Indent all but first line with prefix.
(String@, String@) { String@; } Indent = (String@ prefix, String@ text) {
  (Bool@, String@, String@) { String@; }
  indent = (Bool@ nl, String@ str, String@ rchrs) {
    str.?(nil: Reverse(rchrs));
    nl.?(true: indent(False, str, Append(Reverse(prefix), rchrs)));
    Char@ c = str.cons.head;
    indent(IsNewline(c), str.cons.tail, Cons(c, rchrs));
  };

  indent(False, text, Str|'');
};

(Map@, String@) { String@; }
Subst = (Map@ map, String@ body) {
  (String@, String@, String@) { String@; } subst = (String@ indent, String@ body, String@ r) {
    body.?(nil: r);

    String@ tail = body.cons.tail;
    IsNewline(body.cons.head).?(true: {
      subst(Str|'', tail, Cons(body.cons.head, r));
    });
    String@ nindent = Cons(Chars.' ', indent);

    body.cons.head.?('$': {
      Bool@ do_indent = {
        tail.?(nil: False);
        /Core/Char/Eq%.Eq(Chars.'$', tail.cons.head);
      };

      String@ tail_ = do_indent.?(true: tail.cons.tail, false: tail);
      String@ tail = tail_;

      Maybe@<String@> mv = /Core/Map%.ForEach(map, Nothing<String@>,
        (String@ key, String@ _, Maybe@<String@> mv) {
          mv.?(just: mv);
          StartsWith(tail, key).?(true: Just(key));
          Nothing<String@>;
        });
      mv.?(nothing: subst(nindent, tail, Cons(body.cons.head, r)));
      String@ ntail = Drop(Length(mv.just), tail);
      String@ value = Lookup(map, mv.just).just;
      String@ indented = do_indent.?(true: Indent(indent, value), : value);
      subst(nindent, ntail, Append(Reverse(indented), r));
    });
    subst(nindent, tail, Cons(body.cons.head, r));
  };

  Reverse(subst(Str|'', body, Str|''));
};

(List@<String@>, List@<Text@>, Map@) { Map@; }
MakeMap = (List@<String@> keys, List@<Text@> values, Map@ m) {
  keys.?(nil: m);
  MakeMap(keys.cons.tail, values.cons.tail,
    Insert(m, keys.cons.head, StringOf(values.cons.head)));
};

(List@<String@>, String@, Command@) { Fbld@<Text@>; }
Define = (List@<String@> argnames, String@ body, Command@ command) {
  Int@ wnt_args = Length(argnames);
  Int@ got_args = Length(command.args);
  /Core/Int/Eq%.Eq(wnt_args, got_args ).?(false: {
    Error<Text@>(LocOf(command.name), Strs[
          Str|'expected ', /Core/Int/Show%.Show(wnt_args),
          Str|' args, but got ', /Core/Int/Show%.Show(got_args)]);
    });

  String@ nbody = Subst(MakeMap(argnames, command.args, Empty), body);
  Loc@ unknown = Start|'???';
  Return(Text(nbody, unknown));
};

(List@<String@>)(String@) { Invoke@; }
DefB = (List@<String@> argnames)(String@ body) {
  (Command@ command) {
    Text@ text <- Do(Define(argnames, body, command));
    Run.Block(text);
  };
};

(List@<String@>)(String@) { Invoke@; }
DefI = (List@<String@> argnames)(String@ body) {
  (Command@ command) {
    Text@ text <- Do(Define(argnames, body, command));
    Run.Inline(text);
  };
};

@(DefB, DefI);
