
@ Bool@ = /Core/Bool%.Bool@;

@ Char@ = /Core/Char%.Char@;

% Int = /Core/Int/Lit%.Int; 

<@>@ List@ = /Core/List%.List@;
<@>% Cons = /Core/List%.Cons;
<@>% Nil = /Core/List%.Nil;
<@>% List = /Core/List%.List;
<@>% Concat = /Core/List%.Concat;

<@>@ Maybe@ = /Core/Maybe%.Maybe@;

@ String@ = /Core/String%.String@;
% Str = /Core/String%.Str;
% StrE = /Core/String%.StrE;

@ Unit@ = /Core/Unit%.Unit@;
% Unit = /Core/Unit%.Unit;

@ Loc@ = /Fbld/Loc%.Loc@;

@ Markup@ = /Fbld/Markup%.Markup@;
@ Element@ = /Fbld/Markup%.Element@;

<@>@ M@ = /Fbld/Parse/M%.M@;
<@>% Return = /Fbld/Parse/M%.Return;
<@>% Error = /Fbld/Parse/M%.Error;
<@>% Do = /Fbld/Parse/M%.Do;
% Loc = /Fbld/Parse/M%.Loc;
% Get = /Fbld/Parse/M%.Get;
<@>% Try_ = /Fbld/Parse/M%.Try_;
<@>% Test = /Fbld/Parse/M%.Test;
<@>% Test_ = /Fbld/Parse/M%.Test_;
% String = /Fbld/Parse/M%.String;
<@>% Or = /Fbld/Parse/M%.Or;
% EndOfInput = /Fbld/Parse/M%.EndOfInput;
<@>% Indented = /Fbld/Parse/M%.Indented;

% Inline = /Fbld/Parse/Inline%.Inline;
% Name = /Fbld/Parse/Inline%.Name;
% InlineArgs = /Fbld/Parse/Inline%.Args;

# Parses a blank line. Fails if we aren't at a blank line.
M@<Unit@> BlankLine = {
  Loc@ l <- Do(Loc);
  /Core/Int/Eq%.Eq(Int|1, l.col).?(false: {
    Error<Unit@>(l, Str|'not a blank line');
  });
  String(StrE|'\n');
};

M@<Unit@> SkipBlankLines = {
  Bool@ blank <- Do(Try_(BlankLine));
  blank.?(true: SkipBlankLines);
  Return(Unit);
};

# Parses the rest of the args for a block command.
(Loc@, String@, List@<Markup@>) { M@<Element@>; }
Args = (Loc@ l, String@ name, List@<Markup@> args) {
  List@<Markup@> inline_args <- Do(InlineArgs);

  M@<Unit@> EndOfSameLine = Or(String(StrE|'\n'), String(StrE|' @@\n'));
  List@<Markup@> same_line <- Do({
    Bool@ none <- Do(Test_(EndOfSameLine));
    none.?(true: Return(Nil<Markup@>));

    Unit@ _ <- Do(String|' ');
    Markup@ m <- Do(Inline({
      Bool@ end <- Do(Test_(EndOfSameLine));
      end.?(true: Return(Unit));
      Loc@ l <- Do(Loc);
      Error<Unit@>(l, Str|'not end of same line');
    }));
    Return(List[m]);
  });

  Bool@ final_same_line <- Do(Try_(String(StrE|' @@\n')));
  final_same_line.?(true: {
    Markup@ arg <- Do(Block);
    Return(/Fbld/Markup%.Command(l, name)(Concat[
        args, inline_args, same_line, List[arg]]));
  });

  Unit@ _ <- Do(String(StrE|'\n'));

  List@<Markup@> next <- Do({
    Bool@ present <- Do(Try_(String|' '));
    present.?(false: Return(Nil<Markup@>));
    Markup@ m <- Do(Indented(Block));
    Return(List[m]);
  });

  Bool@ final <- Do(Try_(String(StrE|'@@\n')));
  final.?(true: {
    Markup@ arg <- Do(Block);
    Return(/Fbld/Markup%.Command(l, name)(Concat[
        args, inline_args, same_line, next, List[arg]]));
  });

  Bool@ continue <- Do(Test_(Or(String|'@ ', String|'@[')));
  continue.?(true: {
    Unit@ _ <- Do(String|'@');
    Args(l, name, Concat[
      args, inline_args, same_line, next]);
  });

  Return(/Fbld/Markup%.Command(l, name)(Concat[
      args, inline_args, same_line, next]));
},

# Parses a command starting just after the initial '@'.
M@<Element@> Command = {
  Loc@ l <- Do(Loc);
  String@ name <- Do(Name);
  name.?(nil: Error<Element@>(l, Str|'missing command name'));

  Args(l, name, Nil<Markup@>);
},

# Parses block structured text.
M@<Markup@> Block = {
  Unit@ _ <- Do(SkipBlankLines);

  Bool@ cmd <- Do(Try_(String|'@'));
  cmd.?(true: {
    Element@ command <- Do(Command);
    Markup@ tail <- Do(Block);
    Return(Cons(command, tail));
  });

  Loc@ loc <- Do(Loc);
  Maybe@<Char@> c <- Do(Test(Get));
  c.?(nothing: Return(Nil<Element@>));

  Markup@ inline <- Do(Inline(Or(EndOfInput, BlankLine)));
  Markup@ tail <- Do(Block);
  Return(Cons(/Fbld/Markup%.Command(loc, Str|'.block')[inline], tail));
};

@(Block);
