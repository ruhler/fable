Compiled Code
=============

This tutorial shows how to compile your fble programs to native machine code.

== Interpreted versus Compiled ==

The fble implementation has an internal bytecode it uses to represent an fble
program. That bytecode can be interpreted directly, or it can be compiled
native machine code.

So far in the tutorials we've always used the interpreter to run your
`Hello.fble` program.

Advantages of using the interpreter are:

* You don't have to recompile after making changes to `Hello.fble`.
* You can reuse the same main driver code with multiple different `.fble` files.

Advantages of using compiled code are:

* You can bundle the `Hello.fble` file with the main driver code. Users
  don't need to have access to `Hello.fble` or pass the right path to that
  file.
* Compiled code runs faster than interpreted code. For example, on a Raspberry
  Pi 3, at time of writing, compiled code runs about 30% faster than
  interpreted code.
* In some cases, compiled code has much better debug support than interpreted
  code.

== Fble Disassembler ==

We mentioned above that the fble implementation uses an internal bytecode for
execution. The internal bytecode is not part of the language specification and
is subject to change without notice.

For curiosity and debugging purposes only, fble provides an `fble-disassemble`
command that you can use to see a human readable representation of the
internal bytecode it generates for an fble program. For example, take a look
at the bytecode for the `Hello.fble` program we've written so far:

  fble-disassemble -I . -m /Hello%

Recall the `And4` function from `Hello.fble`:

----
(Bit4@, Bit4@) { Bit4@; } And4 = (Bit4@ a, Bit4@ b) {
  Bit4@(And(a.3, b.3), And(a.2, b.2), And(a.1, b.1), And(a.0, b.0));
};
----

Here's a snippet from the output of fble-disassemble with the bytecode for the
`And4` function:

....
/Hello%.And4![000b] args[2] statics[2] locals[6]  @ ./Hello.fble:16:3
    .  var a a0
    .  var b a1
    .  stmt;  @ ./Hello.fble:16:3
   0.  l0 = a0.0;  @ ./Hello.fble:16:15
   1.  l1 = a1.0;  @ ./Hello.fble:16:20
   2.  l2 = s1(l0, l1);  @ ./Hello.fble:16:9
   3.  release l0, l1;
   4.  l0 = a0.1;  @ ./Hello.fble:16:30
   5.  l1 = a1.1;  @ ./Hello.fble:16:35
   6.  l3 = s1(l0, l1);  @ ./Hello.fble:16:24
   7.  release l0, l1;
   8.  l0 = a0.2;  @ ./Hello.fble:16:45
   9.  l1 = a1.2;  @ ./Hello.fble:16:50
  10.  l4 = s1(l0, l1);  @ ./Hello.fble:16:39
  11.  release l0, l1;
  12.  l0 = a0.3;  @ ./Hello.fble:16:60
  13.  l1 = a1.3;  @ ./Hello.fble:16:65
  14.  l5 = s1(l0, l1);  @ ./Hello.fble:16:54
  15.  release l0, l1;
  16.  l0 = struct(l2, l3, l4, l5);
  17.  release l2, l3, l4, l5;
  18.  return l0;
....

== Compiling to C ==

The `fble-compile` program is used to generate C code or aarch64 assembly code
for an fble program. You can then using `gcc` or `as` to compile that to
native machine code.

To generate C code for `Hello.fble`, run the following command:

  fble-compile --target c --compile --export HelloModule -I . -m /Hello% > Hello.fble.c

The `--target c` option says to generate C code. The `--compile` option says
to generate compiled code for the program, and the `--export HelloModule`
option says to use the symbol name `HelloModule` for the generated code.

You can then compile this to an object file using `gcc`:

  gcc -c -o Hello.fble.o Hello.fble.c

The generated C code references the `fble/fble.h` header file. You'll need to
add a `-I` option with the path to the header files if they are installed in a
non-standard location.

We'll show how to put this together with the `hello.c` main driver program in
just a moment.

== Compiling to Aarch64 ==

The `fble-compile` program can also generate aarch64 assembly code. This is
only useful if your computer has a 64 bit ARM processor. You can check by
running `uname -m`:
  
  $ uname -m
  aarch64

If the output isn't `aarch64`, then skip ahead to the next section.

Generating aarch64 code is just like generating c, exception we change the
`--target` option:

  fble-compile --target aarch64 --compile --export HelloModule -I . -m /Hello% > Hello.fble.s

You can then compile this to an object file using `as`:

  as -o Hello.fble.o Hello.fble.s

== C versus Aarch64 ==

If you have an aarch64 processor, you should use the `--target aarch64` option
instead of `--target c` for the following reasons:

* It is much faster and less memory intensive to compile the generated aarch64
  code than it is to compile the generated c code.
* The generated aarch64 code tends to run faster than the generated C code.
* The generated aarch64 includes debug information that can be used with
  `gdb`. The same debug information is not available when using generated C
  code.

If you don't have an aarch64 processor, you'll need to use the `--target c`
option to get compiled code.

== Using the Compiled Code ==

To make use of the compiled code for `Hello.fble`, we need to make a change to
the `hello.c` main driver code to pick up the compiled code.

Recall from link:MainDriver-2.adoc[] the following snippet of code we used to
load the program:

----
int main(int argc, const char* argv[])
{
  FbleSearchPath search_path;
  FbleVectorInit(search_path);
  FbleVectorAppend(search_path, ".");

  FbleModulePath* module_path = FbleParseModulePath("/Hello%");
  if (module_path == NULL) {
    fprintf(stderr, "Failed to parse module path.\n");
    return 1;
  }

  FbleValueHeap* heap = FbleNewValueHeap();
  FbleValue* linked = FbleLinkFromSource(heap, search_path, module_path, NULL)
  FbleFreeModulePath(module_path);
  FbleVectorFree(search_path);

  ...
----

We use `FbleLinkFromCompiled` instead of `FbleLinkFromSource` to pick up the
compiled code. Change your `hello.c` driver code to the following:

----
int main(int argc, const char* argv[])
{
  FbleValueHeap* heap = FbleNewValueHeap();
  FbleValue* linked = FbleLinkFromCompiled(HelloModule, heap, NULL);

  ...
----

The first argument to `FbleLinkFromCompiled` is `HelloModule`, the symbol
we exported when generating code for `Hello.fble`.

And that's it! The rest of the `hello.c` driver code stays the same. To
compile it now:

  $ gcc -o hello hello.c Hello.fble.o -lfble 

And we can run it just like before:
  
  $ ./hello 0011 1010
  Result: 0010

== Next Steps ==

Next, head over to link:Modules.adoc[] to learn how to split up and
organize fble programs into reusable modules.

