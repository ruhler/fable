
import @ { Bit16M=Bit16; Bit@Bit; Bit1; BitNI; BoolM=Bool@StdLib; };
import Bit16M { Bit16; };

struct Bit32(Bit16 hi, Bit16 lo);

module BitN(BitNI<Bit32>) {
  import @ { Bit32; B = BitN@Bit16M; Bit1; Bit; BoolM; };
  import BoolM { Bool; And; };

  func not(Bit32 a ; Bit32) {
    Bit32(not@B(a.hi), not@B(a.lo));
  };

  func and(Bit32 a, Bit32 b; Bit32) {
    Bit32(and@B(a.hi, b.hi), and@B(a.lo, b.lo));
  };

  func or(Bit32 a, Bit32 b; Bit32) {
    Bit32(or@B(a.hi, b.hi), or@B(a.lo, b.lo));
  };

  func xor(Bit32 a, Bit32 b; Bit32) {
    Bit32(xor@B(a.hi, b.hi), xor@B(a.lo, b.lo));
  };

  func add(Bit32 a, Bit32 b; Bit32) fulladd(a, b, zero@Bit1()).z;

  func zero(; Bit32) {
    Bit32(zero@B(), zero@B());
  };

  func iszero(Bit32 a; Bool) {
     And(iszero@B(a.hi), iszero@B(a.lo));
  };

  func eq(Bit32 a, Bit32 b; Bool) {
     And(eq@B(a.hi, b.hi), eq@B(a.lo, b.lo));
  };

  func clshift(Bit32 a; Bit32) lshift(a, a.hi.hi.7).z;

  struct Result(Bit32 z, Bit cout);

  func fulladd(Bit32 a, Bit32 b, Bit cin; Result) {
    Result@B rlo = fulladd@B(a.lo, b.lo, cin);
    Result@B rhi = fulladd@B(a.hi, b.hi, rlo.cout);
    Result(Bit32(rhi.z, rlo.z), rhi.cout);
  };

  func lshift(Bit32 a, Bit cin; Result) {
    Result@B rlo = lshift@B(a.lo, cin);
    Result@B rhi = lshift@B(a.hi, rlo.cout);
    Result(Bit32(rhi.z, rlo.z), rhi.cout);
  };
};
