The Fable of Calvisus
=====================
Richard Uhler <ruhler@degralder.com>
May 2015

Introduction
------------
What is Calvisus
~~~~~~~~~~~~~~~~
Calvisus is a computer programming language from the Fable collection. It is a
simple, Turing-complete language for interactive programs built on top of a
core Turing-complete functional language for general data manipulation and
compilation tasks.

For those familiar with the Bathylus language, Calvisus extends Bathylus with
support for interactive processes.

This document defines and explains the Calvisus programming language.

Organization of this Document
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This document is intended to serve both as a guided explanation of the
Calvisus language and as a complete reference specification for the language.
It starts with a discussion of how data is represented in Calvisus, followed
by a discussion of how computation on data is described, that in turn is
followed by a discussion of how interactive processes are described. Bits and
pieces of the language syntax are described throughout the document. A
complete syntax reference is available in the appendix, with links to the
description of the corresponding terms.

A Note about Concrete Syntax
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This document defines a concrete syntax for the Calvisus language and uses
that syntax in code examples. This is not intended to suggest the concrete
syntax is a fundamental part of the language. Much more important is the
abstract syntax and the interpretation of the abstract syntax presented here.
Never-the-less, concrete syntax is invaluable for the purposes of
illustration, so a simple, C-like concrete syntax is presented here as the
Calvisus language, rather than describing the language in terms solely as
abstract syntax, or a mix of concrete and abstract syntax, which would be
confusing.

Data
----
The representation and manipulation of data is a central part of the Calvisus
language. Data in Calvisus is organized using structures and unions.
Structures represent a grouping of data items, and unions represent a choice
among data items.

A Note about Assumed Types for Illustration
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Unlike many programming language, Calvisus has no primitive data types. All
types are made up solely of structures and unions. For the purposes of
illustration, it is useful to assume some types have already been defined.
Assume int is the type of signed 32-bit integers with constructors 1(), 2(),
and so on, char is the type of characters, and bool is the type of boolean
values with constructors True() and False(). We will show later how these
types and constructors can be defined using structures and unions.

Structures
~~~~~~~~~~
A structure is a bundle (or grouping) of data values. The items of a structure
are organized into a finite number of fields. Each field has a name, used to
identify the field, and a type, specifying the type of data value for that
field.

For example, a two-dimensional Cartesian coordinate would be represented as a
structure with two fields, an 'x' component, and a 'y' component.

Declaration
^^^^^^^^^^^
Syntax:  'struct' tname '(' [tname fname [',' tname fname [...]]] ')' ';'

Assuming the 'int' type has been defined, the coordinate structure could be
defined using the following syntax:

-----------
struct Coord(int x, int y);
-----------

The Coord struct type has two fields, 'int x', and 'int y'. In general, a
struct type can have any non-negative, fixed number of fields.

A field can have any type that is defined somewhere in the program. For
example, the following shows a contrived struct type with fields of
different type:

-----------
struct Crazy(int a, bool b, bool c, char d);
-----------

A struct may contain fields of that struct type itself, or other structs that
depend on the struct type being defined in a mutually recursive way.
Recursively defined data types are used to represent data that is unbounded in
size. We will show examples of useful recursively defined data types after
unions have been introduced.

Each field of a struct type must have a different name. For example, the
following is not a legal struct type definition:

--------------
struct Foo(int x, bool x);
--------------

The order of fields is important, because it is the order that will be used
when construction values of the type.

Two struct types with different names may have the same fields.
These struct types are considered different, incompatible types.

A struct declaration is valid if the following conditions hold:
1. All field names in the struct declaration are unique.
2. The type of each field refers to a type defined in the program.

It is legal for a struct to be defined that has no fields. This is useful as
the foundation on which all other types are built and is commonly called the
'Unit' type:

--------------
struct Unit();
--------------

Construction
^^^^^^^^^^^^
Syntax:  tname '(' [value [',' value [...]]] ')'

A structure value is constructed by specifying the contents of each component
of the structure in the order in which the fields of the structure type are
declared. For example, the following syntax shows how to construct a value of
type Coord with x component 5 and y component 6:

-------
Coord(5(), 6())
-------

Construction of a structure is valid if the following conditions hold:
1. The number of arguments to the constructor must match the number of fields
declared for the structure.
2. The type of each argument must match the type of the corresponding field
declared for the structure.

The resulting value is a value of the structure type.

Field Access
~~~~~~~~~~~~
Syntax:  value '.' fname
        
The fields of a structure are accessed using the dot notation. For example,
if coord is the value of type Coord constructed with 'Coord(5(), 6())', then
'coord.x' is the value of type int representing the x coordinate (5), and
'coord.y' is the value of type int representing the y coordinate (6).

More generally, a value of a structure type followed by a '.' then a field
name, refers to the value of the field of the structure with that name.

The following is required for a field access to be valid:
1.  The field name must refer to a field declared to be part of the structure.

The resulting value is a value of the type for the field being accessed.

Unions
~~~~~~
The union type is used to describe a choice among named values of different
type.

Declaration
~~~~~~~~~~~
Syntax: 'union'  tname '(' [tname fname [',' tname fname [...]]] ')' ';'

The simplest case of a union type is an enumeration:

----------
union Fruit(Unit apple, Unit banana, Unit kiwi);
----------

A value of type 'Fruit' can be one of 'apple', 'banana', or 'kiwi'. More
generally, the choices for a data value may have non-trivial data associated
with them. A value of a union is tagged with a particular field name. For
example, consider the definition of a calculator instruction type. Perhaps the
calculator has binary operations Add and Subtract, a unary Negate operation,
and a Clear operation. The calculator instruction type could be defined as:

-------------
struct Unary(int a);
struct Binary(int a, int b);
union CalcInstr(Binary add, Binary sub, Unary negate, Unit clear);
-------------

When a value of type CalcInstr is tagged with the field 'add', the Binary
value corresponding to the 'add' field, with operands 'a' and 'b', can be
accessed. If instead the value was tagged with the field 'negate', the Unary
value with operand 'a' can be accessed, and so on.

As with structures, union types with different names are considered distinct
and incompatible.

A union declaration is valid if the following conditions hold:
1. All field names in the union declaration are unique.
2. The type of each field refers to a type defined in the program.
3. The union type must have at least one field.

Rationale for (3): If a union type has no fields, there is no way to construct
a value of that type. More importantly, a union type with no fields would lead
to an ambiguous type for conditional expressions if used as the condition,
and we would much prefer not to have ambiguous types.

Construction
~~~~~~~~~~~~
Syntax: tname ':' fname '(' value ')'

A value of a union type is constructed by providing the name of the field to
tag the union with and the value to use for that field. For example, a
value of type Fruit which is a banana is described using
'Fruit:banana(Unit())', and a calculator instruction for subtracting 2 from 6
is described using 'CalcInstr:subtract(Binary(6(), 2()))'.

The following is required for a valid union construction:
1. The union type must have a field with the given field name.
2. The type of the argument value must match the type of the named field in
the declaration of the union.

The resulting value is a value of the union type.

Field Access
~~~~~~~~~~~~
Syntax: value '.' fname

Field access can be used for unions to access fields using the same syntax as
field access for structures. The key difference is a field access is
considered illegal and produces undefined results if the union is not
tagged with that field. For example, given a calculator instruction
6_minus_2 formed with 'CalcInstr:subtract(Binary(6(), 2()))',
'6_minus_2.subtract' is a well defined value of type Binary. On the other
hand, '6_minus_2.negate' is illegal and produces undefined behavior, because
the CalcInstr value is not tagged with the 'negate' field.

As with field access for structures, the following is required for a field
access to be valid:
1. The field name must refer to a field declared to be part of the union.

At runtime, the following addition condition is required to avoid undefined
behavior:
2. The field name must match the tag on the union value.

The resulting value is a value of the type for the field being accessed.

A Note on Undefined Behavior
^^^^^^^^^^^^^^^^^^^^^^^^^^^^
An implementation may do what it likes in the case of undefined behavior. It
could return an arbitrary result and continue computing, it could halt
computation with an error message, or anything else. The user must not rely on
undefined behavior, compilers should try to warn whenever possible about
undefined behavior detected in programs, and interpreters should offer a debug
mode that explicitly halts the program and reports undefined behavior when it
occurs.

There is some concern about having undefined behavior, because of the fear
that the actual behavior of the dominant interpreter/compiler will come to be
relied on, and hence defined. We could force the user to define the behavior
explicitly, but that would clutter the code, they probably wouldn't have a
good way to define the behavior anyway, and it could hurt performance.  For
that reason, we say the behavior is undefined.

Conditional
~~~~~~~~~~~
Syntax: value '?' '(' [value [',' value [...]]] ')'

A conditional is used to select a value or other object based on the tagged
field of a union. For example, assuming instr is a value of type CalcInstr,
and that 'add', 'sub', and 'neg' are functions for performing addition,
subtraction, and negation of integers respectively, the following represents a
value of type 'int' containing the result of executing the calculator
instruction:

------------------
  instr ? (add(instr.add.a, instr.add.b),
           sub(instr.sub.a, instr.sub.b),
           neg(instr.negate.a),
           0())
------------------

In this example, 'instr' is called the condition of the conditional. What
comes after the question mark are called the arguments of the conditional.

If the tag of the union value refers to the first field in the union
declaration, the conditional takes the value of its first argument.  If the
tag of the union value refers to the second field in the union declaration,
the conditional takes the value of its second argument, and so on.

A conditional is considered valid if the following conditions hold:
1. The condition of the conditional must have a union type.
2. The number of arguments to the conditional must match the number of fields
in the union type.
3. Every argument must have the same type.

The result is an object of the same type as the arguments.

Space and Performance of Data
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
A programmer should assume the following about the space and performance of
data for a decent implementation of the Calvisus language:
* The size of a struct value is big-O of the sum of the size of the fields
  values of the struct value.
* The size of a union value is big-O of the largest field of the union value
  plus log the number of fields in the union.
* A struct value takes O(N) time in the number of fields to construct.
* A union value takes O(log(N)) time in the number of fields to construct.
* Struct and union values are cheap to copy.
* Field access is done in O(log(N)) the number of fields of the value. In
  practice this is basically constant time, because we don't expect there to
  be that many fields.
* Conditionals are done in O(log(N)) the number of fields of the value. In
  practice this basically constant time, because we don't expect there to be
  that many fields.

Value Output Syntax
~~~~~~~~~~~~~~~~~~~
This section specifies a concrete syntax for describing struct and union
values. It consists of solely constructors for struct and union values.

--------------------
dname ::= A name of a declared type.
fname ::= A field name.

value ::= dname ':' fname '(' <value> ')'
       |  dname '(' [<value> [<value> ..]] ')'
       ;
--------------------

A value is output as a stream of characters using the above syntax, with no
whitespace. This produces a unique output for a given data value, in a format
that is valid syntax for an expression of the same type as the value that
produces the value when executed.


Functions
---------
Data computation is described using functions. A function computes an output
data value given input data arguments. Functions in Calvisus are pure; they
are deterministic and without side effects. Functions add variables and
(potentially recursive) function calls to the methods already discussed for
manipulating data.

Declaration
~~~~~~~~~~~
Syntax: 'func' tname '(' [tname vname [',' tname vname [...]]] ';' tname ')' expr ';'

A function declaration defines the name, input arguments, return type, and
body of a function. For example, here is a function that computes the result
of a calculator instruction:

-----------------
func Calculate(CalcInstr instr; int) {
  instr ? (add(instr.add.a, instr.add.b),
           sub(instr.sub.a, instr.sub.b),
           neg(instr.negate.a),
           0());
};
-----------------

The input arguments and the output type are separated by a semicolon in the
argument list.

A function declaration is well formed if the following conditions hold:
1. All argument names are unique.
2. The type of each argument refers to a type defined in the program.
3. The return type of the function refers to a type defined in the program.
4. The body of the function is well formed in the environment of the arguments
and has a type that matches the return type of the function.

Variables, Scopes, and Name Spaces
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
A variable is a name for a data value. Each variable has a unique type
matching the type of the variable's data value. In the previous example,
'instr' is a variable of type 'CalcInstr' that, at the time the function is
called, will refer to a CalcInstr data value.

Variables are lexically scoped. Function arguments are visible in the
the body of the function. Variables can also be introduced by let statements,
in which case the variable defined is visible in only the body of that let
statement.

In general, names in Calvisus are interpreted according to the following name
spaces:
1. All type and function names belong to a single global namespace.
No type or function can have the same name as any other type or function.
+
2. Field names belong to a namespace associated with a specific struct or
union type. No field in a given type can have the same name as any other
field in that same type. It is fine for two different types to have fields
with the same name.
+
3. Variable names belong to a namespace associated with a specific function.
They are only visible inside the function. No variable in a function may
have the same name as another variable in that function, including input
variables. It is fine for variables in different functions to have the same
name.

Expressions
~~~~~~~~~~~
This section discusses the syntax and behavior of expressions in Calvisus.

In the typical case, given a variable scope, an expression evaluates to a data
value. Expressions are typed. A well-formed expression will always produce
a data value whose type matches the type of the expression.

More generally, an expression may also have undefined behavior or fail to
terminate. In the following description of expression behavior, we will not
distinguish between undefined behavior and failure to terminate. Instead we
will say the expression does not finish.

Variable Expression
^^^^^^^^^^^^^^^^^^^
Syntax:  vname

A variable expression evaluates to the value of the named variable in scope.

For a variable expression to be well formed, the following conditions must
hold:
1. The variable name must be the name of a variable in scope.

The type of the expression is the type of the variable.

Struct Expression
^^^^^^^^^^^^^^^^^
Syntax: tname '(' [expr [',' expr [...]]] ')'

A struct expression is used to construct struct values. First the arguments of
the struct expression are evaluated to values, then a new struct data value is
created with its fields set to the corresponding evaluated values.

The order in which the arguments are evaluated is left unspecified. The struct
expression will finish evaluating only if all its arguments finish evaluating.

For a struct expression to be well formed, the following must hold:
1. tname must refer to a struct type defined in the program.
2. The number argument expressions must match the number of fields in the
struct type.
3. Each argument must be well formed and have a type that matches the type of
the corresponding field in the struct declaration.

The type of the expression is the named struct type.

Union Expression
^^^^^^^^^^^^^^^^
Syntax: tname ':' fname '(' expr ')

A union expression is used to construct union values. First the argument of
the union expression is evaluated to a value, then a new union data value is
created tagged with the given field name and with the value set to the
evaluated value.

A union expression will finish evaluating only if its argument finishes
evaluating.

For a union expression to be well formed, the following must hold:
1. tname must refer to a union type defined in the program.
2. fname must refer to a field of that union type.
3. expr must be a well formed expression whose type matches the type of the
named field.

The type of the expression is the named union type.

Field Access Expression
^^^^^^^^^^^^^^^^^^^^^^^
Syntax: expr '.' fname

The field access expression is used to access data from a struct or union.
First the argument expression, sometimes referred to as the object of the
access, is evaluated to a value. Then the named field of the value is
accessed.

A field access expression will finish evaluating only if its object expression
finishes evaluating. If the object is of union type, the behavior is undefined
if the field being accessed does not match the tag of the union value. This is
another case in which a field access expression does not finish evaluating.

The following must hold for the field access expression to be well formed:
1. The object expression must be well formed and have some type T.
2. The field name must be a field of the Type T.

The type of the expression is the type for the named field in T.

Note that it is infeasible in general to determine statically whether a field
access for a union type may result in undefined behavior at runtime. Where
possible, it is encouraged for implementations to warn about potential
undefined behavior determined statically.

Conditional Expression
^^^^^^^^^^^^^^^^^^^^^^
Syntax: expr ? (expr [, expr [...]])

The conditional expression uses the tag of a union value to select among
possible expressions.

A conditional expression is well formed if the following hold:
1. The condition expression is of union type.
2. The number of arguments match the number of fields in the union type of the
condition argument.
3. Each argument must have the same type.

The type of the conditional expression is the same as the type of the arguments.

First the condition is evaluated to a union value. The
tag of the evaluated condition is then used to select the expression in the
argument list in the same position as the tagged field in the union type
declaration. The result of the conditional expression is then the result of
evaluating the selected expression.

The unselected arguments are not evaluated. More precisely, the behavior is
that the conditional expression finishes evaluating if both the condition and
the selected expression finish evaluating.

Application Expression
^^^^^^^^^^^^^^^^^^^^^^
Syntax: tname '(' [expr [',' expr [...]]] ')'

An application expression is used to apply a function to arguments. It has the
same syntax as struct construction, only the tname is the name of a declared
function instead of a name of a declared struct type.

An application expression is well formed if the following hold:
1. The tname must refer to a declared function.
2. The number of argument expressions must match the number of arguments in the
function declaration.
3. Each argument must be well formed and have a type that matches the type of
the corresponding argument in the function declaration.

The type of the expression is the return type listed in the function
declaration.

First the arguments of the application expression are evaluated to values. The
order in which the arguments are evaluated is left unspecified. The
application expression will finish evaluating only if all its arguments finish
evaluating.

The evaluated values become the values for the parameters in the body of the
function, which is then evaluated in its own scope. The variables visible to
the application expression are not visible when executing the function body in
its own scope.

Statement Expression
^^^^^^^^^^^^^^^^^^^^
Syntax: '{' stmt '}'

The statement expression is an artifact of the concrete syntax, to support the
let statement. The statement syntax makes it clear what the scope of a
variable is while allowing a single close brace to end the scope for multiple
variables. Implementations need not make any distinction between expressions
and statements in their internal representation of a program.

The result of a statement expression is the result of evaluating the statement.

The statement expression is well formed if the stmt is well formed and has the
same type as the stmt.

Expression Statement
^^^^^^^^^^^^^^^^^^^^
Syntax: expr ';'

The expression statement is the other half of the artifact of the concrete
syntax to support the let statement. The result of the expression statement is
the result of evaluating the expression.

The expression statement is well formed if the expr is well formed and has the
same type as the expr.

Let Statement
^^^^^^^^^^^^^
Syntax:  tname vname '=' expr ';' stmt                (* let *)

The let statement introduces a local variable whose value can be shared in the
body of another statement or expression. It is interpreted as a sequential
operation. First the expression is evaluated to a value, then the body
statement is executed in a scope where the variable is set to the value from
the expression. Evaluation of the let statement does not finish if evaluation
of the expr or body stmt do not finish.

A let statement is well formed if the following conditions hold:
1. The vname must not refer to a variable in scope.
2. The expr must be well formed with a type equal to tname.
3. The stmt must be well formed.

The type of the let statement is the same as the type of its body statement.

Process
-------
A process is a computation that may have side effects before eventuall
returning a value. Side effects are achieved by putting and getting data to
and from ports.

Get Port
~~~~~~~~
There are two kinds of ports, a 'get' port is used to read data from outside
the process. A get port, denoted with polarity '<', as in 'Foo<', can be used
repeatedly to get subsequent data of the given type -- in this case 'Foo' --
from the port. When a process gets data from a get port, it will block until
data is available on the port.

Put Port
~~~~~~~~
A process can communicate data outside of itself using a 'put' port. A put
port has polarity '>', as in 'Foo>', and can be used to repeatedly put data of
the given type onto the port. The put operation does not block.

Link
~~~~
A link is a FIFO channel with a put port and a get port that two running
processes can use to communicate. The link is unbounded in size so that
putting data into it will never block, but getting data from the link will
block as long as the link is empty. There is the potential for deadlock if all
the running processes are blocked waiting for data on get ports.

Parallel Processes
~~~~~~~~~~~~~~~~~~
Multiple processes can be executed in parallel. At any given time, a port may
only be accessed by a single process. This is enforced statically using a
conservative notion that a port is accessed by a process if the process has or
makes any reference to the port.

Ensuring only a single process has access to a port at any given time ensures
deterministic computation, assuming the external world is deterministic. The
restriction of allowing a single process access to a port at any given time
could be lifted if non-deterministic computation was desired, but for now, we
desire deterministic computation.

Fairness
~~~~~~~~
Evaluation of processes must be fair in the following sense. Any process that
is not blocked on a get of an empty port and is not non-terminating must
eventually make progress.

For example, given three processes A, B, and C...
1. If A and B are blocked on gets, but C is not, C must run.
2. If A and B interact infinitely, and C is not blocked, C must make progress.

Progress is measured by observable actions: puts, gets, and completion.

Declaration
~~~~~~~~~~~
Syntax:  'proc' tname '('
            [tname polarity pname [',' tname polarity pname [...]]] ';'
            [tname vname [',' tname vname [...]]] ';' [tname] ')' proc ';'

A process declaration defines the name, ports, input arguments, optional
return type, and body of a process.

Each port has a type and polarity. The polarity '<' is used for get ports, and
'>' is used for put ports. To remember this, consider a port with type 'Foo<'.
This is a get port because the '<' points towards the type, meaning the port
can be used to get a value of type 'Foo'. A port with type 'Foo>' takes a
value of type 'Foo', so is a put port. 

The return type of a process is optional.

Processes
~~~~~~~~~
This section discusses the syntax and behavior or processes in Calvisus.

In the typical case, given an environment of variables and ports, a process
performs zero or more put and get operations on the ports in the environment
then optionally returns a data value. Processes are typed. A well-formed
process will produce a data value whose type matches the type of the process.
Processes with no return type do not produce data values.

More generally, a process may also have undefined behavior or fail to
terminate, either from evaluation of an expression that fails to terminate,
deadlock, livelock, or because the process simply runs forever.  In the
following description of process behavior, we will not distinguish between
undefined behavior and failure to terminate.  Instead we will say the process
does not finish.

Evaluation Process
^^^^^^^^^^^^^^^^^^
Syntax:    '$' '(' expr ')'

The evaluation process evaluates an expression and returns the result without
performing any put or get operations.

The evaluation process is well formed if the expression is well formed. The
return type of the process is the type of the expression. The process will
return a result if the expression finishes evaluating.

Get Process
^^^^^^^^^^^
Syntax:   pname '(' ')'

The get process performs a get operation on the named port.

The get process is well formed if the following conditions hold:
1. named port has get polarity.

The type of the process is the type of the port. The process will return a
result if there is eventually data on the port to get, otherwise the process
will block.

Put Process
^^^^^^^^^^^
Syntax: pname '(' expr ')'

The put process performs a put operation on the named port.

The put process is well formed if the following conditions hold:
1. The named port has put polarity.
2. The expression is well formed.
3. The type of the named port matches the type of the expression.

The process has no type. The process will finish if the expression finishes
evaluating.

Conditional Process
^^^^^^^^^^^^^^^^^^^
Syntax: expr '?' ( proc [',' proc [...]] ')'

The conditional process uses the tag of a union value to select among possible
processes.

A conditional process is well formed if the following hold:
1. The condition expression is of union type.
2. The number of arguments match the number of fields in the union type of the
condition.
3. Each argument must have the same type.

The type of the conditional process is the same as the type of the arguments.

First the condition is evaluated to a union value. The tag of the evaluated
condition is then used to select the process in the argument list in the same
position as the tagged field in the union type declaration. The side effects
and result of the conditional process is then the side effects and result of
executing the selected process.

The unselected arguments are not executed.

Call Process
^^^^^^^^^^^^
Syntax:  tname '(' [pname [',' pname [...]]] ';'
                   [expr [',' expr [...]]] ')'        

A call process is used to call a process with given port and data arguments.
A call process is well formed if the following hold:
1. The tname must refer to a declared process.
2. The number and polarities of port arguments must match the number and
polarities of port arguments in the process declaration.
3. The number of argument expressions must match the number of expression
arguments in the process declaration.
4. Each argument expression must be well formed and have a type that matches
the type of the corresponding expression argument in the process declaration.

The type of the process is the return type listed in the process declaration.

First the expression arguments of the call process are evaluated to values.
The order in which the arguments are evaluated is left unspecified. The call
process will finish evaluating only if all its arguments finish evaluating.

The evaluated values become the values for the parameters in the body of the
process, and the port arguments become the values for the port parameters in
the body of the process. The ports and variables visible to the call
expression are not visible when executing the process body in its own scope.

Statement Process
~~~~~~~~~~~~~~~~~
Syntax:  '{ pstmt '}'

As with the statement expression, the statement process is an artifact of the
concrete syntax to support execution and link process statements. The
statement syntax makes it clear what the scope of a variable or port is while
allowing a single close brace to end the scope for multiple variables and
ports. Implementations need not make any distinction between processes and
process statements in their internal representation of a program.

The side effects and result of a statement process is the side effects and
result of executing the statement.

The statement process is well formed if the pstmt is well formed and has the
same type as the pstmt.

Link Process Statement
^^^^^^^^^^^^^^^^^^^^^^
Syntax: tname '<>' '(' pname ',' pname ')' ';' pstmt  (* link *)

The link process statement instantiates a link with joined put and get ports
that can be used in subsequent process statements. It adds to the port scope a
get port with the first name in parenthesis and a put port with the second
name in parenthesis. Gets to the get port will read data values that were put
to the put port, in the order they were put.
The body of the process statement is executed in a scope with the new put and
get ports.

A link process statement is well formed if the following conditions hold:
1. The tname must refer to a type declared in the program.
2. The pnames must be unique and not be the same as any variables or ports
already in scope.
3. The body must be well formed.

The type of the link statement is the type of its body statement.

Execution Process Statement
^^^^^^^^^^^^^^^^^^^^^^^^^^^
Syntax:  [exec [',' exec [...]]] ';' [pstmt]

The execution process statement is used to execute zero or more processes in
parallel, optionally followed by execution of a process in the scope that
includes results of the parallely executed processes.

The syntax for exec is:  proc | tname vname = proc.

In the first form, an exec is a process with no return type. In the second
case, the exec is a process with a return type whose result will be added to
scope under the given variable name.

An execution process statement is well formed if:
1. Each execution is well formed, meaning either it is a proc that is well
formed and has no return type, or it is tname vname = proc, the proc is well
formed with type matching tname, and the variable doesn't refer to a variable
or port in scope, and the variable name is distinct from all other variable
names declared in the execution process statement.
2. No port in scope is referred to by more than one of the executions.
3. The body of the process statement, if any, is well formed.

The execution process statement has the same type as its body statement, or no
type if it has no body statement.

To execute an execution process statement, first all processes listed are
executed in parallel, according to the fairness rules already stated in
another section and interleaved in such a way as to avoid violation of
causality.

Once every executed processes has completed, the body of the execution process
statement is executed in a scope augmented with the results of the executed
processes.

The execution process statement completes only if all the executed processes
complete and the body process completes.

Program
-------
Syntax: decl [decl [...]] ;

A program is a collection of type and function declarations. An interpreter or
compiler should have an implementation-specific mechanism for selecting the
main function or process to interpret or compile.

Syntax Reference
----------------
prog ::= decl [decl [...]] ;

decl ::= 'struct' tname '(' [tname fname [',' tname fname [...]]] ')' ';'
      |  'union' tname '(' [tname fname [',' tname fname [...]]] ')' ';'
      |  'func' tname '(' [tname vname [',' tname vname [...]]] ';' tname ')' expr ';'
      |  'proc' tname '('
            [tname polarity pname [',' tname polarity pname [...]]] ';'
            [tname vname [',' tname vname [...]]] ';' [tname] ')' proc ';'
      ;

expr ::= vname                                        (* variable *)
      |  tname '(' [expr [',' expr [...]]] ')'        (* struct *)
      |  tname ':' fname '(' expr ')'                 (* union *)
      |  expr '.' fname                               (* field access *)
      |  expr '?' '(' expr [',' expr [...]] ')'       (* conditional *)
      |  tname '(' [expr [',' expr [...]]] ')'        (* application *)
      |  '{' stmt '}'                                 (* statement *)
      ;

stmt ::= expr ';'                                     (* expression *)
      |  tname vname '=' expr ';' stmt                (* let *)
      ;

polarity ::= '<'                                      (* get *)
          |  '>'                                      (* put *)
          ;

proc ::= '$' '(' expr ')'                             (* eval *)
      |  pname '(' ')'                                (* get *)
      |  pname '(' expr ')'                           (* put *)
      |  expr '?' ( proc [',' proc [...]] ')'         (* conditional *)
      |  tname '(' [pname [',' pname [...]]] ';'      (* call *) 
                   [expr [',' expr [...]]] ')'        
      |  '{ pstmt '}'                                 (* process statment *)
      ;

exec ::= proc
      |  tname vname = proc
      ;

pstmt ::= tname '<>' '(' pname ',' pname ')' ';' pstmt  (* link *)
       |  [exec [',' exec [...]]] ';' [pstmt]           (* execution *)
       ;
   

fname ::= name    (* A name of a field *)
pname ::= name    (* A name of a port *)
tname ::= name    (* A name referring to a type or function *)
vname ::= name    (* A name referring to a value *)

Guidelines for Concrete Syntax
------------------------------
* Don't have keywords that aren't allowed to be used as variable or field names.
  Because I find it very annoying in C and Java how you can't use names like
  'class' or 'union' for variable and field names.


TODO
----
* Add a section describing how we describe syntax?
* Add a section talking about lexicography? Namely that tokens are punctuation
  or words and that whitespace is a token delimiter.
* Add a section saying we support // style comments.
* Add those examples of recursive data types I promised but haven't included
  yet.
* Show how the types bool, char, and int can be defined in the Unions
  section.
* Idea: how about this for name terminology:
  "static name" for function, union, struct, and process names.
  "variable name" for variables.
  "field name" for fields.
* Include examples with all the expression descriptions.
* Figure out and document 'process' specification.
