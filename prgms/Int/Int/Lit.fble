
@ Decimal@ = /Digits%.Decimal@;

<@,@>@ Lit@ = /Literal%.Lit@;

@ Int@ = /Int/Int%.Int@;
% 0 = /Int/Int%.0;
% 1 = /Int/Int%.1;
% 2 = /Int/Int%.2;
% 3 = /Int/Int%.3;
% 4 = /Int/Int%.4;
% 5 = /Int/Int%.5;
% 6 = /Int/Int%.6;
% 7 = /Int/Int%.7;
% 8 = /Int/Int%.8;
% 9 = /Int/Int%.9;
% 10 = /Int/Int%.10;
% Add = /Int/Int%.Add;
% Mul = /Int/Int%.Mul;

(Decimal@) { Int@; } DtoI = (Decimal@ d) { 
  d.?(0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9);
};

# A more convenient name for the decimal digits when writing integer literals.
% D = /Digits%.Decimal;

# Create an Int@ from an Int literal.
# For example: Int@ 42 = I(D|42)
(Lit@<Decimal@>) { Int@; } I = (Lit@<Decimal@> lit) {
  # Ahahaha! See if you can figure out how this works. :)
  @ MkInt@ = (Int@) { Int@; };
  lit<MkInt@>(
    (Decimal@ d, MkInt@ mk)(Int@ msb) {
      mk(Add(Mul(10, msb), DtoI(d)));
    },
    (Int@ msb) { msb; })(0);
};

@(I, D);
