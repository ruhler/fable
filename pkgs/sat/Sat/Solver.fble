
@ Bool@ = /Core/Bool%.Bool@;
% True = /Core/Bool%.True;
% False = /Core/Bool%.False;
% Not = /Core/Bool%.Not;

% Inc = /Core/Int%.Inc;
% Int = /Core/Int/Lit%.Int;

<@>@ Fifo@ = /Core/Fifo%.Fifo@;
<@>% Empty = /Core/Fifo%.Empty;
<@>% First = /Core/Fifo%.First;
<@>% Put = /Core/Fifo%.Put;
<@>% Next = /Core/Fifo%.Next;

<@>@ List@ = /Core/List%.List@;
<@>% List = /Core/List%.List;
<@>% Nil = /Core/List%.Nil;
<@>% Cons = /Core/List%.Cons;
<@>% Append = /Core/List%.Append;

<@>@ Maybe@ = /Core/Maybe%.Maybe@;
<@>% Just = /Core/Maybe%.Just;
<@>% Nothing = /Core/Maybe%.Nothing;

<<@>@>@ Monad@ = /Core/Monad%.Monad@;

<@>@ Show@ = /Core/Show%.Show@;

<<@>@>@ OStream@ = /Core/Stream%.OStream@;

@ String@ = /Core/String%.String@;
% Strs = /Core/String%.Strs;
% Str = /Core/String%.Str;

@ Unit@ = /Core/Unit%.Unit@;
% Unit = /Core/Unit%.Unit;

<<@>@>@ Debug@ = /Sat/Debug%.Debug@;

@ Id@ = /Sat/Id%.Id@;
% EqId = /Sat/Id%.EqId;

@ VarId@ = Id@;
@ ClauseId@ = Id@;

@ Var@ = *(VarId@ id, Bool@ pos);
@ Clause@ = List@<Var@>;

# Imagine two clauses:
#   (a1 + a2 + ... + v)
#   (b1 + b2 + ... + v')
#
# These conflict in the case where:
#   (a1 + a2 + ... + b1 + b2 + ...)
#
# Conflict@ describes a pair of conflicting clauses and the variable they
# conflicted on.
@ Conflict@ = *(ClauseId@ a, ClauseId@ b, VarId@ var);

# pos - the list of clauses this variable appears positive in.
# neg - the list of clauses this variable appears negative in.
@ VarS@ = *(List@<ClauseId@> pos, List@<ClauseId@> neg);

% Vars = /Sat/Id%.Map<VarS@>;
@ Vars@ = Vars.Map@;

% Clauses = /Sat/Id%.Map<Clause@>;
@ Clauses@ = Clauses.Map@; 

% Conflicts = /Sat/Id%.Map<Conflict@>;
@ Conflicts@ = Conflicts.Map@;

# Functions for working with clauses.
# TODO: Move to a separate module?
% Clause = {
  # Adds a variable to a clause, preserving the invariant that each variable
  # appears at most once in a clause.
  #
  # Returns Nothing if the clause contains both x and x' after the insertion.
  (Var@, Clause@) { Maybe@<Clause@>; } AddVar = (Var@ v, Clause@ c) {
    c.?(nil: Just(List[v]));
    Var@ head = c.cons.head;
    EqId(v.id, head.id).?(true: {
      /Core/Bool/Eq%.Eq(v.pos, head.pos).?(true: Just(c));
      Nothing<Clause@>;
    });
    Maybe@<Clause@> tail = AddVar(v, c.cons.tail);
    tail.?(nothing: Nothing<Clause@>);
    Just(Cons(head, tail.just));
  };

  # Adds a list of variables to a clause, preserving the invariant that each
  # variable appears at most once in a clause.
  #
  # Returns Nothing if the clause contains both x and x' after the insertion.
  (List@<Var@>, Clause@) { Maybe@<Clause@>; }
  AddVars = (List@<Var@> vs, Clause@ c) {
    vs.?(nil: Just(c));
    Maybe@<Clause@> mc = AddVar(vs.cons.head, c);
    mc.?(nothing: Nothing<Clause@>);
    AddVars(vs.cons.tail, mc.just);
  };

  # Removes a variable from a clause.
  (VarId@, Clause@) { Clause@; } RemoveVar = (VarId@ vid, Clause@ c) {
    /Core/List%.ForEach(c, Nil<Var@>, (Var@ v, List@<Var@> vars) {
      EqId(vid, v.id).?(true: vars);
      Cons(v, vars);
    });
  };

  @(AddVar, AddVars, RemoveVar);
};

# The reasoning behind a variable assignment.
@ Why@ = +(
  Unit@ attempt,      # This is an attempt to rule out this variable.
  Unit@ pure,         # The variable is a pure literal, so no harm setting it.
  ClauseId@ inferred  # The value was inferred from the given clause.
);

Why@ Attempt = Why@(attempt: Unit);
Why@ Pure = Why@(pure: Unit);
(ClauseId@) { Why@; } Inferred = (ClauseId@ id) { Why@(inferred: id); };

@ AssignOp@ = *(Var@ var, Why@ why);
@ RemoveClauseOp@ = *(ClauseId@ clause);

@ RemoveVarFromClauseOp@ = *(
  ClauseId@ clause,   # The clause to remove the var from.
  VarId@ var,         # The var to remove.
  Why@ why            # Why we are removing the clause.
);

@ RemoveClauseFromVarOp@ = *(ClauseId@ clause, Var@ var);

@ Op@ = +(
  AssignOp@ Assign,
  RemoveClauseOp@ RemoveClause,
  RemoveVarFromClauseOp@ RemoveVarFromClause,
  RemoveClauseFromVarOp@ RemoveClauseFromVar,
  Unit@ Unsat
);

@ Solver@ = *(
  ClauseId@ clause_id,
  Vars@ vars,
  Clauses@ clauses,
  Conflicts@ conflicts,
  List@<Var@> assigns,
  Fifo@<Op@> ops
);

Solver@ NewSolver = Solver@(
  Int|0, Vars.Empty, Clauses.Empty, Conflicts.Empty, Nil<Var@>, Empty<Op@>);

# Add a new clause with the given clause id.
(Solver@, ClauseId@, List@<Var@>) { Solver@; }
AddClauseAt = (Solver@ s, ClauseId@ id, List@<Var@> vars) {
  Maybe@<Clause@> mc = Clause.AddVars(vars, Nil<Var@>);

  # Ignore trivial clauses.
  mc.?(nothing: s);
  Clause@ clause = mc.just;

  Fifo@<Op@> nops = {
    # Check for empty clause.
    clause.?(nil: Put(Op@(Unsat: Unit), s.ops));

    # Check for unit clause.
    clause.cons.tail.?(nil: {
      Put(Op@(Assign: @(var: clause.cons.head, why: Inferred(id))), s.ops);
    });

    s.ops;
  };

  # Update Vars@ data structure.
  Vars@ nvars = /Core/List%.ForEach(clause, s.vars,
    (Var@ v, Vars@ vs) {
      Vars.InsertWith(vs, v.id, (Maybe@<VarS@> mx) {
          VarS@ x = mx.?(
            just: mx.just,
            nothing: VarS@(Nil<ClauseId@>, Nil<ClauseId@>));
          v.pos.?(
            true: VarS@(Cons(id, x.pos), x.neg),
            false: VarS@(x.pos, Cons(id, x.neg)));
        });
    });

  Clauses@ nclauses = Clauses.Insert(s.clauses, id, clause);
  Solver@(s.clause_id, nvars, nclauses, s.conflicts, s.assigns, nops);
};

# Adds a clause to the solver state for the given conflict.
(ClauseId@, Conflict@, Solver@) { Solver@; }
AddConflictClause = (ClauseId@ id, Conflict@ conflict, Solver@ s) {
  Maybe@<Clause@> ma = Clauses.Lookup(s.clauses, conflict.a);
  Clause@ a = Clause.RemoveVar(conflict.var, {
    ma.?(nothing: Nil<Var@>);
    ma.just;
  });

  Maybe@<Clause@> mb = Clauses.Lookup(s.clauses, conflict.b);
  Clause@ b = Clause.RemoveVar(conflict.var, {
    mb.?(nothing: Nil<Var@>);
    mb.just;
  });

  AddClauseAt(s, id, Append(a, b));
};

# @func[AddClause] Adds a clause to cnf state Solver@.
#  This should be done in the initial phase before starting to solve the
#  formula.
#
#  @arg[s] The cnf state to add the clause to.
#  @arg[clause] The clause to add.
#  @returns
#   An updated cnf state with clause added.
(Solver@, List@<Var@>) { Solver@; } AddClause = (Solver@ s, List@<Var@> vars) {
  ClauseId@ id = s.clause_id;
  AddClauseAt(
    Solver@(Inc(id), s.vars, s.clauses, s.conflicts, s.assigns, s.ops),
    id, vars);
};

(Solver@, List@<Clause@>) { Solver@; }
AddClauses = (Solver@ solver, List@<Clause@> clauses) {
  /Core/List%.ForEach(clauses, solver, (Clause@ c, Solver@ s) {
    AddClause(s, c);
  });
};

@ OpResult@ = +(
  Solver@ solver,     # not found to be unsat yet.
  Conflict@ conflict, # unsat due to conflict.
  Unit@ unsat         # trivially unsat.
);

@ Assignment@ = List@<Var@>;

@ SearchResult@ = +(
  Assignment@ sat,
  *(ClauseId@ clause_id, Conflicts@ conflicts) unsat
);

# Result@ --
#   The result of trying to solve a sat problem.
@ Result@ = +(Assignment@ sat, Unit@ unsat);

% Show = {
  Show@<Id@> Id = /Core/Int/Show%.Show;

  Show@<Var@> Var = (Var@ v) {
    String@ sign = v.pos.?(true: Str|'+', false: Str|'-');
    Append(sign, Id(v.id));
  };

  Show@<Clause@> Clause = /Core/List/Show%.Show(Var);

  Show@<Why@> Why = (Why@ w) {
    w.?(
      attempt: Str|'attempt',
      pure: Str|'pure',
      inferred: Strs[Str|'inferred from ', Id(w.inferred)]);
  };

  Show@<AssignOp@> Assign = (AssignOp@ op) {
    Strs[Str|'Assign ', Var(op.var), Str|' (', Why(op.why), Str|')'];
  };

  Show@<Conflict@> Conflict = (Conflict@ c) {
    Strs[Str|'Conflict ', Id(c.a), Str|', ', Id(c.b), Str|' on ', Id(c.var)];
  };

  @(Id, Var, Clause, Why, Assign, Conflict,
    Clauses: Clauses.Show(Clause));
};

@ Algo@ = +(Unit@ dpll, Unit@ cdcl);
Algo@ DPLL = Algo@(dpll: Unit);
Algo@ CDCL = Algo@(cdcl: Unit);

<<@>@ M@>(Monad@<M@>, Debug@<M@>, Algo@)(Solver@) { M@<Result@>; }
Solve = <<@>@ M@>(Monad@<M@> m, Debug@<M@> debug, Algo@ algo) {
  % O = /Core/Stream/OStream%(m);

  # @func[DoAssign] Do an assign operation.
  #  Remove VarId from Variables map. If it's there:
  #  @i Add variable assignment.
  #  @i For each + clause, add a RemoveClause operation.
  #  @i For each - clause, add a RemoveVarFromClause operation.
  (Solver@, AssignOp@) { M@<OpResult@>; } DoAssign = (Solver@ s, AssignOp@ op) {
    Unit@ _ <- m.do(debug(Int|2, (OStream@<M@> dbg) {
      O.PutLine(dbg, Show.Assign(op));
    }));

    Var@ var = op.var;
    Maybe@<VarS@> mvs = Vars.Lookup(s.vars, var.id);
    mvs.?(nothing: m.return(OpResult@(solver: s)));

    VarS@ vs = mvs.just;

    List@<ClauseId@> match = var.pos.?(true: vs.pos, false: vs.neg);
    Fifo@<Op@> match_ops = /Core/List%.ForEach(match, s.ops,
      (ClauseId@ c, Fifo@<Op@> ops) {
        Put(Op@(RemoveClause: @(clause: c)), ops);
      });

    List@<ClauseId@> unmatch = var.pos.?(true: vs.neg, false: vs.pos);
    Fifo@<Op@> unmatch_ops = /Core/List%.ForEach(unmatch, match_ops,
      (ClauseId@ c, Fifo@<Op@> ops) {
        Put(Op@(RemoveVarFromClause: @(clause: c, var: var.id, why: op.why)), ops);
      });

    m.return(OpResult@(solver: @(
        clause_id: s.clause_id, 
        vars: Vars.Delete(s.vars, var.id),
        clauses: s.clauses,
        conflicts: s.conflicts,
        assigns: Cons(var, s.assigns),
        ops: unmatch_ops)));
  };

  # @func[DoRemoveClause] Do a remove clause operation.
  #  Remove clause from clauses. If it's there:
  #  @i For each variable
  #   @i Add a RemoveClauseFromVar operation.
  (Solver@, RemoveClauseOp@) { OpResult@; }
  DoRemoveClause = (Solver@ s, RemoveClauseOp@ op) {
    ClauseId@ c = op.clause;
    Maybe@<Clause@> mcs = Clauses.Lookup(s.clauses, c);
    mcs.?(nothing: OpResult@(solver: s));

    Clause@ cs = mcs.just;
    Fifo@<Op@> nops = /Core/List%.ForEach(cs, s.ops,
      (Var@ v, Fifo@<Op@> ops) {
        Put(Op@(RemoveClauseFromVar: @(clause: c, var: v)), ops);
      });

    OpResult@(solver: @(
        clause_id: s.clause_id,
        vars: s.vars,
        clauses: Clauses.Delete(s.clauses, c),
        conflicts: s.conflicts,
        assigns: s.assigns,
        ops: nops));
  };

  # @func[DoRemoveVarFromClause] Do a remove var from clause operation.
  #  Remove the var from the clause if the clause is there.
  #  @i If clause ends up with single var, add Assign operation.
  #  @i If clause ends up with no vars, mark unsat and exit.
  (Solver@, RemoveVarFromClauseOp@) { M@<OpResult@>; }
  DoRemoveVarFromClause = (Solver@ s, RemoveVarFromClauseOp@ op) {
    ClauseId@ c = op.clause;
    Maybe@<Clause@> mcs = Clauses.Lookup(s.clauses, c);
    mcs.?(nothing: m.return(OpResult@(solver: s)));

    List@<Var@> nvars = Clause.RemoveVar(op.var, mcs.just);

    nvars.?(nil: {
      # Claim: clause conflicts only arise from inferred variables,
      # not attempted assignments nor pure literals.
      ClauseId@ w = op.why.inferred;

      Conflict@ conflict = @(a: c, b: w, var: op.var);
      Unit@ _ <- m.do(debug(Int|3, (OStream@<M@> dbg) {
         O.PutLine(dbg, Show.Conflict(conflict));
      }));
      m.return(OpResult@(conflict: conflict));
    });

    Fifo@<Op@> nops = {
      nvars.cons.tail.?(cons: s.ops);
      Put(Op@(Assign: @(var: nvars.cons.head, why: Inferred(c))), s.ops);
    };

    m.return(OpResult@(solver: @(
        clause_id: s.clause_id,
        vars: s.vars,
        clauses: Clauses.Insert(s.clauses, c, nvars),
        conflicts: s.conflicts,
        assigns: s.assigns,
        ops: nops)));
  };

  # @func[DoRemoveClauseFromVar] Do a remove clause from var operation.
  #  Remove clause from var if the var is there.
  #  @i If the var ends up with a single polarity, add an Assign operation.
  (Solver@, RemoveClauseFromVarOp@) { OpResult@; }
  DoRemoveClauseFromVar = (Solver@ s, RemoveClauseFromVarOp@ op) {
    Var@ var = op.var;
    Maybe@<VarS@> mvs = Vars.Lookup(s.vars, var.id);
    mvs.?(nothing: OpResult@(solver: s));
    VarS@ vs = mvs.just;

    List@<ClauseId@> match = var.pos.?(true: vs.pos, false: vs.neg);
    List@<ClauseId@> ncls = /Core/List%.ForEach(match, Nil<ClauseId@>,
      (ClauseId@ c, List@<ClauseId@> cls) {
        EqId(op.clause, c).?(true: cls);
        Cons(c, cls);
      });

    Fifo@<Op@> nops = {
      ncls.?(cons: s.ops);
      Put(Op@(Assign: @(var: Var@(var.id, Not(var.pos)), why: Pure)), s.ops);
    };

    VarS@ nvs = var.pos.?(
      true: @(pos: ncls, neg: vs.neg),
      false: @(pos: vs.pos, neg: ncls));

    OpResult@(solver: @(
        clause_id: s.clause_id,
        vars: Vars.Insert(s.vars, var.id, nvs),
        clauses: s.clauses,
        conflicts: s.conflicts,
        assigns: s.assigns,
        ops: nops));
  };

  # @func[DoOp] Apply an operation.
  #  @arg[Solver@][s] The formula state to process the op on.
  #  @returns[OpResult]
  #   @i conflict if the op shows the formula is unsatisfiable.
  #   @i The updated state of processing the op otherwise.
  (Op@, Solver@) { M@<OpResult@>; } DoOp = (Op@ op, Solver@ s) {
    op.?(
      Assign: DoAssign(s, op.Assign),
      RemoveClause: m.return(DoRemoveClause(s, op.RemoveClause)),
      RemoveVarFromClause: DoRemoveVarFromClause(s, op.RemoveVarFromClause),
      RemoveClauseFromVar: m.return(DoRemoveClauseFromVar(s, op.RemoveClauseFromVar)),
      Unsat: m.return(OpResult@(unsat: Unit)));
  };

  # @func[DoOps] Process ops until no more ops remain or unsat.
  (Solver@) { M@<OpResult@>; } DoOps = (Solver@ s) {
    Maybe@<Op@> mop = First(s.ops);
    mop.?(nothing: m.return(OpResult@(solver: s)));

    Solver@ ns = Solver@(s.clause_id, s.vars, s.clauses, s.conflicts, s.assigns, Next(s.ops));
    OpResult@ result <- m.do(DoOp(mop.just, ns));

    result.?(solver: DoOps(result.solver));
    m.return(result);
  };

  # Pick some a variable that exists in the given vars map.
  (Vars@) { Maybe@<VarId@>; } PickSomeVar = (Vars@ vars) {
    # TODO: Come up with a more efficient way to pick any single existing
    # variable.
    Vars.ForEach(vars, Nothing<VarId@>,
      (VarId@ v, VarS@ _, Maybe@<VarId@> mv) {
        Just(v);
      });
  };

  (Solver@) { SearchResult@; } UnsatDPLL = (Solver@ s) {
    SearchResult@(unsat: @(clause_id: s.clause_id, conflicts: s.conflicts));
  };

  # Basic DPLL based sat solver.
  (Solver@) { M@<SearchResult@>; } SearchDPLL = (Solver@ s) {
    Unit@ _ <- m.do(debug(Int|4, (OStream@<M@> dbg) {
      O.PutLine(dbg, Show.Clauses(s.clauses));
    }));

    OpResult@ ms <- m.do(DoOps(s));
    ms.?(conflict: m.return(UnsatDPLL(s)));
    ms.?(unsat: m.return(UnsatDPLL(s)));

    Solver@ s = ms.solver;

    Maybe@<VarId@> mvar = PickSomeVar(s.vars);
    mvar.?(nothing: m.return(SearchResult@(sat: s.assigns)));
    VarId@ var = mvar.just;

    Solver@ attempt = Solver@(s.clause_id, s.vars, s.clauses, s.conflicts, s.assigns,
      Put(Op@(Assign: @(var: Var@(var, True), why: Attempt)), s.ops));

    SearchResult@ attempted <- m.do(SearchDPLL(attempt));
    attempted.?(unsat: {
      Solver@ ns = Solver@(s.clause_id, s.vars, s.clauses, s.conflicts, s.assigns,
        Put(Op@(Assign: @(var: Var@(var, False), why: Attempt)), s.ops));
      SearchDPLL(ns);
    });

    m.return(attempted);
  };

  # Sat solver with conflict driven clause learning.
  (Solver@) { M@<SearchResult@>; } SearchCDCL = (Solver@ s) {
    Unit@ _ <- m.do(debug(Int|4, (OStream@<M@> dbg) {
      O.PutLine(dbg, Show.Clauses(s.clauses));
    }));

    OpResult@ ms <- m.do(DoOps(s));
    ms.?(
      conflict: {
        m.return(SearchResult@(unsat: @(
            clause_id: Inc(s.clause_id),
            conflicts: Conflicts.Insert(s.conflicts, s.clause_id, ms.conflict))));
      },
      unsat: {
        m.return(SearchResult@(unsat: @(
            clause_id: s.clause_id,
            conflicts: s.conflicts)));
      });

    Solver@ s = ms.solver;

    Maybe@<VarId@> mvar = PickSomeVar(s.vars);
    mvar.?(nothing: m.return(SearchResult@(sat: s.assigns)));
    VarId@ var = mvar.just;

    Solver@ attempt = Solver@(s.clause_id, s.vars, s.clauses, s.conflicts, s.assigns,
      Put(Op@(Assign: @(var: Var@(var, True), why: Attempt)), s.ops));

    SearchResult@ attempted <- m.do(SearchCDCL(attempt));
    attempted.?(unsat: {
      # Add conflict clauses for all conflicts encountered in our attempted
      # search
      Solver@ ns = Solver@(
        attempted.unsat.clause_id, s.vars, s.clauses,
        attempted.unsat.conflicts, s.assigns, s.ops);
      Solver@ next_attempt = /Core/Iter%.For(
        /Core/Int/Iter%.Range(s.clause_id, ns.clause_id), ns,
        (Id@ i, Solver@ s) {
          Maybe@<Conflict@> conflict = Conflicts.Lookup(ns.conflicts, i);
          AddConflictClause(i, conflict.just, s);
        });
      SearchCDCL(next_attempt);
    });

    m.return(attempted);
  };

  (Solver@) { M@<SearchResult@>; } Search = algo.?(
    dpll: SearchDPLL,
    cdcl: SearchCDCL
  );

  (Solver@ s) {
    SearchResult@ result <- m.do(Search(s));
    m.return(result.?(
      sat: Result@(sat: result.sat),
      unsat: Result@(unsat: Unit)));
  };
};

@(VarId@, Var@, Clause@,
  Solver@, Assignment@, Result@,
  Algo@, DPLL, CDCL,
  EqId, NewSolver, AddClause, AddClauses, Solve);
