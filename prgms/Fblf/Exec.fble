
@ Bool@ = /Bool%.Bool@;
% Not = /Bool%.Not;

@ Heap@ = /Fblf/Heap%.Heap@;
% Copy = /Fblf/Heap%.Copy;
% Write = /Fblf/Heap%.Write;
% Equals = /Fblf/Heap%.Equals;
% Equal = /Fblf/Heap%.Equal;

<@,@>% ForEach = /List%.ForEach;

@ Program@ = /Fblf/Program%.Program@;
@ Condition@ = /Fblf/Program%.Condition@;

# Eval --
#   Evaluate a condition.
(Condition@, Heap@) { Bool@; } Eval = (Condition@ cond, Heap@ heap) {
  Bool@ equals = cond.a.?(
    ref: cond.b.?(
      ref: Equal(heap, cond.a.ref, cond.b.ref, cond.n),
      const: Equals(heap, cond.a.ref, cond.b.const, cond.n)),
    const: cond.b.?(
      ref: Equals(heap, cond.b.ref, cond.a.const, cond.n),
      const: /Maybe%.Nothing<Bool@>.just  # TODO: Implement this case.
  ));

  cond.op.?(eq: equals, ne: Not(equals));
};

# Exec --
#   Execute a program on the given heap.
#
# Behavior is undefined if the heap is not big enough for the program.
(Program@, Heap@) { Heap@; } Exec = (Program@ prgm, Heap@ heap) {
  prgm.?(
    assign: {
      prgm.assign.value.?(
        ref: Copy(heap, prgm.assign.ref, prgm.assign.value.ref, prgm.assign.n),
        const: Write(heap, prgm.assign.ref, prgm.assign.value.const, prgm.assign.n));
    },

    sequence: {
      ForEach<Program@, Heap@>(prgm.sequence, heap, Exec);
    },

    ifelse: {
      Eval(prgm.ifelse.condition, heap).?(
        true: Exec(prgm.ifelse.if_body, heap),
        false: Exec(prgm.ifelse.else_body, heap));
    },

    while: {
      Eval(prgm.while.condition, heap).?(
        true: Exec(prgm, Exec(prgm.while.body, heap)),
        false: heap);
    });
};

@(Exec);
