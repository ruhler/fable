
% B = /Digits%.Bit;

@ Addr@ = /Fblf/Program%.Addr@;
@ Program@ = /Fblf/Program%.Program@;
@ Value@ = /Fblf/Program%.Value@;
% Assign = /Fblf/Program%.Assign;
% Eq = /Fblf/Program%.Eq;
% IfElse = /Fblf/Program%.IfElse;
% Seq = /Fblf/Program%.Seq;
% Noop = /Fblf/Program%.Noop;
% Const = /Fblf/Program%.Const;
% Ref = /Fblf/Program%.Ref;

@ Module@ = /Fblf/Module%.Module@;
% AllocM = /Fblf/Module%.AllocM;
% PureM = /Fblf/Module%.PureM;

@ Int@ = /Int/Int%.Int@;
% Add = /Int/Int%.Add;
% Sub = /Int/Int%.Sub;
% Le = /Int/Int/Eq%.Le;

% D = /Int/Int/Lit%.D;
% I = /Int/Int/Lit%.I;

% CountDownFrom = /Int/Int/Iter%.CountDownFrom;

<@,@>% For = /Iter%.For;

# Add1P --
#   A pure 1-bit adder.
#
# Inputs:
#   a - The address of the first operand.
#   b - The address of the second operand.
#   c - The address of carry bit in.
#   x - The address of the carry bit out.
#   z - The address of where to store the result of the addition.
#
# Results:
#   A program that sets x and z based on the one bit addition a + b + c.
(Addr@, Addr@, Addr@, Addr@, Addr@) { Program@; }
Add1P = (Addr@ a, Addr@ b, Addr@ c, Addr@ x, Addr@ z) {
  Int@ n1 = I(D|1);
  Value@ b0 = Const(B|0);
  Value@ b1 = Const(B|1);

  IfElse(Eq(Ref(a), b0, n1),
    IfElse(Eq(Ref(b), b0, n1),
      Seq([Assign(z, Ref(c), n1), Assign(x, b0, n1)]),
      IfElse(Eq(Ref(c), b0, n1),
        Seq([Assign(z, b1, n1), Assign(x, b0, n1)]),
        Seq([Assign(z, b0, n1), Assign(x, b1, n1)]))),
    IfElse(Eq(Ref(b), b0, n1),
      IfElse(Eq(Ref(c), b0, n1),
        Seq([Assign(z, b1, n1), Assign(x, b0, n1)]),
        Seq([Assign(z, b0, n1), Assign(x, b1, n1)])),
      Seq([Assign(z, Ref(c), n1), Assign(x, b1, n1)])));
};

# AddM -- 
#   An n-bit adder, with most significant bit first.
#
# Inputs:
#   n - The number of bits to add together.
#   a - The address of the first operand.
#   b - The address of the second operand.
#   z - The address of where to store the result of the addition.
(Int@, Addr@, Addr@, Addr@) { Module@; }
AddM = (Int@ n, Addr@ a, Addr@ b, Addr@ z) {
  # We need a single bit of internal state to store the carry bit as we do
  # the addition.
  Addr@ carry <- AllocM(I(D|1));

  Value@ b0 = Const(B|0);
  PureM(For<Int@, Program@>(CountDownFrom(n), Assign(carry, b0, I(D|1)),
    (Int@ i, Program@ s) {
      Program@ add1 = Add1P(Add(a, i), Add(b, i), carry, carry, Add(z, i));
      Seq([s, add1]); 
    }));
};

# IncP --
#   Increment an n-bit number by 1.
#
# Inputs:
#   n - The number of bits of the number to increment.
#   a - The address of the value to increment. The value is most significant
#       bit first.
(Int@, Addr@) { Program@; }
IncP = (Int@ n, Addr@ a) {
  Le(n, I(D|0)).?(
    true: Noop,
    false: {
      Int@ nm1 = Sub(n, I(D|1));
      Addr@ lsb = Add(a, nm1);
      IfElse(Eq(Ref(lsb), Const(B|0), I(D|1)),
        Assign(lsb, Const(B|1), I(D|1)),
        Seq([Assign(lsb, Const(B|0), I(D|1)), IncP(nm1, a)]));
    });
};

# IncM --
#   Increment an n-bit number by 1.
#
# Inputs:
#   n - The number of bits of the number to increment.
#   a - The address of the value to increment. The value is most significant
#       bit first.
(Int@, Addr@) { Module@; } IncM = (Int@ n, Addr@ a) {
  PureM(IncP(n, a));
};

@(AddM, IncM);
