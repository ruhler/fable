
@ App@ = /App%.App@;
@ Event@ = /App%.Event@;
@ Effect@ = /App%.Effect@;

% And = /Bool%.And;

@ Drawing@ = /Drawing%.Drawing@;
@ Color@ = /Drawing%.Color@;
@ Point@ = /Drawing%.Point@;
% Rect = /Drawing%.Rect;
% Over = /Drawing%.Over;
% Transform = /Drawing%.Transform;

@ World@ = /GameOfLife%.World@;
@ Coord@ = /GameOfLife%.Coord@;
% World = /GameOfLife%.World;
<@>% ForWorld = /GameOfLife%.ForWorld;
% Step = /GameOfLife%.Step;

@ Int@ = /Int/Int%.Int@;
% 1 = /Int/Int%.1;
% 2 = /Int/Int%.2;
% Add = /Int/Int%.Add;
% Mul = /Int/Int%.Mul;
% Dec = /Int/Int%.Dec;
% Neg = /Int/Int%.Neg;
% Sub = /Int/Int%.Sub;

% Div = /Int/Int/Div%.Div;

% IsZero = /Int/Int/Eq%.IsZero;
% Lt = /Int/Int/Eq%.Lt;

% Int = /Int/Int/Lit%.Int;

<@>% List = /List%.List;

<@>@ Get@ = /Process%.Get@;
<@>@ Put@ = /Process%.Put@;

@ Unit@ = /Unit%.Unit@;
% Unit = /Unit%.Unit;

(Int@, Int@) { Coord@; } C = (Int@ x, Int@ y) { Coord@(x, y); };

Int@ XMin = Neg(Int|50);
Int@ XMax = Int|50;
Int@ YMin = Neg(Int|50);
Int@ YMax = Int|50;
Int@ Width = Sub(XMax, XMin);
Int@ Height = Sub(YMax, YMin);

World@ acorn = World(List<Coord@>[
  C(Int|0, Int|1),

  C(Int|1, Int|3),

  C(Int|2, Int|0),
  C(Int|2, Int|1),
  C(Int|2, Int|4),
  C(Int|2, Int|5),
  C(Int|2, Int|6)
]);

(World@) { Drawing@; } DrawWorld = (World@ w) {
  Drawing@ clear = Rect(XMin, YMin, Width, Height, Color@(black: Unit));
    
  # 2. For each live cell in range, draw a green unit square.
  ForWorld<Drawing@>(w, clear, (Coord@ coord, Unit@ _, Drawing@ d) {
    Int@ r = coord.row;
    Int@ c = coord.col;
    And(And(Lt(YMin, r), Lt(XMin, c)),
        And(Lt(r, YMax), Lt(c, XMax))).?(
       true: Over(d, Rect(c, r, 1, 1, Color@(green: Unit))),
       false: d);
  });
};

@ Input@ = +(Unit@ quit, Unit@ step);

(Get@<Event@>) { Get@<Input@>; } GetInput = (Get@<Event@> in) {
  Event@ e := in;
  e.?(tick: !(Input@(step: Unit)),
      key_down: e.key_down.?(q: !(Input@(quit: Unit)), : GetInput(in)),
      key_up: GetInput(in));
};

(Get@<Input@>, Put@<Effect@>, Int@, World@) { Unit@!; }
StepUI = (Get@<Input@> in, Put@<Effect@> out, Int@ n, World@ w) {
  Unit@ _ := out(Effect@(draw: DrawWorld(w)));
  Unit@ _ := out(Effect@(tick: Int|200));
  Input@ x := in;
  x.?(quit: !(Unit),
      step: IsZero(n).?(
              true: !(Unit),
              false: StepUI(in, out, Dec(n), Step(w))));
};

App@ Main = (Int@ width, Int@ height, Get@<Event@> in, Put@<Effect@> out) {
  # Map game coordinates into screen coordinate.
  Int@ ax = Div(width, Width);
  Int@ bx = Div(width, 2);
  Int@ ay = Div(height, Height);
  Int@ by = Div(height, 2);

  (Point@) { Point@; } f = (Point@ p) {
    @(x: Add(Mul(ax, p.x), bx), 
      y: Add(Mul(ay, p.y), by));
  };

  Put@<Effect@> game_out = (Effect@ e) {
    Effect@ transformed = e.?(
      tick: e,
      draw: Effect@(draw: Transform(f, e.draw)));

    # Note: we don't just use out(transformed) here because of a bug in
    # profiling tail calls of PUT values.
    Unit@ _ := out(transformed);
    !(Unit);
  };

  Unit@ _ := StepUI(GetInput(in), game_out, Int|200, acorn);

  Unit@! WaitForKeyPress = {
    Event@ e := in;
    e.?(tick: WaitForKeyPress, key_down: !(Unit), key_up: WaitForKeyPress);
  };
  WaitForKeyPress;
};

Main;
