
@ State@ = /Games/BenchmarkGame/PiDigits%.State@;
@ StreamResult@ = /Games/BenchmarkGame/PiDigits%.StreamResult@;
% Stream = /Games/BenchmarkGame/PiDigits%.Stream;
% Initial = /Games/BenchmarkGame/PiDigits%.Initial;

@ Bool@ = /Core/Bool%.Bool@;
% True = /Core/Bool%.True;

% Chars = /Core/Char%.Chars;

@ Int@ = /Core/Int%.Int@;
% Inc = /Core/Int%.Inc;
% Div = /Core/Int/Div%.Div;
% Eq = /Core/Int/Eq%.Eq;
% Int = /Core/Int/Lit%.Int;

<@>@ List@ = /Core/List%.List@;

<<@>@>@ Monad@ = /Core/Monad%.Monad@;

<<@>@>@ Stdio@ = /Core/Stdio%.Stdio@;
<<@>@>@ Main@ = /Core/Stdio%.Main@;

@ String@ = /Core/String%.String@;

@ Unit@ = /Core/Unit%.Unit@;
% Unit = /Core/Unit%.Unit;

# Output the digits of pi, one digit output for each input string, starting
# from state 's'.
Main@ Main = <<@>@ M@>(Monad@<M@> m, Stdio@<M@> stdio, List@<String@> args) {
  Int@ n = /Core/Int/Show%.Read(args.cons.head);
  Int@ l = Int|10;
  (Int@, State@) { M@<Bool@>; } PiDigits = (Int@ i, State@ s) {
    Eq(i, n).?(true: m.return(True));

    StreamResult@ r = Stream(s);
    Unit@ _ <- m.do(stdio.out(/Core/Int/Show%.Show(r.output)));

    Int@ ni = Inc(i);
    Unit@ _ <- m.do(Eq(Int|0, Div(ni, l).r).?(true: {
      Unit@ _ <- m.do(stdio.out[Chars.tab, Chars.':']);
      Unit@ _ <- m.do(stdio.out(/Core/Int/Show%.Show(ni)));
      stdio.out[Chars.nl];
    }, false: m.return(Unit)));

    PiDigits(ni, r.state);
  };

  PiDigits(Int|0, Initial);
};

/Core/IO/Stdio%.IOStdio(Main);
