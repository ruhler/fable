mdefn UBNat( ; ; UBNat()) {
  using Unit() { Unit; };
  using Bool() { Bool; True; False; };

  union Nat(
    Unit 0,
    Unit 1,
    Nat 2p0,  # 2 * x + 0, where x != 0
    Nat 2p1   # 2 * x + 1, where x != 0
  );

  # Compute 2 * x.
  # This is like Nat:2p0(x), but properly handles the case when x is 0.
  func 2p0(Nat x; Nat) {
    Nat z = Nat:2p0(x);
    ?(x; 0(), z, z, z);
  };

  # Compute 2 * x + 1.
  # This is like Nat:2p1(x), but properly handles the case when x is 0.
  func 2p1(Nat x; Nat) {
    Nat z = Nat:2p1(x);
    ?(x; 1(), z, z, z);
  };

  # Compute 4 * x.
  func 4p0(Nat x; Nat) {
    Nat z = Nat:2p0(Nat:2p0(x));
    ?(x; 0(), z, z, z);
  };

  func 0( ; Nat) Nat:0(Unit());
  func 1( ; Nat) Nat:1(Unit());
  func 2( ; Nat) Nat:2p0(1());
  func 3( ; Nat) Nat:2p1(1());
  func 4( ; Nat) Nat:2p0(2());
  func 5( ; Nat) Nat:2p1(2());
  func 6( ; Nat) Nat:2p0(3());
  func 7( ; Nat) Nat:2p1(3());
  func 8( ; Nat) Nat:2p0(4());
  func 9( ; Nat) Nat:2p1(4());
  func 10( ; Nat) Nat:2p0(5());
  func 100( ; Nat) Mul(10(), 10());

  func Lit2(Nat a, Nat b; Nat) Add(Mul(10(), a), b);
  func Lit3(Nat a, Nat b, Nat c; Nat) Add(Mul(100(), a), Lit2(b, c));

  func Inc(Nat a; Nat) {
    ?(a; 1(), 2(), Nat:2p1(a.2p0), Nat:2p0(Inc(a.2p1))); 
  };

  func Dec(Nat a; Nat) {
    ?(a; 0(),                     # 0 - 1 ==> 0
         0(),                     # 1 - 1 = 0
         2p1(Dec(a.2p0)),         # 2a - 1 = 2(a-1)+1
         Nat:2p0(a.2p1));         # 2a+1 - 1 = 2a
  };

  func Add(Nat a, Nat b; Nat) {
    ?(a; b,
         Inc(b),
         ?(b; a,
              Nat:2p1(a.2p0),
              Nat:2p0(Add(a.2p0, b.2p0)),        # 2a + 2b = 2(a+b)
              Nat:2p1(Add(a.2p0, b.2p1))),       # 2a + 2b+1 = 2(a+b)+1
         ?(b; a, 
              Nat:2p0(Inc(a.2p1)),               # 2a+1 + 1 = 2(a+1)
              Nat:2p1(Add(a.2p1, b.2p0)),        # 2a+1 + 2b = 2(a+b)+1
              Nat:2p0(Inc(Add(a.2p1, b.2p1))))); # 2a+1 + 2b+1 = 2(a+b+1)
  };

  func Sub(Nat a, Nat b; Nat) {             
    ?(b; a,                                   # a - 0 = a
         Dec(a),                              # a - 1 = a - 1
         ?(a; 0(),                            # 0 - 2b ==> 0
              0(),                            # 1 - 2b ==> 0
              2p0(Sub(a.2p0, b.2p0)),         # 2a - 2b = 2(a-b)
              2p1(Sub(a.2p1, b.2p0))),        # 2a+1 - 2b = 2(a-b) + 1
         ?(a; 0(),                            # 0 - (2b+1) ==> 0
              0(),                            # 1 - (2b+1) ==> 0
              Dec(2p0(Sub(a.2p0, b.2p1))),    # 2a - (2b+1) = 2(a-b) - 1
              2p0(Sub(a.2p1, b.2p1))));       # 2a+1 - (2b+1) = 2(a-b)
  };

  func Mul(Nat a, Nat b; Nat) {              
    ?(a; 0(),                                   # 0 * b = 0
         b,                                     # 1 * b = b
         ?(b; 0(),                              # 2a * 0 = 0
              a,                                # 2a * 1 = 2a
              4p0(Mul(a.2p0, b.2p0)),           # 2a * 2b = 4ab
              Add(4p0(Mul(a.2p0, b.2p1)), a)),  # 2a * (2b+1) = 4ab + 2a
         ?(b; 0(),                              # (2a+1) * 0 = 0
              a,                                # (2a+1) * 1 = 2a+1
              Add(4p0(Mul(a.2p1, b.2p0)), b),   # (2a+1) * 2b = 4ab + 2b
                                                # (2a+1) * (2b+1) = 2(2ab + a + b) + 1
              Nat:2p1(Add(Nat:2p0(Mul(a.2p1, b.2p1)), Add(a.2p1, b.2p1)))));
                  
  };

  struct DivModResult(Nat quotient, Nat remainder);
  func Div(Nat a, Nat b; Nat) DivMod(a, b).quotient;
  func Mod(Nat a, Nat b; Nat) DivMod(a, b).remainder;

  func DivMod(Nat a, Nat b; DivModResult) {
    ?(b; DivModResult(0(), 0()),    
         DivModResult(a, 0()),
         DivModAux(a, b),
         DivModAux(a, b));
  };

  # DivMod assuming b > 1
  func DivModAux(Nat a, Nat b; DivModResult) {
    ?(a; DivModResult(0(), 0()),
         DivModResult(0(), 1()),
         { 
            DivModResult qr = DivModAux(a.2p0, b);
            Nat 2r = 2p0(qr.remainder);
            ?(Lt(2r, b);
                DivModResult(2p0(qr.quotient), 2r),
                DivModResult(2p1(qr.quotient), Sub(2r, b)));
         },
         {
            DivModResult qr = DivModAux(a.2p1, b);
            Nat 2rp1 = Inc(2p0(qr.remainder));
            ?(Lt(2rp1, b);
                DivModResult(2p0(qr.quotient), 2rp1),
                DivModResult(2p1(qr.quotient), Sub(2rp1, b)));
         });
  };

  func IsZero(Nat a; Bool) {
    ?(a; True(), False(), False(), False());
  };

  func Eq(Nat a, Nat b; Bool) {
    ?(a;
       ?(b; True(), False(), False(), False()),
       ?(b; False(), True(), False(), False()),
       ?(b; False(), False(), Eq(a.2p0, b.2p0), False()),
       ?(b; False(), False(), False(), Eq(a.2p1, b.2p1)));
  };

  func Ne(Nat a, Nat b; Bool) {
    ?(a;
       ?(b; False(), True(), True(), True()),
       ?(b; True(), False(), True(), True()),
       ?(b; True(), True(), Ne(a.2p0, b.2p0), True()),
       ?(b; True(), True(), True(), Ne(a.2p1, b.2p1)));
  };

  func Lt(Nat a, Nat b; Bool) {
    ?(a;
       ?(b; False(), True(), True(), True()),
       ?(b; False(), False(), True(), True()),
       ?(b; False(), False(), Lt(a.2p0, b.2p0), Le(a.2p0, b.2p1)),
       ?(b; False(), False(), Lt(a.2p1, b.2p0), Lt(a.2p1, b.2p1)));
  };

  func Le(Nat a, Nat b; Bool) {
    ?(a;
       ?(b; True(), True(), True(), True()),
       ?(b; False(), True(), True(), True()),
       ?(b; False(), False(), Le(a.2p0, b.2p0), Le(a.2p0, b.2p1)),
       ?(b; False(), False(), Lt(a.2p1, b.2p0), Le(a.2p1, b.2p1)));
  };

  func Gt(Nat a, Nat b; Bool) {
    ?(a; False(),
       ?(b; True(), False(), False(), False()),
       ?(b; True(), True(), Gt(a.2p0, b.2p0), Gt(a.2p0, b.2p1)),
       ?(b; True(), True(), Ge(a.2p1, b.2p0), Gt(a.2p1, b.2p1)));
  };

  func Ge(Nat a, Nat b; Bool) {
    ?(a;
       ?(b; True(), False(), False(), False()),
       ?(b; True(), True(), False(), False()),
       ?(b; True(), True(), Ge(a.2p0, b.2p0), Gt(a.2p0, b.2p1)),
       ?(b; True(), True(), Ge(a.2p1, b.2p0), Ge(a.2p1, b.2p1)));
  };
};
