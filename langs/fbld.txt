Damocrates is a meta-language built on top of Androcles, Bathylus, and Calvisus
designed to be programmed by human, with features for modularity and
development.

Damocrates should be statically compilable into Androcles/Bathylus/Calvisus.
Abstractions introduced by the Damocrates language should be zero-cost in the
sense that they will have no overhead at runtime after compiling the program
down to Androcles/Bathylus/Calvisus. The developer should not have to make a
tradeoff between modularity/abstraction and runtime performance.

Features:
* Modules: see fbld.modules.txt
* Polymorphism: see below 

Polymorphism
============
Goal: Avoid writing multiple copies of effectively the same code.

Solution:
Types can be parameterized by types.
Functions can be parameterized by types and functions.
Processes can be parameterized by types, functions, and processes.

Example:
  Type declaration: union Maybe<type T>(Unit Nothing, T Just);
  Type constructor: Maybe<Bool>:Just(Bool:True(Unit()))
  Function declaration: func isJust<type T>(Maybe<T> x; Bool) ...
  Function use: isJust<Int>(x)
  Function declaration and use:
    func mapMaybe<type A, type B; func F(A;B)>(Maybe<A> x; Maybe<B>) ...
    mapMaybe<Int, Bool; IsNegative>(x)

Other Needs
===========
* A way to make a list of tests without requiring the number of parenthesis
  to be linear in the number of tests in the list.
    

