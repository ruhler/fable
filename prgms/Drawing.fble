{ /Unit%; @(Unit@, Unit); };
{ /Int/Int%; @(Int@, Add, Sub); };
{ /Int/Int/Eq%; @(Min, Abs); };

@ Color@ = +(
    Unit@ black,
    Unit@ red,
    Unit@ green,
    Unit@ yellow,
    Unit@ blue,
    Unit@ magenta,
    Unit@ cyan,
    Unit@ white
    );

@ Drawing@ = +(
  # A blank (transparent) drawing.
  Unit@ blank,
  
  # A filled rectangle.
  *(Int@ x, Int@ y, Int@ w, Int@ h, Color@ color) rect,

  # Draw one drawing over another.
  *(Drawing@ below, Drawing@ above) over
);

Drawing@ Blank = Drawing@(blank: Unit);

# Draw a rectangle filled solid with the given color.
(Int@, Int@, Int@, Int@, Color@) { Drawing@; }
Rect = (Int@ x, Int@ y, Int@ w, Int@ h, Color@ color) {
  Drawing@(rect: @(x, y, w, h, color));
};

# Compose two drawings together by drawing one over another.
(Drawing@, Drawing@) { Drawing@; } Over = (Drawing@ below, Drawing@ above) {
  Drawing@(over: @(below, above));
};

# Transform all of the coordinates in the given drawing.
@ Point@ = *(Int@ x, Int@ y);
((Point@) { Point@; }, Drawing@) { Drawing@; }
Transform = ((Point@) { Point@; } f, Drawing@ d) {
  ?(d; blank: d,
       rect: {
         # TODO: Fix the representation of Rect so we don't have to do this
         # hackish stuff.
         d.rect;
         Point@ xy = f(@(x: x, y: y));
         Point@ wh = f(@(x: Add(x, w), y: Add(y, h)));
         Int@ nx = Min(xy.x, wh.x);
         Int@ ny = Min(xy.y, wh.y);
         Int@ nw = Abs(Sub(wh.x, xy.x));
         Int@ nh = Abs(Sub(wh.y, xy.y));
         Rect(nx, ny, nw, nh, color);
       },
       over: {
         d.over;
         Over(Transform(f, below), Transform(f, above));
       });
};

@(Color@, Drawing@, Point@, Blank, Rect, Over, Transform);
