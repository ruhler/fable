Fble Docs
=========
In the process of writing tutorials and trying to generate man pages, the
question has come up of whether we should use markdown or asciidoc. Let's
discuss.

Markdown is fairly standard and reasonable enough to use. But it doesn't
consistently support advanced features I would want for real documentation or
anything more basic than headings, links, and lists. I want things like
includes and definition lists.

I would love a tool that can check the syntax of my docs. And also be able to
convert to man pages in a fairly standard way.

I feel like asciidoc is more likely to have well defined syntax, advanced
features for more complicated docs, and conversion to man pages.

The potential downsides of asciidoc:
* Another dependency to add to the project. Though it could be set up as a
dist dependency rather than a build or run dependency.
* Potentially less appealing syntax? Need to double check.
* Less standard, for example, integration with github readme.

Where I'm thinking about using docs:
* Project README - how does it show up on github?
* Tutorials - how easy to connect tutorials together?
* Book - booklike stuff wanted.
* Program help text to convert to man pages.
* Library function doc comments to convert to man pages.

I would like to check the syntax of asciidoc too:
* Support for '##' style headers instead of '~~~~~~~'?
== Title ==, === Title === looks like is what we would use.
Not consistent with markdown.
* Support for definition lists?
Yes. For example:
x:: ...

See /usr/share/doc/asciidoc/userguide.html for asciidoc docs.

In general, it's pretty clear that asciidoc will not be compatible with
markdown.

Apparently github does support asciidoc? Yes. I just need to use '.adoc',
           '.ad', or .asciidoc extension.

           I don't see an obvious syntax checker for asciidoc yet, but maybe we could
           enable warnings and give an error if there is a warning generating some
           format for asciidoc.

           My vote: let's give asciidoc a shot. I know how I feel about markdown. It's
           been a while since I tried asciidoc.

           To start:
           * Update README, tutorials
           - Add build commands to call asciidoc or asciidoctor as seems best for
           syntax checks.
           * Consider generating man pages for --help via asciidoc fragments instead of
           using help2man.

           Oh, I guess one question is how a doc comment would look as an asciidoc.

           // Foo --
           // Inputs::
           // * ...
           // Side effects::
           // * ...
           // Returns::

           I think it works via definition list just fine. Cool. Is it worth changing the
           header too?

           // = Foo =
           // Inputs::
           // * ...
           // Side effects::
           // * ...
           // Returns::

           That's just as easy to parse as // Foo --. I think it looks fine.

           ---

           Initial reactions after converting README.md to README.adoc:
           * asciidoc does give an error in some cases.
           * Reading the asciidoc.txt sample file, it's not quite as easy for me to read
           in ascii format as I would have liked.
           * I don't like having 'XXXXXXXXXXXXXXXXXXXXXXXXXXXX' delimiters for things.
           Seems like arbitrary length lines are asked for. Just use 4 chars to start?
           * It's nice having definition lists. I like that.

           ---

           I wonder if I can write help usage for programs directly in asciidoc, and
           import the rendered text to use in --help. Wouldn't that be nicer? Then we
           could read it separately, include in a bigger manual, generate man pages, all
           that from the raw source documentation?

           Trouble is, manpage input format has special requirements different from help
           text and generic asciidoc description.

           Also, trying to generate text output from asciidoc is a pain. And I don't like
           the generated output style at the moment (lots of horizontal rules for no
               apparent reason?).

           Ugh. I'm going to be honest. I feel like really all I want is:
           * title, section headers, paragraphs, unordered lists, ordered lists,
           definition lists, code blocks, inline code blocks, comments, callouts (todo,
               warning, note, etc.), references to other docs, links.

           Markdown and asciidoc are both so close, but not quite there?
           * markdown is missing definition lists, callouts, references to other docs?
           * asciidoc is missing... none of these? But it doesn't do nested indenting
           well. Like, definition lists can't be indented, right? No, it looks like you
           can indent them.

           ---

           The real problem is, I don't have enough control over how things are
           generated, because I don't have my own programmatic representation of a
           document. Imagine I could parse a document and represent it abstractly. Then I
           could easily generate whatever I want in terms of man pages and checking
           proper document format.

           But, guess what? I have a programming language that I could use for this. Why
           not write a doc package in fble? Generating man pages is not going to be
           difficult.

           How things could work:
           * fble program to parse header files and generate man pages.
           * fble program to parse help text and generate man pages.
           - I don't think we want to generate help text from an fble program, because
           that gives us an annoying bootstrapping problem.

           But that still leaves open the question: what syntax do we use? Do we keep
           README as a markdown format? What syntax do we use for tutorials, markdown?
           Asciidoc?

           I'll tell you the syntax I like: markdown plus definition lists. I guess
           technically we could use asciidoc for that, because I think asciidoc,
           technically, supports the '## ...' style section titles (though vim doesn't
               syntax highlight that).

           My documentation needs are not complex. If I want to go for a standard
           approach, asciidoc is better because it supports everything I could want in a
           more standard way than markdown. For man pages, I really would prefer to
           generate them myself.

           So, here is what I propose: Use a strict, small, subset of asciidoc. Write an
           fble program that can parse that subset of asciidoc. Use it for the following:
           * To extract doc comments on header files and generate man pages.
           * To extract help text on main program and generate man pages.
           * To syntax check my README file and tutorials.

           How about if I don't want to write my own program? If I don't want to be
           restricted to a subset of asciidoc?
           * README file and tutorials can be fullblown asciidoc.
           * Write code to extract general description and convert to custom format man
           page for library code. As in, everything in the doc comment goes to the
           description section of the man page. Ignore RETURN VALUE section of man
           page. Write my own wrapper around the asciidoc.
           * Continue to use help2man for commands? Or write them in such a way that I
           can extract asciidoc directly?
           - The hard part is separating synopsys and options? Honestly, I don't really
           want asciidoc syntax in the output of --help.

           Perhaps another option is to write my own asciidoc backend to generate text
           to use as input to --help and for man pages? That's an idea worth exploring I
           think.

           So, here's where we stand at the moment:
           * Continue to push ahead with asciidoc approach, but explore more advanced
           options. Don't give up on asciidoc yet.

           Proposal:
           * README and tutorials in asciidoc.
           * --help text for commands generated automatically from fble-foo.adoc file
           using a custom asciidoc backend.
           * man page for commands generated automatically from fble-foo.adoc file using
           another custom asciidoc backend.
           * Use tcl to extract header file doc info and generate man pages from them via
           asciidoc using another custom asciidoc backend.


           Let's start by seeing if we can generate useful --help from an asciidoc file.

           Features to look for:
           * attribute to define brief format for man page.
           * attribute to define synopsys/usage text.

           Ug. It's just hard. Asciidoc is so complicated. I really am tempted to just
           write my own. It can't possibly be that hard to parse basic formatting, can
           it?

           ---

           Before going down that route, let's just double check if there isn't some
           other standard document format that meets my requirements.

           creole - no definition lists
           github flavored markdown - no definition lists
           mediawiki - no definition lists
           reStructuredText - no definition lists, overly verbose.

           No, I don't see any that I like. Best bet, I feel like, is to use a subset of
           asciidoc, call it asciidoc, but implement my own parser for the subset.
           Hopefully that gets me the best of most worlds:
           * Standard doc format that can be read by things like github and vim syntax
           highlighting.
           * Full control over generated output.
           * Can implement my own checker.
           * No need to have asciidoc installed.

           With the plus of having another fble program to try to write.

           Let's be honest about what this really means:
           * For doc comments and --help text, use a subset of asciidoc.
           * For everything else, may as well use full asciidoc.

           Because I only need to generate man pages from doc comments and --help
           text.

           ---

           Every time I try to do asciidoc, it feels like a slog. I'm playing around with
           labelled lists using fairly commonly accepted syntax of:

           label
           : definition
           label
           : definition

           It's actually not so bad.

           Oh, and I should remember I probably want the language spec to be turned into
           a doc with whatever format I choose.

           I'm not sure if github supports definition lists in its markdown.

           Options:
           * markdown with definition lists
           - custom parser and man page generator for a subset?
           - or use pandoc or some such for generating man pages.
           * asciidoc 
           - custom parser and man page generator for a subset?

           ---

           Screw it. Let's me have some fun and do my own doc format from scratch. It can
           be whatever I want: as similar or different from markdown or asciidoc. No
           worry about standards or anything like that. How would I do it?

           We have a lot of docs existing to work with. Let's start with adding minimal
           features needed for those. Starting with README:

  * Title (or section 0?)
* Sections (each with a title)
  * Paragraphs
  * Definition list.
  * Verbatim blocks.
  * Inline verbatim.

  Start with those.

  The syntax I'm thinking about:
  * section syntax, paragraphs, verbatim blocks, inline verbatim from markdown.
  Ish.
  * definition list is:  '@ <label>: <definition>'.

  Let's see how that might look.

  What extension should I use for my doc format? .txt perhaps? .fbld, short for
  fbledoc? Let's stick with .txt for now. README.txt looks okay to me for now.
  It would look even better with syntax highlighting.

  Anyway, more important than the concrete syntax is the abstract syntax.

  First question: is everything in a section, or can there be things not in a
  section? Explicit sections have titles. If you had something in an implicit
  section, would it be a section without a title?

  Once you start a section, the only way out is to start a new section or end
  the document. We don't have explicit section end markers. That, to me,
  suggests a section has a title, optional (non subsection) content, followed by
  a list of subsections.

  Then it makes sense for a whole doc to be a top level section. The title of
  the top level section is the title of the doc?

  Question: what's the difference between the 'root' section, and a top level
  section? For example, if we use:

# Foo
  ...

  To give the title of the doc, what if you say:

# Foo
  ...

# Bar
  ...

  Then we don't have a document title, but rather two level 1 subsections in the
  document. Options:
  * Don't allow level 1 section anywhere in doc except at the beginning.
  * Use a separate syntax to describe the title of the doc.

  I'm leaning towards using separate syntax for the document title.

  Historically I've used:

  Title
  =====
  Author

  Anyway, that's back to a concrete syntax issue. Sounds like sections are clear
  to me.

  Section:
  (title :: String)
  (content :: Maybe Content)
(subsections :: [Section])

  Where a top level document is of type Section.

  Question: Can we use inline formatting in titles? I don't think I personally
  tend to do that in practice. Let's simplify and say no for now. We can add
  that back later.

  What is content?

  Content is a list of (non-section) blocks.

  Content: (blocks :: [Block])

  Block: ParagraphBlock | CodeBlock | DefinitionListBlock
  ParagraphBlock: (spans :: [Span])
  CodeBlock: (text :: String)
  DefinitionListBlock: [(label :: String, content :: Content)]

  Span: TextSpan | CodeSpan
  TextSpan: (text :: String)
  CodeSpan: (text :: String)

  Note, in particular, the body of a labelled list element is Content, which
  could be multiple paragraphs. At minimum it is at least a single paragraph.
  I'm not sure if that's right, but it's a good place to start. It's only wrong
  if we have reason to distinguish between a paragraph and a list of spans. I
  don't see a reason to.

  Cool. We have a draft spec for documents. Shall I codify it? Then we can dig
  into the nitty gritty of the concrete syntax.

  Section:
  * '#' in left column, number of consecutive '#' is section level. Whitespace 
  after last '#'. Everything following the whitespace to the end of the line
  is the name of the title.
  * Let's say line before and after have to be blank lines. So blank lines form
  a kind of delimiter here.
  * Content is everything that follows up until the next section that's not at a
  subsection level from this one.

  Document title brainstorm:

  Foo
  ===

# Foo

  % Foo

  Honestly, I like the first one from a human reader point of view. It gives
  weight enough to make it look like a title, and leaves room for metadata
  beneath it. I think better to be entirely separate from section syntax, even
  though the whole doc is meant to be one big section.

  Okay, so, ignore any initial blank lines in the document.
  The first non-blank line should be followed by a line of '===...' of same
  length as previous line? Let's say it's an error not to include a title? Or
  should the title be optional? Can the title be empty?

  Food Thought
  ====

  Food
  =========

  I don't like having to match the number of '=' to the length of the title. I
  don't like it being mismatched. Anything better we could do instead?

  = Foo =
  Richard Uhler <...>

  Actually, I think a single '=' sign beneath looks okay.

  Foo
  =
  Richard Uhler <...>


  Okay, let's say title is first non-blank line, and it must be followed by a
  line consisting of one or more consecutive '=' signs, of any number.

  To have an empty tile? A section title could be empty by just not providing
  one. How about same here: empty title by having the line of '=' be the first
  thing.

  What about no title at all? Like, no '=' at all? I don't like it. I want it to
  be required.

  Okay, so, start of document is:
  <blank lines>
  non-blank line followed by '==' line
  or '==' line

  And content starts after a blank line, then beyond.

  That's sections for you. Next is blocks, which could be at some indent level,
  because we may want nested lists. We keep track of a current indent level and
  read blocks relative to that.

  Skip blank lines. Interesting question: can we always use blank lines for
  delimiters? Is there ever a time we don't want to do that? I'm thinking of a
  code block with blank lines in it. If we treat blank line as delimiter, that
  would mean we have multiple code blocks back to back rather than a single code
  block.

  I certainly have code blocks in question with blank lines in them. Potentially
  multiple blank lines. Imagine we want to highlight a code block a different
  color. I think we need to consider code blocks with blank lines inside them
  all as one code block. Don't get rid of the blank line. Especially if there
  are multiple.

  How about start and end of a code block? Strip blank lines? Then, is it not
  possible to have an initial blank line?

  How about this: code blocks are always indented. That's the concrete syntax
  for them. So, if you want to continue the code block, continue the indent.

  So, a single code block:

  ....@ Unit@ = *();
  ....@ Bit@ = +(Unit@ 0, Unit@ 1);
  ....@ Bit4@ = *(Bit@ 3, Bit@ 2, Bit@ 1, Bit@ 0);
  ....
  ....Unit@ Unit = Unit@();
  ....
  ....Bit@ 0 = Bit@(0: Unit);
  ....Bit@ 1 = Bit@(1: Unit);

  And three adjacent code blocks:

  ....@ Unit@ = *();
  ....@ Bit@ = +(Unit@ 0, Unit@ 1);
  ....@ Bit4@ = *(Bit@ 3, Bit@ 2, Bit@ 1, Bit@ 0);

  ....Unit@ Unit = Unit@();

  ....Bit@ 0 = Bit@(0: Unit);
  ....Bit@ 1 = Bit@(1: Unit);

  From a viewer's perspective, they look the same. No harm. The hardest part
  will be writing them and remembering to indent if you want it to be a single
  block.

  This way you can do blank lines before and after the same way. I like that.

  And this way, we can treat blank lines as delimiters of content.

  In terms of blocks, taking into account the indent level to know how much of
  the stack of current elements to close:
  * '# ' starts a new section.
  * '* ' is a list element.
  * '@ ' denotes a labeled list element.
  * '  ' or other indent is a code block.
  * Anything else is a paragraph. Hopefully you don't want to start a paragraph
  with '#', '*', or '@'. If you do, uh... We should have a paragraph symbol
  you can use to escape those? Or, just escape with a '\' character? But what
  if we want, for example, bold to start the paragraph, versus '*' to start
  the paragraph? Maybe have '$ ' or '^ ' be an optional paragraph marker for
  those special cases? Or '*' versus \*? No, I like '$ ' or '^ ' for an
  explicit paragraph, as opposed to an implicit paragraph. Then *foo* could
  still be a bolded thing at the front a paragraph, and \* foo could be a
  literal '*' character at the start of a paragraph.

  * this is a list item
  $ *this* is a bolded first word of a paragraph.
  $ \*\*\* is three asterisks at the start of a paragraph.
  $ *\** is a bold asterisk at the start of a paragraph.

  ---

  An important challenge is going to be allowing special characters to show up
  as regular characters in paragraphs. Here is what I propose:
  * A blank line is required after a paragraph before you consider anything a
  special character. Blank line between paragraph and section, list, etc.
  * Option, or maybe always have it be, so the first line clearly denotes a
  paragraph.

  For example, maybe paragraphs always have a single space to start? Is that
  sufficient? So we don't have to worry about what may be a special character,
  and we can add all sorts of new special characters later on like, 1, 2, 3, a,
  b, c, A, B, C, i, I, etc.

  I don't know. Single space to start each paragraph feels weird to me. Too
  subtle perhaps. Awkward with single line paragraphs. Maybe for now stick with
  the idea of '$' optional to start? Or, think about it more.

  Maybe a better approach would be to make special characters more special. They
  don't show up too often. Not as much as paragraphs. For example, maybe '@' is
  in front of every special character, and we just need to escape @@?

  @## Section
  @* list item 1
  @* list item 2
  @* nested list item
  @. X: labeled.

  Who puts '@' in a paragraph anyway?

  No. I think go with what we had before. No special '@' character. Take our
  changes with having to know what to escape. Allow '$' as an explicit paragraph
  marker to support those escapes.

  ---

  Next topic of discussion: whitespace and the vagaries thereof.

  Is it okay to align, for example, definition lists? I'm pretty sure I would
  want to. For example:

  -I DIR::                     add DIR to the module search path
  -m, --module MODULE_PATH::   the path of the module to compile

  The definitions are left aligned. That means there is an arbitrary amount of
  space between the label and the definition.

  According to our abstract syntax, the definition is <Content>. Content can be
  a code block, and a code block is denoted by using indent. If we support
  arbitrary whitespace between label and definition, how could we possibly code
  block content for that definition?

  Options:
  * Don't allow arbitrary whitespace. Always use a single space.
  * Use '> ...' as an indicator for code block instead of indent.
  * Have some sort of invisible hack, for example, where we put the verbatim
  text on the next line.

  That also begs the question: for definition lists:
  * What is the indent level set to for subsequent lines.
  * How to put the definition on a separate line?

  For example:
  @ foo: this is a really long example text in
  a short window
  @ bar: here is a another example that is
  slightly different
  @ sludge:
  here is a definition on a different line.
  @ also:             left aligned definition
  that wraps back to the beginning.
  @ and also:         left aligned definition
  that wraps back to the 
  alignment

  More examples:
  @ -I DIR:                     add DIR to the module search path
  @ -m, --module MODULE_PATH:   the path of the module to compile

  @ -I DIR: add DIR to the module search path
  @ -m, --module MODULE_PATH: the path of the module to compile

  @ -I DIR:
  add DIR to the module search path
  @ -m, --module MODULE_PATH:
  the path of the module to compile

  @ bin/:
  Source code for fble compiler binaries.
  @ book/:
  Drafts for a book about the design of the fble language.
  @ include/:
  Public header files for the fble library.
  @ lib/:
  Source code for an fble interpreter and compiler implemented in C.
  @ pkgs/:
  Sample fble library and application packages.
  @ spec/:
  Specification of the fble language, including spec tests.
  @ test/:
  Source code for fble test binaries and other test utilities.
  @ thoughts/:
  A collection of running discussions about fble.
  @ tutorials/:
  Tutorials for getting started with fble.

  Okay. That's actually growing on me. In this case, we require the label to be
  on its own line. The content starts at 2 space indent on the next line. The
  above examples are worst case examples where you might want compact definition
  lists. They aren't so bad. They are all aligned. And now, in theory, we could
  have a code block:

  @ foo:
  code block is here

  Question: do we need the colon at all now?

  @ -I DIR
  add DIR to the module search path
  @ -m, --module MODULE_PATH
  the path of the module to compile


  @ test/
  Source code for fble test binaries and other test utilities.
  @ thoughts/
  A collection of running discussions about fble.
  @ tutorials/
  Tutorials for getting started with fble.

  I feel like no, we don't.

  ---

  Next topic: how many spaces to indent?
  * always 2 spaces?
  * let the user decide?

  It's related to the above discussion. If it's not a fixed number of spaces,
  then code blocks aren't obvious to start when entering a new indent level.

  I personally would always decide 2 spaces. This is for me. Let's just require
  2 space indent everywhere.

  ---

  Idea: let's call this format fbld. Recycle the name. Where 'd' stands for doc.
  You could imagine having 'fblt' for my 'test' format.

  ---

  Question: how do you have two back-to-back lists? For example:

  * l1.1
  * l1.2

  * l2.1
  * l2.2

  Is that one list or two? Now, consider instead:

  * l1.1

  * l1.2

  * l2.1

  * l2.2

  That's clearly one list. How about:

  * l1.1

  * l1.2


  * l2.1

  * l2.2

  How about:

  * l1.1

  * l1.2 

  which in this case is a multi-line list item.

  Which makes it much harder to keep track of the end.

  * l2.1

  * l2.2

  Actually, it's not too hard. If we want to support multiple lists back to
  back, put two blank lines before the list element instead of a single blank
  line. This suggests we can't coalesce blank lines together into generic
  delimiters, because we want to allow blank lines between list items, but also,
  in this case, between lists.

  Whitespace means so much in this language. I guess that's not surprising,
  given the goal is to have something structured and uncluttered. So we use
  whitespace for the structure without having it clutter things up.

  ---

  Anyway, I think we have enough worked out to get going. I think it could be
  easier to write the spec after first writing an implementation. This spec
  sounds hard to me to write, given the effect of whitespace, indent, and
  context on the meaning of the syntax.

  Things to do:
  * Draft fbld.txt spec.
  * Start pkgs/fbld with definition of Doc@ types.
  * Implement printer for Doc@.
  - Do it right, so we can use this to see if there are any kinds of documents
  you can't express in the concrete syntax.
  * Implement parser for Doc@.
  * Write a vim syntax file.

  Summary of decisions so I don't forget:
  * title\n=== for title, where any number of '=' characters allowed.
  * '#' for section
  * '*' for unordered list
  * '@ <label>\n  <content>' for definition list.
  * '$' optionally for paragraph
  * paragraph requires blank line to end.
  * 2 space indent for code block
  * 2 space indent for continuation.
  * 2 blank lines splits lists in two.
  * `...` for code inline

  Future work:
  * *...* for bold inline? italic inline? mixed bold/italic?
  * Numbered lists.
  * link to other file.
  * 'include' other file (with some handling of section levels).

  ---

  Interesting side note: github renders markdown files nicely, and asciidoc
  files. It would be nice if links between files worked for that. Presumably
  using my own markup language will not work with github.

  Looks like links in theory would be: [display](tutorials/Tutorials.md). So
  that would be, uh, [tutorials/Tutorials.md](tutorials/Tutorials.md)? Could I
  just do (tutorials/Tutorials.md) instead? In asciidoc, you can do
  link:tutorial/Tutorials.md[]. Maybe markdown can do
  [](tutorials/Tutorials.md)? Apparently not.

  In that case, maybe I want to use asciidoc primarily while in the progress of
  switching to my own format? Now because it has definition lists and more
  convenient local reference links.

  ---

  Let me give asciidoc another chance. It seems to be okay for tutorials,
  readme. Can we use it reasonably for man pages is the question. I think it's
  worth having the same discussion again that we had before, in case anything
  different comes out of it.

  First commands:
  * Writing the man page in asciidoc creates a reasonable description to read. I
  have no complaints with, for example, bin/fble-compile.adoc.
  * The generated man page is not great, but it's serviceable.
  - Examples don't render very well.
  - No bold/italics in synopsis.
  - But aside from minor things like that, it's fine.
  - I guess this is because I haven't manually done the markup. I can add
  that.
  * Any way to get --help text from this?
  - The default generated text is not nearly concise enough. Table of
  contents, lots of blank lines, lots of -------------- lines.

  The question, then, is how can I change the style of the output? Maybe now's a
  good time to read the documentation for asciidoc in detail, with an eye for
  how to do my own output formatting.

  Notes from reading asciidoc docs:
  * Learn about DocBook.
  * In theory I can change the input language by changing config files.
  * DocBook is XML. XSLT is a style sheet. Looks like we could provide custom
  XSLT and CSS stylesheets.
  * See manpage.xsl for the manpage style sheet.
  * There is something called themes, which changes .css and .js for generated
  html?
  * It's possible to annotate a section with a template name, which appears to
  get processed in a template-specific way in the backend. For example:
  'bibliography' section.
  * We can automatically set the template for a section based on its title using
  [specialsections] part of an asciidoc .conf file. But this use is not
  recommended. They say it is deprecated.
  * Looks like the .conf file contains templates for generating documents.

  Okay, so how does the text backend work when invoking a2x? Does asciidoc
  generate docbook via docbook backend, and then use xslt to turn that into
  text? Or does it go straight asciidoc to text?

  It goes:
  foo.adoc =(asciidoc)=> foo.xml =(xsltproc)=> foo.text.html =(w3m)=> foo.text

  In this case, a lot of the junk is brought in by xsltproc.

  So, we have options. We could try to add special config file to go straight to
  text from foo.adoc. Or we could try to improve xsltproc.

  How do man pages work right now? It generates a different foo.xml file that is
  a refentry format instead of article format. Then uses xsltproc with a manpage
  xslt sytlesheet to generate the man page.

  Let's first understand the asciidoc conf files and how the .xml file is
  generated. For man pages:

  /etc/asciidoc/asciidoc.conf
  - defines input language format.

  /etc/asciidoc/docbook45.conf
  - generates the xml tags using templates.

  Then a bunch of mostly irrelevant filters:
  /etc/asciidoc/filters/graphviz/graphviz-filter.conf
  /etc/asciidoc/filters/source/source-highlight-filter.conf
  /etc/asciidoc/filters/music/music-filter.conf
  /etc/asciidoc/filters/latex/latex-filter.conf
  /etc/asciidoc/filters/code/code-filter.conf

  /etc/asciidoc/lang-en.conf
  English language stuff.

  Can I try doing my own configuration files to start? Or, are there any other
  configuration files available I could use instead? No. But I bet I could write
  my own.

  How about we start here then? How would I turn my man-page structured
  fble-compile.adoc file into help-text suitable output?

  * <NAME> section
  * Add 'Usage:' in front of synopsys section text, same line.
  * Render description in as-is formatted text, limited to 80 cols.
  Maybe go through roff or something to do the formatting for me?
  * Change sect2 titles to '<Title>'
  * Change sect3 titles to '<Title>:'

  It's all the same info. I think it's reasonable to try and generate help text
  from the man page asciidoc input.

  Shall I try?

  Looks like I could use:
  asciidoc -v -e -f /etc/asciidoc/asciidoc.conf -f ruhler.conf fble-compile.adoc

  To try and pass my own custom .conf file. I'm not sure how to use my own
  backend otherwise.

  ---

  Working through how to make a config file that would translate
  fble-compile.adoc to a reasonable usage help text:
  * How to add Usage: as special case for SYNOPSIS section?
  * How to get rid of &#8230; for '...' in synopsis?
  * How to add blank lines between paragraphs in the description?
  * How to get list item numbers?
  - {listindex} is the attribute (found by reading /usr/bin/asciidoc).
  * How to put first list line on the same line as list index?
  - I don't think I can.
  * Indent options. How to put definition on same line?
  * How to show 'EXIT STATUS', 'EXAMPLE' titles as special case for those
  sections?
  - Or maybe remove NAME, SYNOPSYS, DESCRIPTION, OPTIONs as special cases?
  * Remove footer text. DONE.

  The generated output from asciidoc includes raw text from the input file. That
  means I can't do direct processing on that text, like stripping newlines,
  reflowing to fit column width, etc. Things like aligning list definitions will
  be hard. This suggests I'll want to pass the output through some post
  processor that can do wrapping and alignment for me.

  Two post-processors come to mind:
  1. Whatever is used for man pages. roff?
  2. xsltproc.

  Perhaps it's worth learning about xsltproc first.

  Okay, I guess let's read about xslt:
  * Ugh. It's a template language in xml syntax. I'm not convinced it will be
  sufficient to address the problem I'm having. That is, I don't think it will
  provide layout functionality. If it doesn't, then there is no value using it
  instead of using asciidoc for that part.

  Why is this so hard? Why can't we just have a data structure that I can write
  python code to generate output from, for example? I could probably write a raw
  xml backend to asciidoc, and then use xml libraries in python to generate
  output.

  Maybe now is a good time to step back and ask what I'm trying to accomplish in
  this case anyway. I want to have a single source of truth for the
  documentation of an fble binary program that can be reused in the man page and
  --help text. I've said asciidoc is nice to use to describe the single source
  of truth, because it has the structure elements for lists, sections, etc. In
  that case, however, we would require asciidoc to generate the executable. Is
  that really what I want? Like, is this worth the complexity and overhead? Just
  duplicate the usage info. It's not that much.

  I could, of course, go the other direction, like I have now. Custom structured
  usage text that I generate asciidoc and/or man pages from. It's limited
  because I want to use the compact text form as the source of truth, which
  makes it hard to extract structure.

  There are a few cruxes here:
  * How to capture structure in compact text?
  - For if I want --help to be source of truth.
  - For library function doc comments.
  * How to avoid bootstrap problem for fble binaries
  - To minimize dependencies needed to build them.
  - To have them not depend on themselves.
  * How to minimize dependencies on external tools.
  - Like help2man, asciidoc, xsltproc, etc.
  * How to take advantage of github / other standard processing of docs?

  If it weren't for github showing asciidoc and markdown nicely, it makes sense
  to have a custom format:
  * --help text and doc comments are source of truth.
  * So no issue with bootstrapping.
  * No extra dependencies.
  * Full control over generated code.
  * A fun example to add to fble.

  The downsides being:
  * Github doesn't render things in a pretty fashion.
  * Readers won't be able to google to understand the syntax of documentation.
  * It could be a fair amount of work to define my own markup language.

  Perhaps fble binaries are a bad place to start, because they don't really need
  clear text source of truth. But library doc comments do need a clear text
  source of truth, because they are comments in code.

  // # FbleNewStructValue
  //
  // Create a new struct value with given arguments.
  //
  // @ Inputs
  //   @ heap
  //     The heap to allocate the value on.
  //   @ argc
  //     The number of fields in the struct value.
  //   @ args
  //     'argc' `FbleValue` arguments to the struct value. Args are borrowed,
  //     and may be `NULL`.
  //
  // @ Results
  //   A newly allocated struct value with given args.
  //
  // @ Side effects
  //   * The returned struct value must be freed using FbleReleaseValue when no
  //     longer in use.

  That's a little less compact than I want though. I would prefer:

  // FbleNewStructValue --
  //
  // Create a new struct value with given arguments.
  //
  // Inputs:
  //   heap - The heap to allocate the value on.
  //   argc - The number of fields in the struct value.
  //   args - 'argc' `FbleValue` arguments to the struct value. Args are borrowed,
  //          and may be `NULL`.
  //
  // Results:
  //   A newly allocated struct value with given args.
  //
  // Side effects:
  // * The returned struct value must be freed using FbleReleaseValue when no
  //   longer in use.

  That is, the '@ ' of a definition list shifts things two characters to the
  right, and the newline shifts things down an extra line.

  Compare to doxygen:

  /**
   * \brief Create a new struct value with given arguments.
   *
   * \param heap  The heap to allocate the value on.
   * \param argc  The number of fields in the struct value.
   * \param args  'argc' `FbleValue` arguments to the struct value.
   *              Args are borrowed, and may be `NULL`.
   *
   * \return A newly allocated struct value with given args.
   *
   * @ Side effects
   *   * The returned struct value must be freed using FbleReleaseValue when no
   *     longer in use.
   */

  Which is slightly more compact, because it doesn't use extra lines for
  'Inputs', 'Results', and 'Side effects' sections or the title of the function.

  Maybe I come up with my own doc comment format?

  Why not use doxygen:
  * It doesn't generate output the way I want.
  * No tag for side effects.
  * Doesn't have title of function at top of comment.
  * \brief seems not useful to me.
  * I don't like /** ... */ to denote doc comment? Though I guess I don't care
  that much. This could be a decent way to denote what is a doc comment versus
  general code comment.

  I might prefer something like:

  /**
   * FbleNewStructValue
   * 
   * Create a new struct value with given arguments.
   *
   * \param heap  The heap to allocate the value on.
   * \param argc  The number of fields in the struct value.
   * \param args  'argc' `FbleValue` arguments to the struct value.
   *              Args are borrowed, and may be `NULL`.
   *
   * \return A newly allocated struct value with given args.
   *
   * \effect The returned struct value must be freed using FbleReleaseValue when
   *         no longer in use.
   * \effect Some other effect, just for example purposes.
   */

  Asciidoc would give us:

  // FbleNewStructValue
  // ------------------
  // Create a new struct value with given arguments.
  //
  // Inputs::
  //   heap:: The heap to allocate the value on.
  //   argc:: The number of fields in the struct value.
  //   args:: 'argc' `FbleValue` arguments to the struct value.
  //     Args are borrowed and may be `NULL`.
  //
  // Results::
  //   A newly allocated struct value with given args.
  //
  // Side effects::
  //   * The returned struct value must be freed using FbleReleaseValue when no
  //     longer in use.

  That's pretty compact.

  ---

  Let me take a break from this to start working on what needs to be done
  regardless: extract the doc comments from the header files. I'm thinking in
  tcl.

  Can we get everything with some regex? My goal would be: given a header file,
  extract all the doc comments into a list.

  ---

  I'm going to take a detour and try the doxygen route. I'll get back to you on
  how well that works out.

  ---

  Here's where we are currently at with documentation:

  * binaries:
  - help usage as plain text in program.
  - man pages via help2text or asciidoc. Need to make a decision.
  * library functions:
  - doxygen in source code.
  - man pages via doxygen. Need to set up install.
  * tutorials, readme, spec, etc.
  - asciidoc.

  And general thoughts:
  * asciidoc takes a long time to convert spec to html, and syntax highlighting
  in vim doesn't work at all. Yet another case of asciidoc "ugh".
  * It would be great to have easy programmatic access to the structure of these
  docs, because then I could generate whatever I want from them.
  * If I'm doing my own doc format, maybe don't rely on indentation for meaning?
  Because vim syntax highlighting sounds hard in that case. And if it's hard
  for vim, it's hard for anyone.

  What if I take a break by implementing a markdown library in fble? It's been
  too long since I've written fble code. Anything I write I could later adapt to
  support a custom format if I want, or asciidoc, or some subset of
  markdown/asciidoc, and get more control over generated manpages, etc. Not
  necessarily for practical purposes, but for example purposes?

  Start with commonmark, which is best standardized. But what do you do with it?
  Parse it? Convert it to something? Convert it to a man page?

  ---

  Let the spiral continue.

  Imagine I wanted to invent my own doc format. What are the goals and use
  cases?

  * vim syntax highlighting that works.
  - e.g. metadata colored differently, section titles highlighted, definition
  terms. Just a little bit to add color here and there.
  * Be able to write code to generate whatever outputs I want based on document
  structure.
  * Be able to clearly specify structure document.
  * Be able to capture all the structure I care about it my own documents.
  - e.g. definition lists, links, etc.
  * Support for document-specific custom structure
  - e.g. sideeffects, synopsis, concrete/abstract/example.
  * Support for generating man pages, latex, html.
  - man pages for distribution. latex and html as option to share more
  formally.
  * Content can be understood easily from reading document source.
  * Focus on structure only, not on presentation.
  * Easy to parse structure by computer or by human.
  * Would be nice if we could have a linter/error checker to detect errors in
  syntax.
  * Would be nice if things like github could auto-display the formatted
  version, but I assume that won't happen for anything custom I do.
  * Nice concrete syntax to write (whatever that means).

  As we've said before, we can separate into two parts: abstract syntax and
  concrete syntax. The abstract syntax will be whatever is important to me. I
  can look at my existing docs to get an idea.

  What's wrong with existing formats?
  * Markdown
  - Lacks structure I care about, like definition lists (though I could pick
      one of the extended formats that does have definition lists).
  - I don't have my own parser for it (though I could write one).
  - Structure not entirely obvious from reading. Just look at how complicated
  the specs are.
  * asciidoc
  - vim syntax highlighting doesn't work.
  - I don't have a parser for it.
  - Structure is not clear from text, in my opinion.
  * xml
  - I don't have a parser for it. But would be easy to write.
  - I would have to come up with a schema definition.
  - Having <p> around all paragraphs too annoying to write?
  This suggests a new requirement?
  * plain text
  - No syntax highlighting.
  - I don't have a parser for it. Structure is not clear from the text.
  * tcl
  - Braces and substitution within braces is awkward.

  Markdown and asciidoc specify the abstract and concrete syntax. xml/tcl don't
  specify an abstract syntax, which means I could make them work just fine with
  whatever abstract syntax I choose. That suggests I really do care about the
  concrete syntax. It might be nice if I can separate abstract syntax and
  concrete syntax, so that you could reuse the concrete syntax for other
  kinds of structures. But then, why not just use xml?

  It's way too verbose. Just compare:

  <dl>
  <dt>bin</dt>
  <dd>Source code for fble compiler binaries.</dd>
  <dt>book</dt>
  <dd>Drafts for a book about the design of the fble language.</dd>
  <dt>include</dt>
  <dd>Public header files for the fble library.</dd>
  <dt>lib</dt>
  <dd>Source code for an fble interpreter and compiler implemented in C.</dd>
  </dl>

  versus:

  bin/:: Source code for fble compiler binaries.
  book/:: Drafts for a book about the design of the fble language.
  include/:: Public header files for the fble library.
  lib/:: Source code for an fble interpreter and compiler implemented in C.

  Particularly with syntax highlighting on the later. It's too much tags. It
  really gets in the way of reading the document and seeing the content of the
  text.

  I'm thinking instead something like:

  [def] bin/:     Source code for fble compiler binaries.
  [def] book/:    Drafts for a book about the design of the fble language.
  [def] include/: Public header files for the fble library.
  [def] lib/:     Source code for an fble interpreter and compiler implemented in C.

  So, we still give an initial tag. But there is some built in structure to say
  a list definition item is the item followed by the content. And maybe,
  somehow, it knows to use ':' as the separator?

  That's the biggest challenge here. How to clearly separate arguments to a
  structure without becoming overly cumbersome? Specify the terminator as part
  of the command?

  [def /] bin/     Source code for fble compiler binaries.
  [def /] book/    Drafts for a book about the design of the fble language.
  [def /] include/ Public header files for the fble library.
  [def /] lib/     Source code for an fble interpreter and compiler implemented in C.

  [def :] bin/:     Source code for fble compiler binaries.
  [def :] book/:    Drafts for a book about the design of the fble language.
  [def :] include/: Public header files for the fble library.
  [def :] lib/:     Source code for an fble interpreter and compiler implemented in C.

  [def  ] bin/      Source code for fble compiler binaries.
  [def  ] book/     Drafts for a book about the design of the fble language.
  [def  ] include/  Public header files for the fble library.
  [def  ] lib/      Source code for an fble interpreter and compiler implemented in C.

  [def \n] bin/
  Source code for fble compiler binaries.
  [def \n] book/
  Drafts for a book about the design of the fble language.
  [def \n] include/
  Public header files for the fble library.
  [def \n] lib/
  Source code for an fble interpreter and compiler implemented in C.

  The last one is stretching it. That's a bit hard to read.

  [def] bin/     ' Source code for fble compiler binaries.
  [def] book/    ' Drafts for a book about the design of the fble language.
  [def] include/ ' Public header files for the fble library.
  [def] lib/     ' Source code for an fble interpreter and compiler implemented in C.

  [def]{bin/}     Source code for fble compiler binaries.
  [def]{book/}    Drafts for a book about the design of the fble language.
  [def]{include/} Public header files for the fble library.
  [def]{lib/}     Source code for an fble interpreter and compiler implemented in C.

  @def' bin/'     Source code for fble compiler binaries.
  @def' book/'    Drafts for a book about the design of the fble language.
  @def' include/' Public header files for the fble library.
  @def' lib/'     Source code for an fble interpreter and compiler implemented in C.

  @def "bin/"     Source code for fble compiler binaries.
  @def "book/"    Drafts for a book about the design of the fble language.
  @def "include/" Public header files for the fble library.
  @def "lib/"     Source code for an fble interpreter and compiler implemented in C.

  @def 'bin/'     Source code for fble compiler binaries.
  @def 'book/'    Drafts for a book about the design of the fble language.
  @def 'include/' Public header files for the fble library.
  @def 'lib/'     Source code for an fble interpreter and compiler implemented in C.

  Some thoughts when playing around with things:
  * Blank lines, new lines, spaces are all natural boundaries for things.
  * @foo[text] is decent for inline items. Unclear if we can naturally nest
  things like that.

  @def bin/     @= Source code for fble compiler binaries.
  @def book/    @= Drafts for a book about the design of the fble language.
  @def include/ @= Public header files for the fble library.
  @def lib/     @= Source code for an fble interpreter and compiler implemented in C.

  @def[bin]     Source code for fble compiler binaries.
  @def[book]    Drafts for a book about the design of the fble language.
  @def[include] Public header files for the fble library.
  @def[lib]     Source code for an fble interpreter and compiler implemented in C.

  Think about it more.

  ---

  Random idea: what if I use tcl for fble binary usage help? Specify the
  structure explicitly via tcl, and generate text to use for the help usage and
  for the man page directly from that? That way I can directly encode exactly
  the structure I'm interested in, right?

  * Paragraphs split across lines are annoying.

  ---

  Okay, here's my proposal for a structure-agnostic syntax for marking up text,
  that's hopefully reasonable to read.

  A document is a sequence of commands.

  A command has syntax:
  @tag[arg1][arg2]... lastarg

  Where lastarg is treated specially as follows:
  * If the @tag is not at column 0, there is no last arg. The command ends at
  the first non-'[' character. This is used for inline tags. For example:
  @emph[this text is emphasized] and the following is not.
  * If the @tag is at column 0 and the first non-'[' character is on the same
  line as the last ']', the last arg goes until the end of the same line.
  * If the @tag is at column 0 and the first non-'[' character is on the line
  after the last ']', the last arg goes until the next blank line.

  With escape characters:
 @@ for '@'
 @[ for '['
 @] for ']'

And the syntax for a tag is [a-zA-Z0-9_]+ 

That's it. The entire concrete syntax. You add all your own structure on top
of that.

In terms of evaluation: commands are called with the raw values of their
arguments, whitespace included. The commands have the option to parse those
arguments as further arguments, where tags have local meaning.

Let me write up some examples to see how good or bad it looks. And probably
worth drafting a vim syntax file while I'm at it.

Some thoughts:
* Would be nice to have a way to explicitly disable long arg for inline tags
  that happen to line up on the left column. For now, put a space in front?
  Otherwise... brainstorm something. Maybe @tag[][]@ to end the long arg? That
  is, an '@' character on the same line? I don't know. Maybe use "@" at the
  end of the previous line to prevent it from triggering.
* Note, tags that take no arguments need to be followed by a blank line. Once
  again, it feels like it would be nice to have an explicit terminator command
  for tags. In case you want something more compact.

Okay, let's pick a decent syntax to terminate a command early. This takes
effect when a long argument is expected. If you see '@', it means there is no
long argument.

Another thought: it's unclear when something should be an argument or a
separate command. For example, I assume 'section' is a command to start a
section. Subsequent commands add to whatever the most recent section is. Same
for a list? If so, then maybe we want an @endlist command to say end the
current list? Or should the list take the list elements as arguments?

@list
@li First item.
@li Second item.
@li Third item.

@list[
@li
First item.

@li
Second item.

@li
Third item.
]

@list@
@li
First item.

@li
Second item.

@li
Third item.
@endlist@

In the case of a list, I prefer the list items be passed as the single
argument to the list. What about the case of a section?

Honestly, I think I would prefer section to take its contents as a single
argument. Can we come up with a nicer syntax for this? The square bracket
feels a little clunky.

@section My Favorite Section.
@{

@}

The idea is, @{ ... @} is a compound long argument.

But we can already use [ ... ] for that. Why do I prefer @{ ... @}? Maybe
allow them to be used interchangeably?

The idea is @{ would happen on the start of the next line.

So, could we do something like: @foo @{ first arg. @}, equivalent to
@foo[first arg.]@? Sure. Let's say yes. [ and @{ are both options. They need
to be equally matched, so [ is matched with ], and @{ is matched with @}.

But then, @[ as an escape is a little unintuitive. Maybe \@, \[, \] \\ are
better escape characters. Yeah, I think so.

That begs the question:

@foo
[ argument ]
[ argument ]

That should be allowed right? You can put a bracket on the next line. The
syntax is kind of nice too, so let's say yes. A bracket argument is allowed to
start on the next line where a long argument would start.

Summary of syntax:
  '@' tag [arg...]['@']
* \\, \@, \[, \] are escapes.
* Long argument parsing as discussed above.

Style guidelines: use args as much as possible, rather than, for example
@startsection, @endsection like commands.

Note, something like:

@foo
@bar
@sludge a.
@sludge b.

How is that parsed?

@bar is the start of the long argument for @foo.
@sludge is the start of the long argument for @bar.
Next @sludge continues the long argument for @bar.
Then we hit the newline. That ends the long argument for @bar. Does it also
end the long argument for @foo? I think it should.

I tried this out on fble-compile help text. I'm pretty happy with how the doc
looks. It's pretty readable, and has very clear structure to it. The only
thing unintuitive is the definition of the tags, partly by design. Custom tags
are allowed.

---

Some adjustments:
* Use @@tag for block level tags, @tag for inline level tags. The difference
  being whether they take a long argument or not. Then we don't need '@' as a
  terminator.
* in between text goes to a default special tag. So it can be treated as a
  command too.
* There's some open question about when whitespace is significant. Don't need
  to work out the details yet. Start with whatever makes sense to me and
  refine if needed.

Hmm.. '@@' looks a little excessive when stacked together. And now I wonder if
@{ should be changed to @@{ instead.

For example:

@@exitstatus
@@definitions
@@def[0] Success.
@@def[1] Failure.
@@def[2] Usage error.

Any other ideas I have. Maybe @ for has long arg, and $ for doesn't? Yeah.
That's much better. Let's go with that.

@tag[...][...]... ...
$tag[...][...]
\\, \@, \$, \[, \]

Umm... should @{ only be used for long form arguments? Use square bracket
otherwise?

No. Let's ditch @{. Just use square bracket instead. That's fine.

Next question: What would be the commands used for:

This is some $emph[emphasized] text. That's part of a 
paragraph. And some more $emph[strong] text.

Followed by another paragraph.

The question is, do we treat the paragraph as a special entity? I feel like we
ought to. Yeah. It's the tail part of a long arg to an implicit @_, right? So,
that's the same as:

@_
This is some $emph[emphasized] text. That's part of a 
paragraph. And some more $emph[strong] text.

@_
Followed by another paragraph.

Which is two '_' commands, each taking a single argument. The argument to the
first is:

"This is some $emph[empahsized] text. That's part of a
paragraph. And some more $emph[string] text."

The argument to the second is: "Followed by another paragraph."

The argument to the first paragraph can then be parsed as:

$_[This is some ]$emph[emphaiszed]$_[ text. That's part of a
paragraph. And some more ]$emph[strong]$_[ text.]

Notice:
* We preserve space in the spans. That space is important.
* The space can wrap around lines.

Okay? How can we precisely specify the syntax?

S0:
  Start state. Just finished a block command, or at start of doc.
  '@' -> Start parsing @ command (Go to S3).
  * -> Set @_ as current command. Start parsing long arg for @_ command as if it
    was on a new line (Go to S1).

S1:
  Parse long arg starting on next line.
  '[' -> Read up to next matching ']',
         add everything read as arg to command on top of the stack. Include
         leading and trailing whitespace in arg.
         Go to S2.
  * -> Read up to next blank line (which may be the current line).
         add everything read as arg to current command.
         Include leading and trailing whitespace in arg.
         Issue current command.
         Go to S0

S2:
  Parse long arg, not yet on next line.
  '\n' -> Go to S1.
  '[' -> Read up to next matching ']',
         add everything read as arg to current command. Include
         leading and trailing whitespace in arg.
         Go to S2.
  * -> Read up to end of line.
         add everything read to current command on top of the stack.
         Include leading and trailing whitespace in arg.
         Issue current command.
         Go to S0.

S3:
  Just read '@'.
  Read [a-zA-Z0-9_]+ as tag. Set as current command.
  Go to S2.
  

Questions:
* When to switch default text from @_ form to $_ form? When to start parsing
  '$' form?

---

Next revision:

We have two separate passes: block and inline.

The block pass interprets text as a sequence of block commands and executes
those. Parsing is pretty straight forward as described above:
1. Skip blank lines. While not at end of input:
2. If next character is not '@', read all characters until the next blank
   line. Issue the 'default block' command with the string read as the single
   argument. Then go to (1).
2. If next character is '@', read '@' and the tag.
3. If next character is not newline or '[', read all characters until end of
   line. Add that as the last argument to the current command. Issue the
   current command, and go to (1).
4. If next character is '[', read all characters until matching ']'. Add that
   as next argument to current command. Go to (3).
5. If next character is newline, skip passed that and go to 6.
6. If next character is '[', read all characters until matching ']'. Add that
   as next argument to current command. Go to (3).
7. If next character is newline, issue the current command. Go to (1).
8. Read all characters up until next blank line. Add those as an arg to
   current command issue the current command, and go to (1).

The inline pass interprets text as a sequence of inline commands and executes
those.
1. While not at end of input:
2. If next character is not '@', read all characters until the next '@'. Issue
   the 'default inline' command with the string read as the single argument.
   Then go to (1).
3. If next characters is '@', read '@' and the tag.
4. If next characters is '[', read all characters until matching ']'. Add that
   as next argument to current command. Go to (4).
5. If next character is not '[', issue the current command and go to (1).

Note:
* We reuse '@' for both block and inline elements. The parsing above should be
  a able to sort them out, except for the case where you want an inline
  command at the beginning of a default block. In that case, use an explicit
  block command instead.
* Also, mention that we escape \@, \[, \], and \\. 
* It's up to the command to decide whether it's argument should be interpreted
  as blocks or inline commands. At the end of the day, the default block
  command will likely want to interpret it's argument as inline commands. And
  the default inline command will only ever receive unmarked-up text.
* Still some open question about whitespace? I think, include all whitespace
  in [ ... ]. And for a long argument starting on the next line. The places we
  skip whitespace are blank lines between commands, space between '[]'
  arguments, and space before same line last arg.

Awesome. What are the next steps here?
* Write a vim syntax file, to see how things will look.
* Write some tcl code to implement this. Two procs: exec_blocks, exec_inlines.
* Write a tcl script to generate a man page from my bin/fble-compile.fbld
  file.

That will prove that it still looks nice with syntax highlighting, we can
implement the parser for it, and we can do something useful with the result.

How to highlight?
* @<tag> should be purple I think. Easy to see.
* [ and ] should be ... red maybe?
* \[ \\ \] \@ should be like a character literal.
That's it. Just those three things. I don't want to highlight any argument
text. We could add structure specific highlighting if we want later on. For
example, if I have a doc where @section is defined, and the first arg to
@section is the title, we can recognize that and highlight the title? Maybe
easier said than done. Don't worry about it for now.

Cool. Syntax highlighting looks great. I ended up with identifier for tag,
special for brackets, and character for escapes.

I started pulling together thoughts in specs/fbld.txt. That needs a lot of
work, but better than nothing right now.

Let's see if we can implement it next in tcl. Call it 'fbld.tcl'.

---

I implemented the parser for inline structured text. It was annoying, but not
bad. Note: I prefer to pass a generic 'invoke' function as an argument to the
tcl function that can reroute commands given command name and args. That's
nicer for my test case, for example, where I want all commands treated the
same way.

Next (and final?) step in the fbld implementation: implement support for
parsing block structured text. How to do that? Just plow ahead and see how it
goes I guess. Maybe shouldn't be too hard?

Can I do parsing of block level structure entirely on a line-by line basis? I
should be able to, right? Let's give it a try.

Well, except matching [] can span across multiple lines, which would be
awkward. Maybe don't short cut for now.

---

Okay, my draft of parsing block structure is done. Again, a bit tedious, but
otherwise pretty simple and straight forward.

Cool! Next step is to try generating some help text or man pages for my usage
doc.

Maybe we write something called usage.tcl that defines three modes:
1. Check that commands are valid with expected number of arguments and proper
subparsing.
2. Convert to usage text (as a C header file like xxd -i produces?)
3. Convert to man page.

That will be the real test.

---

Let's start with man page generation. What markup do I need?
* name, brief
* synopsys:  
  - distinguish between bold for 'as-is', italics for args.
* options
* exit status
* examples
* filenames italics

What do I want to for inline commands?
* @arg.  Call it @a for short?
* @file. Call it @f for short?
* @lit.  Call it @l for short?

Let's try that.

The only thing I'm not sure how to do right is referencing an element of a
list. Can I avoid having to do that to start? Yeah. I think I can manage.

Let's start by cleaning up bin/fble-compile.fbld.

Top level commands:
* default: @par[inline]
* @usage[inline]
* @defs[block]
* @options[block]
* @subsection[text][block]
* @exitstatus[block]
* @examples

Within @options
* @opt[inline][inline]

Within @examples
* @ex[text][inline]

Within @defs:
* @def[inline][block]


Inline Commands:
* @l[text]
* @a[text]

---

Observations when trying to implement man page generator:
* I'm ignoring outer structure like @defs, just passing through to @def. So
  should I not need @defs tag? Or should I somehow make use of the overall
  @defs structure?
* My implementation is not right, in that it really depends what indent level
  you are at for things. Somehow we need to keep that context, for example if
  you are printing a paragraph inside a list? Not sure.

---

Issues with my man page generation:
* Extra space between fble-compile and -m in usage, and in front of
  fble-compile.
 - Let me skip this .SY thing. That helps with the first space, but not the
   second. Maybe need a non-breaking space \& somewhere?
* definition lists have no space between tag and content.
 - Because the label doesn't include a newline. We should manually add a
   newline. DONE.
* Default nest for definition list 8 chars. Change to 4?
 - Change ".TP" to ".TP 4" fixes this.
* Need to strip whitespace from main function function paragraph?
* Option shows .P as part of the option.
 - Same issue as defs.
* Defs shows .TP for exit status.
 - Because there's no newline after the definition in this case.
 - So, strip whatever newline is there, and add my own?
* opts not nearly so compact as I would like.
 - Because it's using .P for block text. Should I treat it as inline instead
   of block?
* Newline needed after example so .EE tag works as expected.
* Main Function has a blank line before it, but Exported Module and Compiled
  Module do not.
  - Are we parsing definition value as inline instead of block? Yes. We were.
    If we go back to block, we get stuck in an infinite loop somehow.
  - It's parsing "Success." as a default, then seems to get stuck trying to
    parse the next one?

Definition lists are tricky. Assume the definitions are block level structure,
which is needed in some cases, such as my definition for "Main Function". That
means they will output a .P tag to start, but that doesn't fit with the .TP we
use.

---

Okay, so I think I got it down to three issues:
1. How to do definition lists supporting block definitions and compact lists.
2. That extra space in the usage before -m.
 - It's not just an extra space. It was an entire missing [...], because we
   didn't remember to unescape the final text. I can fix that.
 - Cool. This is fixed now.
3. The extra whitespace in the main function example.
 - It's almost like, for a paragraph, we want to split it into lines, trim
   each of the lines, concatenate those all together with a single space into
   one big long line, and then parse the inline structure?

Let me think on the paragraphs and definition lists things.

---

The most obvious thing to do about definition lists is have two kinds of
definitions: a short definition that takes inline structured text, and a long
definition that takes blocked structured text. The expectation is the short
definition goes on the same line as the label if it fits, and the long
definition always starts on the next line.

For paragraphs, this is admittedly a weird case. In general, it's just a
matter of defining how paragraphs should behave with respect to whitespace
and implementing it.

---

Cool. Man page is done. Looks decent. Next step is to generate help text. Let
me see if I can reuse groff for that to format the text?

How to run groff?
* Need to specify output format. Looks like it defaults to postscript.
 - Looks like -T ascii?
* Maybe also -m man to get those macros?
* Is there a way to set column width? I don't see an option. Maybe in the doc
  itself using some formatting tags?

Looks like -m man requires a .TH tag to work, which I don't really want. I
should learn how to format the document using pure troff formatting, without
the man page macros, so I don't need to pass -m man to groff.

The formatting I want:
* Newline
 - .br for go to next line.
 - .sp for single blank line.
* Indent margin for definitions.
 - .in +2, .in -2
* Tagged paragraphs for compact definitions.
* Section headers (flush left)
 Just regular text.
* Indent margin for sections.
 - .in +2, .in -2

Let's read through the troff user manual in detail and see what I learn.

Next things to find:
* Figure out how not to get a bunch of white space on the output at the end.
* Any decent way to set options on same line as tag if tag is not too long? Or
  would that require an if statement that I don't feel like writing?
 - Maybe not worth it. Just trim from the end in tcl before create a c header
   file.

Cool. I'm happy with the generated usage text.

Next steps:
* Write some tcl code to invoke groff and convert output to a c header file
  like xxd.
* See if I can increase the text width for roff to 78 chars or some such.
 - grotty is the back end. I don't see any options there.
 - Maybe it's a page size option?
  .ll for line length perhaps? And .l for the current value?
  Yup. .ll 78 uses 78 characters.

I want: generate roff ==> groff ==> tcl string ==> header file.

What's the easiest way to invoke groff from tcl, passing the generated roff
text?

Options:
* Write to temp files and pass those around.
* Write to a pipe of some sort in tcl and pass that around?
* Write to a tcl string and pass that in.

I think, let's use the string form. Generate the roff as a tcl string, exec
groff returning the output string, and process that returned string.

So, change 'puts' to a more generic output function?

---

We're far enough along on fbld to do some cleanup. What is it that I want to
show?

* Generate fble-compile.1 via fbld.
* Generate fble-compile --help usage text via fbld.
* Generate fble-deps.1 via fbld.
* Generate fble-deps --help usage text via fbld.
* Remove dependency on help2man and replace it with dependency on groff.

To get there: fbld.usage.tcl needs to support different options. I'm thinking:

Well, I'm seeing any shared code right now. So how about:
* fbld.usage.man.tcl for generating man pages.
* fbld.usage.help.tcl for generating help text.

Or do I prefer to have target option? Yeah, I kind of feel like target option
would be nice?

fbld.usage.tcl --target [man | help]

The info needed for a man page:
* title of the man page. So, --title ...

The info needed for help text:
* Nothing. Just the input.

Take input on stdin? Sure, why not. That's easy. Or, pass on command line. How
about command line for now.
 
Too tedious. For now, let me have separate scripts.

Cool. Works great.

---

What are some next steps? Brainstorm:
* Better error messages when processing fbld formatted files.
* Better define/clean up the fbld 'usage' document structure?
 - For example, some tags seem unused.
 - Should we enforce more about what tags can appear where?
 - Should section headers be just headers instead of sections too?
* Remove all uses of asciidoc?
 - Tutorials, READMEs, and language specs.

---

Re github integration. Github has a list of markdown formats it supports.
There's a public repo with the library for the conversion. github also has
github pages, which can serve a site generated from the source code.

That sounds like a good, general approach for documentation going forward.
Have the source code be whatever makes most sense for me to describe the
informational content. Have a build target that can generate a website from
the source code. That website can nicely bundle up the language spec, man
pages, doxygen output, tutorials, and what have you. Use github pages to
publish the website to github, or some other mechanism to publish it somewhere
else, or access it locally.

The next question is about tutorials. I want to continue writing tutorials.
What format should I write them in?

Tutorials should be reasonably easy to read from source, but we'll also,
eventually, want to generate a website from them. For now, let me focus on the
content of the tutorials, not the syntax. I'll continue to use asciidoc until
I need more structure from it the way usage text wanted.

---

Tags I want in tutorials:
* @tutorial[name][body]
* @l[text]
* @section[name][body]
* @code[language][body]
* @list[body]
 - @item[id][body]

---

Just some quite thoughts about how to organize fbld:
* front ends (e.g. usage, readme, spec, tutorial) convert a set of front end
  specific tags to a set of core tags. This is a restructuring pass.
* back ends (e.g. html, pdf, roff, txt) convert core tags to formatted
  documents. This is a formatting pass.
* Try to keep the same meaning for all the core tags across all the front ends
  and back ends.
* Hopefully we won't run into cases where backends have to be aware of
  particular front ends or restrictions thereof, though I think this is a
  fundamentally hard problem, so mileage may vary.

Maybe we have:
* fbld.tcl - Does tag agnostic parsing.
* backends/
    core.tcl - The core tags. Just does type checking of them. No output.
    man.tcl - For outputting man pages (requires special input structure?).
    roff.tcl - For outputting roff.
    html.tcl - For outputting html.
    etc.
* frontends/
    usage.tcl - For converting to core.
    readme.tcl - For converting to core.

I don't know. Man pages seem hard to do without very restrictive inputs.

I suppose another approach is have a library of tags. Maybe backends are a
library of converting tags to back end formatting, and front ends are what
select which tags to use and drive the backend tag libraries to produce the
desired output?

Let's review what kinds of conversions I want:
* usage ==> check, man, help, html, pdf
* readme ==> check, html, pdf
* tutorial ==> check, html, pdf
* spec ==> check, html, pdf
    
To start, skip pdf. Just keep in mind that it might be a thing we want
eventually.

I think we should also think about how to bundle multiple documents together.
For example, if generating html, we want to be able to link between documents.
If generating pdf, maybe we want to bundle everything together into a single
pdf and link internally, or maybe we want to generate pdfs and use URLs to
link between them?

I'm not sure. I think it's too early at this point to make informed decisions.
Best thing to do next, I think, is hack together the following:
* Migrate rest of .adoc files to .fbld.
* Support for checking usage, readme, tutorial, spec
  In particular, define the tags I want to support for all of them.
* Implement html backends for all use cases.

We can do a round of reorganization after we've sketched all those things out.

I'd like to drive things with the check scripts, so I'm forced to use the
right tags and keep a list of all the tags that I'm using.

How should I structure all of this code? The components are:
* common
  - checking
  - man generation
  - roff generation
  - html generation
* usage specific
  - checking
  - man generation
  - txt generation
  - html generation
* readme specific
  - checking
  - html generation
* tutorial specific
  - checking
  - html generation
* spec specific
  - checking
  - html generation

How about this:
* common checking.
* man generation
* roff generation
* html generation
* usage wrapper
* readme wrapper
* tutorial wrapper
* spec wrapper

I'm hoping we don't need any backend specific generation in the wrappers. We
can just reuse generation for existing common tags. So a wrapper does some
extra tag checking and conversion, then calls the checking/generation helpers
to support all forms of generation.

That suggests users interact with the wrapper for a given frontend, with
options to specify what kind of output formats to generate. The backends are
all libraries for frontends to reuse.

How should we record what front end a particular doc is using? Ideas:
* Put it in the filename: README.fbld, foo.usage.fbld, foo.spec.fbld.
  I don't really like that.
* Add a tag to the document. For example: @readme[Fable], @tutorial[Title],
  @spec[Title], @usage[Title].
* Have a generic tag to indicate. For example: @fbld[spec], @fbld[README],
  @fbld[tutorial].

I like the second option: @readme, @tutorial, @spec, @usage, etc. as the top
level tag. The front end can give an error if you don't have the right top
level tag. You could also imagine a future where you mix together documents of
different tags, using the tags to specify how to dispatch them. For example,
maybe we have a @collection front end that we use for a website, a pdf, or
some other collection of documents that can all link between one another.
Yeah. I like that idea.

Let's do it:
fbld/
  fbld.tcl
  test.tcl
  backends/
    check.tcl
    man.tcl
    roff.tcl
    html.tcl
  frontends/
    usage.tcl
    readme.tcl
    tutorial.tcl
    spec.tcl
    collection.tcl

Steps:
1. Reorganize existing code to match above proposed organization.
2. Add support for check.
3. Add tutorial front end.
4. Add html back end.
5. Add readme and spec front ends.

We should be in good shape then.

What tags do I want to support?
Common Inline:
* @inline[text] - Default inline. 
* @l[text] - for literal string.
* @a[text] - for an argument.
* @label[id] - A label for a reference.
* @ref[id][caption] - Links to a local label.
* @url[url][?text] - A url link, with optional text. Text defaults to the url.
* @file[file][?text] - A file link, with optional text. Text defaults to the file.
* @fbld[file][?text] - A link to another fbld file with optional text.
   file should be the path to a .fbld file, relative to the root of whereever
   you expect documents to be read from.
   An optional #... tag can be used to reference a specific label within the
   fbld file.

Common Block:
* @par[text]: Paragraph. Default.
* @defs[block]: List of definitions for definition list.
  TODO: Remove this. @definition and @def can be standalone.
* @definition[name][value]: Long form definition.
* @def[name][value]: Short form definition.
* @section[title][body]: A top level section.
* @subsection[title][body]: A second level section.
* @code[language][text]: A code listing.
  Languages: sh, fble, vim

Usage Specific Block:
* @name[name][brief]: TODO: change this to @usage[name][brief][content]?
  <name> - <text> in help output.
  NAME section in man output.
* @usage[...]: Gives synopsys. TODO: change to @synopsys.
  Usage: <text> in help output.
  SYNOPSYS section in man output.
* @description[text]: Description section.
  <text> in help output.
  DESCRIPTION section in man output.
* @options[text]: Options section.
  <text> in help output.
  OPTIONS section in man output.
* @opt[text]: A specific option.
  <text> in help output.
* @exitstatus[text]: Exit status section.
  Exit Status: ... in help output.
  EXIT STATUS section in man output.
* @examples[body]: Examples section.
  Examples: ... in help output.
* @ex[text][desc]: A specific example.
  EXAMPLES section in man output.

Tutorial Specific Blocks:
* @tutorial[name][content]
* @exercise[content] An exercise list item.
  Can be implemented as a definition list, where the names of the definitions
  are 'Exercise N'? Or a numbered list?

So the question is, can we express all of the usage specific tags
using common tags? I think yes. It's pretty straight forward. Either add a
section, or go to direct inline. All except for example, which maybe wants a
newline in it? No. We can do example too, as two paragraphs: literal text for
the example followed by a paragraph description.

Questions:
* Should we have @defs, @exercises, etc. wrapper tags for lists or not?
  I think we need this for html and to distinguish between two adjacent
  lists. But that only matters for numbered things right? Not definitions?
* Should we only allow relevant items in @defs, @exercises lists?
  Yes. @defs can only contain @def tags, nothing else. Or, if we create an
  ordered or unordered list, it can only contain @item subtags.
* Should we have numbered and unnumbered lists?
  I feel like I would rather have explicit numbering in the .fbld source.
  If so, maybe we don't need an @list tag at all, just @item[name][content]?
* How to link to another tutorial from a tutorial?
  Ideally it's easy to get to the source spec.
  Maybe: @ref[tutorials/Basic.fbld]?
  Maybe: @tutorial[Basic] (inline tag).
  Maybe: @link[Basic][tutorials/Basic.fbld] ...
  I think I prefer the last version, where we give a different name and
  target. But we want to be able to distinguish between different kinds of
  targets: urls, raw files, .fbld files that will turn into other relative
  links.
  Maybe: @url[www.degralder.com], @fbld[tutorials/Basic.fbld],
         @file[tutorials/Basic/Basic.fble],
         @link[Basic][@fbld[tutorials/Basic.fbld]] 
  Or, @url, @file, and @fbld are the three kinds of links, with an optional
  argument for text to display? For example:

  Head over to the @fbld[tutorials/Variables.fbld][Variables] tutorial to
  learn all about variables. Yeah. Let's go with that then.

* How to link to the language spec? Ideally a specific section within a
  language spec?
  I know I can use @fbld to link to the spec itself. Maybe let's not worry
  about a particular target section yet? Otherwise what we would want are
  labels for certain points in code, and a way to refer to that anchor in the
  @fbld filename syntax. Maybe:
 
  @bookmark[types_kinds_and_variables]

  @section[Types, Kinds and Variables][...]

  And then: @fbld[spec/fble.fbld#types_kinds_and_variables].
  And for local references: @fbld[#types_kinds_and_variables][Section 2]?
  Or something different for a local reference, like:
  @link[#types_kinds_and_variables][Section 2]?

  Or perhaps:
    @section[Types, Kinds and Variables @id[types_kinds_and_variables]][...]
  So there is less overhead to specifying a link target?

  What are common ways to define links in existing systems?
  * Asciidoc: [[...]] for destination, <<...>> for source.
     anchor:... for destination, xref:... for source.
  * html: id="..." for destination, <a href="#..."> for source. id works in
    any tag.
  * latex: \label[...] for destination, \ref[...] for source.
  * markdown: <a id="..." for destination, (#...) for source.

  I kind of like: @label[id], @ref[id][caption]. So we could do:

    @section[Types, Kinds and Variables @label[types_kinds_and_variables]][...]
    See @ref[types_kinds_and_variables][Section 2] for more info.
    See @fbld[spec/fble.fbld#types_kinds_and_variables][Section 2 of the fble
    spec] for more info.

  Yeah. Let's go with that.

I'm happy with this initial list of tags for usage and tutorials. I'd like to
switch to using them and be able to check code. But how do I structure the
code to support this?

Take usage.tcl. I expect it will have command line options to --check, --man,
--help, whatever. All in that one file.

It will define some of its own tags. It can implement these by invoking the
corresponding tags from core.

We want the context to be implicit. Like, if it's generating output, or
whatever back end its calling into. Fine. So check.tcl should define all the
individual tag functions inline_* and block_*, and that's all we need right?
Same for all the backends, except the backends have some global state that
needs to be set up for outputting things, right? Maybe they assume a global
output function to be defined. Yeah.

And the front ends will define their own tag functions and invoke functions.
Then set up the output and error procs, and invoke the fbld function to parse
the document. Easy.

Maybe let's write some new code from scratch:
* check.tcl for checking common tags.
* usage.tcl as front end for checking usage text. I can add build rules to
  check this. Let's start there.

Do we want a better name than 'check.tcl' for checking the tags? How about
core.tcl, for core tags? I like that a little better. And maybe don't treat it
as a backend, because it's more like an interface between frontends and
backends.

---

What next? I see two options:
A. Reuse usage.tcl for generating help and man pages.
B. Write a tutorial.tcl frontend and use it to check syntax of tutorials.

(B) sounds like more fun. Let's start there.

---

Issue: It's to hard to see where a command fails. Ideally I can print a proper
error message with line and column numbers relative to the .fbld file.

This will need some coordination. Or will it? Maybe we can use some global
variables to hide that?

* find_inline_command needs to know starting line and col.
* find_arg_end needs to know starting line and col.
* inline needs to know starting line and col.
* block needs to know starting line and col.

But inline and block are called from the tag commands. Which means they need
access to line and col for each argument, to be able to pass that back.

I suppose we could pass around arrays instead of strings? Wherever we want to
pass text, instead pass a triple: line, col, text. Ugh. Sounds hard.

Some hacks will get us by in the short term.

---

I'm thinking perhaps we should have front ends generate .fbld files, and have
backends operate directly on the generated .fbld files? Not sure.

How to fix links?

Currently I write a link for another tutorial using tutorials/Foo.fbld. But
html thinks tutorials/Foo.fbld is relative to the source file, which is in the
tutorials directory, so we get tutorials/tutorials/Foo.fbld, which is a bad
link.

How about we make links relative to the source file? That's much more well
defined, should work with generated html, is easy to fix up via tcl if needed,
and, if we're lucky, works just as well or better in vim, because it doesn't
depend on the current working directory. Let's give it a try.

Yeah, linking relative to the source file works great.

---

How to switch Tutorials.adoc to a .fbld file? What kind of file should it be?
It's certainly not a tutorial. I kind of wish I had a generic 'document'
class, for documents that don't need any special front end or tags. Like
README.fbld or Tutorials.fbld. That goes back to the idea of having front ends
generate .fbld files and back ends work on .fbld files.

Note that the front end is a little back end aware. For example, usage wants
to generate a different document for man page than help usage text. If that
wasn't the case, there would be no need for front ends.

Let's be slightly more clear. Front ends serve the following purposes:
* Provide domain specific tags. For example: @exercise, @opt. To make it nicer
  to write certain kinds of documents.
* Provide backend specific implementations of those domain specific tags. But
  in terms of core document structure. Not in terms of the raw backend
  output?

I don't know. As I said before, this is going to be a hard problem. No need to
solve it cleanly right now. But let's do the following:

* Add a @document[title][content] tag to the fbld core tag set.
* Change core.tcl to take a generic document as input and check that.
* Change html.tcl to take a generic document as input and output html for
  that.
* Change tutorial.tcl to always output a generic document.
* Change tutorials/Tutorials.adoc and README.adoc to be generic @document
  .fbld files. This should fix all the website links I hope.

---

On further thought, I'm thinking maybe fbld.tcl should be the main driver, and
you pass a list of .tcl files as input to it. The individual .tcl files define
tag commands, named as inline_* and block_*. And that's how you specify the
desired backend and any front end processing?

We want composition of front ends and back ends. Currently I have it designed
as every front end lists the back ends it goes with, and you select there. Is
that too front end specific?

The issue is that I want to introduce a generic doc@ type and reuse the html
backend for that. So I want more ways to compose things than I have had so
far.

---

Some more core tags to support:
* @note[block] for a callout note.
* @item for a list item.

---

Trouble with front end composition. How can I convert @usage to @doc? I can't
call ::block_doc directly, because I want to insert content before it parses
things. Hmm...

I guess I want:

@usage[name][brief][content]

To turn into: ...

Well, actually that depends on whether I want help usage or man usage. In
which case, how do we do check usage? I suppose to check we can do man usage.
So we want to turn it into:

@doc[$name][
@section[NAME][$name - $brief]

@content
]

Maybe that's not so hard? Just modify the string? I'm not convinced, but we
can do it short term. Eventually maybe we want to make it easier to pass the
block scripts instead of a string that needs to be processed a certain way?

Yeah, this will need some work.

---

I switched the README to .fbld syntax. I think it will be hard for new people,
but let's just auto-generate a .txt file from the .fbld source to include in a
release. Easy.

---

How can I do syntax highlighting of code blocks? I feel like asciidoc has some
generic syntax highlighter it uses. Can I reuse that?

Looks like it uses one of:
* http://www.gnu.org/software/src-highlite
* http://www.andre-simon.de/doku/highlight/en/highlight.html
* http://pygments.org

In particular, I'm looking for one where I can easily add my own highlighting
for fbld and fble. A quick search doesn't bring any obvious leaders.

Lets start with the GNU source-highlight, which looks like it supports custom
syntax. And hey, I already have it installed.

How to write my own language file? Notes from reading the user manual:
* fbld.lang, fble.lang
* # for comments.
* Single line regex. That's fine.
* "...|...|..." for keywords.
* '...' for general regex without back references.

Looks like the .lang file is of the form:
class = '...'
(class1, class2, ...) = '...'

Questions:
* What class names should I use? Any standard ones?
  - Looks like just pick some language and go based on that.
  comment, label, normal, preproc, specialchar, string, symbol, todo
* For fble, it will be nice if we can reuse instead of copy paste regex for
  quoted and unquoted words. Any support for that? Worse case just copy paste.
  vardef <var> = ..., $<var> maybe? Yes. Looks like it works. Perfect.
* comment start "#"
* Earlier entries are matched before later entries.

Let me give it a try.

What's the default.style used? How do I specify that?
* /usr/share/source-highlight/default.style

Let's pick class names based on that. For fbld to start, I have tag, bracket,
and escape char. In vim I use Identifier, Character, and Special for those.
For source-highlight, maybe: usertype, symbol, specialchar. Let's try it.

How to pass my lang file explicitly?

source-highlight --lang-def=filename

Let's try it out. Awesome. Works great for fbld. Now for fble.

classes are:
  quoted      ==> Identifier  ==> ??? regexp?
  comment     ==> Comment     ==> comment
  type        ==> Type        ==> usertype
  label       ==> Label       ==> label
  literal     ==> String      ==> string
  module-path ==> Include     ==> preproc
  poly        ==> Special     ==> symbol
  not-poly    ==> ()          ==> normal

Should I define my own fble.style file instead of trying to fit into the
default? I'd rather go with defaults where possible. Let's try regexp for
quoted. It's a pretty rare case.

Looks great for fble. I would choose different colors, but whatever.

Now, how can I use source-highlight in the html implementation? Should be easy
right? exec the command in a code block. Map language name to source-highlight
languages. Or switch all my uses to whatever language source-highlight already
uses?

---

@l[@<@<Bit@>>] is being rendered in html as:

<code>@<@<Bit@>></code>

Which showing up in chrome as:

@<@>

Clearly we need to do some escaping in generated code segments. What
characters need escaping?

According to the internet:

 & becomes &amp;
 < becomes &lt;
 > becomes &gt;

Easy.

---

I converted the fble spec from asciidoc to fbld. I like it a lot. It shows a
good example of how to easily define some custom document tags by having an
fble.fbld.tcl file associated with the document.

Ran into issues with fbld I ran into before:
* When is it okay to use unescaped [ and ]? I relaxed the restriction in the
  parser. I'm not sure what to do officially.
* Tracking down errors was hard. In one case I had a space on what I thought
  was an empty line before @code, which turned it into an inline tag which
  wasn't supported.

---

Question: Can we replace doxygen entirely with an fbld-based documentation
system?

Pros:
* Full control over formatting tags and generated output.
* Can remove dependency on doxygen and clang.
Cons:
* Means using a custom doc format instead of more standard doxygen.
* Extra effort required to parse C code to ensure everything is documented as
  desired.

I think it's mostly a question of how to parse out the documentation from the
source code. If we can implement that easily enough, great. I'm not too
worried about using a standard doc format as long as we have some checks for
legal formatting. If it's too hard to parse out the documentation, then the
decision is much harder.

---

There's a choice to be made. Do we want to parse the list of documented
elements from the underlying language, or do we want doc comments to be
essentially separate from the underlying language.

If we do the former, we can get:
* Checks that we have documented everything.
* Names of entities and types not needed in the doc comments themselves.

If we do the later, we can get:
* Support across any language, and it's much simpler to implement.

Honestly, I don't care that much if some entities are not documented or some
arguments are not documented. The bigger question is whether I'm okay
duplicating information in the comments that you could get from the code. Two
things come to mind: entity names and arg/field types.

Imagine. Instead of:

/**
 * Evaluates a linked program.
 * 
 * The program is assumed to be a zero argument function as returned by
 * FbleLink.
 *
 * @param heap     The heap to use for allocating values.
 * @param program  The program to evaluate.
 * @param profile  The profile to update. May be NULL to disable profiling.
 *
 * @returns
 *   The value of the evaluated program, or NULL in case of a runtime error in
 *   the program.
 *
 * @sideeffects
 * * The returned value must be freed with FbleReleaseValue when no longer in
 *   use.
 * * Prints an error message to stderr in case of a runtime error.
 * * Updates profiling information in profile based on the execution of the
 *   program.
 */
FbleValue* FbleEval(FbleValueHeap* heap, FbleValue* program, FbleProfile* profile);

We would have something like:


// @func[FbleEval][Evaluates a linked program.][
// The program is assumed to be a zero argument function as returned by
// FbleLink.
//
// @param[FbleValueHeap*][heap] The heap to use for allocating values.
// @param[FbleValue*][program] The program to evaluate.
// @param[FbleProfile*][profile]
// The profile to update. May be NULL to disable profiling.
//
// @returns[FbleValue*]
// The value of the evaluated program, or NULL in case of a runtime error in
// the program.
//
// @sideeffects
// @item
// The returned value must be freed with FbleReleaseValue when no longer in
// use.
//
// @item Prints an error message to stderr in case of a runtime error.
// @item
// Updates profiling information in profile based on the execution of the
// program.
// ]

Which I don't mind.

Let's say we are going to do this then. How do I want to do the man pages?
That's the only thing I'm really worried about loosing from doxygen. But we
don't really do them great today anyway.

Options are:
* One function per man page. The man pages will be small, not have a lot of
  context. Can auto-generate easily enough.
* One file per man page. The man page is big, plenty of context. In some
  cases, perhaps too much context.
* Manually written man pages that reference the doc comments.

Honestly? I'm tempted to write the man pages by hand. In which case, the
format of the doc comments doesn't matter at all and we are back where we
started.

If they are written by hand, it's easy and natural to group however makes
sense. It means a duplicate source for the documentation though, which will be
a pain. On the other hand, this is public API. It should be a pain to change
the API.

Custom man pages are nice because we can merge descriptions of common
arguments, for example.

I'm tempted. If we do this, I don't have to update any of the doc comments in
the source code to a different syntax, because it's just for human
consumption.

Or... just do one function per man page, and take directly from the doc
comments in source. There is sufficient info in those comments. Use an fbld
format that we can more easily map to man pages.

I want to set up install of my first man page this way. Play around.

Steps might be:
* Remove doxygen from the build.
* Pick a function, change it to fbld docs, generate a man page and install
  that. Play around, see how it feels. Then go from there.

---

Fbld tags for documenting library functions:

@func[name][brief][description]
@param[type][name][description]
@returns[type][description]
@sideeffects[content]

Maybe we'll want to add @see[...] eventually, but don't worry about that for
now, because I don't have any of that content in place.

How to turn the above into a man page, assuming @param, @returns, and
@sideeffects are all part of the @func description?

Let's manually translate this to start.

Here's what I'm thinking:
* NAME - section has name + brief
* SYNOPSYS - has #include <fble/fble.h>, then params + return.
* DESCRIPTION - brief + body of description, minus return and side effects.
  Turn params into defs.
* RETURN - with return.
* SIDE EFFECTS - with side effects.

Make sure to generate to man 3, not man 1.

This will be a good test of fbld, because it's more complicated than straight
pass through. I need multiple passes. Not sure how that will work.

---

Thoughts on how to set this up on the build side.

Conceptually, given a .h file, we want to generate multiple man pages. We don't
know which man pages to generate until we've read the .h file. We want to have
targets to generate the individual man pages and copy them, so we'll want to
go: .h -> .ninja with a list of rules to generate individual man pages.

Should it be:
 .h -> .ninja, *.3.fbld

Where .ninja gives rules for *.3.fbld to *.3 and installed *.3?

Or:
 .h -> .ninja,

Where .ninja gives rules to extract a particular named *.3.fbld? No, that
doesn't make sense. That means rereading the .h file over and over again. We
should do the former.

So, write a script that takes a .h file and produces a .ninja file and *.3.fbld files. The .ninja file and each *.3.fbld file depends on the .h file.

In this case, I'll also want to write a script that generates a .ninja file for
the include/fble directory. Any time that directory changes, it generates a new
.ninja file, and for each subninja file it needs to create, if that doesn't
already exist, generate it from scratch.

Sounds like a (complicated) plan.

---

Let's forge ahead. Not sure how to organize the code, but the pieces are
clear:

* Pick an example and update the doc in place in the .h file.
* Write tcl code to extract a doc comment from a .h file along with the name
  associated with it.
   // @func[name] ...
   //
   //
   ...
* Write fbld tcl code to convert @func to @doc man page doc.
* Write build rules to generate the man pages from doc.
  For now, just hard code the mapping from .h to function in the build.tcl
  file.

I see two approaches we can take:
1. tcl script takes .h as input and generates a bunch of individual <func>.fbld
files as output. We process those .fbld files individually.
2. tcl script takes .h as input, generates a single big .fbld as output. Then
a second tcl script takes the big .fbld as input and generates a bunch of
individual <func>.fbld or <func>.3 as output.

The nice thing about (1) is fewer scripts. The nice thing about (2) is we can
more naturally support things like @file description and more easily compose
with different programming languages?

Let's start with the simpler approach. Get something working, then decide.

Okay. Starting with FbleEval function in fble-value.h.

Question:
* // style or /* style comments? I think // is easier for the script to
  recognize. How does it look from the doc?

Honestly, I find the /** ... */ easier to read. Either way, it's tough to read
the fbld markup from a comment. We get no syntax highlighting help.

Honestly, use of whitespace to highlight structure instead of braces makes a
big difference visually. Compare:

// @func[FbleEval][Evaluates a linked program.][
// The program is assumed to be a zero argument function as returned by
// FbleLink.
//
// @arg[FbleValueHeap*][heap] The heap to use for allocating values.
// @arg[FbleValue*][program] The program to evaluate.
// @arg[FbleProfile*][profile]
// The profile to update. May be NULL to disable profiling.
//
// @returns[FbleValue*]
// The value of the evaluated program, or @l[NULL] in case of a runtime error in
// the program.
//
// @sideeffects[
// @item
// The returned value must be freed with @l[FbleReleaseValue] when no longer in
// use.
//
// @item Prints an error message to stderr in case of a runtime error.
// @item
// Updates profiling information in profile based on the execution of the
// program.
// ]]

/**
 * @func[FbleEval]
 * Evaluates a linked program.
 *
 * The program is assumed to be a zero argument function as returned by
 * FbleLink.
 *
 * @arg[FbleValueHeap*][heap]     The heap to use for allocating values.
 * @arg[FbleValue*    ][program]  The program to evaluate.
 * @arg[FbleProfile*  ][profile]  The profile to update. May be NULL to
 *                                disable profiling.
 *
 * @returns[FbleValue*]
 *   The value of the evaluated program, or @l[NULL] in case of a runtime
 *   error in the program.
 *
 * @sideeffects
 *  @i The returned value must be freed with @l[FbleReleaseValue] when no
 *     longer in use.
 *  @i Prints an error message to stderr in case of a runtime error.
 *  @i Updates profiling information in profile based on the execution of
 *     the program.
 */

How much of this is legit fbld code already, and what isn't?

* Loss of structure of @func. That is, we assume everything after @func is
  part of the body. If we had multiple @func tags, or multiple top level tags,
  it would be ambiguous.
* Extra whitespace in type: is fine. We can just trim it.
* Extra whitespace before last arg on same line is fine. We can trim it.
* Wrapped line not legit. No way to distinguish between continuation of same
  argument versus start of next command.
* Indented body is legit. Just trim the whitespace (inside and out).

Technically speaking, it's only the line wrapping that causes problems.

First, how about structure. Can we use whitespace more generally for structure
instead of braces?

For example, maybe do a single space indent.

@tag[...][...]
 body line
 body line
 
 body line

non-body line.

Technically that's legit. It's not until you get to the blank line before the
non-body line that the body of the @tag argument ends. No need for braces.

That means, literally, all I have to do is figure out line wrapping to make
the doc look way better? That's definitely worth a try.

Two things I would like:

Same and next line args. So, instead of

@func[FbleEval][Evaluates a linked program.][
Content
]

I would love to be able to say:

@func[FbleEval] Evaluates a linked program.
 
 CONTENT

Next I would like to be able to say:

@func[FbleEval] This is a really long brief line
                that goes to the next line.

Or:

@func[FbleEval] This is a really long brief line
  that goes to the next line.

A couple ideas:
* Use an explicit line continuation character like '\'
* Have the tag itself accept two unbraced arguments - same line and body, and
  concatenate them if it wants to.

For example, @i always accepts both and concatenates. Something like @func
doesn't concatenate.

This needs more thought, but roughly speaking something like:
* Indent becomes part of parsing structure to distinguish between block and
  inline tags.
* All block tags support both a same line arg and a next line arg. They are
  interpreted based on the particular command tag in question.

Needs thought. Needs review of concerns I had when initially creating fbld.

---

Thoughts: we can simplify the syntax while we are at it. Proposal is:

* Allow both same line and following line args in the same command.
* For following line arg, always use a single space indent to specify the
  argument.

So, for example:

@tag[foo][bar] This is same line arg.
 This is next line arg.
 
 @tag part of arg.
@tag not part of arg.

Note: we need a single space on the otherwise apparently blank line.

Two questions:
* How nice/tedious is this for docs in practice?
* What about prior concerns I had?

Let me start with prior concerns. They were:
* Don't rely on indentation for meaning because vim syntax highlighting is
  hard.

That's it. The only concern I found. I know vim syntax doesn't care about
indent though. It already doesn't treat particular tags specially.

I thought maybe something about it being bad to structure the document based
on invisible spaces. For example, the following would be two different things:

@tag[foo]
 hello

 there


@tag[foo]
 hello
 
 there
 
In the first case, we have:
 @tag[foo][hello]
 @default[there]

In the second, we have:
 @tag[foo][hello\n\nthere]

No way to tell that from reading. Is that a special case for blank lines? Or
maybe it's okay if you really care?

I'm not sure. Let me reformat some docs and see how it feels to me:
* FbleEval doc comment.
  Looks great. The big challenge is remember to include spaces in blank lines.
* README.fbld
* fble.fbld
* HelloWorld.fbld

I wonder if I could highlight spaces on blank lines in vim syntax to make this
more obvious?

Or, treat blank lines specially. It's not really the blank line we care about,
it's the line that has a non-blank character at an indent level less than the
@tag. That would be better. Let's go with that. Then no space is required on a
blank line.

Any place this could cause problems? Not sure. I guess we'll find out.

README.txt:
* I fear it will be real easy to forget to indent content lines. Any way to
  enforce that?
* I have the choice now for section titles if I want them in braces or not. I
  don't know which I prefer yet.
* Indenting contents of sections a single space doesn't bother me. 
* It doesn't magically make things readable without syntax highlighting.

HelloWorld.fbld:
* Would be nice to have vim indent support to easily format things to be on
  the same indent.
* The growing indent bothers me a little more in this case. Getting nesting
  four deep: doc, section, subsection, code.
* Without the [], you can no longer jump directly to the start or end of a
  section in vim as easily.
* It is real easy this way to see when a section ends: you get a new tag
  that's not indented as far as the content just before it.
* Note that default blocks go to the next blank line still, not based on
  indent.
* It's going to be a bit tedious to convert everything to the new format. The
  biggest change being the extra indent.

fble.fbld:
* More compact @item lists are kind of nice.

Honestly, I think header doc comment gets a big improvement from this new
syntax. Less so for other docs, but not generally harmful. Just tedious to do
the conversion for.

The biggest fear is that I get the indent wrong and it silently groups content
with the wrong block. I don't have to worry about that when using braces.
Anything I can do to make that better?

Anything vim folds can do to help? I'm not convinced. We could add folds
automatically from the syntax file, and then use some columns on the left to
show the state of the folds, but I'm not sure it adds much, and it causes even
more space to be used up on the left side of the terminal.

Could we enable warnings somehow? Like, if you indent a tag you don't expect
to? Or you nest tags you don't expect to?

What would be nice is a vim command like [{ that jumps from the current line
to the tag where that arg applies to. So at least if you are in doubt you can
jump right to the place where the section is.

What do you think? Should we make the leap? For the sake of nicer header docs?
I vote yes.

---

I updated the .fbld spec. I think it's definitely simpler now, though the spec
itself doesn't do a great job describing it.

Next steps:
* Update the fbld test cases.
* Update the fbld implementation.
* Convert everything over to the new spec.

Notes from conversion experience:
* set autoindent in vim. Then it will line up indent from first line.
* I'm pretty happy with improvements to appearance of usage .fbld files from
  this change.
* Yeah. Overall, from the point of view of how the documents look to read, I'm
  really liking this change.

Cool. All transferred over to the new spec.

---

Back to FbleEval as a proof of concept, next step is to write a tcl script to
extract the doc comment for it and write out an FbleEval.fbld file.

We can just use a regex I bet:

/**\n * @func[([a-zA-Z0-9_])].* */

Iterate through, all of them, output .fbld files separately based on the @func
part.

We could also pass FbleEval the name as an argument. Then target that specific
value, give an error if it doesn't exit. Might be cleaner from a build script
side of things. I like that.

Easy. Actually, I ended up skipping regex, but whatever. Easy, if not super
robust at this point.

Next step: write a doc comment to man page converter.
