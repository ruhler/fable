Fble Modules Revisited
----------------------
Yet another revisiting of modules. Specifically I want to work out the
appropriate language features and conventions to be used with modules to
address the following:

* Avoid introducing false dependencies.
  For example, I just added an Equals function to Map. That brings in a
  dependency on Bool that wasn't there before. And if I want to reuse EqMaybe,
  that would bring in a dependency on Maybe too. It was not obvious at the
  time how I could easily avoid that.

* Where to put different bits of code.
  For example, Foo vs. Foo_Tests vs. Foo/Tests, vs. Foo/Foo, Foo/Tests.
  I want to know how I ought to organize modules consistently. And clarify
  the conventional relationship is between a parent module and its children.
  Does the parent depend on the children? The children depend on the parent?
  Is there no conventional dependency relationship between parent and child?
  Are the children internal or public? Do they have access to internals or
  access to public stuff?

  For example, I would expect Foo/Tests not to have access to the internal
  data type for Foo, because they are testing the public API. But it's nice to
  put them in a subdirectory along with Foo just for organizational purposes.

* Abstract type support.
  I should be able to make types abstract, perhaps using the ?= statement
  suggested. But make sure this still allows me to give access to the
  definition of the type to multiple internal modules without giving access to
  the type externally.

* Add and test implementation support for private modules.


Proposal:
* How big a module is is determined by dependencies. If you use a module, you
  should only bring in dependencies you have to have to use the module. You
  shouldn't bring in other false dependencies.

* It should be possible to refine a large module into smaller submodules
  without users of the module noticing. Where the submodules can be private.
  This means a parent module has privileged access to its immediate children.

* If a module is marked as private, it produces private things.
  Ideas for how to mark a module as private:
   Foo!.fble
   Foo!/
   Foo._.fble
   Foo~.fble
   Foo~/ 
   Foo~

  Yeah, I like the last one. So if a file is Foo~.fble, the module Foo is
  marked as private. If a directory is Foo~/, it is marked as private. The
  module is referred to without the trailing tilde. There must not be both
  private and public versions of the same module.

* If a module is in a directory, it has privileged access to things in that
  directory and immediate child directories.

* Modules in the same directory are developed by the same developer.

* Use directories for organizing modules as well as privilege.
  For example, prefer Foo/Tests.fble over Foo_Tests.fble, just because it
  shows the relationship between the two better.


There are 4 kinds of modules, depending on whether they are privileged or not,
and whether they produce private stuff or not:

* private, privileged: put in subdirectory.
* private, non-privileged: put in subdirectory.
* public, privileged: put in subdirectory or at root.
* public, non-privileged: ??

My proposal, though this mixes up two different kinds of concerns, is to
group modules in the same directory that refer to the same thing, even if some
of those modules make use of privileged access while others don't.

Note: Any private stuff that needs to be shared by multiple modules must be
defined in a private module. You can only mix private and public in the same
module if only the public bits of that module are to be accessed.

Random idea: Could we use Foo/Tests.fble to say Tests does not have private
access to Foo~/FooInternal~.fble?  Uh... that looks confusing to me. It
suggests a module has the following:

  value
  privileged children - can access private children
  non-privileged children - can't access private children

In other words, we explicitly label the four kinds of children:
  privileged, private:      e.g. Foo~/FooInternal~.fble
  privileged, public:       e.g. Foo~/Data.fble
  non-privileged, private:  e.g. ???
  non-privileged, public:   e.g. Foo/Tests.fble

If that's the case, could we have two different symbols to track this in the
file system? Assume by default non-privileged, public? Then have, for example:

+ means privileged
- means private

So we have:
  Foo/Internal+-.fble
  Foo/Data+.fble
  Foo/Tests.fble

Or: '*' for read and write, '+' for read only, '-' for write only?
  Foo/Internal*.fble
  Foo/Data+.fble
  Foo/Tests.fble

Or: '-' for read and write. e.g. internal only private.
    '+' for public with private access.
        blank for public with public access.

That sounds like a nice proposal to me. Let's try it and see how it feels.
Then the only thing left is to figure out abstract data types.

---

When writing the spec for the above access controls, I realize having separate
privileged and non-privileged makes for an awkward situation.

If you just have public and private, then we assume a parent has private
access to its children and private access to its siblings. And children have
access to their parent.

If you add non-privileged, then there are two groups that a parent is involved
with: its children and its siblings. Then you need two specifications. Does it
have privileged access to its children? Does it have privileged access to its
siblings?

If all you get from privileged/non-privileged is an extra compile time check,
maybe it's not worth it? It doesn't really fit in the notion that a directory
is all owned by the same organization. It adds a strange corner case to the
spec.

Potentially you could work around it too, for example:

  Foo/
    Tests.fble
    Impl*/Impl.fble

Well, no. That doesn't really work. Because if Tests.fble doesn't have the
access it needs, neither does Foo. Unless Foo is just a re-export of an
internal module:
  
  Foo.fble        // re-exports Private.fble
  Foo/            
    Tests.fble    // uses Private.fble
    Private*.fble // re-exports API.fble
    Private*/
      Impl.fble
      API.fble
    
So yeah, worst case, using reexport, which is trivial, you could separate the
access into privileged and non-privileged just using directory structure with
public and private. My vote is to get rid of the notion of privileged and
non-privileged for the first implementation.

---

Experience Report: It feels like module organization is a hard problem.
Consider integers. I figure I want IntP, IntS, and Int. But IntP decrement
wants to use IntS and IntP subtraction wants to use Int. Then IntS division
wants to use Int subtraction, and so on. We end up with a long dependency
chain if we split everything up:

  IntP -> IntS -> Int -> IntP.Sub -> Int.Sub -> IntP.Div -> Int.Div

It is nice to have each module be a small focused thing. None of them really
have any private internal functions, so the only practical value at the moment
for using separate modules seems to be to separate them into small focused
things and for namespace support, so that we can have an Eq function for IntP,
an Eq function for IntS, and an Eq function for Int.

This is actually a deeper question I think. Is it better to define separate
IntP, IntS, and Int types that constrain the data type, or is it better to use
a generic Int type? It's certainly proving inconvenient to keep track of which
types all the functions are used for and converting between them when I have
IntP, IntS, and Int types.

Or: is it better to define these across a bunch of modules to avoid false
dependencies, or better to just define them all in one module and avoid the
headache of splitting them up?

---

Things I want to try to see how well they work:
* Lots of little modules. Because what, really, is the cost of that? I think
it's just being able to remember what module to import. It doesn't reduce the
number of import statements you would use.

* Don't require modules to all be imported at the top of the file. I'm not
convinced it adds much. For example, /Bool/Show%.Show is just as good or
better to use than locally defining ShowBool. Take a little more risk here and
see if it leads to any problems.

