
@ Bool@ = /Bool%.Bool@;
% True = /Bool%.True;
% False = /Bool%.False;

@ Program@ = /Fblf/Program%.Program@;
@ Proc@ = /Fblf/Program%.Proc@;
@ Var@ = /Fblf/Program%.Var@;
@ Stmt@ = /Fblf/Program%.Stmt@;
% Call = /Fblf/Program%.Call;

@ Int@ = /Int/Int%.Int@;
% Add = /Int/Int%.Add;
% Int = /Int/Int/Lit%.Int;
% Eq = /Int/Int/Eq%.Eq;

<@>@ List@ = /List%.List@;
<@>% Cons = /List%.Cons;
<@>% Nil = /List%.Nil;
<@,@>% Map = /List%.Map;
<@>% Contains = /List/Eq%.Contains;

@ String@ = /String%.String@;
% Concat = /String%.Concat;
% Str = /String%.Str;

@ Unit@ = /Unit%.Unit@;

# Module@ -- 
#   Monadic API used to define a collection of fblf procedures that share the
#   same internal state and module arguments.
#
# Fields:
#   name - the globally unique name of the current module.
#   this - pointer to 'this' internal state variable.
#   args - the list of arguments, not including 'this', passed to the module
#          when it was instantiated.
#   define - set to true if we should define methods on this module, false
#            otherwise.
#   heap - the number of bits allocated on the heap so far for the internal
#          state of this module.
#   modules - the list of modules that have already been defined.
#   program - the program procedures defined so far.
@ Read@ = *(String@ name, Var@ this, List@<Var@> args, Bool@ define);
@ State@ = *(Int@ heap, List@<String@> modules, Program@ program);
<@>@ ModuleR@ = <@ T@> { *(State@ s, T@ x); };
<@>@ Module@ = <@ T@>(Read@, State@) { ModuleR@<T@>; };

# Helper function to make a variable that's relative to the intrernal state of
# a module.
(Int@) { Var@; } Local = (Int@ offset) {
  # The retured variable is relative to arg '0', which corresponds to 'this'.
  Var@(Int|0, offset);
};

# LocalArgs --
#   Given a list of vars [x, y, z], produce a list of vars [n, n+1, n+2].
(Int@, List@<Var@>) { List@<Var@>; } LocalArgs = (Int@ n, List@<Var@> l) {
  l.?(
    cons: Cons<Var@>(Var@(n, Int|0), LocalArgs(Add(n, Int|1), l.cons.tail)),
    nil: Nil<Var@>);
};

<@ T@>(String@, (List@<Var@>) { Module@<T@>; })(List@<Var@>) { Module@<T@>; }
Module = <@ T@>(String@ name, (List@<Var@>) { Module@<T@>; } body)(List@<Var@> args)(Read@ r, State@ s) {
  # Add the procedures from this module to the program if this is the first
  # time we've encountered the module.
  State@ ns = r.define.?(
    true: Contains<String@>(/String/Eq%.Eq)(s.modules, name).?(
      true: s,
      false: {
        List@<Var@> local_args = LocalArgs(Int|1, args);
        State@ ns = body(local_args)(
          Read@(name, Var@(Int|0, Int|0), local_args, True),
          State@(Int|0, s.modules, s.program)).s;
        State@(s.heap, Cons<String@>(name, ns.modules), ns.program);
      }),
    false: s);

  # Run the body of the module inline to get its returned value relative to
  # whatever module is instantiating it.
  body(args)(Read@(name, Local(s.heap), args, False), ns);
};

# Module0 --
#   Define a module that takes no arguments.
<@ T@>(String@, Module@<T@>) { Module@<T@>; }
Module0 = <@ T@>(String@ name, Module@<T@> body) {
  Module<T@>(name, (List@<Var@> _) { body; })[];
};

# Module1 --
#   Define a module that takes 1 argument.
<@ T@>(String@, (Var@) { Module@<T@>; }) { (Var@) { Module@<T@>; }; }
Module1 = <@ T@>(String@ name, (Var@) { Module@<T@>; } m)(Var@ arg) {
  Module<T@>(name, (List@<Var@> l) { m(l.cons.head); })[arg];
};

# Module2 --
#   Define a module that takes 2 arguments.
<@ T@>(String@, (Var@, Var@) { Module@<T@>; }) { (Var@, Var@) { Module@<T@>; }; }
Module2 = <@ T@>(String@ name, (Var@, Var@) { Module@<T@>; } m)(Var@ arg1, Var@ arg2) {
  Module<T@>(name, (List@<Var@> l) {
    m(l.cons.head,
      l.cons.tail.cons.head);
    })[arg1, arg2];
};

# Module3 --
#   Define a module that takes 3 arguments.
<@ T@>(String@, (Var@, Var@, Var@) { Module@<T@>; }) { (Var@, Var@, Var@) { Module@<T@>; }; }
Module3 = <@ T@>(String@ name, (Var@, Var@, Var@) { Module@<T@>; } m)(Var@ arg1, Var@ arg2, Var@ arg3) {
  Module<T@>(name, (List@<Var@> l) {
    m(l.cons.head,
      l.cons.tail.cons.head,
      l.cons.tail.cons.tail.cons.head);
    })[arg1, arg2, arg3];
};

# Module4 --
#   Define a module that takes 4 arguments.
<@ T@>(String@, (Var@, Var@, Var@, Var@) { Module@<T@>; }) { (Var@, Var@, Var@, Var@) { Module@<T@>; }; }
Module4 = <@ T@>(String@ name, (Var@, Var@, Var@, Var@) { Module@<T@>; } m)
  (Var@ arg1, Var@ arg2, Var@ arg3, Var@ arg4) {
  Module<T@>(name, (List@<Var@> l) {
    m(l.cons.head,
      l.cons.tail.cons.head,
      l.cons.tail.cons.tail.cons.head,
      l.cons.tail.cons.tail.cons.tail.cons.head);
    })[arg1, arg2, arg3, arg4];
};

# Module5 --
#   Define a module that takes 5 arguments.
<@ T@>(String@, (Var@, Var@, Var@, Var@, Var@) { Module@<T@>; }) { (Var@, Var@, Var@, Var@, Var@) { Module@<T@>; }; }
Module5 = <@ T@>(String@ name, (Var@, Var@, Var@, Var@, Var@) { Module@<T@>; } m)
  (Var@ arg1, Var@ arg2, Var@ arg3, Var@ arg4, Var@ arg5) {
  Module<T@>(name, (List@<Var@> l) {
    m(l.cons.head,
      l.cons.tail.cons.head,
      l.cons.tail.cons.tail.cons.head,
      l.cons.tail.cons.tail.cons.tail.cons.head,
      l.cons.tail.cons.tail.cons.tail.cons.tail.cons.head);
    })[arg1, arg2, arg3, arg4, arg5];
};

# Do --
#   Monadic bind for Module@ monad.
<@ A@, @ B@>(Module@<A@>)((A@) { Module@<B@>; }) { Module@<B@>; }
Do = <@ A@, @ B@>(Module@<A@> m)((A@) { Module@<B@>; } f)(Read@ r, State@ s) {
  ModuleR@<A@> a = m(r, s);
  f(a.x)(r, a.s);
};

# Return --
#   Monadic return for Module@ monad.
<@ T@>(T@) { Module@<T@>; }
Return = <@ T@>(T@ x)(Read@ r, State@ s) {
  ModuleR@<T@>(s, x);
};

# Alloc --
#   Allocate n bits on the heap for use in an instance of this module.
(Int@) { Module@<Var@>; } Alloc = (Int@ n)(Read@ r, State@ s) {
  ModuleR@<Var@>(State@(Add(s.heap, n), s.modules, s.program), Local(s.heap));
};

<@ T@>(Int@)((Var@) { Module@<T@>; }) { Module@<T@>; }
DoAlloc = <@ T@>(Int@ n) { Do<Var@, T@>(Alloc(n)); };

# Method@ --
#   Method@ is used to represent a Call Stmt@.
#
# This is user documentation only. It is not enforced by the type system.
@ Method@ = Stmt@;

# Method --
#   Define a method of a module.
#
# Inputs:
#   name - the name of the method.
#   stmt - the body of the method.
(String@, Stmt@) { Module@<Method@>; }
Method = (String@ name, Stmt@ stmt)(Read@ r, State@ s) {
  String@ proc_id = Concat[r.name, Str|'.', name];
  
  Program@ program = r.define.?(
    true: {
      Int@ argc = Add(/List/Length%.Length<Var@>(r.args), Int|1);
      Proc@ proc = Proc@(proc_id, argc, stmt);
      Cons<Proc@>(proc, s.program);
    },
    false: s.program);

  Stmt@ call = Call(proc_id)(Cons<Var@>(r.this, r.args));
  ModuleR@<Method@>(State@(s.heap, s.modules, program), call);
};

<@ T@>(String@, Stmt@)((Method@) { Module@<T@>; }) { Module@<T@>; }
DoMethod = <@ T@>(String@ name, Stmt@ body) { Do<Stmt@, T@>(Method(name, body)); };

# MethodArgs --
#   Extract the concrete arguments to supply to a method call for a method
#   returned from running the top level module.
#
# If a method is returned from the top level module, its args should all be
# relative to the 'this' var with id 0, which refers to bit 0 of the heap of a
# top level module.
#
# Behavior is undefined if the given method is not from a top level module.
(Method@) { List@<Int@>; } MethodArgs = (Method@ method) {
  Map<Var@, Int@>(method.call.args, (Var@ v) {
    Unit@ _ = Eq(Int|0, v.id).true;  # Assert
    v.offset;
  });
};

# Run --
#   Runs a module, returning the generated program, the size of the heap
#   required by the module, and whatever the module returns.
<@>@ Ran@ = <@ T@> { *(Program@ program, Int@ heap, T@ x); };

<@ T@>(Module@<T@>) { Ran@<T@>; } Run = <@ T@>(Module@<T@> m) {
  ModuleR@<T@> mr = m(
    Read@(Str|'', Local(Int|0), Nil<Var@>, True),
    State@(Int|0, Nil<String@>, Nil<Proc@>));
  Ran@<T@>(mr.s.program, mr.s.heap, mr.x);
};

@(Module@, Method@, Ran@,
  Module0, Module1, Module2, Module3, Module4, Module5,
  Do, Return, Alloc, DoAlloc, Method, DoMethod, MethodArgs,
  Run);
