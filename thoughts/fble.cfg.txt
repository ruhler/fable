
Conditionally updating multiple variables is tedious in fble. Can we add some
form of conditional update to fble? That would improve a lot of things, for
example, in the Invaders Game Tick loop.

Things to keep in mind:
* We don't want to support in place updates of struct or union field values
  with an easy syntax, because that would imply the update is cheap when in
  reality it may require a copy of the entire value.
* Unlike struct and union field value updates, variable updates in a scope can
  be done in place cheaply, because there is only ever one user of the current
  scope (static variables not included).

So the idea is that a statement could either return a value, or modify the
values of (but not the types of) existing non-static local variables. And we
have a way to conditionally "execute" a statement.

* One interesting question is whether we require static knowledge of whether a
  statement returns a value vs. modifies local variables, or if that's
  something we could do one or the other based on dynamic values. The later is
  more general, and I could certainly make up use cases for it, but maybe that
  adds too much complexity to the code or the implementation that is better
  avoided?

When talking about conditional execution, if the body of the condition returns
a value, then we don't continue to the point after the condition. That's like
a return.

How might this look syntactically? How do the process statements interact with
this?

The current definition of stmt is very linear:

stmt ::=
   expr ';'
 | spec name '=' expr [',' spec name '=' expr [...]] ';' stmt        (* let *)
 | expr '.?(' name ':' expr [',' name ':' expr [...]] ')' ';' stmt   (* union_select *)
 | type name [',' type name [...]] '<-' expr ';' stmt                (* func_bind *)
 | type '~' name ',' name ';' stmt                                   (* proc_link *)
 | type name ':=' expr [',' type name ':=' expr [...]] ';' stmt      (* proc_exec *)
 ;

I guess the goal is to make it more like a (directed acyclic) graph of
conditional control flow?

* If we can modify the environment, any reason not to start supporting loops
  whose body just do a modification of the environment?

* This would also open up the question of uninitialized values, which we may
  want to support now.

---

Exploration, not worrying about proc for now.

A stmt either returns an expression or modifies values in the environment. It
can't do both.

stmt ::=
   expr ';'
     Returns the value of the expression in the environment.
 | spec name '=' expr [',' spec name '=' expr [...]] ';' stmt        (* let *)
     Same as normal let. Value of statement is value of body,
     new variables shadow any existing ones.
 | name '=' expr ';' 
     Update the value of a variable the environment.
 | expr '.?(' name ':' expr [',' name ':' expr [...]] ')' ';' stmt   (* union_select *)

For union select, we want the body of a branch to be stmt instead of expr.
Though expr could work as well. Which raises the question: what is it? A
statement or an expression? We could force it to be a stmt by requiring it be
a block.


So, we want an option for { stmt } to modify it's outer context. So why can't
an arbitrary expression modify its outer context? Then we have issues with
order of operations.

We want:
  name '=' expr ';' stmt, to update a variable in place.

We also want:
  expr '.?(' name ':' { name '=' expr ';' stmt }, ...) to conditionally update
  a variable.

But how do we distinguish between { name '=' expr ';' stmt } and expr?

Maybe we have something outside of the syntax do a check that says you can
only modify a variable in a limited set of contexts.

For example, in an expression that has a unique next statement to execute, or
where there is no ambiguity about order of operations?

For example, the following is fine:

Foo@ foo = a;
x.?(p: { foo = b; ... }, q: { foo = c; ... });

But the following is not:
Foo@ foo = a;
f(x.?(p: { foo = b; ... }, q: { foo = c; ... }), x.?(p: { foo = c; ... }, ...))

Because we don't know the order of operations. In other words, the validity of
an expression depends on the context where it is used.

