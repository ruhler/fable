
@ Bool@ = /Core/Bool%.Bool@;
% True = /Core/Bool%.True;
% False = /Core/Bool%.False;

@ Int@ = /Core/Int%.Int@;
% Add = /Core/Int%.Add;
% Sub = /Core/Int%.Sub;
% Decr = /Core/Int%.Decr;
% IsZero = /Core/Int/Eq%.IsZero;
% Le = /Core/Int/Eq%.Le;
% Div = /Core/Int/Div%.Div;
% Range = /Core/Int/Iter%.Range;
% CountUpTo = /Core/Int/Iter%.CountUpTo;

<<@>@>@ Monad@ = /Core/Monad%.Monad@;

<@>% Cons = /Core/List%.Cons;
<@>% Nil = /Core/List%.Nil;
<@>% List = /Core/List%.List;
% Take = /Core/List/Length%.Take;

@ VarId@ = /SatGame/Puzzle%.VarId@;
@ Var@ = /SatGame/Puzzle%.Var@;
@ Clause@ = /SatGame/Puzzle%.Clause@;
@ Params@ = /SatGame/Puzzle%.Params@;
@ Puzzle@ = /SatGame/Puzzle%.Puzzle@;

<<@>@>@ Random@ = /SatGame/Random%.Random@;
<<@>@>% RandInt = /SatGame/Random/Int%.RandInt;
<<@>@>% Shuffle = /SatGame/Random/List%.Shuffle;

# @func[Generate] Generates a random satgame puzzle.
#  @arg[<@>@][M@] Type of monad to use for random number generation.
#  @arg[Monad@<M@>][m] Monad to use for random number generation.
#  @arg[Random@<M@>][rand] Random number generator.
#  @arg[Params@][params] Parameters for the puzzle to generate.
#  @returns[M@<Puzzle@>] The generated puzzle.
<<@>@ M@>(Monad@<M@> m, Random@<M@> rand, Params@ params) {
  (VarId@) { M@<VarId@>; } RandVarId = RandInt(m, rand);

  (Int@) { M@<Var@>; } RandVar = (VarId@ max) {
    Bool@ pos <- m.do(rand.bool);
    VarId@ id <- m.do(RandVarId(max));
    m.return(Var@(id, pos));
  };

  (Clause@, VarId@) { Bool@; }
  ContainsVarId = (Clause@ c, VarId@ id) {
    c.?(nil: False);
    /Core/Int/Eq%.Eq(c.cons.head.id, id).?(true: True);
    ContainsVarId(c.cons.tail, id);
  };

  # Generates a random clause with variable v.
  (Params@, Var@) { M@<Clause@>; } GenClause = (Params@ params, Var@ v) {
    # Adds N random variables with id less than v.id to the given clause.
    (Int@, Clause@) { M@<Clause@>; } AddVars = (Int@ n, Clause@ c) {
      IsZero(n).?(true: m.return(c));

      Var@ var <- m.do(RandVar(v.id));
      ContainsVarId(c, var.id).?(true: AddVars(n, c));
      AddVars(Decr(n), Cons(var, c));
    };

    Clause@ clause <- m.do(AddVars(Decr(params.num_vars_per_clause), List[v]));
    Shuffle(m, rand, clause);
  };
    
  Le(params.num_vars, params.num_vars_per_clause).?(true: {
    # We can't generate a puzzle unless we have more vars to work with than
    # vars per clause.
    % TooFewVars = /Core/Undef%.Undef<M@<Puzzle@>>;
    TooFewVars.undefined;
  });

  Int@ num_free_vars = Sub(params.num_vars, params.num_vars_per_clause);
  Int@ clauses_per_variable = Div(Decr(Add(params.num_clauses, num_free_vars)), num_free_vars).q;

  Puzzle@ puzzle <- m.do(/Core/Iter%.For(
    Range(params.num_vars_per_clause, params.num_vars), m.return(Nil<Clause@>),
    (VarId@ vid, M@<Puzzle@> mp) {
      Bool@ pos <- m.do(rand.bool);
      Var@ var = Var@(vid, pos);
      /Core/Iter%.For(CountUpTo(clauses_per_variable), mp,
        (Int@ _, M@<Puzzle@> mp) {
          Puzzle@ tail <- m.do(mp);
          Clause@ clause <- m.do(GenClause(params, var));
          m.return(Cons(clause, tail));
        });
    }));
  Puzzle@ shuffled <- m.do(Shuffle(m, rand, puzzle));
  m.return(Take(params.num_clauses, shuffled));
};
