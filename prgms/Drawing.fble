
@ Unit@ = /Unit%.Unit@;
% Unit = /Unit%.Unit;

@ Int@ = /Int/Int%.Int@;
% Add = /Int/Int%.Add;
% Mul = /Int/Int%.Mul;
% Int = /Int/Int/Lit%.Int;

<@>@ List@ = /List%.List@;
<@>% List = /List%.List;
<@,@>% Map = /List%.Map;

@ Color@ = +(
  Unit@ black,
  Unit@ red,
  Unit@ green,
  Unit@ yellow,
  Unit@ blue,
  Unit@ magenta,
  Unit@ cyan,
  Unit@ white);

@ Point@ = *(Int@ x, Int@ y);

@ Drawing@ = +(
  # A blank (transparent) drawing.
  Unit@ blank,
  
  # A filled path.
  #
  # The path is implicitly closed. For example, to draw a rectangle, give the
  # four corner points in order, such as: [(0, 0), (2, 0), (2, 2), (0, 2)].
  *(List@<Point@> points, Color@ color) path,

  # Draw one drawing over another.
  *(Drawing@ below, Drawing@ above) over
);

# Transform@ --
#   Represents an affine transformation of the form a*x + b.
@ Transform@ = *(Point@ a, Point@ b);

# Draw@ --
#   An API for drawing that keeps track of the current transformation stack.
@ Draw@ = (Transform@) { Drawing@; };

# Transform --
#   Transforms a point using the given transformation.
(Transform@)(Point@) { Point@; } Transform = (Transform@ t)(Point@ p) {
  @(x: Add(Mul(t.a.x, p.x), t.b.x),
    y: Add(Mul(t.a.y, p.y), t.b.y));
};

Draw@ Blank = (Transform@ _) { Drawing@(blank: Unit); };

# Draw a path filled solid with the given color.
#
# The path is implicitly closed. For example, to draw a rectangle, give the
# four corner points in order, such as: [(0, 0), (2, 0), (2, 2), (0, 2)].
(List@<Point@>, Color@) { Draw@; } Path = (List@<Point@> points, Color@ color)(Transform@ t) {
  Drawing@(path: @(
      points: Map<Point@, Point@>(points, Transform(t)),
      color: color));
};

# Draw a rectangle filled solid with the given color.
(Int@, Int@, Int@, Int@, Color@) { Draw@; }
Rect = (Int@ x, Int@ y, Int@ w, Int@ h, Color@ color) {
  Path(List<Point@>[
    Point@(x, y),
    Point@(Add(x, w), y),
    Point@(Add(x, w), Add(y, h)),
    Point@(x, Add(y, h))], color);
};

# Compose two drawings together by drawing one over another.
(Draw@, Draw@) { Draw@; } Over = (Draw@ below, Draw@ above)(Transform@ t) {
  Drawing@(over: @(below: below(t), above: above(t)));
};

# Combing a list of drawings into a single drawing by drawing each subsequent
# drawing on top of the previous drawing.
(List@<Draw@>) { Draw@; } Drawings = (List@<Draw@> drawings) {
  drawings.?(
    cons: Over(drawings.cons.head, Drawings(drawings.cons.tail)),
    nil: Blank);
};

# Transform the drawing using an affine transform. Each point p will be
# transformed to (a.x*p.x + b.x, a.y*p.y + b.y).
(Point@, Point@, Draw@) { Draw@; }
Affine = (Point@ a, Point@ b, Draw@ d)(Transform@ t) {
  Transform@ nt = @(
    a: @(x: Mul(t.a.x, a.x), y: Mul(t.a.y, a.y)),
    b: @(x: Add(Mul(t.a.x, b.x), t.b.x), y: Add(Mul(t.a.y, b.y), t.b.y)));
  d(nt);
};

# Translate the drawing by the given x and y amounts.
(Int@, Int@, Draw@) { Draw@; }
Translate = (Int@ dx, Int@ dy, Draw@ d) {
  Affine(@(x: Int|1, y: Int|1), @(x: dx, y: dy), d);
};

# Render a drawing directly without any transformation.
(Draw@) { Drawing@; } Draw = (Draw@ d) {
  Transform@ t = @(a: @(x: Int|1, y: Int|1), b: @(x: Int|0, y: Int|0));
  d(t);
};

@(Color@, Drawing@, Draw@, Point@,
  Blank, Path, Rect, Over, Drawings, Affine, Translate, Draw);
