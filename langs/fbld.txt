Damocrates is a meta-language built on top of Androcles, Bathylus, and Calvisus
designed to be programmed by human, with features for modularity and
development.

Damocrates should be statically compilable into Androcles/Bathylus/Calvisus.
Abstractions introduced by the Damocrates language should be zero-cost in the
sense that they will have no overhead at runtime after compiling the program
down to Androcles/Bathylus/Calvisus. The developer should not have to make a
tradeoff between modularity/abstraction and runtime performance.

Overview
--------
Damocrates adds support for modularity and polymorphism on top of the
Calvisus language. The purpose of these features is to facilitate reuse of
code across multiple programs, expanding the scale of programs that can be
developed.

Fbld shifts a focus on implementing programs that exists in fblc to a focus on
implementing reusable pieces of programs. These pieces of programs are called
modules. A module is a collection of types, functions, processes and other
modules.

For example, many programs make use of some form of integer arithmetic. Rather
than reimplementing and retesting integer arithmetic for each program, a single
integer arithmetic module can be developed and reused. The integer arithmetic
module will define an integer type and functions that operate on integer
values.

To effectively reuse a piece of code, it must be easy to understand what
that code does at a high level and how it should be used; it should not be
important to understand implementation details of the code. Fbld has the
notion of a module interface, which provides an abstract view of the code
provided by a module to make it easy for users to make use of the module
without having to understand extraneous implementation details.

For example, the integer arithmetic module could be used knowing there is some
type Int with operations to add two Ints together, but the user need not know
whether the Int type is implemented using a unary, binary, 2s-complement or
other representation.

Interfaces allow modules to be developed independent of their use and reused
independent of their development. Modules can be understood and developed in
isolation then combined to form large programs that would otherwise be too
complex and costly to develop.

Interfaces make it possible to write code that is agnostic to the details of
how types, functions, and processes are defined and implemented. To take full
advantage of this, fbld adds support for polymorphic declarations, which
allow code to be reused in multiple different contexts with different
definitions of the types, functions, and processes it interfaces with within
the same program. Polymorphism is supported by allowing types and interfaces
to be parameterized by types and allowing funcs, procs, and modules to be
parameterized by by types and other modules.

For example, there are common data structures, such as lists, which can be
used with many different element types. Fbld's polymorphism allows a
list type to be defined that is a function of a given type parameter.
Basic list functions can be defined that can be reused for lists of Ints,
lists of booleans, lists of lists, or lists of any other type. This is a form
of parametric polymorphism.

As another example, some computation involving numbers can be defined that
works on any type of number satisfying a required set of operations. A module
involving polynomials, for example, could be reused with natural numbers,
integers, real numbers, or booleans. This is a form of ad-hoc polymorphism.

Concepts
--------
Fbld adds two new constructs to fblc: modules and interfaces.

A module defines a collection of types, functions, processes and submodules.
Each module implements some interface.

An interface is an abstraction of a module that includes only type, function,
process and submodule declarations, without their implementations. For a
module to properly implement an interface, every type, function, and process
declared in the interface must have a corresponding implementation supplied by
the module.

Interfaces
----------
mtype <interface_name> ['<' <type_parameters> '>'] {
  <interface_declarations>
};

Interfaces are named. They take zero or more type parameters and contain zero
or more interface_declaration elements. Type parameters, if present, are
specified using a comma-separated list of simple names. These names can be
used within the interface_declarations to refer to the types passed to the
interface when the interface is instantiated.

Angle brackets are used to denote interface and module parameters, analogous to
how parentheses are used to denote function parameters.

There are 8 kinds of interface_declaration items: using, type, struct, union,
func, proc, mtype, and mdefn.

Qualified References
^^^^^^^^^^^^^^^^^^^^
A module serves as a namespaces. Entities defined in different modules can
have the same name. In order to reference an entity from an external module,
both the name of the entity and the name of the external module must be
supplied using a qualified reference taking the form <name>@<mref>. For
example, to refer to a function 'True' in a module named Bool that takes no
type or module parameters:
   True@Bool

The 'using' declaration described later allows external entities to be
imported under local names, which can greatly reduce the quantity of syntax
needed to describe references to external entities.

Interfaces and modules must not recursively reference any other modules. In
other words, the graph of interface and module dependencies should be a
directed acyclic graph. The reason for this is to avoid complex and confusing
module dependencies that would make it difficult to reason about or understand
a module in isolation.

Using Declarations
^^^^^^^^^^^^^^^^^^
The 'using' declaration provides a syntactic sugar to make it easier to refer
to entities declared within another module. Each 'using' declaration creates
a simple local alias for one or more entities from an another module.

By default entities are imported using the same name they are declared with,
but it is possible to specify an alternate name when importing an entity in
order to avoid name conflicts.

For example:
  using Bool { Bool; true=True; false=False; };

The above statement imports three entities from the Bool module. In this case
the Bool module does not have any type parameters, so no type arguments are
provided. If the module has type parameters, then type arguments must be
specified for every type parameter. The entities that are imported are
specific to the type arguments provided.

Following the module is a list of entities to give local names to, each entity
terminated with a semicolon. The entity can either be a single name,
indicating that entity from the module is being imported under its same name,
and can be referred to elsewhere by that simple name. Or the entity can have
the form 'name' = 'name', where the first name is the name the entity is
imported under, and the second name is the name of the entity as declared in
the module it is being imported from.

Type and module parameters do not need to be supplied in the using statement
for imported polymorphic entities. The locally imported names will refer to
polymorphic entities that can be used with different type and module
parameters within the local name space. For example, a List type could be
imported once from the List module, then used locally as List<Int>,
List<Bool>, or any other kind of list.

It is legal to have multiple using statements for the same concrete module and
to import the same external entity multiple times under the same or different
names, either within a single using statement or spanning across multiple
using statements for the same concrete module. It is not required to have a
using statement for all references to external entities.

TODO: What if a module declares a function, mtype, and mdefn all with the same
name and you import that name with a using statement. Do you get all three
entities imported?

Struct and Union Declarations
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Struct and union declarations are as in fblc, except that they now support
polymorphic type parameters and can reference qualified types from other
modules.

For example, a generic Maybe type can be declared using a polymorphic struct
declaration:

   struct Maybe<T>(T just, Unit nothing);

To refer to a concrete instance of the Maybe type, a type argument must be
supplied. For example, Maybe<Bool> could be used for an optional Bool and
Maybe<Int> could be used for an optional Int.

Struct and union declarations may refer to types from other modules. For
example, if the Int type is declared in a separate Integer module, a
Coord type could be defined:
   
   struct Coord(Int@Integer x, Int@Integer y); 

Struct and union declarations can appear in both module interfaces and module
definitions. If a struct or union declaration appears in a module interface,
it must appear verbatim in any module definition that implements that
interface. This can be interpreted as saying the struct declaration in the
interface specifies the interface for constructing and deconstructing the
type, while the corresponding declaration in the module definition is a
unique definition of the type. If two different modules ModuleA and ModuleB
implement the same interface Interface, and that interface includes a struct
or union declaration Foo, then Foo@ModuleA is considered a different type from
Foo@ModuleB.

An abstract type declaration can be used in an interface rather than a struct
or type declaration to represent an abstract type without providing module
users with an interface to construct or deconstruct the type. See the section
on abstract type declarations for more information.

Abstract Type Declarations
^^^^^^^^^^^^^^^^^^^^^^^^^^
The 'type' declaration is used to declare an abstract type that is defined
internally by modules implementing the interface. For example:

   type Int;

Defines an abstract Int type. The 'Int' type can be used anywhere a type is
expected. Values of abstract types cannot be used as objects of member access
or arguments to conditional expressions or processes.

Abstract types may be parameterized by types. For example, an abstract
implementation of a list type could be declared as:
   type List<T>;

Modules
--------
mdefn <module_name> ['<' <type_parameters> ; <module_parameters> '>'] '(' <interface> ')' {
  <module_declarations>
};

Module are named. Modules have zero or more type parameters and module
parameters. The type parameters are as in interfaces, a comma separate list of
simple names of types that can be referred to from within the module.

Module names belong to a different namespace than interface names. It is
acceptable to have a module with the same name as an interface. This is common
practice for interfaces that are expected to have a single implementation.

Each module parameter is specified as an interface and a module parameter
name. The module parameter can be used by providing any concrete module that
implements the given interface. Module parameters may refer to the type
parameters of the module.

Every module implements a specific interface. This means the module will
provide definitions for all components declared in the interface. The
concrete interface specification can refer to type parameters and module
parameter types.

TODO: Give a range of interesting concrete examples here.

Following the module declaration is a list of module declaration items. These
include 'using', 'struct', 'union', 'func', 'proc' , 'mtype' and 'mdefn'
declarations. The 'using' declaration is as for module interfaces. The
'union', 'func', and 'proc' declarations are as for fblc with additional
support for qualified references to external entities.

Syntax Reference
----------------
  mtype ::= 'mtype' iname ['<' [tname [',' tname [...]]] '>'] '{'
                [mtype_decl [mtype_decl [...]]] '}' ';' ;

  mdefn ::= 'mdefn' mname ['<'[tname [',' tname [...]]] ';'
                              [iref mname [',' iref mname [...]]] '>']
                          '(' iref ')' '{'
                [mdefn_decl [mdefn_decl [...]]] '}' ';' ;

  iref ::= iname ['<' [qref [',' qref [...]]] '>'] ;
         | iref '@' mref

  mref ::= mname ['<' [qref [',' qref [...]]] '; [mref [',' mref [...]]] '>']
         | mref '@' mref
         ;
          

  qref ::= tname ['@' mref] ;
  
  mtype_decl ::= 'using' mref '{' [tname ['=' tname]; [tname ['=' tname]; [...]]] '}' ';'
              |  'type' tname ';'
              |  'struct' tname '(' [qref fname [',' qref fname [...]]] ')' ';'
              |  'union' tname '(' [qref fname [',' qref fname [...]]] ')' ';'
              |  'func' tname '(' [qref vname [',' qref vname [...]]] ';' qref ')' ';'
              |  'proc' tname '('
                    [qref polarity pname [',' qref polarity pname [...]]] ';'
                    [qref vname [',' qref vname [...]]] ';' qref ')' ';'
              |  mtype
              |  'mdefn' mname ['<'[tname [',' tname [...]]] ';'
                                   [iref mname [',' iref mname [...]]] '>']
                              '(' iref ')' ';'
              ;

  mdefn_decl ::= 'using' mref '{' [tname ['=' tname]; [tname ['=' tname]; [...]]] '}' ';'
              |  'struct' tname '(' [qref fname [',' qref fname [...]]] ')' ';'
              |  'union' tname '(' [qref fname [',' qref fname [...]]] ')' ';'
              |  'func' tname '(' [qref vname [',' qref vname [...]]] ';' qref ')' expr ';'
              |  'proc' tname '('
                    [qref polarity pname [',' qref polarity pname [...]]] ';'
                    [qref vname [',' qref vname [...]]] ';' qref ')' proc ';'
              |  mtype
              |  mdefn
              ;

  iname ::= name ;  (* A name referring to an interface *)
  mname ::= name ;  (* A name referring to a module *)

  expr ::= ... (* as in fblc, with qref in place of tname *)
  proc ::= ... (* as in fblc, with qref in place of tname *)

  polarity ::= ... (* as in fblc *)
  fname ::= ... (* as in fblc *)
  pname ::= ... (* as in fblc *)
  tname ::= ... (* as in fblc *)
  vname ::= ... (* as in fblc *)

TODO
----
* Finish this spec!
 - Talk about how polymorphism works for types, funcs, processes
 - Talk about what it means to have submodules, what the restrictions are on
   recursion, and what entities are visible.
 - Give interesting examples for polymorphic and submodules.


Open Questions
--------------
* Can you import the same entity multiple times under a different name in the
  same using statement?
* Can you have multiple using statements for the same (concrete) module?
* Can you import the same entity multiple times under a different name in
  different using statements?
* Can you import public entities from your own module in using statements?
* Can you import private entities from your own module in using statements?
* Can you import funcs or procs in an mtype's using statement, or only
  types?
* Can you use an imported type in the import's module parameter?
  For example, something like: using Maybe(T) { T=Maybe };

Wish List
---------
* Some way to create a variable sized object that doesn't require O(N) 
  open-paren/close-paren pairs. For example, have a 'list' literal or varargs
  function. This would be useful when defining a list of test cases, for
  example.

* Builtin support for arrays? For example, it's pretty daunting to think about
  how to define a large 2D array. Or how to define an array for a HashTable
  implementation. Use case and alternatives not fully explored yet.

* There's no way currently to define a private module. This means it is not
  possible to re-use polymorphic code on private data types. For example:
  Snake defines a private data type Pos with associated PosEq function. It
  would be great if it could reuse a polymorphic List find function, but it
  can't define the Eq instance for Pos without making Pos a public data type.

  Example: I want to implement a generic List map function, but that requires
  defining a separate module for the function argument any time I want to use
  the map function, which is prohibitively ridiculous.

  This is clearly a flaw in the language that should be addressed.
