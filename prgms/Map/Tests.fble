
@ Bool@ = /Bool%.Bool@;
% True = /Bool%.True;
% False = /Bool%.False;
% And = /Bool%.And;
@ Char@ = /Char%.Char@;
% Chars = /Char%.Chars;
<@>@ Eq@ = /Eq%.Eq@;
<@>@ List@ = /List%.List@;
<@>% List = /List%.List;
<@>% Append = /List%.Append;
<@>% Nil = /List%.Nil;
<@>% Cons = /List%.Cons;
<@>@ Maybe@ = /Maybe%.Maybe@;
<@>% Just = /Maybe%.Just;
<@>% Nothing = /Maybe%.Nothing;
<@>@ Show@ = /Show%.Show@;
@ String@ = /String%.String@;
% Str = /String%.Str;
% UnitS = /Structure%.UnitS;
% LeftS = /Structure%.LeftS;
% RightS = /Structure%.RightS;
% PairS = /Structure%.PairS;
<@>@ Structured@ = /Structured%.Structured@;
@ Test@ = /Test%.Test@;
% Test = /Test%.Test;
% TestSuite = /Test%.TestSuite;
<@>% AssertEquals = /Test%.AssertEquals;
@ Unit@ = /Unit%.Unit@;
% Unit = /Unit%.Unit;

@ Bit1@ = +(Unit@ 0, Unit@ 1);
@ Bit2@ = *(Bit1@ h, Bit1@ l);

Bit2@ A = Bit2@(Bit1@(0: Unit), Bit1@(0: Unit));
Bit2@ B = Bit2@(Bit1@(0: Unit), Bit1@(1: Unit));
Bit2@ C = Bit2@(Bit1@(1: Unit), Bit1@(0: Unit));

Eq@<Bit1@> EqBit1 = (Bit1@ a, Bit1@ b) {
  a.?(
    0: b.?(0: True, 1: False),
    1: b.?(0: False, 1: True));
};

Show@<Bit1@> ShowBit1 = (Bit1@ x) {
  Str(x.?(0: Chars|0, 1: Chars|1));
};

Eq@<Bit2@> EqBit2 = (Bit2@ a, Bit2@ b) {
  And(EqBit1(a.h, b.h), EqBit1(a.l, b.l));
};

Show@<Bit2@> ShowBit2 = (Bit2@ x) {
  Append<Char@>(ShowBit1(x.h), ShowBit1(x.l));
};

Structured@<Bit2@> Bit2S = (Bit2@ x) {
  PairS(
    x.h.?(0: LeftS(UnitS), 1: RightS(UnitS)),
    x.l.?(0: LeftS(UnitS), 1: RightS(UnitS)));
};

<@>@ Map@ = /Map%.Map@<Bit2@>;
<@>% Empty = /Map%.Empty<Bit2@>;
<@>% Lookup = /Map%.Lookup<Bit2@>(Bit2S);
<@>% Insert = /Map%.Insert<Bit2@>(Bit2S);
<@>% Delete = /Map%.Delete<Bit2@>(Bit2S);
<@,@>% ForEach = /Map%.ForEach<Bit2@>;

Test@ Tests = TestSuite(Chars|Map, [
  Test(Chars|'empty', !({
    Maybe@<Unit@> wnt = Nothing<Unit@>;
    Maybe@<Unit@> got = Lookup<Unit@>(Empty<Unit@>, B);
    AssertEquals<Maybe@<Unit@>>(
      /Maybe/Eq%.Eq<Unit@>(/Unit/Eq%.Eq),
      /Maybe/Show%.Show<Unit@>(/Unit/Show%.Show),
      wnt, got);
  })),

  Test(Chars|'not found', !({
    Map@<Unit@> map = Insert<Unit@>(Empty<Unit@>, C, Unit);
    Maybe@<Unit@> wnt = Nothing<Unit@>;
    Maybe@<Unit@> got = Lookup<Unit@>(map, B);
    AssertEquals<Maybe@<Unit@>>(
      /Maybe/Eq%.Eq<Unit@>(/Unit/Eq%.Eq),
      /Maybe/Show%.Show<Unit@>(/Unit/Show%.Show),
      wnt, got);
  })),

  Test(Chars|'found', !({
    Map@<Bool@> map = Insert<Bool@>(Insert<Bool@>(Insert<Bool@>(Empty<Bool@>,
      A, False),
      B, True),
      C, False);
    Maybe@<Bool@> wnt = Just<Bool@>(True);
    Maybe@<Bool@> got = Lookup<Bool@>(map, B);
    AssertEquals<Maybe@<Bool@>>(
      /Maybe/Eq%.Eq<Bool@>(/Bool/Eq%.Eq),
      /Maybe/Show%.Show<Bool@>(/Bool/Show%.Show),
      wnt, got);
  })),

  Test(Chars|'replace', !({
    Map@<Bool@> map = Insert<Bool@>(Insert<Bool@>(Empty<Bool@>,
      B, False),
      B, True);
    Maybe@<Bool@> wnt = Just<Bool@>(True);
    Maybe@<Bool@> got = Lookup<Bool@>(map, B);
    AssertEquals<Maybe@<Bool@>>(
      /Maybe/Eq%.Eq<Bool@>(/Bool/Eq%.Eq),
      /Maybe/Show%.Show<Bool@>(/Bool/Show%.Show),
      wnt, got);
  })),

  Test(Chars|'delete', !({
    Map@<Bool@> map = Delete<Bool@>(Insert<Bool@>(Empty<Bool@>, B, False), B);
    Maybe@<Bool@> wnt = Nothing<Bool@>;
    Maybe@<Bool@> got = Lookup<Bool@>(map, B);
    AssertEquals<Maybe@<Bool@>>(
      /Maybe/Eq%.Eq<Bool@>(/Bool/Eq%.Eq),
      /Maybe/Show%.Show<Bool@>(/Bool/Show%.Show),
      wnt, got);
  })),

  Test(Chars|'foreach', !({
    Map@<Bool@> map = Insert<Bool@>(Insert<Bool@>(Insert<Bool@>(Empty<Bool@>,
      B, True),
      A, True),
      B, False);

    # Note: A < B, we expect the ForEach to iterate in the order A, B. Because
    # we add A to the end of the list before B, we expect the resulting list
    # to be in the order B, A.
    @ Entry@ = *(Bit2@ key, Bool@ value);
    List@<Entry@> wnt = List<Entry@>([Entry@(B, False), Entry@(A, True)]);
    List@<Entry@> got = ForEach<Bool@, List@<Entry@>>(map, Nil<Entry@>,
      (Bit2@ k, Bool@ v, List@<Entry@> l) {
        Cons<Entry@>(Entry@(k, v), l);
      });
    AssertEquals<List@<Entry@>>(
      /List/Eq%.Eq<Entry@>((Entry@ a, Entry@ b) {
        And(EqBit2(a.key, b.key), /Bool/Eq%.Eq(a.value, b.value));
      }),
      /List/Show%.Show<Entry@>((Entry@ e) {
        /String%.Concat(List<String@>([
            ShowBit2(e.key),
            Str(Chars|': '),
            /Bool/Show%.Show(e.value)
            ]));
      }),
      wnt, got);
  })),

  Test(Chars|'eq: equal', !({
    Map@<Bool@> a = Insert<Bool@>(Insert<Bool@>(Insert<Bool@>(
          Empty<Bool@>, A, True), B, False), C, False);
    Map@<Bool@> b = Insert<Bool@>(Insert<Bool@>(Insert<Bool@>(
          Empty<Bool@>, A, True), B, False), C, False);

    Bool@ wnt = True;
    Bool@ got = /Map/Eq%.Eq<Bit2@, Bool@>(/Bool/Eq%.Eq)(a, b);
    AssertEquals<Bool@>(/Bool/Eq%.Eq, /Bool/Show%.Show, wnt, got);
  })),

  Test(Chars|'eq: value mismatch', !({
    Map@<Bool@> a = Insert<Bool@>(Insert<Bool@>(Insert<Bool@>(
          Empty<Bool@>, A, True), B, True), C, False);
    Map@<Bool@> b = Insert<Bool@>(Insert<Bool@>(Insert<Bool@>(
          Empty<Bool@>, A, True), B, False), C, False);

    Bool@ wnt = False;
    Bool@ got = /Map/Eq%.Eq<Bit2@, Bool@>(/Bool/Eq%.Eq)(a, b);
    AssertEquals<Bool@>(/Bool/Eq%.Eq, /Bool/Show%.Show, wnt, got);
  })),

  Test(Chars|'eq: different number of elements', !({
    Map@<Bool@> a = Insert<Bool@>(Insert<Bool@>(Insert<Bool@>(
          Empty<Bool@>, A, True), B, False), C, False);
    Map@<Bool@> b = Insert<Bool@>(Insert<Bool@>(Empty<Bool@>, A, True), B, False);

    Bool@ wnt = False;
    Bool@ got = /Map/Eq%.Eq<Bit2@, Bool@>(/Bool/Eq%.Eq)(a, b);
    AssertEquals<Bool@>(/Bool/Eq%.Eq, /Bool/Show%.Show, wnt, got);
  })),

  Test(Chars|'eq: deleted to empty', !({
    Map@<Bool@> a = Delete<Bool@>(Insert<Bool@>(Empty<Bool@>, A, True), A);
    Map@<Bool@> b = Empty<Bool@>;

    Bool@ wnt = True;
    Bool@ got = /Map/Eq%.Eq<Bit2@, Bool@>(/Bool/Eq%.Eq)(a, b);
    AssertEquals<Bool@>(/Bool/Eq%.Eq, /Bool/Show%.Show, wnt, got);
  })),

  Test(Chars|'eq: empty from deleted', !({
    Map@<Bool@> a = Empty<Bool@>;
    Map@<Bool@> b = Delete<Bool@>(Insert<Bool@>(Empty<Bool@>, A, True), A);

    Bool@ wnt = True;
    Bool@ got = /Map/Eq%.Eq<Bit2@, Bool@>(/Bool/Eq%.Eq)(a, b);
    AssertEquals<Bool@>(/Bool/Eq%.Eq, /Bool/Show%.Show, wnt, got);
  })),

  Test(Chars|'eq: empty from deleted pair second', !({
    Map@<Bool@> a = Insert<Bool@>(Empty<Bool@>, A, True);
    Map@<Bool@> b = Delete<Bool@>(Insert<Bool@>(a, B, True), B);

    Bool@ wnt = True;
    Bool@ got = /Map/Eq%.Eq<Bit2@, Bool@>(/Bool/Eq%.Eq)(a, b);
    AssertEquals<Bool@>(/Bool/Eq%.Eq, /Bool/Show%.Show, wnt, got);
  })),

  Test(Chars|'eq: empty from deleted pair first', !({
    Map@<Bool@> a = Insert<Bool@>(Empty<Bool@>, A, True);
    Map@<Bool@> b = Delete<Bool@>(Insert<Bool@>(a, C, True), C);

    Bool@ wnt = True;
    Bool@ got = /Map/Eq%.Eq<Bit2@, Bool@>(/Bool/Eq%.Eq)(a, b);
    AssertEquals<Bool@>(/Bool/Eq%.Eq, /Bool/Show%.Show, wnt, got);
  })),

  Test(Chars|'eq: equal any order', !({
    Map@<Bool@> a = Insert<Bool@>(Insert<Bool@>(Insert<Bool@>(
          Empty<Bool@>, B, False), C, False), A, True);
    Map@<Bool@> b = Insert<Bool@>(Insert<Bool@>(Insert<Bool@>(
          Empty<Bool@>, A, True), B, False), C, False);

    Bool@ wnt = True;
    Bool@ got = /Map/Eq%.Eq<Bit2@, Bool@>(/Bool/Eq%.Eq)(a, b);
    AssertEquals<Bool@>(/Bool/Eq%.Eq, /Bool/Show%.Show, wnt, got);
  })),

  Test(Chars|'Show empty', !({
    Map@<Bool@> map = Empty<Bool@>;
    String@ wnt = Str(Chars|'{ }');
    String@ got = /Map/Show%.Show<Bit2@, Bool@>(ShowBit2, /Bool/Show%.Show)(map);
    AssertEquals<String@>(/String/Eq%.Eq, /String/Show%.Show, wnt, got);
  })),

  Test(Chars|'Show single', !({
    Map@<Bool@> map = Insert<Bool@>(Empty<Bool@>, B, False);
    String@ wnt = Str(Chars|'{ 01 => False; }');
    String@ got = /Map/Show%.Show<Bit2@, Bool@>(ShowBit2, /Bool/Show%.Show)(map);
    AssertEquals<String@>(/String/Eq%.Eq, /String/Show%.Show, wnt, got);
  })),

  Test(Chars|'Show multi', !({
    Map@<Bool@> map = Insert<Bool@>(Insert<Bool@>(Empty<Bool@>, B, False), C, True);
    String@ wnt = Str(Chars|'{ 01 => False; 10 => True; }');
    String@ got = /Map/Show%.Show<Bit2@, Bool@>(ShowBit2, /Bool/Show%.Show)(map);
    AssertEquals<String@>(/String/Eq%.Eq, /String/Show%.Show, wnt, got);
  }))
]);

@(Tests);
