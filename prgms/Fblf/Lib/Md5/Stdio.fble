
% True = /Bool%.True;

% Compile = /Fblf/Compile%.Compile;

@ Output@ = /Fblf/Compile/Output%.Output@;
% Do = /Fblf/Compile/Output%.Do;
% Return = /Fblf/Compile/Output%.Return;
% Output = /Fblf/Compile/Output%.Output;

@ Md5@ = /Fblf/Lib/Md5%.Md5@;
% Md5M = /Fblf/Lib/Md5%.Md5;

<@>@ Ran@ = /Fblf/Module%.Ran@;
@ Method@ = /Fblf/Module%.Method@;
<@>% Module0 = /Fblf/Module%.Module0;
<@>% Run = /Fblf/Module%.Run;
<@>% DoAlloc = /Fblf/Module%.DoAlloc;
<@>% DoMethod = /Fblf/Module%.DoMethod;
<@,@>% DoInst = /Fblf/Module%.DoInst;

@ Var@ = /Fblf/Program%.Var@;

% Int = /Int/Int/Lit%.Int;

<@>@ Maybe@ = /Maybe%.Maybe@;

<@>@ Get@ = /Process%.Get@;
<@>@ Put@ = /Process%.Put@;

@ Stdio@ = /Stdio%.Stdio@;

@ String@ = /String%.String@;
% Str = /String%.Str;

@ Unit@ = /Unit%.Unit@;
% Unit = /Unit%.Unit;

Stdio@ Md5 = (Get@<Maybe@<String@>> _, Put@<String@> put) {
  Ran@<Unit@> ran = Run<Unit@>(Module0<Unit@>(Str|'Md5Stdio', {
    Var@ input <- DoAlloc<Unit@>(Int|8);
    Var@ hash <- DoAlloc<Unit@>(Int|128);
    Md5@ md5 <- DoInst<Md5@, Unit@>(Md5M(input, hash));

    # We have to re-export the methods to make them relative to this module.
    Method@ reset <- DoMethod<Unit@>(md5.reset);
    Method@ feed <- DoMethod<Unit@>(md5.feed);
    Method@ finish <- DoMethod<Unit@>(md5.finish);
    /Fblf/Module%.Return<Unit@>(Unit);
  }));

  Output@ output = {
    Unit@ _ <- Do(Compile(ran.program));
    Return;
  };

  Unit@ _ := Output(put, output);

  !(True);
};

Md5;
