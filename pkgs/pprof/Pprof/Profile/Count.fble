
<@>@ List@ = /Core/List%.List@;
<@>% List = /Core/List%.List;
<@>% Concat = /Core/List%.Concat;
<@>% ForEach = /Core/List%.ForEach;

@ Location@ = /Pprof/Profile%.Location@;
@ Profile@ = /Pprof/Profile%.Profile@;
@ Sample@ = /Pprof/Profile%.Sample@;
@ Sequence@ = /Pprof/Profile%.Sequence@;

@ Value@ = /Pprof/Profile/Value%.Value@;
% 0 = /Pprof/Profile/Value%.0;
% Add = /Pprof/Profile/Value%.Add;

% LM = /Pprof/Profile/LocationMap%;

% IsSuffixOf = /Pprof/Profile/Sequence%.IsSuffixOf;
% IsSubsequenceOf = /Pprof/Profile/Sequence%.IsSubsequenceOf;

# @struct[Result@] Result of a profile count.
#  @field[List@<Int@>][self]
#   The count of metric values for samples where the sequence in question is a
#   suffix.
#  @field[List@<Int@>][total]
#   The count of metric values for samples where the sequence in question
#   appears anywhere in the sample.
@ Count@ = *(
  Value@ self,
  Value@ total
);

(Count@, Count@) { Count@; }
AddCount = (Count@ a, Count@ b) {
  @(self: Add(a.self, b.self), total: Add(a.total, b.total));
};

(Sequence@, Sample@) { Count@; }
CountSample = (Sequence@ seq, Sample@ s) {
  @(self: IsSuffixOf(seq, s.path).?(true: s.metrics, false: 0),
    total: IsSubsequenceOf(seq, s.path).?(true: s.metrics, false: 0));
};

(Sequence@, List@<Sample@>) { Count@; }
CountSamples = (Sequence@ seq, List@<Sample@> samples) {
  samples.?(nil: Count@(0, 0));
  Count@ tail = CountSamples(seq, samples.cons.tail);
  AddCount(CountSample(seq, samples.cons.head), tail);
};

(Sequence@, Profile@) { Count@; }
Count = (Sequence@ s, Profile@ p) {
  CountSamples(s, p.samples);
};

# Returns a count for every location L for the sequence prefix, L, suffix.
(Sequence@, Sequence@, Profile@) { LM.Map@<Count@>; }
Counts = (Sequence@ prefix, Sequence@ suffix, Profile@ profile) {
  ForEach(profile.locations, LM.Empty<Count@>,
    (Location@ loc, LM.Map@<Count@> m) {
      LM.Insert(m, loc.id, Count(Concat[prefix, List[loc.id], suffix], profile));
    });
};

@(Count@, Count, Counts);
