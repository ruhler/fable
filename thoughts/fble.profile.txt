Revisiting Fble Profiling
=========================
For two reasons:
1. We've hit the bug where we say AUTO_EXIT, but fail to do an ENTER right
after that, which messes up the stack and is producing bad profile data.

In this case because we do a tail call of a PUT value, and the PUT function
doesn't do a profile ENTER.

More generally, I've known that AUTO_EXIT is dangerous for a while and that we
should switch to REPLACE. Maybe now's the time to figure that out.

2. We ought to support profiling with compiled code. So that we can get rid of
the interpreter entirely if we want, and because we just ought to.

Let's start with (1).

To be clear about the bug, we have the following call structure:

R calls A
  A calls B
    B tail calls C
  A calls D

So the profile should say:
  R called A
  A called B, D
  B called C

Normally this is done as:

(init)              R
ENTER_A             R->A
ENTER B             R->A->B
AUTO_EXIT (B)       R->A->B
ENTER C             R->A->B->C
EXIT (C)            R->A
ENTER D             R->A->D
EXIT (D)            R->A
EXIT (A)            R

But in this case we don't have the ENTER C or EXIT (C). So instead we get:

(init)              R
ENTER_A             R->A
ENTER B             R->A->B
AUTO_EXIT (B)       R->A->B
ENTER D             R->A->B->D
EXIT (D)            R->A
EXIT (A)            R

And now it looks like B called D, when it did not.

The proposed fix is to replace AUTO_EXIT with REPLACE:

(init)              R
ENTER_A             R->A
ENTER B             R->A->B
REPLACE C           R->A(->B)->C
EXIT (C)            R->A
ENTER D             R->A->D
EXIT (D)            R->A
EXIT (A)            R

But that requires more coordination between B and C than we currently have
infrastructure for in the fble ISA. IN particular, B has to say if it's a tail
call or not, and C has to say what block is being called into.

---

I bet we've been running into this profiling issue unnoticed for a while now.

There are two places we use AUTO_EXIT in practice:
1. For exiting select expressions, where we know (by assumption between
compile.c and typecheck.c) that we will do an ENTER/EXIT around each branch.

2. For tail calls, where we don't know what function will be called, but we
assume (incorrectly) that the function will start with an ENTER call.

Regardless of whether we use AUTO_EXIT or REPLACE, it seems like we have to
require every function to have a profiling block associated with it. The
function we call has to mark when it exits, otherwise we can't properly track
instructions executed by the function. Unless we assume there will be no
samples in the body of the function?

The tricky part about this is how do we know what profiling block ID to use
for PUT and GET values, given those function's were not generated by the
compiler? More generally, how to handle any user constructed functions, where,
once again, the compiler didn't generate the function, so we don't know what
block ID to use for it?

Note that blocks are uniquely determined by name and location (because the
user couldn't tell the difference otherwise). Name alone is not enough. I see
in practice we have some blocks with the same names. May or may not be a bug,
but it doesn't seem unreasonable to have two blocks with the same name in
general.

I feel like we ought to just have every FbleExecutable* have a profile block
id associated with it. When you call it, that enters the profile block. When
you return from it, that exits the profile block. The executable can do it's
own enter/exit inside that if it wants to, the caller need not care.

For PUT and GET functions, it would be great for the profile block to be named
and located based on the link where they are declared. How about we require
the user to pass a block ID as input to FbleNewGetValue and
FbleNewPutValue?

For profiling with compilation, how about we say block ids in generated code
are relative to the FbleExecutable block, and we reserve the FbleExecutable
block id when we allocate the (top level) FbleExecutable. Perhaps an
FbleExecutable keeps track of how many profile block ids it wants.

Maybe we shouldn't be reallocating FbleExecutable for every new function in
the generated code...

That all sounds reasonable and doable to me. Add Profile as an argument to the
compiler generated linking function so we can add profiling block info then.

Is there any way we could turn off profiling for a function? Like have a
special profile ID that means: don't take stats on this transition, just keep
proper track of the stack. Then you could always use the special profile ID if
you don't want to support profiling. That would allow you to mix profiling
code with non-profiling code. And then we could make GET and PUT functions
non-profiling code to start. Which probably makes the most sense for them
anyway.

The last bit needed for profiling compiled code is a reasonably efficient way
to sample. In the interpreter we randomly sample about 0.1% of the time on
every instruction. Could we group instructions together somehow so we only
have to sample when we come into an instruction? But what if there are
multiple ENTER/EXITs in a block?

I suppose we could just emit a call to a Sample function before each
instruction, and worry about optimizing later. Yeah. That sounds good.

I wonder if this notion of a phantom block ID could be an easy fix for the
AUTO_EXIT issue? No. We would need a phantom EXIT call that corresponds to a
phantom REPLACE call, and that's what we are missing today.

---

How do we get to the end target?

End target:
* BlockId for each FbleExecutable.
* Call, TailCall do implicit ENTER, REPLACE.
* Return does implicit EXIT.
* May as well make the profiling ops into instructions instead of separate
  ops.
* Profile loaded as part of loading compiled code.
* Replace instead of AutoExit in profiling API.
* FbleExecutable block id relative block ids.
* PUT/GET block ID comes from Link instruction.
* Phantom block ID?

Certainly there are some parts of this I can do separately and incrementally.
For example:
* We can add an FbleProfileReplaceBlock function to wrap AutoExit + Enter.
 - And maybe figure out how to use that for union select?
* We can add PUT/GET block IDs from the instruction.
* We could turn PROFILE_OPs into FbleInstrs.

But the big one that sounds hard is requiring all FbleExecutable to have block
IDs and making other block id references relative to those block ids.

---

While I'm at it, perhaps I should clean up handling of profiling in
typecheck.c versus compile.c? I feel like typecheck.c has the job of giving
labels and locations for those expressions we want to wrap in profiling blocks
while compile has the job of actually emitting the profiling ops. Might work
better if the two were coordinated. For example, build profiling into to the
FbleTc data type: typecheck.c populates the information needed by the
compiler. Both agree on exactly what gets labelled for profiling. 

And as part of that, consider going through FbleTc to cover what should be
labelled for profiling. Perhaps anywhere we have a multiple sub FbleTc*? That
would give us:
* let bindings (body is default)
* struct args? Is this useful for anything?
* union select choices
* func args? Is this useful? What names to use?
* exec bindings (body is default)

I would say, ditch struct and func args. I don't think those are too useful.
And as long as we have let, you could always wrap it in a variable if you
prefer.

Definitely let bindings. Definitely union select choices, because we want to
know which ones calls and time goes to. And I think exec bindings, for the
benchmark example I ran into above. Nothing else is needed.

In terms of execution:
- top level body
- function body

So the block id for a function will be named after whatever labels
(let/exec/union select) the function value is defined in.

That sounds like a nice place to start to me.

I guess the issue I'm running into with benchmark exec labels missing is
because the labels are for a function returned from another function. We
aren't defining a new function (or process), so we don't get a new name.
Hopefully, if we at least add labels for exec bindings and make sure to wrap
them in Enter/Exit blocks in compile.c, then we'll see the exec binding
labelled block calling into whatever that function being returned was.

