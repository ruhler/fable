
@ Bool@ = /Bool%.Bool@;
% True = /Bool%.True;

@ Int@ = /Int/Int%.Int@;
% Add = /Int/Int%.Add;
% Sub = /Int/Int%.Sub;
% 0 = /Int/Int%.0;
% Eq = /Int/Int/Eq%.Eq;
% Le = /Int/Int/Eq%.Le;
% Ge = /Int/Int/Eq%.Ge;
% Div = /Int/Int/Div%.Div;

% I = /Int/Int/Lit%.I;
% D = /Int/Int/Lit%.D;

<@,@>@ Lit@ = /Literal%.Lit@;

<@>@ List@ = /List%.List@;
<@>% List = /List%.List;
<@>% Nil = /List%.Nil;
<@>% Cons = /List%.Cons;
<@>% Concat = /List%.Concat;
<@,@>% Map = /List%.Map;
<@>% Length = /List/Length%.Length;

@ Bit@ = /Digits%.Bit@;
@ Hex@ = /Digits%.Hex@;
% B = /Digits%.Bit;

# Heap@ --
#   A bit-addressable heap of bits.
#
# This should be treated as an opaque type externally.
#
# Fields:
#   m - The size of 'left' and the address of the first value in 'right'.
@ HeapB@ = *(Heap@ left, Int@ m, Heap@ right),
@ Heap@ = +(Bit@ value, HeapB@ binary);

# Addr@ --
#   The address of a bit on the heap.
@ Addr@ = Int@;

# Ptr@ --
#   A pair of heap and address that identifies a particular sequence of bits.
@ Ptr@ = *(Heap@ heap, Addr@ addr);

# MkHeap --
#   Create a heap of n bits initialized from the given list of bits in order.
#
# Returns the heap and the list of bits not used for initialization.
(Int@, List@<Bit@>) { *(Heap@ heap, List@<Bit@> unused); }
MkHeap = (Int@ n, List@<Bit@> bits) {
  Le(n, I(D|0)).?(
    true: @(heap: Heap@(value: B.1), unused: bits),
    false: Eq(n, I(D|1)).?(
      true: @(heap: Heap@(value: bits.cons.head), unused: bits.cons.tail),
      false: {
        Int@ m = Div(n, I(D|2));
        % left = MkHeap(m, bits);
        % right = MkHeap(Sub(n, m), left.unused);
        @(
          heap: Heap@(binary: HeapB@(left.heap, m, right.heap)),
          unused: right.unused);
      }));
};

# Heap --
#   Create a heap of n uninitialized bits.
(Int@) { Heap@; } Heap = (Int@ n) {
  # We simulate uninitialized bits using the sequence 0101010101010...
  List@<Bit@> uninit = Cons<Bit@>(B.0, Cons<Bit@>(B.1, uninit));
  MkHeap(n, uninit).heap;
};

# HeapFromBits --
#   Create a preinitialized heap of bits.
(List@<Bit@>) { Heap@; } HeapFromBits = (List@<Bit@> bits) {
  Int@ n = Length<Bit@>(bits);
  MkHeap(n, bits).heap;
};

# HeapFromBitStr --
#   Create a preinitialized heap of bits.
(Lit@<Bit@>) { Heap@; } HeapFromBitStr = (Lit@<Bit@> bits) {
  HeapFromBits(List<Bit@>(bits));
};

# HeapFromHexStr --
(Lit@<Hex@>) { Heap@; } HeapFromHexStr = (Lit@<Hex@> hex) {
  List@<Hex@> l = List<Hex@>(hex);
  List@<Bit@> bits = Concat<Bit@>(Map<Hex@, List@<Bit@>>(l, (Hex@ h) {
    List<Bit@>(h.?(
      0: B|0000, 1: B|0001, 2: B|0010, 3: B|0011,
      4: B|0100, 5: B|0101, 6: B|0110, 7: B|0111,
      8: B|1000, 9: B|1001, A: B|1010, B: B|1011,
      C: B|1100, D: B|1101, E: B|1110, F: B|1111));
  }));
  HeapFromBits(bits);
};

# GetBits --
#   Get n bits from the bit heap.
#
# Behavior is undefined if there are't enough bits in the heap to get n.
(Ptr@, Int@, List@<Bit@>) { List@<Bit@>; }
GetBits = (Ptr@ ptr, Int@ n, List@<Bit@> tail) {
  ptr.heap.?(
    value: Le(n, 0).?(
      true: tail,
      false: Cons<Bit@>(ptr.heap.value, tail)),
    binary: {
      Int@ m = Add(ptr.addr, n);
      Le(m, ptr.heap.binary.m).?(
        true: GetBits(Ptr@(ptr.heap.binary.left, ptr.addr), n, tail),
        false: Ge(ptr.addr, ptr.heap.binary.m).?(
          true: GetBits(Ptr@(ptr.heap.binary.right,
              Sub(ptr.addr, ptr.heap.binary.m)), n, tail),
          false: {
            Int@ nl = Sub(ptr.heap.binary.m, ptr.addr);
            Int@ nr = Sub(n, nl);
            GetBits(Ptr@(ptr.heap.binary.left, ptr.addr), nl,
              GetBits(Ptr@(ptr.heap.binary.right, I(D|0)), nr, tail));
          }));
    });
};

# SetBits --
#   Set n bits of the bit heap.
#
# Behavior is undefined if there are't enough bits in the heap to set n.
(Ptr@, Int@, List@<Bit@>) { *(Heap@ heap, List@<Bit@> unused); }
SetBits = (Ptr@ ptr, Int@ n, List@<Bit@> bits) {
  ptr.heap.?(
    value: Le(n, 0).?(
      true: @(heap: ptr.heap, unused: bits),
      false: @(heap: Heap@(value: bits.cons.head), unused: bits.cons.tail)),
    binary: {
      Int@ m = Add(ptr.addr, n);
      Le(m, ptr.heap.binary.m).?(
        true: {
          % left = SetBits(Ptr@(ptr.heap.binary.left, ptr.addr), n, bits);
          @(heap: Heap@(binary:
                HeapB@(left.heap, ptr.heap.binary.m, ptr.heap.binary.right)),
            unused: left.unused);
        },
        false: Ge(ptr.addr, ptr.heap.binary.m).?(
          true: {
            % right = SetBits(Ptr@(ptr.heap.binary.right,
                Sub(ptr.addr, ptr.heap.binary.m)), n, bits);
            @(heap: Heap@(binary:
                  HeapB@(ptr.heap.binary.left, ptr.heap.binary.m, right.heap)),
              unused: right.unused);
          },
          false: {
            Int@ nl = Sub(ptr.heap.binary.m, ptr.addr);
            Int@ nr = Sub(n, nl);
            % left = SetBits(Ptr@(ptr.heap.binary.left, ptr.addr), nl, bits);
            % right = SetBits(Ptr@(ptr.heap.binary.right, I(D|0)), nr, left.unused);
            @(heap: Heap@(binary: HeapB@(left.heap, ptr.heap.binary.m, right.heap)),
              unused: right.unused);
          }));
    });
};

# EqBits --
#   Test for n bits worth of equality.
#
# Behavior is undefined if there are't enough bits in the heap to set n.
(Ptr@, Int@, List@<Bit@>) { *(Bool@ equals, List@<Bit@> unused); }
EqBits = (Ptr@ ptr, Int@ n, List@<Bit@> bits) {
  ptr.heap.?(
    value: Le(n, 0).?(
      true: @(equals: True, unused: bits),
      false: @(
        equals: /Digits/Eq%.EqBit(ptr.heap.value, bits.cons.head),
        unused: bits.cons.tail)),
    binary: {
      Int@ m = Add(ptr.addr, n);
      Le(m, ptr.heap.binary.m).?(
        true: EqBits(Ptr@(ptr.heap.binary.left, ptr.addr), n, bits),
        false: Ge(ptr.addr, ptr.heap.binary.m).?(
          true: EqBits(Ptr@(ptr.heap.binary.right,
                Sub(ptr.addr, ptr.heap.binary.m)), n, bits),
          false: {
            Int@ nl = Sub(ptr.heap.binary.m, ptr.addr);
            Int@ nr = Sub(n, nl);
            % left = EqBits(Ptr@(ptr.heap.binary.left, ptr.addr), nl, bits);
            left.equals.?(
              true: EqBits(Ptr@(ptr.heap.binary.right, I(D|0)), nr, left.unused),
              false: left);
          }));
    });
};

# HeapFromPtr --
#   Create a heap initialized with the bits pointed to by ptr.
(Ptr@, Int@) { Heap@; } HeapFromPtr = (Ptr@ ptr, Int@ n) {
  HeapFromBits(GetBits(ptr, n, Nil<Bit@>));
};

# Equals --
#   Return true if the n bits referred to by pointers a and b are equal.
(Ptr@, List@<Bit@>, Int@) { Bool@; } EqualsBits = (Ptr@ a, List@<Bit@> b, Int@ n) {
  EqBits(a, n, b).equals;
};

# Equals --
#   Return true if the n bits referred to by pointers a and b are equal.
#
# Behavior is undefined if there aren't n bits in a and b to compare.
(Ptr@, Ptr@, Int@) { Bool@; } Equals = (Ptr@ a, Ptr@ b, Int@ n) {
  EqBits(a, n, GetBits(b, n, Nil<Bit@>)).equals;
};

# AssignBits --
#   Assign the first n bits at ptr with the value of the given bits.
#
# Returns the updated Heap for ptr after the assignment.
#
# Behavior is undefined if there aren't n bits to assign from or to.
(Ptr@, List@<Bit@>, Int@) { Heap@; }
AssignBits = (Ptr@ ptr, List@<Bit@> bits, Int@ n) {
  SetBits(ptr, n, bits).heap;
};

# Assign --
#   Assign the first n bits at ptr with the value of the first n bits from val.
#
# Returns the updated Heap for ptr after the assignment.
#
# Behavior is undefined if there aren't n bits to assign from or to.
(Ptr@, Ptr@, Int@) { Heap@; } Assign = (Ptr@ ptr, Ptr@ val, Int@ n) {
  SetBits(ptr, n, GetBits(val, n, Nil<Bit@>)).heap;
};

# GetAllBits --
#   Get all of the bits of a heap in order.
#
# TODO: This doesn't work for an empty heap?
(Heap@) { List@<Bit@>; } GetAllBits = {
  (Heap@, List@<Bit@>) { List@<Bit@>; } F = (Heap@ h, List@<Bit@> tail) {
    h.?(
      value: Cons<Bit@>(h.value, tail),
      binary: F(h.binary.left, F(h.binary.right, tail)));
  };

  (Heap@ h) {
    F(h, Nil<Bit@>);
  };
};

@(Heap@, Ptr@, Heap, HeapFromBits, HeapFromBitStr, HeapFromHexStr, HeapFromPtr, EqualsBits, Equals, AssignBits, Assign, GetAllBits);
