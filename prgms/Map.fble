
@ Structure@ = /Structure%.Structure@;
<@>@ Structured@ = /Structured%.Structured@;

@ Unit@ = /Unit%.Unit@;
% Unit = /Unit%.Unit;

<@>@ Maybe@ = /Maybe%.Maybe@;
<@>% Nothing = /Maybe%.Nothing;
<@>% Just = /Maybe%.Just;

<@,@>@ Entry@ = <@ K@, @ V@> { *(K@ key, V@ value); };

<@ K@, @ V@>(Maybe@<Entry@<K@, V@>>) { Maybe@<V@>; }
MValue = <@ K@, @ V@>(Maybe@<Entry@<K@, V@>> m) {
  m.?(just: Just<V@>(m.just.value), nothing: Nothing<V@>);
};

# A map from K@ to V@, using Data@ as the lookup hash for K@.
<@,@>@ DataMap@ = <@ K@, @ V@>{ +(Unit@ empty, DataMapP@<K@, V@> map); },
<@,@>@ DataMapP@ = <@ K@, @ V@>{ 
  *(Maybe@<Entry@<K@,V@>> unit,
    *(DataMap@<K@, V@> a, DataMap@<K@, V@> b) sum,
    DataMap@<Unit@, DataMap@<K@, V@>> product);
};

<@ K@, @ V@>{ DataMap@<K@, V@>; } Empty = <@ K@, @ V@>{
  DataMap@<K@, V@>(empty: Unit);
};

<@ K@, @ V@>(DataMap@<K@, V@>, Structure@) { Maybe@<V@>; }
Lookup = <@ K@, @ V@>(DataMap@<K@, V@> map, Structure@ hash) {
  map.?(
     empty: Nothing<V@>,
     map: {
       hash.?(
          unit: MValue<K@, V@>(map.map.unit),
          either: hash.either.?(
                   a: Lookup<K@, V@>(map.map.sum.a, hash.either.a),
                   b: Lookup<K@, V@>(map.map.sum.b, hash.either.b)),
          pair: {
            Maybe@<DataMap@<K@, V@>> mm = Lookup<Unit@, DataMap@<K@, V@>>(map.map.product, hash.pair.a);
            mm.?(
                just: Lookup<K@, V@>(mm.just, hash.pair.b),
                nothing: Nothing<V@>);
          });
     });
};

# Insert that transforms the existing value, if any.
<@ K@, @ V@>(DataMap@<K@, V@>, K@, Structure@, (Maybe@<V@>){ V@; }) { DataMap@<K@, V@>; }
InsertWith = <@ K@, @ V@>(DataMap@<K@, V@> map, K@ key, Structure@ hash, (Maybe@<V@>){ V@; } with) {
  DataMapP@<K@, V@> p =
    map.?(
       empty: DataMapP@<K@, V@>(
         Nothing<Entry@<K@, V@>>,
         @(a: Empty<K@, V@>, b: Empty<K@, V@>),
         Empty<Unit@, DataMap@<K@, V@>>),
       map: map.map);
  DataMap@<K@, V@>(map:
   hash.?(
     unit: DataMapP@<K@, V@>(
       Just<Entry@<K@, V@>>(Entry@<K@, V@>(key, with(MValue<K@, V@>(p.unit)))),
       p.sum,
       p.product
     ),
     either: hash.either.?(
              a: DataMapP@<K@, V@>(p.unit, @(a: InsertWith<K@, V@>(p.sum.a, key, hash.either.a, with), b: p.sum.b), p.product),
              b: DataMapP@<K@, V@>(p.unit, @(a: p.sum.a, b: InsertWith<K@, V@>(p.sum.b, key, hash.either.b, with)), p.product)),
     pair: {
       DataMapP@<K@, V@>(p.unit, p.sum,
         InsertWith<Unit@, DataMap@<K@, V@>>(p.product, Unit, hash.pair.a, (Maybe@<DataMap@<K@, V@>> mm) {
           InsertWith<K@, V@>(mm.?(just: mm.just, nothing: Empty<K@, V@>), key, hash.pair.b, with);
         }));
     }));
};

<@ K@>(Structured@<K@>)<@ V@>(DataMap@<K@, V@>, K@, V@) { DataMap@<K@, V@>; }
Insert = <@ K@>(Structured@<K@> s)<@ V@>(DataMap@<K@, V@> map, K@ key, V@ value) {
  InsertWith<K@, V@>(map, key, s(key), (Maybe@<V@> _) { value; });
};

<@ K@, @ V@, @ B@>(DataMap@<K@, V@>, B@, (K@, V@, B@) { B@;}) { B@; }
For = <@ K@, @ V@, @ B@>(DataMap@<K@, V@> m, B@ base, (K@, V@, B@) { B@;} body) {
  m.?(
    empty: base,
    map: {
      B@ b2 = m.map.unit.?(
                  just: body(m.map.unit.just.key, m.map.unit.just.value, base),
                  nothing: base);
      B@ b3 = For<K@, V@, B@>(m.map.sum.a, b2, body);
      B@ b4 = For<K@, V@, B@>(m.map.sum.b, b3, body);
      B@ b5 = For<Unit@, DataMap@<K@, V@>, B@>(m.map.product, b4,
        (Unit@ _, DataMap@<K@, V@> v, B@ b) {
          For<K@, V@, B@>(v, b, body);
      });
      b5;
    });
};

# Map@ interface parameterized by key type.
<@>@ Map@ = <@ K@> {
  <@>@ M@ = DataMap@<K@>;
  *(@<M@> Map@,
    <@ V@>(M@<V@>, K@) { Maybe@<V@>; } Lookup,
    <@ V@>(M@<V@>, K@, (Maybe@<V@>){ V@; }) { M@<V@>; } InsertWith
   );
};
  
# An implementation of the Map interface.
<@ K@>((K@) { Structure@; }) { Map@<K@>; }
Map = <@ K@>((K@) { Structure@; } ToData) {
  <@>@ M@ = DataMap@<K@>;
  Map@<K@>(M@,
    <@ V@>(M@<V@> m, K@ k) {
      Lookup<K@, V@>(m, ToData(k));
    },
    <@ V@>(M@<V@> m, K@ k, (Maybe@<V@>) { V@; } w) {
      InsertWith<K@, V@>(m, k, ToData(k), w);
    }
  );
};

@(DataMap@, Map@, Map, Empty, Insert, For);
