
@ Bool@ = /Bool%.Bool@;
% True = /Bool%.True;
% False = /Bool%.False;
% Or = /Bool%.Or;

@ Drawing@ = /Drawing%.Drawing@;
% Blank = /Drawing%.Blank;
% Over = /Drawing%.Over;
% Translate = /Drawing%.Translate;

% Alien1A = /Invaders/Graphics%.Aliens.Alien1A;
% Alien1B = /Invaders/Graphics%.Aliens.Alien1B;
% Alien2A = /Invaders/Graphics%.Aliens.Alien2A;
% Alien2B = /Invaders/Graphics%.Aliens.Alien2B;
% Alien3A = /Invaders/Graphics%.Aliens.Alien3A;
% Alien3B = /Invaders/Graphics%.Aliens.Alien3B;
% DeadAlien = /Invaders/Graphics%.DeadAlien;

@ Int@ = /Int/Int%.Int@;
% Add = /Int/Int%.Add;
% Sub = /Int/Int%.Sub;
% Inc = /Int/Int%.Inc;
% Mul = /Int/Int%.Mul;
% Div = /Int/Int/Div%.Div;
% Mod = /Int/Int/Div%.Mod;
% Eq = /Int/Int/Eq%.Eq;
% Le = /Int/Int/Eq%.Le;
% Lt = /Int/Int/Eq%.Lt;
% Ge = /Int/Int/Eq%.Ge;
% Gt = /Int/Int/Eq%.Gt;
% Int = /Int/Int/Lit%.Int;

<@,@>% DoWhile = /Loop%.DoWhile;
<@,@>% For = /Loop%.For;

<@>@ List@ = /List%.List@;
<@>% Cons = /List%.Cons;
<@>% Nil = /List%.Nil;

<@>@ Maybe@ = /Maybe%.Maybe@;
<@>% Just = /Maybe%.Just;
<@>% Nothing = /Maybe%.Nothing;

@ Unit@ = /Unit%.Unit@;
% Unit = /Unit%.Unit;

# Aliens move together in a group of rows and columns. They decide which
# direction to move. Then each live alien, in turn, makes a move. They go 4
# pixels side by side in a move, or 16 pixels down. Time between moves starts
# at 8 units, then gradually goes down to 2 units depending on how many aliens
# are alive. After a full round of moves, if any live alien has reached an
# edge, as a group they go down and plan to switch direction.

# NumRows --
#   The number of rows of aliens in the group.
Int@ NumRows = Int|5;

# NumCols --
#   The number of columns of aliens in the group.
Int@ NumCols = Int|11;

# NumAliens --
#   The total number of aliens in the group.
Int@ NumAliens = Mul(NumRows, NumCols);

# Alien@ --
#   An individual alien is identified by its position in the group, in the
#   order that they move: left to right, bottom to top.
@ Alien@ = Int@;

# Row -- 
#   Which row the given alien belongs to. Row 0 is the bottom row.
(Alien@) { Int@; } Row = (Alien@ a) {
  Div(a, NumCols);
};

# Col --
#   Which column the given alien belongs to. Col 0 is the left column.
(Alien@) { Int@; } Col = (Alien@ a) {
  Mod(a, NumCols);
};

# Next --
#   Iteration over aliens in order.
(Alien@) { Maybe@<Alien@>; } Next = (Alien@ a) {
  Alien@ next = Inc(a);
  Lt(next, NumAliens).?(true: Just<Alien@>(next), false: Nothing<Alien@>);
};

# Set@ --
#   A set of aliens, to keep track of which aliens are alive or dead.
# A set of aliens.
@ Set@ = /Map%.Map@<Alien@, Unit@>;

# AlienLt, AlienLe -- 
#   Less than comparison operations for Aliens.
/Eq%.Eq@<Alien@> AlienLt = /Int/Int/Eq%.Lt;
/Eq%.Eq@<Alien@> AlienLe = /Int/Int/Eq%.Le;

# AllAliens --
#   The set of all aliens.
Set@ AllAliens = {
  % Insert = /Map%.Insert<Alien@>(AlienLt)<Unit@>;
  DoWhile<Alien@, Set@>(Int|0, Next, /Map%.Empty<Alien@, Unit@>, 
    (Alien@ a, Set@ s) {
      Insert(s, a, Unit);
    });
};

(Set@) { Bool@; } IsEmpty = /Map%.IsEmpty<Alien@, Unit@>;

# Contains --
#   Returns true if the set contains the given alien, false otherwise.
(Set@, Alien@) { Bool@; } Contains = {
  % Lookup = /Map%.Lookup<Alien@>(AlienLt)<Unit@>;
  (Set@ set, Alien@ alien) {
    Lookup(set, alien).?(just: True, nothing: False);
  };
};

# Remove --
#   Remove an element of the set.
(Set@, Alien@) { Set@; } Remove = /Map%.Delete<Alien@>(AlienLt)<Unit@>;

# NextAlive --
#   Returns the next live alien in the given set, or Nothing if we have
#   reached the end of live aliens.
(Set@, Alien@) { Maybe@<Alien@>; } NextAlive = (Set@ alive, Alien@ a) {
  Maybe@<Alien@> mnext = Next(a);
  mnext.?(
    just: {
      Alien@ next = mnext.just;
      Contains(alive, next).?(
        true: Just<Alien@>(next),
        false: NextAlive(alive, next));
    },
    nothing: Nothing<Alien@>);
};

# FirstAlive --
#   Returns the first live alien in the given set, or Nothing if there are no
#   live aliens.
(Set@) { Maybe@<Alien@>; } FirstAlive = (Set@ alive) {
  Alien@ first = Int|0;
  Contains(alive, first).?(
    true: Just<Alien@>(first),
    false: NextAlive(alive, first));
};

# Phase@ --
#   Which graphic to use for the alien. It toggles back and forth between 'a'
#   and 'b'.
@ Phase@ = +(Unit@ a, Unit@ b);

# FlipPhase --
#   Switch to the other phase.
(Phase@) { Phase@; } FlipPhase = (Phase@ p) {
  p.?(a: Phase@(b: Unit), b: Phase@(a: Unit));
};

# Dir@ --
#   The direction the alien's are currently facing.
@ Dir@ = +(Unit@ left, Unit@ right);

# FlipDir --
#   Switch to the other direction.
(Dir@) { Dir@; } FlipDir = (Dir@ d) {
  d.?(left: Dir@(right: Unit), right: Dir@(left: Unit));
};

# LeftEdge --
#   The furthest left, in game coordinates, the left edge of an alien will go.
Int@ LeftEdge = Int|46;

# RightEdge --
#   The furthest right, in game coordinates, the left edge of an alien will go.
Int@ RightEdge = Int|262;

# StrideX --
#   The horizontal distance, in game coordinates, between the left edge of an
#   alien and the left edge of its immediately adjacent alien.
Int@ StrideX = Int|15;

# StrideY --
#   The vertical distance, in game coordinates, between the bottom edge of an
#   alien and the bottom edge of its immediately adjacent alien.
Int@ StrideY = Int|16;

# Width --
#   The width of a single alien.
Int@ Width = Int|10;

# Height --
#   The height of a single alien.
Int@ Height = Int|8;

# MoveX --
#   How far an alien moves side to side, in game coordinates, in a single
#   step.
Int@ MoveX = Int|2;

# MoveY --
#   How far an alien moves down, in game coordinates, in a single step.
Int@ MoveY = Int|8;

# DyingTime --
#   How many ticks it takes for an alien to die.
Int@ DyingTime = Int|10;

# Dying@ --
#   Represents a dying alien.
#
# Fields:
#   x, y - The position of the dead alien
#   wait - how many ticks to wait before the dead alien disappears.
@ Dying@ = *(Int@ x, Int@ y, Int@ wait);

# Aliens@ --
#   The state of a group of aliens.
@ Aliens@ = *(
  # The (x, y) position of the bottom left edge of the group of aliens,
  # independent of which aliens are alive or dead, for those aliens in the
  # group that have not moved yet.
  Int@ src_x,
  Int@ src_y,

  # The (x, y) position of the bottom left edge of the group of aliens,
  # independent of which aliens are alive or dead, for those aliens in the
  # group that have already moved.
  Int@ dst_x,
  Int@ dst_y,

  # The set of aliens in the group that are alive.
  Set@ alive,            

  # The direction the aliens are currently moving.
  Dir@ dir,

  # The phase that the group is moving to.
  Phase@ phase,          

  # The next alien to move, or Nothing if we have finished iterating through
  # all of the aliens. All aliens before 'next' have been (conceptually) moved
  # to relative to the group coordinates (x, y). All aliens 'next' and later
  # have yet to be moved.
  Maybe@<Alien@> next,

  # Set to true if we should change direction in the next full round.
  Bool@ turn,

  # The list of currently dying aliens.
  List@<Dying@> dying
);

# Initial --
#   The initial set of aliens, given the current game level.
(Int@) { Aliens@; } Initial = (Int@ level) {
  Int@ y = Sub(Int|104, Mul(Mod(level, Int|6), StrideY));
  @(src_x: LeftEdge,
    src_y: y,
    dst_x: Add(LeftEdge, MoveX),
    dst_y: y,
    alive: AllAliens,
    dir: Dir@(right: Unit),
    phase: Phase@(b: Unit),
    next: Just<Alien@>(Int|0),
    turn: False,
    dying: Nil<Dying@>);
};

# TickDying --
#   Advance the dying aliens by one unit of time tick.
(List@<Dying@>) { List@<Dying@>; } TickDying = (List@<Dying@> dying) {
  dying.?(nil: dying);

  Dying@ head = dying.cons.head;
  List@<Dying@> tail = TickDying(dying.cons.tail);

  Int@ nwait = Sub(head.wait, Int|1);
  Eq(Int|0, nwait).?(true: tail);
  Cons<Dying@>(Dying@(head.x, head.y, nwait), tail);
};

# Tick --
#   Advance the aliens by one unit of time tick.
(Aliens@) { Aliens@; } Tick = (Aliens@ a) {
  a.next.?(
    just: {
      Int@ left = Add(a.dst_x, Mul(StrideX, Col(a.next.just)));
      Bool@ turn = Or(a.turn, a.dir.?(
        left: Lt(left, LeftEdge),
        right: Gt(left, RightEdge)));
      Maybe@<Alien@> next = NextAlive(a.alive, a.next.just);
      Aliens@(a.src_x, a.src_y, a.dst_x, a.dst_y, a.alive,
        a.dir, a.phase, next, turn, TickDying(a.dying));
    },
    nothing: {
      *(Int@ x, Int@ y, Dir@ dir) updates = a.turn.?(
        true: @(
          x: a.dst_x,
          y: Sub(a.dst_y, MoveY),
          dir: FlipDir(a.dir)),
        false: @(
          x: a.dir.?(left: Sub(a.dst_x, MoveX), right: Add(a.dst_x, MoveX)),
          y: a.dst_y,
          dir: a.dir));
      Maybe@<Alien@> next = FirstAlive(a.alive);
      Aliens@(a.dst_x, a.dst_y, updates.x, updates.y,
        a.alive, updates.dir, FlipPhase(a.phase),
        next, False, TickDying(a.dying));
    });
};

# Collision --
#   Returns the alien, if any, that occupy the same location as the given
#   point.
(Int@, Int@, Aliens@) { Maybe@<Alien@>; }
Collision = (Int@ x, Int@ y, Aliens@ aliens) {
  # Identify the alien at point x, y relative to the given aliens position.
  (Int@, Int@) { Maybe@<Alien@>; } Candidate = (Int@ aliens_x, Int@ aliens_y) {
    Lt(x, aliens_x).?(true: Nothing<Alien@>);
    Lt(y, aliens_y).?(true: Nothing<Alien@>);
    Ge(x, Add(aliens_x, Mul(StrideX, NumCols))).?(true: Nothing<Alien@>);
    Ge(y, Add(aliens_y, Mul(StrideY, NumRows))).?(true: Nothing<Alien@>);

    Int@ dx = Sub(x, aliens_x);
    Int@ dy = Sub(y, aliens_y);
    Int@ rx = Mod(dx, StrideX);
    Int@ ry = Mod(dy, StrideY);

    Le(rx, Width).?(false: Nothing<Alien@>);
    Le(ry, Height).?(false: Nothing<Alien@>);

    Alien@ alien = Add(Mul(NumCols, Div(dy, StrideY)), Div(dx, StrideX));
    Contains(aliens.alive, alien).?(false: Nothing<Alien@>);

    Just<Alien@>(alien);
  };

  Maybe@<Alien@> src_candidate = Candidate(aliens.src_x, aliens.src_y);
  Bool@ src_valid = {
    src_candidate.?(nothing: False);
    aliens.next.?(nothing: False);
    AlienLe(aliens.next.just, src_candidate.just);
  };
  src_valid.?(true: src_candidate);

  Maybe@<Alien@> dst_candidate = Candidate(aliens.dst_x, aliens.dst_y);
  Bool@ dst_valid = {
    dst_candidate.?(nothing: False);
    aliens.next.?(nothing: True);
    AlienLt(dst_candidate.just, aliens.next.just);
  };
  dst_valid.?(true: dst_candidate);

  Nothing<Alien@>;
};

# Kill the given alien.
(Aliens@, Alien@) { Aliens@; } Kill = (Aliens@ aliens, Alien@ alien) {
  Dying@ dying = {
    Bool@ moved = aliens.next.?(just: Lt(alien, aliens.next.just), nothing: True);
    Int@ group_x = moved.?(true: aliens.dst_x, false: aliens.src_x);
    Int@ group_y = moved.?(true: aliens.dst_y, false: aliens.src_y);
    Int@ alien_x = Add(group_x, Mul(StrideX, Col(alien)));
    Int@ alien_y = Add(group_y, Mul(StrideY, Row(alien)));
    Dying@(alien_x, alien_y, DyingTime);
  };

  @(src_x: aliens.src_x,
    src_y: aliens.src_y,
    dst_x: aliens.dst_x,
    dst_y: aliens.dst_y,
    alive: Remove(aliens.alive, alien),
    dir: aliens.dir,
    phase: aliens.phase,
    next: aliens.next,
    turn: aliens.turn,
    dying: Cons<Dying@>(dying, aliens.dying));
};

# Points --
#   The number of points earned by killing the given alien.
(Alien@) { Int@; } Points = (Alien@ alien) {
  Int@ half_row = Div(Row(alien), Int|2);
  Eq(Int|0, half_row).?(true: Int|10);
  Eq(Int|1, half_row).?(true: Int|20);
  Int|30;
};

# Sprite --
#   Return the alien sprite for an alien in the given row with the given
#   phase.
(Int@, Phase@) { Drawing@; } Sprite = (Int@ row, Phase@ phase) {
  Int@ half_row = Div(row, Int|2);
  Eq(Int|0, half_row).?(true: phase.?(a: Alien1A, b: Alien1B));
  Eq(Int|1, half_row).?(true: phase.?(a: Alien2A, b: Alien2B));
  phase.?(a: Alien3A, b: Alien3B);
};

@ Kill@ = *(Int@ points, Aliens@ aliens);

(Int@, Int@, Aliens@) { Maybe@<Kill@>; }
Shoot = (Int@ x, Int@ y, Aliens@ aliens) {
  Maybe@<Alien@> kill = Collision(x, y, aliens);
  kill.?(nothing: Nothing<Kill@>);
  Just<Kill@>(Kill@(Points(kill.just), Kill(aliens, kill.just)));
};

# AllDead --
#   Returns true if all the aliens are dead, false otherwise.
(Aliens@) { Bool@; } AllDead = (Aliens@ as) {
  IsEmpty(as.alive);
};

# Draw --
#   Make a drawing of the aliens in their current location.
(Aliens@) { Drawing@; } Draw = (Aliens@ as) {
  Drawing@ dying = /List%.ForEach<Dying@, Drawing@>(as.dying, Blank,
    (Dying@ dy, Drawing@ d) {
      Over(d, Translate(dy.x, dy.y, DeadAlien));
    });
     
  For<Alien@, Drawing@>(
    FirstAlive(as.alive),
    (Alien@ a) { NextAlive(as.alive, a); },
    dying,
    (Alien@ a, Drawing@ d) {
      Bool@ moved = as.next.?(just: Lt(a, as.next.just), nothing: True);
      Int@ group_x = moved.?(true: as.dst_x, false: as.src_x);
      Int@ group_y = moved.?(true: as.dst_y, false: as.src_y);
      Int@ alien_x = Add(group_x, Mul(StrideX, Col(a)));
      Int@ alien_y = Add(group_y, Mul(StrideY, Row(a)));
      Phase@ phase = moved.?(true: as.phase, false: FlipPhase(as.phase));
      Over(d, Translate(alien_x, alien_y, Sprite(Row(a), phase)));
    });
};

@(Alien@, Aliens@, Kill@, Initial, Tick, Shoot, AllDead, Draw);
