
@ Program@ = /Fblf/Program%.Program@;
@ Proc@ = /Fblf/Program%.Proc@;
@ Var@ = /Fblf/Program%.Var@;
@ Stmt@ = /Fblf/Program%.Stmt@;
% Call = /Fblf/Program%.Call;
% Offset = /Fblf/Program%.Offset;
% LookupProc = /Fblf/Program%.LookupProc;

@ Int@ = /Int/Int%.Int@;
% Add = /Int/Int%.Add;
% Int = /Int/Int/Lit%.Int;
% Eq = /Int/Int/Eq%.Eq;

<@>@ List@ = /List%.List@;
<@>% Cons = /List%.Cons;
<@>% Nil = /List%.Nil;
<@,@>% Map = /List%.Map;

@ String@ = /String%.String@;
% Concat = /String%.Concat;
% Str = /String%.Str;

@ Unit@ = /Unit%.Unit@;

# ModuleM@ -- 
#   Monadic API used to define a collection of fblf procedures that share the
#   same internal state and module arguments.
#
# Fields:
#   name - the globally unique name of the current module.
#   args - the list of arguments passed to the module when it was instantiated.
#          Includes the 'this' argument as the first element of the list.
#   heap - the number of bits allocated on the heap so far for the internal
#          state of this module.
#   methods - the number of methods defined in the module so far.
#   program - the program procedures defined so far.
@ State@ = *(
  String@ name,
  List@<Var@> args,
  Int@ heap,
  Int@ methods,
  Program@ program
);
<@>@ ModuleR@ = <@ T@>{ *(State@ s, T@ r); };
<@>@ ModuleM@ = <@ T@>(State@) { ModuleR@<T@>; };

# Module@ --
#   A module defined using ModuleM@ with a name and the list of arguments
#   supplied to it when the module was instantiated.
#
# Fields:
#   name - A globally unique name of the module.
#   body - The body of the module.
#   args - List of arguments passed to the module, from the perspective of the
#          module that instantiates this module. Not including 'this'.
<@>@ Module@ = <@ T@> { *(String@ name, ModuleM@<T@> body, List@<Var@> args); };

# Module --
#   Helper to define a module with unverified number of arguments.
#
# The list of args provided should be the list of explicit arguments, not
# including 'this', all from the perspective of the module that instantiates
# this module.
#
# It is the users responsibility to ensure the number of arguments provided to
# the module match the number expected to be used by the module.
#
# The provided module name must be globally unique.
<@ T@>(String@, ModuleM@<T@>)(List@<Var@>) { Module@<T@>; }
Module = <@ T@>(String@ name, ModuleM@<T@> body)(List@<Var@> args) {
  Module@<T@>(name, body, args);
};

# Module0 --
#   Define a module that takes no arguments.
<@ T@>(String@, ModuleM@<T@>) { Module@<T@>; }
Module0 = <@ T@>(String@ name, ModuleM@<T@> body) {
  Module<T@>(name, body)[];
};

# Module1 --
#   Define a module that takes 1 argument.
<@ T@>(String@, (Var@) { ModuleM@<T@>; }) { (Var@) { Module@<T@>; }; }
Module1 = <@ T@>(String@ name, (Var@) { ModuleM@<T@>; } m)(Var@ arg) {
  # Arg id 0 is reserved for local state.
  Module<T@>(name, m(Var@(Int|1, Int|0)))[arg];
};

# Module2 --
#   Define a module that takes 2 arguments.
<@ T@>(String@, (Var@, Var@) { ModuleM@<T@>; }) { (Var@, Var@) { Module@<T@>; }; }
Module2 = <@ T@>(String@ name, (Var@, Var@) { ModuleM@<T@>; } m)(Var@ arg1, Var@ arg2) {
  # Arg id 0 is reserved for local state.
  Module<T@>(name, m(Var@(Int|1, Int|0), Var@(Int|2, Int|0)))[arg1, arg2];
};

# Module3 --
#   Define a module that takes 3 arguments.
<@ T@>(String@, (Var@, Var@, Var@) { ModuleM@<T@>; }) { (Var@, Var@, Var@) { Module@<T@>; }; }
Module3 = <@ T@>(String@ name, (Var@, Var@, Var@) { ModuleM@<T@>; } m)(Var@ arg1, Var@ arg2, Var@ arg3) {
  # Arg id 0 is reserved for local state.
  Module<T@>(name, m(Var@(Int|1, Int|0), Var@(Int|2, Int|0), Var@(Int|3, Int|0)))[arg1, arg2, arg3];
};

# Module4 --
#   Define a module that takes 4 arguments.
<@ T@>(String@, (Var@, Var@, Var@, Var@) { ModuleM@<T@>; }) { (Var@, Var@, Var@, Var@) { Module@<T@>; }; }
Module4 = <@ T@>(String@ name, (Var@, Var@, Var@, Var@) { ModuleM@<T@>; } m)
  (Var@ arg1, Var@ arg2, Var@ arg3, Var@ arg4) {
  # Arg id 0 is reserved for local state.
  Module<T@>(name, m(
      Var@(Int|1, Int|0),
      Var@(Int|2, Int|0),
      Var@(Int|3, Int|0),
      Var@(Int|4, Int|0)))[arg1, arg2, arg3, arg4];
};

# Module5 --
#   Define a module that takes 5 arguments.
<@ T@>(String@, (Var@, Var@, Var@, Var@, Var@) { ModuleM@<T@>; }) { (Var@, Var@, Var@, Var@, Var@) { Module@<T@>; }; }
Module5 = <@ T@>(String@ name, (Var@, Var@, Var@, Var@, Var@) { ModuleM@<T@>; } m)
  (Var@ arg1, Var@ arg2, Var@ arg3, Var@ arg4, Var@ arg5) {
  # Arg id 0 is reserved for local state.
  Module<T@>(name, m(
      Var@(Int|1, Int|0),
      Var@(Int|2, Int|0),
      Var@(Int|3, Int|0),
      Var@(Int|4, Int|0),
      Var@(Int|5, Int|0)))[arg1, arg2, arg3, arg4, arg5];
};

# Do --
#   Monadic bind for ModuleM monad.
<@ A@, @ B@>(ModuleM@<A@>)((A@) { ModuleM@<B@>; }) { ModuleM@<B@>; }
Do = <@ A@, @ B@>(ModuleM@<A@> m)((A@) { ModuleM@<B@>; } f)(State@ s) {
  ModuleR@<A@> a = m(s);
  f(a.r)(a.s);
};

# Return --
#   Monadic return for ModuleM monad.
<@ T@>(T@) { ModuleM@<T@>; }
Return = <@ T@>(T@ r)(State@ s) {
  ModuleR@<T@>(s, r);
};

# Helper function to make a variable that's relative to the intrernal state of
# a module.
(Int@) { Var@; } Local = (Int@ offset) {
  # The retured variable is relative to arg '0', which corresponds to 'this'.
  Var@(Int|0, offset);
};

# Alloc --
#   Allocate n bits on the heap for use in an instance of this module.
(Int@) { ModuleM@<Var@>; } Alloc = (Int@ n)(State@ s) {
  ModuleR@<Var@>(State@(s.name, s.args, Add(s.heap, n), s.methods, s.program), Local(s.heap));
};

<@ T@>(Int@)((Var@) { ModuleM@<T@>; }) { ModuleM@<T@>; }
DoAlloc = <@ T@>(Int@ n) { Do<Var@, T@>(Alloc(n)); };

# Inst --
#   Instantiate a module for use in an instance of this module.
<@ T@>(Module@<T@>) { ModuleM@<T@>; }
Inst = <@ T@>(Module@<T@> m)(State@ s) {
  List@<Var@> args = Cons<Var@>(Local(s.heap), m.args);
  ModuleR@<T@> mr = m.body(State@(m.name, args, Int|0, Int|0, s.program));
  ModuleR@<T@>(State@(s.name, s.args, Add(s.heap, mr.s.heap), s.methods, mr.s.program), mr.r);
}; 

<@ A@, @ B@>(Module@<A@>)((A@) { ModuleM@<B@>; }) { ModuleM@<B@>; }
DoInst = <@ A@, @ B@>(Module@<A@> m) {
  Do<A@, B@>(Inst<A@>(m));
};

# Method --
#   Define a module method.
@ Method@ = Stmt@;

# Note: The returned method can only be used for defining methods in the
# module that instantiates this module. It cannot be used for defining local
# methods or returned to the instantiator of the instantiator of this module.
#
# TODO: Any way to get around the above pitfall or add some security to
# prevent misuse from happening accidentally?
(Stmt@) { ModuleM@<Method@>; }
Method = (Stmt@ stmt)(State@ s) {
  String@ proc_id = Concat[s.name, Str|'.', /Int/Int/Show%.Show(s.methods)];
  
  # Add the method to the program only if it hasn't already been defined.
  Program@ program = LookupProc(proc_id, s.program).?(
    just: s.program,
    nothing: {
      Int@ argc = /List/Length%.Length<Var@>(s.args);
      Proc@ proc = Proc@(proc_id, argc, stmt);
      Cons<Proc@>(proc, s.program);
    });

  Stmt@ call = Call(proc_id)(s.args);
  ModuleR@<Method@>(State@(s.name, s.args, s.heap, Add(s.methods, Int|1), program), call);
};

<@ T@>(Stmt@)((Method@) { ModuleM@<T@>; }) { ModuleM@<T@>; }
DoMethod = <@ T@>(Stmt@ body) { Do<Stmt@, T@>(Method(body)); };

# Extract the value of the arguments to a method, assuming they are all
# relative to 'this'.
# TODO: Give a better explanation of what this is for.
(Method@) { List@<Int@>; } MethodArgs = (Method@ method) {
  Map<Var@, Int@>(method.call.args, (Var@ v) {
    Unit@ _ = Eq(Int|0, v.id).true;  # Assert
    v.offset;
  });
};

# Export a local Var@ to the equivalent variable from the point of view of the
# parent module.
#
# TODO: The need for this is annoying. Anything we can do to get around it?
(Var@) { ModuleM@<Var@>; }
Export = (Var@ var)(State@ s) {
  Var@ arg = /List/Length%.Drop<Var@>(var.id, s.args).cons.head;
  ModuleR@<Var@>(s, Offset(arg, var.offset));
};

<@ T@>(Var@)((Var@) { ModuleM@<T@>; }) { ModuleM@<T@>; }
DoExport = <@ T@>(Var@ v) { Do<Var@, T@>(Export(v)); };

# Run --
#   Runs a module, returning the generated program, the size of the heap
#   required by the module, and whatever the module returns.
<@>@ Ran@ = <@ T@> { *(Program@ program, Int@ heap, T@ x); };

<@ T@>(Module@<T@>) { Ran@<T@>; } Run = <@ T@>(Module@<T@> m) {
  List@<Var@> args = Cons<Var@>(Local(Int|0), m.args);
  ModuleR@<T@> mr = m.body(State@(m.name, args, Int|0, Int|0, Nil<Proc@>));
  Ran@<T@>(mr.s.program, mr.s.heap, mr.r);
};

@(ModuleM@, Module@, Method@, Ran@,
  Module0, Module1, Module2, Module3, Module4, Module5,
  Do, Return, Alloc, DoAlloc, Inst, DoInst, Method, DoMethod, MethodArgs,
  Export, DoExport, Run);
