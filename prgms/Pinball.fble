
@ App@ = /App%.App@;
@ Event@ = /App%.Event@;
@ Effect@ = /App%.Effect@;

@ Drawing@ = /Drawing%.Drawing@;
@ Point@ = /Drawing%.Point@;
% Color = /Drawing%.Color;
% Over = /Drawing%.Over;
% Rect = /Drawing%.Rect;
% Affine = /Drawing%.Affine;

@ Int@ = /Int/Int%.Int@;

<@>@ Get@ = /Process%.Get@;
<@>@ Put@ = /Process%.Put@;

@ Rat@ = /Rat%.Rat@;
% Add = /Rat%.Add;
% Sub = /Rat%.Sub;
% Neg = /Rat%.Neg;
% Mul = /Rat%.Mul;
% Div = /Rat%.Div;
% Lt = /Rat/Eq%.Lt;
% Le = /Rat/Eq%.Le;
% Int = /Rat/Lit%.Int;

@ Unit@ = /Unit%.Unit@;
% Unit = /Unit%.Unit;

@ Ball@ = *(Rat@ y, Rat@ v);

Ball@ Initial = Ball@(Int|100, Int|0);

# HALF_G --
#   Half the acceleration due to gravity.
Rat@ HALF_G = Neg(Div(Int|1, Int|4));

# R --
#   The coefficient of restitution: the fraction of energy preserved during a
#   collision.
Rat@ R = Div(Int|9, Int|10);


# Shrink --
#   Limit the precision of the ball to avoid taking up a potentially
#   significant necessary memory and computation time.
(Ball@) { Ball@; } Shrink = {
  Rat@ P = Div(Int|1, Int|1000);
  (Rat@) { Rat@; } A = (Rat@ x) { /Rat%.Approx(x, P); };

  (Ball@ b) {
    Ball@(A(b.y), A(b.v));
  };
};

# Move --
#   Move the ball by the given amount of time, assuming velocity stays
#   constant.
#
# In case of collision, we break down the time period into smaller bits. The
# assumption that velocity is constant is intended to prevent the case where
# we break down the time period into smaller and smaller bits and end up never
# reaching the end of the time period as a result. This is also assumes we
# don't have any super tight corners that would cause us to collide an
# excessive number of times in a single time period.
(Ball@, Rat@) { Ball@; } Move = (Ball@ b, Rat@ t) {
  Le(t, Int|0).?(true: b);

  Rat@ y = Add(b.y, Mul(b.v, t));

  Lt(y, Int|0).?(false: Ball@(y, b.v));
  Lt(b.v, Int|0).?(false: Ball@(y, b.v));

  # The ball has dropped below ground level and is going downward. Have it
  # bounce up instead.
  # 0 = y0 + vt ==>  t = -y0/v
  Rat@ t0 = Div(Neg(b.y), b.v);
  Move(Ball@(Int|0, Mul(R, Neg(b.v))), Sub(t, t0));
};

# Tick --
#   Advance the ball by one unit of time.
(Ball@) { Ball@; } Tick = (Ball@ b) {
  # 1. Compute average expected velocity over the time period.
  Rat@ v_avg = Add(b.v, HALF_G);

  # 2. Move the ball assuming constant velocity.
  Ball@ b_moved = Move(Ball@(b.y, v_avg), Int|1);

  # 3. Compute final velocity.
  Rat@ v = Add(b_moved.v, HALF_G);
  Shrink(Ball@(b_moved.y, v));
};

(Ball@) { Drawing@; } Draw = (Ball@ ball) {
  Int@ y = /Int/Int/Div%.Div(ball.y.n, ball.y.d).q;
  Rect(Int|0.n, y, Int|10.n, Int|10.n, Color.Cyan);
};

(Get@<Event@>, Put@<Ball@>, Unit@!, Ball@) { Unit@!; }
Run = (Get@<Event@> in, Put@<Ball@> draw, Unit@! tick, Ball@ ball) {
  Event@ e := in;

  e.?(tick: {
    Unit@ _ := tick;
    Unit@ _ := draw(ball);
    Run(in, draw, tick, Tick(ball));
  });

  e.?(key_down: {
    e.key_down.?(q: !(Unit));
    Run(in, draw, tick, ball);
  });
  Run(in, draw, tick, ball);
};

App@ Main = (Int@ width, Int@ height, Get@<Event@> in, Put@<Effect@> out) {
  Point@ a = @(x: Int|1.n, y: Neg(Int|1).n);
  Point@ b = @(x: Int|320.n, y: Int|240.n);
  Int@ frame_period = Int|16.n;
  Unit@! tick = out(Effect@(tick: frame_period));

  (Ball@) { Unit@!; } draw = (Ball@ s) {
    out(Effect@(draw: Over(
      Rect(Int|0.n, Int|0.n, width, height, Color.Black),
      Affine(a, b, Draw(s)))));
  };

  Unit@ _ := out(Effect@(tick: Int|0.n));
  Run(in, draw, tick, Initial); 
};

Main;

