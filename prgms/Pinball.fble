
@ App@ = /App%.App@;
@ Event@ = /App%.Event@;
@ Effect@ = /App%.Effect@;

@ Drawing@ = /Drawing%.Drawing@;
@ Point@ = /Drawing%.Point@;
% Color = /Drawing%.Color;
% Over = /Drawing%.Over;
% Rect = /Drawing%.Rect;
% Affine = /Drawing%.Affine;

% Triangle = /Graphics/2D%.Triangle;

@ Int@ = /Int/Int%.Int@;

<@>@ List@ = /List%.List@;
<@>% List = /List%.List;

<@>@ Get@ = /Process%.Get@;
<@>@ Put@ = /Process%.Put@;

@ Rat@ = /Rat%.Rat@;
% Add = /Rat%.Add;
% Sub = /Rat%.Sub;
% Neg = /Rat%.Neg;
% Mul = /Rat%.Mul;
% Div = /Rat%.Div;
% Gt = /Rat/Eq%.Gt;
% Lt = /Rat/Eq%.Lt;
% Le = /Rat/Eq%.Le;
% Int = /Rat/Lit%.Int;

@ Unit@ = /Unit%.Unit@;
% Unit = /Unit%.Unit;

@ Vec@ = *(Rat@ x, Rat@ y);

(Vec@, Vec@) { Vec@; } AddV = (Vec@ a, Vec@ b) {
  Vec@(Add(a.x, b.x), Add(a.y, b.y));
};

(Vec@, Vec@) { Vec@; } SubV = (Vec@ a, Vec@ b) {
  Vec@(Sub(a.x, b.x), Sub(a.y, b.y));
};

(Vec@, Rat@) { Vec@; } MulVS = (Vec@ a, Rat@ s) {
  Vec@(Mul(a.x, s), Mul(a.y, s));
};

# RotateTo --
#   Given unit normal vector n and arbitrary vector v, rotate the vector v
#   to a coordinate system where n is at (0, 1).
(Vec@, Vec@) { Vec@; } RotateTo = (Vec@ n, Vec@ v) {
  Rat@ x = Sub(Mul(n.y, v.x), Mul(n.x, v.y));
  Rat@ y = Add(Mul(n.x, v.x), Mul(n.y, v.y));
  @(x, y);
};

# RotateFrom --
#   Given unit normal vector n and arbitrary vector v, rotate the vector v
#   out of a coordinate system where n is at (0, 1).
(Vec@, Vec@) { Vec@; } RotateFrom = (Vec@ n, Vec@ v) {
  Rat@ x = Add(Mul(n.y, v.x), Mul(n.x, v.y));
  Rat@ y = Sub(Mul(n.y, v.y), Mul(n.x, v.x));
  @(x, y);
};

(Vec@) { Point@; } Point = (Vec@ a) {
  Point@(
    /Int/Int/Div%.Div(a.x.n, a.x.d).q,
    /Int/Int/Div%.Div(a.y.n, a.y.d).q);
};

@ Ball@ = *(Vec@ pos, Vec@ vel);

@ Edge@ = *(
  Vec@ normal,     # Unit normal vector.
  Vec@ start,      # Starting position of the edge.
  Rat@ length      # Length of the edge.
);

@ World@ = *(Ball@ ball, List@<Edge@> edges);

World@ Initial = World@(
  Ball@(Vec@(Int|0, Int|100), Vec@(Int|1, Int|0)),
  List<Edge@>[
    Edge@(Vec@(Int|0, Int|1), Vec@(Neg(Int|100), Int|0), Int|200),
    Edge@(Vec@(Neg(Int|1), Int|0), Vec@(Int|30, Neg(Int|20)), Int|100)
  ]);

# HALF_G --
#   Half the acceleration due to gravity.
Vec@ HALF_G = Vec@(Int|0, Neg(Div(Int|1, Int|4)));

# R --
#   The coefficient of restitution: the fraction of energy preserved during a
#   collision.
Rat@ R = Div(Int|8, Int|10);

# Shrink --
#   Limit the precision of the ball to avoid taking up a potentially
#   significant necessary memory and computation time.
(Ball@) { Ball@; } Shrink = {
  Rat@ P = Div(Int|1, Int|128);
  (Rat@) { Rat@; } A = (Rat@ x) { /Rat%.Approx(x, P); };

  (Ball@ b) {
    Ball@(Vec@(A(b.pos.x), A(b.pos.y)), Vec@(A(b.vel.x), A(b.vel.y)));
  };
};

# Collide --
#   Check for and apply collision between ball and edge if any.
#
# Returns the ball in the state just after it's first collision at time
# 'time'.
@ CollideResult@ = *(Ball@ ball, Rat@ time);
(Vec@, Vec@, Vec@, Rat@, List@<Edge@>) { CollideResult@; }
Collide = (Vec@ start, Vec@ end, Vec@ vel, Rat@ time, List@<Edge@> edges) {
  edges.?(nil: @(ball: Ball@(end, vel), time));

  Edge@ edge = edges.cons.head;

  # For there to be considered a collision, the ball must start above the
  # edge and end below the edge.
  # TODO: what if the ball starts just below the edge. Could that be a case
  # where it is falling through the edge due to imprecision? Can we consider
  # it a collision if the ball starts just below the edge too to prevent that?
  Vec@ s = RotateTo(edge.normal, SubV(start, edge.start));
  Lt(s.y, Int|0).?(true: Collide(start, end, vel, time, edges.cons.tail));

  Vec@ e = RotateTo(edge.normal, SubV(end, edge.start));
  Gt(e.y, Int|0).?(true: Collide(start, end, vel, time, edges.cons.tail));

  # Collision detected.
  # 0 = y0 + vt ==>  t = -y0/v
  Vec@ v0 = RotateTo(edge.normal, vel);
  Rat@ t = Div(Neg(s.y), v0.y);
  Vec@ vc = Vec@(v0.x, Neg(v0.y));

  Vec@ end = AddV(start, MulVS(vel, t));
  Vec@ vel = RotateFrom(edge.normal, vc);
  Collide(start, end, MulVS(vel, R), t, edges.cons.tail);
};

# Move --
#   Move the ball by the given amount of time, assuming velocity stays
#   constant.
#
# In case of collision, we break down the time period into smaller bits. The
# assumption that velocity is constant is intended to prevent the case where
# we break down the time period into smaller and smaller bits and end up never
# reaching the end of the time period as a result. This is also assumes we
# don't have any super tight corners that would cause us to collide an
# excessive number of times in a single time period.
(Ball@, Rat@, List@<Edge@>) { Ball@; } Move = (Ball@ b, Rat@ t, List@<Edge@> edges) {
  Le(t, Int|0).?(true: b);

  Vec@ end = AddV(b.pos, MulVS(b.vel, t));
  CollideResult@ cr = Collide(b.pos, end, b.vel, t, edges);
  Move(cr.ball, Sub(t, cr.time), edges);
};

# Tick --
#   Advance the world by one unit of time.
(World@) { World@; } Tick = (World@ w) {
  # 1. Compute average expected velocity over the time period.
  Vec@ v_avg = AddV(w.ball.vel, HALF_G);

  # 2. Move the ball assuming constant velocity.
  Ball@ b_moved = Move(Ball@(w.ball.pos, v_avg), Int|1, w.edges);

  # 3. Compute final velocity.
  Vec@ v = AddV(b_moved.vel, HALF_G);

  World@(Shrink(Ball@(b_moved.pos, v)), w.edges);
};

(Ball@) { Drawing@; } DrawBall = (Ball@ ball) {
  Point@ p = Point(ball.pos);
  Rect(p.x, p.y, Int|10.n, Int|10.n, Color.Cyan);
};

(Edge@) { Drawing@; } DrawEdge = (Edge@ edge) {
  Point@ a = Point(edge.start);
  Point@ b = Point(SubV(edge.start, MulVS(edge.normal, Int|10)));
  Vec@ tangent = Vec@(edge.normal.y, Neg(edge.normal.x));
  Point@ c = Point(AddV(edge.start, MulVS(tangent, edge.length)));
  Triangle(a, b, c, Color.Green);
};

(World@) { Drawing@; } Draw = (World@ world) {
  /List%.ForEach<Edge@, Drawing@>(world.edges, DrawBall(world.ball),
    (Edge@ e, Drawing@ d) {
      Over(d, DrawEdge(e));
  });
};

(Get@<Event@>, Put@<World@>, Unit@!, World@) { Unit@!; }
Run = (Get@<Event@> in, Put@<World@> draw, Unit@! tick, World@ world) {
  Event@ e := in;

  e.?(tick: {
    Unit@ _ := tick;
    Unit@ _ := draw(world);
    Run(in, draw, tick, Tick(world));
  });

  e.?(key_down: {
    e.key_down.?(q: !(Unit));
    Run(in, draw, tick, world);
  });
  Run(in, draw, tick, world);
};

App@ Main = (Int@ width, Int@ height, Get@<Event@> in, Put@<Effect@> out) {
  Point@ a = @(x: Int|1.n, y: Neg(Int|1).n);
  Point@ b = @(x: Int|320.n, y: Int|240.n);
  Int@ frame_period = Int|16.n;
  Unit@! tick = out(Effect@(tick: frame_period));

  (World@) { Unit@!; } draw = (World@ s) {
    out(Effect@(draw: Over(
      Rect(Int|0.n, Int|0.n, width, height, Color.Black),
      Affine(a, b, Draw(s)))));
  };

  Unit@ _ := out(Effect@(tick: Int|0.n));
  Run(in, draw, tick, Initial); 
};

Main;

