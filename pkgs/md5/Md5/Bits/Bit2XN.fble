
@ Bool@ = /Core/Bool%.Bool@;
% And = /Core/Bool%.And;

<@>@ Bits@ = /Md5/Bits/Bits%.Bits@;
<@>@ Overflow@ = /Md5/Bits/Bits%.Overflow@;

<@>@ Bit2XT@ = <@ T@> { *(T@ hi, T@ lo); };

@(Bit2X@: Bit2XT@, Bit2XN: <@ T@>(Bits@<T@> B) {
  @ Bit2X@ = Bit2XT@<T@>;

  (Bit2X@){Bit2X@;} not = (Bit2X@ a) {
    Bit2X@(B.not(a.hi), B.not(a.lo));
  };

  (Bit2X@, Bit2X@){Bit2X@;} and = (Bit2X@ a, Bit2X@ b) {
    Bit2X@(B.and(a.hi, b.hi), B.and(a.lo, b.lo));
  };

  (Bit2X@, Bit2X@){Bit2X@;} or = (Bit2X@ a, Bit2X@ b) {
    Bit2X@(B.or(a.hi, b.hi), B.or(a.lo, b.lo));
  };

  (Bit2X@, Bit2X@){Bit2X@;} xor = (Bit2X@ a, Bit2X@ b) {
    Bit2X@(B.xor(a.hi, b.hi), B.xor(a.lo, b.lo));
  };

  (Bit2X@, Bit2X@, /Md5/Bits/Bit1%.Bit1@) { Overflow@<Bit2X@>; }
  add_overflow = (Bit2X@ a, Bit2X@ b, /Md5/Bits/Bit1%.Bit1@ cin) {
      Overflow@<T@> rlo = B.add_overflow(a.lo, b.lo, cin);
      Overflow@<T@> rhi = B.add_overflow(a.hi, b.hi, rlo.out);
      Overflow@(Bit2X@(rhi.x, rlo.x), rhi.out);
    };

  (Bit2X@, Bit2X@){Bit2X@;} add = (Bit2X@ a, Bit2X@ b) {
    add_overflow(a, b, /Md5/Bits/Bit1%.Bits.zero).x;
  };

  (Bit2X@) { Overflow@<Bit2X@>; } inc_overflow = (Bit2X@ a) {
      Overflow@<T@> rlo = B.inc_overflow(a.lo);
      rlo.out.?(
          0: Overflow@(Bit2X@(a.hi, rlo.x), /Md5/Bits/Bit1%.Bits.zero),
          1: {
              Overflow@<T@> rhi = B.inc_overflow(a.hi);
              Overflow@(Bit2X@(rhi.x, rlo.x), rhi.out);
          });
    };

  (Bit2X@){Bit2X@;} inc = (Bit2X@ a) {
    inc_overflow(a).x;
  };

  Bit2X@ zero = Bit2X@(B.zero, B.zero);

  (Bit2X@){Bool@;} iszero = (Bit2X@ a) {
    And(B.iszero(a.hi), B.iszero(a.lo));
  };

  (Bit2X@, Bit2X@){Bool@;} eq = (Bit2X@ a, Bit2X@ b) {
    And(B.eq(a.hi, b.hi), B.eq(a.lo, b.lo));
  };

  (Bit2X@){/Md5/Bits/Bit1%.Bit1@;} msb = (Bit2X@ a) {
    B.msb(a.hi);
  };

  (Bit2X@, /Md5/Bits/Bit1%.Bit1@) { Overflow@<Bit2X@>; }
  lshift_overflow = (Bit2X@ a, /Md5/Bits/Bit1%.Bit1@ cin) {
      Overflow@<T@> rlo = B.lshift_overflow(a.lo, cin);
      Overflow@<T@> rhi = B.lshift_overflow(a.hi, rlo.out);
      Overflow@(Bit2X@(rhi.x, rlo.x), rhi.out);
    };

  Bits@<Bit2X@>(
    not, and, or, xor, add, inc, zero, iszero, eq, msb,
    add_overflow, inc_overflow, lshift_overflow
  );
});
