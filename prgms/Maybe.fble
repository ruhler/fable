@ Unit@ = /Unit%.Unit@;
% Unit = /Unit%.Unit;

# Maybe@ --
#   Type representing an optional value.
#
# Type Parameters:
#   T@ - The type of value that is optional.
#
# Fields: 
#   just - The value is present.
#   nothing - The value is not present.
<@>@ Maybe@ = <@ T@> { +(T@ just, Unit@ nothing); };

# Just --
#   Construct a Maybe@ with a value that is present.
#
# Type Parameters:
#   T@ - The type of the value that is present.
#
# Arguments:
#   x - The value that is present.
#
# Returns:
#   A Maybe@ with the given present value.
#
# Example Use:
#   Maybe@<Foo@> = Just<Foo@>(MyFoo);
<@ T@>(T@){ Maybe@<T@>; } Just = <@ T@>(T@ x) { Maybe@<T@>(just: x); };

# Nothing --
#   A Maybe@ that does not have a value present.
#
# Type Parameters:
#   T@ - The type of value that the Maybe holds.
#
# Example Use:
#   Maybe@<Foo@> = Nothing<Foo@>;
Maybe@ Nothing = <@ T@> { Maybe@<T@>(nothing: Unit); };

# For --
#   TODO: Clean up the way this function is specified.
<@ I@, @ B@>(I@, B@, (I@) { Maybe@<I@>; }, (I@, B@) { B@; }) { B@; }
For = <@ I@, @ B@>(I@ i, B@ base, (I@) { Maybe@<I@>; } next, (I@, B@) { B@; } body) {
  Maybe@<I@> mnext = next(i);
  mnext.?(
    just: For<I@, B@>(mnext.just, body(i, base), next, body),
    nothing: body(i, base));
};

@(Maybe@, Just, Nothing, For);
