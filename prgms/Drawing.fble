
@ Unit@ = /Unit%.Unit@;
% Unit = /Unit%.Unit;

@ Int@ = /Int/Int%.Int@;
% Int = /Int/Int/Lit%.Int;

<@>@ List@ = /List%.List@;

@ Color@ = +(
  Unit@ black,
  Unit@ red,
  Unit@ green,
  Unit@ yellow,
  Unit@ blue,
  Unit@ magenta,
  Unit@ cyan,
  Unit@ white);

@ Point@ = *(Int@ x, Int@ y);

@ Drawing@ = +(
  # A blank (transparent) drawing.
  Unit@ blank,

  # A filled rectangle.
  *(Int@ x, Int@ y, Int@ w, Int@ h, Color@ color) rect,
  
  # Draw a drawing transformed by an affine transformation of the form
  # a*x + b.
  *(Point@ a, Point@ b, Drawing@ drawing) transformed,

  # Draw one drawing over another.
  *(Drawing@ below, Drawing@ above) over
);

Drawing@ Blank = Drawing@(blank: Unit);

# Draw a rectangle filled solid with the given color.
(Int@, Int@, Int@, Int@, Color@) { Drawing@; }
Rect = (Int@ x, Int@ y, Int@ w, Int@ h, Color@ color) {
  Drawing@(rect: @(x, y, w, h, color));
};

# Compose two drawings together by drawing one over another.
(Drawing@, Drawing@) { Drawing@; } Over = (Drawing@ below, Drawing@ above) {
  Drawing@(over: @(below: below, above: above));
};

# Combing a list of drawings into a single drawing by drawing each subsequent
# drawing on top of the previous drawing.
(List@<Drawing@>) { Drawing@; } Drawings = (List@<Drawing@> drawings) {
  drawings.?(
    cons: Over(drawings.cons.head, Drawings(drawings.cons.tail)),
    nil: Blank);
};

# Transform the drawing using an affine transform. Each point p will be
# transformed to (a.x*p.x + b.x, a.y*p.y + b.y).
(Point@, Point@, Drawing@) { Drawing@; }
Affine = (Point@ a, Point@ b, Drawing@ d) {
  Drawing@(transformed: @(a, b, drawing: d));
};

# Translate the drawing by the given x and y amounts.
(Int@, Int@, Drawing@) { Drawing@; }
Translate = (Int@ dx, Int@ dy, Drawing@ d) {
  Affine(@(x: Int|1, y: Int|1), @(x: dx, y: dy), d);
};

@(Color@, Drawing@, Point@,
  Blank, Rect, Over, Drawings, Affine, Translate);
