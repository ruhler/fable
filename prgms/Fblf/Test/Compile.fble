
@ Char@ = /Char%.Char@;

@ Bit@ = /Digits%.Bit@;

% Int = /Int/Int/Lit%.Int;

<@>@ List@ = /List%.List@;
<@>% Cons = /List%.Cons;
<@>% Nil = /List%.Nil;
<@>% Append = /List%.Append;
<@,@>% ForEach = /List%.ForEach;
<@,@>% Map = /List%.Map;

<@>% Length = /List/Length%.Length;

@ Output@ = /Fblf/Compile/Output%.Output@;
% Line = /Fblf/Compile/Output%.Line;
% Do = /Fblf/Compile/Output%.Do;
% Return = /Fblf/Compile/Output%.Return;

<@>@ Export@ = /Fblf/Export%.Export@;
% ExportStmt = /Fblf/Export%.ExportStmt;

<@>@ Module@ = /Fblf/Module%.Module@;
<@>@ Ran@ = /Fblf/Module%.Ran@;
@ Method@ = /Fblf/Module%.Method@;
<@>% DoMethod = /Fblf/Module%.DoMethod;
% MethodArgs = /Fblf/Module%.MethodArgs;
<@>% Module0 = /Fblf/Module%.Module0;
<@>% Module1 = /Fblf/Module%.Module1;
<@>% Run = /Fblf/Module%.Run;
<@>% DoAlloc = /Fblf/Module%.DoAlloc;

@ Var@ = /Fblf/Program%.Var@;
% Assign = /Fblf/Program%.Assign;
% Binary = /Fblf/Program%.Binary;
% Var = /Fblf/Program%.Var;
% Seq = /Fblf/Program%.Seq;
% IfElse = /Fblf/Program%.IfElse;
% Eq = /Fblf/Program%.Eq;

@ Test@ = /Fblf/Test%.Test@;
@ TestInstance@ = /Fblf/Test%.TestInstance@;

@ String@ = /String%.String@;
% Str = /String%.Str;
% Strs = /String%.Strs;

@ Unit@ = /Unit%.Unit@;

# Test Module: given single bit variable 'pass', sets it to true if the test
# succeeds, false otherwise.
@ TestMethod@ = *(String@ name, Method@ method);
@ TMs@ = List@<TestMethod@>;

Export@<TestMethod@> ExportTestMethod = ((Var@) { Var@; } f, TestMethod@ x) {
  TestMethod@(x.name, ExportStmt(f, x.method));
};

Export@<TMs@> ExportTMs = ((Var@) { Var@; } f, TMs@ x) {
  Map<TestMethod@, TestMethod@>(x, (TestMethod@ tm) { ExportTestMethod(f, tm); });
};

# Collect all the individual test cases from a test suite into a single module.
(Var@, String@, Test@, TMs@) { Module@<TMs@>; } Collect = (Var@ pass, String@ prefix, Test@ test, TMs@ tail) {
  test.?(
    case: {
      String@ name = Append<Char@>(prefix, test.case.name);
      (Var@) { Module@<TestMethod@>; } tm = Module1<TestMethod@>(ExportTestMethod, name, (Var@ pass) {
        TestInstance@ ti <- /Fblf/Module%.Do<TestInstance@, TestMethod@>(test.case.test);

        Method@ method <- DoMethod<TestMethod@>(Str|'test', Seq[
          Assign(pass, Binary|0, Int|1),
          ti.method,
          IfElse(Eq(Var(ti.result), Binary(ti.expected), Length<Bit@>(ti.expected)),
            Assign(pass, Binary|1, Int|1),
            Assign(pass, Binary|0, Int|1))
        ]);

        /Fblf/Module%.Return<TestMethod@>(TestMethod@(name, method));
      });

      TestMethod@ method <- /Fblf/Module%.Do<TestMethod@, TMs@>(tm(pass));
      /Fblf/Module%.Return<TMs@>(Cons<TestMethod@>(method, tail));
    },
    suite: {
      String@ nprefix = Strs[prefix, test.suite.name, Str|'.'];
      Module@<TMs@> base = /Fblf/Module%.Return<TMs@>(tail);
      ForEach<Test@, Module@<TMs@>>(test.suite.tests, base, (Test@ t, Module@<TMs@> m) {
        TMs@ as <- /Fblf/Module%.Do<TMs@, TMs@>(m);
        Collect(pass, nprefix, t, as);
      });
    });
};

# Compile --
#   Compiles an fblf test suite into a C file that runs all the tests.
(Test@) { Output@; } Compile = (Test@ t) {
  Unit@ _ <- Do(Line|'#include <assert.h>');
  Unit@ _ <- Do(Line|'');
  Unit@ _ <- Do(Line|'#include "fblf-heap.h"');
  Unit@ _ <- Do(Line|'');

  Module@<TMs@> test_module = Module0<TMs@>(ExportTMs, Str|'TestsModule', {
    Var@ pass <- DoAlloc<TMs@>(Int|1);
    Collect(pass, Str|'', t, Nil<TestMethod@>);
  });

  Ran@<TMs@> ran = Run<TMs@>(test_module);

  Unit@ _ <- Do(/Fblf/Compile%.Compile(Str|'_prog', ran.program));

  Unit@ _ <- Do(Line|'int main()');
  Unit@ _ <- Do(Line|'{');
  Unit@ _ <- Do(Line(Strs[
    Str|'  FblfHeapWord heap[FBLF_HEAP_WORDS_FOR_BITS(',
    /Int/Int/Show%.Show(ran.heap),
    Str|')];'
  ]));
  Unit@ _ <- Do(Line|'');
    
  Unit@ _ <- Do(ForEach<TestMethod@, Output@>(ran.x, Return, (TestMethod@ tm, Output@ o) {
    Unit@ _ <- Do(o);
    Unit@ _ <- Do(/Fblf/Compile%.CompileUserCall(Str|'_prog', Str|'  ', Str|'heap', tm.method.call.proc, MethodArgs(tm.method)));
    Unit@ _ <- Do(Line(Strs[
      Str|'  assert(FblfHeapRead(heap, 0, 1) == 1 && "',
      tm.name,  # TODO: Hopefully there are no funny characters in the name.
      Str|' FAILED");'
    ]));
    Unit@ _ <- Do(Line|'');
    Return;
  }));

  Unit@ _ <- Do(Line|'  return 0;');
  Unit@ _ <- Do(Line|'}');
  Return;
};

@(Compile);
