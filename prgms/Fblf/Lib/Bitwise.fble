% B = /Digits%.Bit;

@ Addr@ = /Fblf/Program%.Addr@;
@ ProgramM@ = /Fblf/Program%.ProgramM@;
@ Module@ = /Fblf/Program%.Module@;
% Assign = /Fblf/Program%.Assign;
% Eq = /Fblf/Program%.Eq;
% If = /Fblf/Program%.If;
% Seq = /Fblf/Program%.Seq;
% Noop = /Fblf/Program%.Noop;
% Const = /Fblf/Program%.Const;
% Ref = /Fblf/Program%.Ref;

@ Int@ = /Int/Int%.Int@;
% Add = /Int/Int%.Add;
% Sub = /Int/Int%.Sub;
% Lt = /Int/Int/Eq%.Lt;

% D = /Int/Int/Lit%.D;
% I = /Int/Int/Lit%.I;

<@>@ Maybe@ = /Maybe%.Maybe@;
<@>% Just = /Maybe%.Just;
<@>% Nothing = /Maybe%.Nothing;

<@,@>% For = /Loop%.For;

# AndF --
#   n-bit bitwise AND.
#
# Inputs:
#   n - The number of bits in each operand.
#   a - The address of the first operand.
#   b - The address of the second operand.
#   z - The address of the result.
(Int@, Addr@, Addr@, Addr@) { Module@; }
AndF = (Int@ n, Addr@ a, Addr@ b, Addr@ z)(Addr@ free) {
  (Int@) { Maybe@<Int@>; } next = (Int@ i) {
    /Int/Int/Eq%.Le(i, I(D|0)).?(true: Nothing<Int@>, false: Just<Int@>(Sub(i, I(D|1))));
  };

  For<Int@, ProgramM@>(next(n), next, ProgramM@(free, Noop),
    (Int@ i, ProgramM@ s) {
      Addr@ ai = Add(a, i);
      Addr@ bi = Add(b, i);
      Addr@ zi = Add(z, i);

      # TODO: The caller better not alias a and z, or this won't work!
      ProgramM@(s.free, Seq([s.program, 
        If(Eq(Ref(ai), Const(B|0), I(D|1)),
          Assign(zi, Const(B|0), I(D|1))),
        If(Eq(Ref(ai), Const(B|1), I(D|1)),
          Assign(zi, Ref(bi), I(D|1)))]));
    });
};

# OrF --
#   n-bit bitwise OR.
#
# Inputs:
#   n - The number of bits in each operand.
#   a - The address of the first operand.
#   b - The address of the second operand.
#   z - The address of the result.
(Int@, Addr@, Addr@, Addr@) { Module@; }
OrF = (Int@ n, Addr@ a, Addr@ b, Addr@ z)(Addr@ free) {
  (Int@) { Maybe@<Int@>; } next = (Int@ i) {
    /Int/Int/Eq%.Le(i, I(D|0)).?(true: Nothing<Int@>, false: Just<Int@>(Sub(i, I(D|1))));
  };

  For<Int@, ProgramM@>(next(n), next, ProgramM@(free, Noop),
    (Int@ i, ProgramM@ s) {
      Addr@ ai = Add(a, i);
      Addr@ bi = Add(b, i);
      Addr@ zi = Add(z, i);

      # TODO: The caller better not alias a and z, or this won't work!
      ProgramM@(s.free, Seq([s.program, 
        If(Eq(Ref(ai), Const(B|1), I(D|1)),
          Assign(zi, Const(B|1), I(D|1))),
        If(Eq(Ref(ai), Const(B|0), I(D|1)),
          Assign(zi, Ref(bi), I(D|1)))]));
    });
};

# XorF --
#   n-bit bitwise XOR.
#
# Inputs:
#   n - The number of bits in each operand.
#   a - The address of the first operand.
#   b - The address of the second operand.
#   z - The address of the result.
(Int@, Addr@, Addr@, Addr@) { Module@; }
XorF = (Int@ n, Addr@ a, Addr@ b, Addr@ z)(Addr@ free) {
  (Int@) { Maybe@<Int@>; } next = (Int@ i) {
    /Int/Int/Eq%.Le(i, I(D|0)).?(true: Nothing<Int@>, false: Just<Int@>(Sub(i, I(D|1))));
  };

  For<Int@, ProgramM@>(next(n), next, ProgramM@(free, Noop),
    (Int@ i, ProgramM@ s) {
      Addr@ ai = Add(a, i);
      Addr@ bi = Add(b, i);
      Addr@ zi = Add(z, i);

      # TODO: The caller better not alias a and z, or this won't work!
      ProgramM@(s.free, Seq([s.program, 
        Assign(zi, Const(B|0), I(D|1)),
        If(Eq(Ref(ai), Const(B|0), I(D|1)),
          Assign(zi, Ref(bi), I(D|1))),
        If(Eq(Ref(bi), Const(B|0), I(D|1)),
          Assign(zi, Ref(ai), I(D|1)))]));
    });
};

# NotF --
#   n-bit bitwise NOT.
#
# Inputs:
#   n - The number of bits in the operand.
#   a - The address of the operand.
#   z - The address of the result.
(Int@, Addr@, Addr@) { Module@; }
NotF = (Int@ n, Addr@ a, Addr@ z)(Addr@ free) {
  (Int@) { Maybe@<Int@>; } next = (Int@ i) {
    /Int/Int/Eq%.Le(i, I(D|0)).?(true: Nothing<Int@>, false: Just<Int@>(Sub(i, I(D|1))));
  };

  For<Int@, ProgramM@>(next(n), next, ProgramM@(free, Noop),
    (Int@ i, ProgramM@ s) {
      Addr@ ai = Add(a, i);
      Addr@ zi = Add(z, i);

      # TODO: The caller better not alias a and z, or this won't work!
      ProgramM@(s.free, Seq([s.program, 
        If(Eq(Ref(ai), Const(B|1), I(D|1)),
          Assign(zi, Const(B|0), I(D|1))),
        If(Eq(Ref(ai), Const(B|0), I(D|1)),
          Assign(zi, Const(B|1), I(D|1)))]));
    });
};

# ClsF --
#   n-bit circular left shift.
#
# Inputs:
#   n - The number of bits in the operand.
#   s - The number of bits to shift left.
#   a - The address of the operand.
#   z - The address of the result.
(Int@, Int@, Addr@, Addr@) { Module@; }
ClsF = (Int@ n, Int@ s, Addr@ a, Addr@ z)(Addr@ free) {
  (Int@) { Maybe@<Int@>; } next = (Int@ i) {
    /Int/Int/Eq%.Le(i, I(D|0)).?(true: Nothing<Int@>, false: Just<Int@>(Sub(i, I(D|1))));
  };

  For<Int@, ProgramM@>(next(n), next, ProgramM@(free, Noop),
    (Int@ i, ProgramM@ ss) {
      Addr@ ai = Add(a, i);
      Int@ offset = Lt(i, s).?(
        true: Sub(Add(n, i), s),
        false: Sub(i, s));
      Addr@ zi = Add(z, offset);

      ProgramM@(ss.free, Seq([ss.program, Assign(zi, Ref(ai), I(D|1))]));
    });
};

@(AndF, OrF, XorF, NotF, ClsF);
