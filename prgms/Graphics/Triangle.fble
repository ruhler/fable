
% And = /Bool%.And;

@ Drawing@ = /Drawing%.Drawing@;
@ Color@ = /Drawing%.Color@;
@ Point@ = /Drawing%.Point@;
% Blank = /Drawing%.Blank;

@ Vec@ = /Graphics/3D%.Vec@;

@ Camera@ = /Graphics/Camera%.Camera@;
% Perspective = /Graphics/Camera%.Perspective;

% Le = /Int/Int/Eq%.Le;
% Gt = /Int/Int/Eq%.Gt;
% Int = /Int/Int/Lit%.Int;

# Draw@ --
#   A function to draw a triangle in 3D.
@ Draw@ = (Camera@, Vec@, Vec@, Vec@, Color@) { Drawing@; };

# Clipped --
#   Draw an already clipped triangle.
Draw@ Clipped = (Camera@ camera, Vec@ a, Vec@ b, Vec@ c, Color@ color) {
  Point@ a_ = Perspective(camera, a);
  Point@ b_ = Perspective(camera, b);
  Point@ c_ = Perspective(camera, c);
  /Graphics/2D%.Triangle(a_, b_, c_, color);
};

# ClipLeft --
#   Draw a triangle after clipping any bits too far to the left for the camera
#   to see.
(Draw@) { Draw@; } ClipLeft = (Draw@ draw) {
  # TODO: Actually implement clipping.
  draw;
};

# ClipRight --
#   Draw a triangle after clipping any bits too far to the right for the camera
#   to see.
(Draw@) { Draw@; } ClipRight = (Draw@ draw) {
  # TODO: Actually implement clipping.
  draw;
};

# ClipTop --
#   Draw a triangle after clipping any bits too far to the top for the camera
#   to see.
(Draw@) { Draw@; } ClipTop = (Draw@ draw) {
  # TODO: Actually implement clipping.
  draw;
};

# ClipBottom --
#   Draw a triangle after clipping any bits too far to the bottom for the
#   camera to see.
(Draw@) { Draw@; } ClipBottom = (Draw@ draw) {
  # TODO: Actually implement clipping.
  draw;
};

# ClipBehind --
#   Draw a triangle after clipping any bits behind the camera.
#
# TODO: This shouldn't be needed once the other clipping functions are
# implemented, right?
(Draw@) { Draw@; } ClipBehind = (Draw@ draw) {
  (Camera@ camera, Vec@ a, Vec@ b, Vec@ c, Color@ color) {
    # Rotate the points [a, b, c] such that any points behind the camera are at
    # the end of the list [a, b, c].
    % l = {
      And(Le(a.z, Int|0), Gt(b.z, Int|0)).?(true: @(a: b, b: c, c: a));
      And(Le(b.z, Int|0), Gt(c.z, Int|0)).?(true: @(a: c, b: a, c: b));
      @(a, b, c);
    };
    Vec@ a = l.a; Vec@ b = l.b; Vec@ c = l.c;

    # Only draw the triangle if all points are in front of the camera for now.
    Le(c.z, Int|0).?(true: Blank);
    draw(camera, a, b, c, color);
  };
};

# Triangle --
#   Draw a triangle from the point of view of a camera.
#
# The input points should all be from calling /Graphics/Camera%.Vertex with
# the same camera.  That is, the input points are relative to the position and
# orientation of the camera.
(Camera@, Vec@, Vec@, Vec@, Color@) { Drawing@; }
Triangle = {
  ClipBehind(ClipTop(ClipLeft(ClipRight(ClipBottom(Clipped)))));
};

@(Triangle);
