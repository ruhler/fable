
@ App@ = /App%.App@;
@ Event@ = /App%.Event@;
@ Effect@ = /App%.Effect@;

@ Bool@ = /Bool%.Bool@;
% False = /Bool%.False;
% True = /Bool%.True;

@ Draw@ = /Drawing%.Draw@;
@ Color@ = /Drawing%.Color@;
@ Point@ = /Drawing%.Point@;
% Rect = /Drawing%.Rect;
% Over = /Drawing%.Over;
% Affine = /Drawing%.Affine;

@ Coord@ = /Hwdg%.Coord@;
@ Data@ = /Hwdg%.Data@;
@ Gate@ = /Hwdg%.Gate@;
@ Gates@ = /Hwdg%.Gates@;
@ Cells@ = /Hwdg%.Cells@;
<@>@ Ports@ = /Hwdg%.Ports@;
% Data0 = /Hwdg%.0;
% Data1 = /Hwdg%.1;
% SetData = /Hwdg%.SetData;
% EmptyCells = /Hwdg%.EmptyCells;
<@>% ForEachGate = /Hwdg%.ForEachGate;

@ Int@ = /Int/Int%.Int@;
% 0 = /Int/Int%.0;
% 1 = /Int/Int%.1;
% 2 = /Int/Int%.2;
% Inc = /Int/Int%.Inc;
% Dec = /Int/Int%.Dec;
% Neg = /Int/Int%.Neg;
% Sub = /Int/Int%.Sub;

% Div = /Int/Int/Div%.Div;

% IsZero = /Int/Int/Eq%.IsZero;

% Int = /Int/Int/Lit%.Int;

<@>@ Maybe@ = /Maybe%.Maybe@;

<@>@ Get@ = /Process%.Get@;
<@>@ Put@ = /Process%.Put@;

@ Unit@ = /Unit%.Unit@;
% Unit = /Unit%.Unit;

Int@ XMin = Neg(Int|20);
Int@ XMax = Int|20;
Int@ YMin = Neg(Int|20);
Int@ YMax = Int|20;
Int@ Width = Sub(XMax, XMin);
Int@ Height = Sub(YMax, YMin);

# Gates --
#   The particular gates for the hardware layout to simulate.
Gates@ Gates = /Hwdg/Adder%.Adder4;

# Cells --
#   The initial data configuration of the hardware to simulate
Cells@ Cells = {
  SetData(SetData(SetData(SetData(SetData(SetData(SetData(SetData(SetData(EmptyCells,
    Coord@(Int|0, 0), Data1), # a3
    Coord@(Int|4, 0), Data1), # a2
    Coord@(Int|8, 0), Data1), # a1
    Coord@(Int|12, 0), Data1), # a0
    Coord@(Int|3, 0), Data1), # b3
    Coord@(Int|7, 0), Data0), # b2
    Coord@(Int|11, 0), Data1), # b1
    Coord@(Int|15, 0), Data1), # b0
    Coord@(Int|16, 2), Data0); # c
};

# Draw --
#   Draw the current hardware configuration.
(Gates@, Cells@) { Draw@; } Draw = (Gates@ gates, Cells@ cells) {
  # 1. Clear the background.
  Draw@ clear = Rect(XMin, YMin, Width, Height, Color@(black: Unit));

  # 2. For each input or output port of a gate, draw a white unit square.
  # TODO: Don't assume Gates is a /Map%.Map@?
 Draw@ io = ForEachGate<Draw@>(gates, clear,
   (Coord@ p, Gate@ g, Draw@ d) {
     Ports@<Coord@> coords = Ports@<Coord@>(
       Coord@(p.x, p.y), Coord@(Inc(p.x), p.y),
       Coord@(p.x, Inc(p.y)), Coord@(Inc(p.x), Inc(p.y)));

     Ports@<Bool@> used = Ports@<Bool@>(
       g.ports.ul.?(unused: False, : True),
       g.ports.ur.?(unused: False, : True),
       g.ports.ll.?(unused: False, : True),
       g.ports.lr.?(unused: False, : True));

     Ports@<Draw@> fills = Ports@<Draw@>(
       Rect(coords.ul.x, coords.ul.y, 1, 1, Color@(white: Unit)),
       Rect(coords.ur.x, coords.ur.y, 1, 1, Color@(white: Unit)),
       Rect(coords.ll.x, coords.ll.y, 1, 1, Color@(white: Unit)),
       Rect(coords.lr.x, coords.lr.y, 1, 1, Color@(white: Unit)));

     Draw@ d_ul = used.ul.?(true: Over(d, fills.ul), false: d);
     Draw@ d_ur = used.ur.?(true: Over(d_ul, fills.ur), false: d_ul);
     Draw@ d_ll = used.ll.?(true: Over(d_ur, fills.ll), false: d_ur);
     Draw@ d_lr = used.lr.?(true: Over(d_ll, fills.lr), false: d_ll);
     d_lr;
   });
    
  # 3. Draw a green square for 1 and a red square for 0.
  # TODO: Don't assume Cells@ is a /Map%.Map@?
  /Map%.ForEach<Coord@, Data@, Draw@>(cells, io,
    (Coord@ p, Data@ data, Draw@ d) {
      Color@ color = data.?(0: Color@(red: Unit), 1: Color@(green: Unit));
      Over(d, Rect(p.x, p.y, 1, 1, color));
    });
};

@ Input@ = +(Unit@ quit, Unit@ step);

(Get@<Event@>) { Get@<Input@>; } GetInput = (Get@<Event@> in) {
  Event@ e := in;
  e.?(tick: !(Input@(step: Unit)),
      key_down: e.key_down.?(q: !(Input@(quit: Unit)), : GetInput(in)),
      key_up: GetInput(in));
};

(Gates@, Cells@) { Cells@; } Step = (Gates@ gates, Cells@ cells) {
  Maybe@<Cells@> mcells = /Hwdg%.Step(gates, cells);
  mcells.?(just: mcells.just, nothing: cells);
};

(Get@<Input@>, Put@<Effect@>, Int@, Gates@, Cells@) { Unit@!; }
StepUI = (Get@<Input@> in, Put@<Effect@> out, Int@ n, Gates@ gates, Cells@ cells) {
  Unit@ _ := out(Effect@(draw: Draw(gates, cells)));
  Unit@ _ := out(Effect@(tick: Int|400));
  Input@ x := in;
  x.?(quit: !(Unit),
      step: IsZero(n).?(
              true: !(Unit),
              false: StepUI(in, out, Dec(n), gates, Step(gates, cells))));
};

App@ Main = (Int@ width, Int@ height, Get@<Event@> in, Put@<Effect@> out) {
  # Map game coordinates into screen coordinate.
  Point@ a = @(x: Div(width, Width), y: Div(height, Height));
  Point@ b = @(x: Div(width, 2), y: Div(height, 2));

  Put@<Effect@> game_out = (Effect@ e) {
    Effect@ transformed = e.?(
      tick: e,
      draw: Effect@(draw: Affine(a, b, e.draw)));
    # Note: we don't just use 'out(transformed)' here because of a bug in
    # profiling when tail calling a PUT value function.
    Unit@ _ := out(transformed);
    !(Unit);
  };

  Unit@! WaitForKeyPress = {
    Event@ e := in;
    e.?(tick: WaitForKeyPress, key_down: !(Unit), key_up: WaitForKeyPress);
  };

  Unit@ _ := game_out(Effect@(draw: Draw(Gates, Cells)));
  Unit@ _ := WaitForKeyPress;
  Unit@ _ := StepUI(GetInput(in), game_out, Int|2000, Gates, Cells);

  WaitForKeyPress;
};

Main;
