
@ Int@ = /Int/Int%.Int@;
% D = /Int/Int/Lit%.D;
% I = /Int/Int/Lit%.I;

@ Addr@ = /Fblf/Program%.Addr@;

@ Module@ = /Fblf/Module%.Module@;
% AllocM = /Fblf/Module%.AllocM;
% SeqM = /Fblf/Module%.SeqM;

% AddF = /Fblf/Lib/Add%.AddF;
% AndF = /Fblf/Lib/Bitwise%.AndF;
% OrF = /Fblf/Lib/Bitwise%.OrF;
% XorF = /Fblf/Lib/Bitwise%.XorF;
% NotF = /Fblf/Lib/Bitwise%.NotF;

Int@ 32 = I(D|32);

(Addr@, Addr@, Addr@, Addr@) { Module@; }
RoundF = (Addr@ x, Addr@ y, Addr@ z, Addr@ r) {
  # r = or(and(x, y), and(not(x), z));
  AllocM(32, (Addr@ nx) {
    AllocM(32, (Addr@ anxz) {
      AllocM(32, (Addr@ xy) {
        SeqM([
          NotF(32, x, nx),
          AddF(32, nx, z, anxz),
          AndF(32, x, y, xy),
          OrF(32, xy, anxz, r)]);
      });
    });
  });
};

(Addr@, Addr@, Addr@, Addr@) { Module@; }
RoundG = (Addr@ x, Addr@ y, Addr@ z, Addr@ r) {
  # r = or(and(x, z), and(y, not(z)));
  AllocM(32, (Addr@ nz) {
    AllocM(32, (Addr@ aynz) {
      AllocM(32, (Addr@ xz) {
        SeqM([
          NotF(32, z, nz),
          AddF(32, y, nz, aynz),
          AndF(32, x, z, xz),
          OrF(32, xz, aynz, r)]);
      });
    });
  });
};

(Addr@, Addr@, Addr@, Addr@) { Module@; }
RoundH = (Addr@ x, Addr@ y, Addr@ z, Addr@ r) {
  # r = xor(x, xor(y, z));
  AllocM(32, (Addr@ yz) {
    SeqM([
      XorF(32, y, z, yz),
      XorF(32, x, yz, r)]);
  });
};

(Addr@, Addr@, Addr@, Addr@) { Module@; }
RoundI = (Addr@ x, Addr@ y, Addr@ z, Addr@ r) {
  # r = xor(y, or(x, not(z)));
  AllocM(32, (Addr@ nz) {
    AllocM(32, (Addr@ xnz) {
      SeqM([
        NotF(32, z, nz),
        OrF(32, x, nz, xnz),
        XorF(32, y, xnz, r)]);
    });
  });
};

@(RoundF, RoundG, RoundH, RoundI);
