
<@>@ List@ = /Core/List%.List@;
<@>% List = /Core/List%.List;
<@>% Cons = /Core/List%.Cons;
<@>% Append = /Core/List%.Append;

<@>@ Maybe@ = /Core/Maybe%.Maybe@;

@ String@ = /Core/String%.String@;
% Strs = /Core/String%.Strs;
% Str = /Core/String%.Str;

@ Markup@ = /Fbld/Markup%.Markup@;
@ Command@ = /Fbld/Markup%.Command@;
@ Element@ = /Fbld/Markup%.Element@;

% Text = /Fbld/Text%.Text;

<@>@ Result@ = /Fbld/Result%.Result@;
<@>% Err = /Fbld/Result%.Err;
% r = /Fbld/Result%.Monad;

@ Impl@ = (Env@, Command@) { Result@<Markup@>; },
@ Env@ = /Core/Map%.Map@<String@, Impl@>;

% EmptyEnv = /Core/Map%.Empty<String@, Impl@>;
% InsertEnv = /Core/Map%.Insert<String@>(/Core/String/Ord%.Ord)<Impl@>;
% LookupEnv = /Core/Map%.Lookup<String@>(/Core/String/Ord%.Ord)<Impl@>;

(Env@, Command@) { Result@<Markup@>; }
Command = (Env@ env, Command@ cmd) {
  Maybe@<Impl@> impl = LookupEnv(env, cmd.name.text);
  impl.?(nothing: {
    Err<Markup@>(Text(cmd.name.loc, Strs[Str|'no such command: ', cmd.name.text]));
  });
  impl.just(env, cmd);
};

(Env@, Element@) { Result@<Markup@>; }
Element = (Env@ env, Element@ element) {
  element.?(plain: r.return(List[element]));
  Command(env, element.command);
};

(Env@, Markup@) { Result@<Markup@>; }
Eval = (Env@ env, Markup@ markup) {
  markup.?(nil: r.return(markup));
  Markup@ head <- r.do(Element(env, markup.cons.head));
  Markup@ tail <- r.do(Eval(env, markup.cons.tail));
  r.return(Append(head, tail));
};

(Env@, List@<Markup@>) { Result@<List@<Markup@>>; }
Evals = (Env@ env, List@<Markup@> markups) {
  markups.?(nil: r.return(markups));
  Markup@ head <- r.do(Eval(env, markups.cons.head));
  List@<Markup@> tail <- r.do(Evals(env, markups.cons.tail));
  r.return(Cons(head, tail));
};

@(Impl@, Env@,
  EmptyEnv, LookupEnv, InsertEnv,
  Eval, Evals);
