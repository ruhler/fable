
@ Bool@ = /Core/Bool%.Bool@;
% True = /Core/Bool%.True;
% False = /Core/Bool%.False;

@ Char@ = /Core/Char%.Char@;

<@>@ List@ = /Core/List%.List@;
<@>% Cons = /Core/List%.Cons;
<@>% Nil = /Core/List%.Nil;
<@>% Reverse = /Core/List%.Reverse;

@ Int@ = /Core/Int%.Int@;
% Decr = /Core/Int%.Decr;
% Le = /Core/Int/Eq%.Le;
% Int = /Core/Int/Lit%.Int;

@ String@ = /Core/String%.String@;
% Str = /Core/String%.Str;

@ Loc@ = /Fbld/Loc%.Loc@;
% Advance = /Fbld/Loc%.Advance;

@ _@ = %(/Fbld/Text%);

@ LChar@ = *(Char@ char, Loc@ loc);

@ Text_@ = +(
  Loc@ empty,
  *(LChar@ head, Text_@ tail) cons,
  *(Text_@ a, Text_@ b) append    # a and b are both non-empty.
);

(Loc@) { Text_@; }
Empty_ = (Loc@ loc) {
  Text_@(empty: loc);
};

(String@, Loc@) { Text_@; }
Text_ = {
  # String@ -> reverse order list of LChar@
  (String@, Loc@, List@<LChar@>) { List@<LChar@>; }
  chars = (String@ str, Loc@ loc, List@<LChar@> cs) {
    str.?(nil: cs);

    LChar@ c = LChar@(str.cons.head, loc);
    chars(str.cons.tail, Advance(loc, str.cons.head), Cons(c, cs));
  };

  # Reverse order list of LChar@ -> Text@
  (List@<LChar@>, Text_@) { Text_@; }
  text = (List@<LChar@> cs, Text_@ t) {
    cs.?(nil: t);
    Text_@ tail = Text_@(cons: @(head: cs.cons.head, tail: t));
    text(cs.cons.tail, tail);
  };
  
  (String@ str, Loc@ loc) {
    str.?(nil: Empty_(loc));
    List@<LChar@> cs = chars(str, loc, Nil<LChar@>);
    text(cs, Empty_(cs.cons.head.loc));
  };
};

(Text_@, Text_@) { Text_@; }
Append_ = (Text_@ a, Text_@ b) {
  a.?(empty: b);
  b.?(empty: a);
  Text_@(append: @(a, b));
};

(Text_@) { Bool@; }
IsEmpty_ = (Text_@ text) {
  text.?(empty: True);
  False;
};

(Text_@) { Char@; }
Head_ = (Text_@ text) {
  text.?(cons: text.cons.head.char);
  Head_(text.append.a);
};

(Text_@) { Text_@; }
Tail_ = (Text_@ text) {
  text.?(cons: text.cons.tail);
  Append_(Tail_(text.append.a), text.append.b);
};

(Text_@) { Loc@; }
LocOf_ = (Text_@ text) {
  text.?(empty: text.empty);
  text.?(cons: text.cons.head.loc);
  LocOf_(text.append.a);
};

# Abstract string type that supports location tracking and fast concatenation.
@ Text@ = _@<Text_@>;

(String@, Loc@) { Text@; } Text = _@.<@<Text>>(Text_);

# Returns the first character of text.
# Behavior is undefined if the text is empty.
(Text@) { Char@; } Head = _@.<@<Head>>(Head_);

# LocOf --
#   Gets the location of the start of the text.
(Text@) { Loc@; } LocOf = _@.<@<LocOf>>(LocOf_);

(Text@) { Bool@; } IsEmpty = _@.<@<IsEmpty>>(IsEmpty_);

(Loc@) { Text@; } Empty = _@.<@<Empty>>(Empty_);

(Text@, Text@) { Text@; } Append = _@.<@<Append>>(Append_);

(Text@) { Text@; } Tail = _@.<@<Tail>>(Tail_);

# StringOf --
#   Extracts the contents of the text into a String@.
#
# Note: This may be an expensive operation. Avoid duplicate calls where
# possible.
(Text@) { String@; }
StringOf = {
  (Text@, String@) { String@; }
  str = (Text@ t, String@ r) {
    IsEmpty(t).?(true: Reverse(r));
    str(Tail(t), Cons(Head(t), r));
  };

  (Text@ text) {
    str(text, Str|'');
  };
};

(Loc@, List@<Text@>) { Text@; }
Concat = (Loc@ l, List@<Text@> x) {
  x.?(nil: Empty(l));
  Append(x.cons.head, Concat(l, x.cons.tail));
};

(Text@, String@) { Bool@; }
StartsWith = (Text@ text, String@ sub) {
  sub.?(nil: True);
  IsEmpty(text).?(true: False);
  /Core/Char/Eq%.Eq(sub.cons.head, Head(text)).?(false: False);
  StartsWith(Tail(text), sub.cons.tail);
};

(Int@, Text@) { Text@; } Drop = (Int@ n, Text@ l) {
  Le(n, Int|0).?(true: l);
  IsEmpty(l).?(true: l);
  Drop(Decr(n), Tail(l));
};

@(Text@, Text, StringOf, LocOf, IsEmpty, Empty, Head, Tail, Append, Concat,
  StartsWith, Drop);
