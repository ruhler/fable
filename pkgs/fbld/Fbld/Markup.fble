
<@>@ List@ = /Core/List%.List@;
<@>% Append = /Core/List%.Append;

@ String@ = /Core/String%.String@;
% Str = /Core/String%.Str;
% Strs = /Core/String%.Strs;

@ Loc@ = /Fbld/Loc%.Loc@;

<@>@ Result@ = /Fbld/Result%.Result@;
<@>% Err = /Fbld/Result%.Err;
% r = /Fbld/Result%.Monad;

@ Text@ = /Fbld/Text%.Text@;
% Text = /Fbld/Text%.Text;

# Fble Marked up text.
@ Command@ = *(Text@ name, List@<Markup@> args),
@ Element@ = +(Text@ plain, Command@ command),
@ Markup@ = List@<Element@>;

(List@<Element@>) { Markup@; } Markup = /Core/List%.List<Element@>;

(Loc@, String@) { Element@; }
Plain = (Loc@ l, String@ str) {
  Element@(plain: Text@(l, str));
};

(Loc@, String@)(List@<Markup@>) { Element@; }
Command = (Loc@ l, String@ name)(List@<Markup@> args) {
  Element@(command: Command@(Text@(l, name), args));
};

# Interprets Markup@ as plain text.
# Fails if the Markup isn't plain text.
(Markup@) { Result@<String@>; }
ToPlain = (Markup@ m) {
  m.?(nil: r.return(Str|''));
  Element@ e = m.cons.head;
  e.?(command: {
    Err<String@>(Text(e.command.name.loc, Strs[
        Str|'expected plain text, but found command @',
        e.command.name.text
        ]));
  });

  String@ head = e.plain.text;
  String@ tail <- r.do(ToPlain(m.cons.tail));
  r.return(Append(head, tail));
};

@(Markup@, Command@, Element@,
  Markup, Command, Plain,
  ToPlain);
