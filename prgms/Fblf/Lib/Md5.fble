
@ Hex@ = /Digits%.Hex@;
% BitStr = /Digits/String%.BitStr;

@ Int@ = /Int/Int%.Int@;
% Add = /Int/Int%.Add;
% Sub = /Int/Int%.Sub;
% Mul = /Int/Int%.Mul;
% Exp2 = /Int/Int%.Exp2;
% Int = /Int/Int/Lit%.Int;

@ Program@ = /Fblf/Program%.Program@;
@ Addr@ = /Fblf/Program%.Addr@;
@ Condition@ = /Fblf/Program%.Condition@;
@ Value@ = /Fblf/Program%.Value@;
% Assign = /Fblf/Program%.Assign;
% Eq = /Fblf/Program%.Eq;
% Ne = /Fblf/Program%.Ne;
% IfElse = /Fblf/Program%.IfElse;
% If = /Fblf/Program%.If;
% While = /Fblf/Program%.While;
% Const = /Fblf/Program%.Const;
% Ref = /Fblf/Program%.Ref;
% Seq = /Fblf/Program%.Seq;

<@>@ Module@ = /Fblf/Module%.Module@;
<@>% AllocM = /Fblf/Module%.AllocM;
<@>% SharedM = /Fblf/Module%.SharedM;
<@, @>% InstM = /Fblf/Module%.InstM;
<@>% PureM = /Fblf/Module%.PureM;
% SeqM = /Fblf/Module%.SeqM;

% AddM = /Fblf/Lib/Add%.AddM;
% IncP = /Fblf/Lib/Add%.IncP;
% DecP = /Fblf/Lib/Add%.DecP;
% AndM = /Fblf/Lib/Bitwise%.AndM;
% OrM = /Fblf/Lib/Bitwise%.OrM;
% XorM = /Fblf/Lib/Bitwise%.XorM;
% NotM = /Fblf/Lib/Bitwise%.NotM;
% ClsM = /Fblf/Lib/Bitwise%.ClsM;

<@>@ List@ = /List%.List@;

Int@ 32 = Int|32;

<@>@ BlockOf@ = <@ T@> {
  *(T@ 00, T@ 01, T@ 02, T@ 03,
    T@ 04, T@ 05, T@ 06, T@ 07,
    T@ 08, T@ 09, T@ 10, T@ 11,
    T@ 12, T@ 13, T@ 14, T@ 15);
};

# Addr32@ --
#   An fblf Addr@ that points to a 32 bit value.
#
# For now this is only for documentation purposes. It isn't enforced at the
# type level.
@ Addr32@ = Addr@;

# Value32@ --
#   An fblf Value@ that has 32 bits.
#
# For now this is only for documentation purposes. It isn't enforced at the
# type level.
@ Value32@ = Value@;

(List@<Hex@>) { Value@; } H = /Fblf/Program%.ConstHex;

BlockOf@<Value32@> T1 = BlockOf@<Value32@>(
  H|D76AA478, H|E8C7B756, H|242070DB, H|C1BDCEEE,
  H|F57C0FAF, H|4787C62A, H|A8304613, H|FD469501,
  H|698098D8, H|8B44F7AF, H|FFFF5BB1, H|895CD7BE,
  H|6B901122, H|FD987193, H|A679438E, H|49B40821
);

BlockOf@<Value32@> T2 = BlockOf@<Value32@>(
  H|F61E2562, H|C040B340, H|265E5A51, H|E9B6C7AA,
  H|D62F105D, H|02441453, H|D8A1E681, H|E7D3FBC8,
  H|21E1CDE6, H|C33707D6, H|F4D50D87, H|455A14ED,
  H|A9E3E905, H|FCEFA3F8, H|676F02D9, H|8D2A4C8A
);

BlockOf@<Value32@> T3 = BlockOf@<Value32@>(
  H|FFFA3942, H|8771F681, H|6D9D6122, H|FDE5380C,
  H|A4BEEA44, H|4BDECFA9, H|F6BB4B60, H|BEBFBC70,
  H|289B7EC6, H|EAA127FA, H|D4EF3085, H|04881D05,
  H|D9D4D039, H|E6DB99E5, H|1FA27CF8, H|C4AC5665
);

BlockOf@<Value32@> T4 = BlockOf@<Value32@>(
  H|F4292244, H|432AFF97, H|AB9423A7, H|FC93A039,
  H|655B59C3, H|8F0CCC92, H|FFEFF47D, H|85845DD1,
  H|6FA87E4F, H|FE2CE6E0, H|A3014314, H|4E0811A1,
  H|F7537E82, H|BD3AF235, H|2AD7D2BB, H|EB86D391
);

# X@ -- 
#   The type of functions F, G, H, I.
#
# Inputs: x, y, z, r
#   Computes r = X(x, y, z)
@ X@ = (Addr32@, Addr32@, Addr32@, Addr32@) { Module@<Program@>; };

# XX@ --
#   The type of functions FF, GG, HH, II.
#
# Inputs: a, b, c, d, x, s, t, r
#
#   Computes r = X(a, b, c, d, x, s, t);
@ XX@ = (Addr32@, Addr32@, Addr32@, Addr32@, Addr32@, Int@, Value32@, Addr32@) { Module@<Program@>; };

(X@) { XX@; }
XX = (X@ xf)(Addr32@ a, Addr32@ b, Addr32@ c, Addr32@ d, Addr32@ x, Int@ s, Value32@ t, Addr32@ r) {
  # r = add(b, cls(add(add(a, xf(b, c, d)), add(x, t)), s));
  Addr32@ tv <- AllocM<Program@>(32);
  Addr32@ xtv <- AllocM<Program@>(32);
  Addr32@ xfv <- AllocM<Program@>(32);
  Addr32@ axfv <- AllocM<Program@>(32);
  Addr32@ axfxtv <- AllocM<Program@>(32);
  Addr32@ clsv <- AllocM<Program@>(32);
  SeqM[
    PureM<Program@>(Assign(tv, t, 32)),
    AddM(32, x, tv, xtv),
    xf(b, c, d, xfv),
    AddM(32, a, xfv, axfv),
    AddM(32, axfv, xtv, axfxtv),
    ClsM(32, s, axfxtv, clsv),
    AddM(32, b, clsv, r)
  ];
};

XX@ FF = XX((Addr32@ x, Addr32@ y, Addr32@ z, Addr32@ r) {
  # r = or(and(x, y), and(not(x), z));
  Addr32@ nx <- AllocM<Program@>(32);
  Addr32@ anxz <- AllocM<Program@>(32);
  Addr32@ xy <- AllocM<Program@>(32);
  SeqM[
    NotM(32, x, nx),
    AndM(32, nx, z, anxz),
    AndM(32, x, y, xy),
    OrM(32, xy, anxz, r)];
});

XX@ GG = XX((Addr32@ x, Addr32@ y, Addr32@ z, Addr32@ r) {
  # r = or(and(x, z), and(y, not(z)));
  Addr32@ nz <- AllocM<Program@>(32);
  Addr32@ aynz <- AllocM<Program@>(32);
  Addr32@ xz <- AllocM<Program@>(32);
  SeqM[
    NotM(32, z, nz),
    AndM(32, y, nz, aynz),
    AndM(32, x, z, xz),
    OrM(32, xz, aynz, r)];
});

XX@ HH = XX((Addr32@ x, Addr32@ y, Addr32@ z, Addr32@ r) {
  # r = xor(x, xor(y, z));
  Addr32@ yz <- AllocM<Program@>(32);
  SeqM[
    XorM(32, y, z, yz),
    XorM(32, x, yz, r)];
});

XX@ II = XX((Addr32@ x, Addr32@ y, Addr32@ z, Addr32@ r) {
  # r = xor(y, or(x, not(z)));
  Addr32@ nz <- AllocM<Program@>(32);
  Addr32@ xnz <- AllocM<Program@>(32);
  SeqM[
    NotM(32, z, nz),
    OrM(32, x, nz, xnz),
    XorM(32, y, xnz, r)];
});

# Round@ --
#   A Round module.
#
# Inputs:
#   a, b, c, d - The 32 bit words of ABCD
#   block - The input block.
#
# Updates values of ABCD in place based on the input block.
@ Round@ = (Addr32@, Addr32@, Addr32@, Addr32@, BlockOf@<Addr32@>) { Module@<Program@>; };

# RoundX --
#   Returns the round module based on the given parameters.
#
# Inputs:
#   xx - The FF, GG, HH, or II function to use for the round.
#   s0, s1, s2, s3 - The four shift values used in the round.
#   t - The T constants to use in the round.
#   permute - How to permute the input block.
(XX@, Int@, Int@, Int@, Int@, BlockOf@<Value32@>, (BlockOf@<Addr32@>) { BlockOf@<Addr32@>; }) { Round@; }
RoundX = (XX@ xx, Int@ s0, Int@ s1, Int@ s2, Int@ s3, BlockOf@<Value32@> t, (BlockOf@<Addr32@>) { BlockOf@<Addr32@>; } permute)
(Addr32@ a, Addr32@ b, Addr32@ c, Addr32@ d, BlockOf@<Addr32@> block) {
  BlockOf@<Addr32@> permuted = permute(block);
  SeqM[
    xx(a, b, c, d, permuted.00, s0, t.00, a),
    xx(d, a, b, c, permuted.01, s1, t.01, d),
    xx(c, d, a, b, permuted.02, s2, t.02, c),
    xx(b, c, d, a, permuted.03, s3, t.03, b),
    xx(a, b, c, d, permuted.04, s0, t.04, a),
    xx(d, a, b, c, permuted.05, s1, t.05, d),
    xx(c, d, a, b, permuted.06, s2, t.06, c),
    xx(b, c, d, a, permuted.07, s3, t.07, b),
    xx(a, b, c, d, permuted.08, s0, t.08, a),
    xx(d, a, b, c, permuted.09, s1, t.09, d),
    xx(c, d, a, b, permuted.10, s2, t.10, c),
    xx(b, c, d, a, permuted.11, s3, t.11, b),
    xx(a, b, c, d, permuted.12, s0, t.12, a),
    xx(d, a, b, c, permuted.13, s1, t.13, d),
    xx(c, d, a, b, permuted.14, s2, t.14, c),
    xx(b, c, d, a, permuted.15, s3, t.15, b)];
};

Round@ Round1 = RoundX(FF, Int|7, Int|12, Int|17, Int|22, T1, (BlockOf@<Addr32@> b) {
  b;
});

Round@ Round2 = RoundX(GG, Int|5, Int|9, Int|14, Int|20, T2, (BlockOf@<Addr32@> b) {
  BlockOf@<Addr32@>(
    b.01, b.06, b.11, b.00,
    b.05, b.10, b.15, b.04,
    b.09, b.14, b.03, b.08,
    b.13, b.02, b.07, b.12);
});

Round@ Round3 = RoundX(HH, Int|4, Int|11, Int|16, Int|23, T3, (BlockOf@<Addr32@> b) {
  BlockOf@<Addr32@>(
    b.05, b.08, b.11, b.14,
    b.01, b.04, b.07, b.10,
    b.13, b.00, b.03, b.06,
    b.09, b.12, b.15, b.02);
});

Round@ Round4 = RoundX(II, Int|6, Int|10, Int|15, Int|21, T4, (BlockOf@<Addr32@> b) {
  BlockOf@<Addr32@>(
    b.00, b.07, b.14, b.05,
    b.12, b.03, b.10, b.01,
    b.08, b.15, b.06, b.13,
    b.04, b.11, b.02, b.09);
});

(Addr32@, Addr32@, Addr32@, Addr32@, BlockOf@<Addr32@>) { Module@<Program@>; }
DoBlock = (Addr32@ a, Addr32@ b, Addr32@ c, Addr32@ d, BlockOf@<Addr32@> block) {
  Addr32@ save_a <- AllocM<Program@>(32);
  Addr32@ save_b <- AllocM<Program@>(32);
  Addr32@ save_c <- AllocM<Program@>(32);
  Addr32@ save_d <- AllocM<Program@>(32);
  SeqM[
    PureM<Program@>(Assign(save_a, Ref(a), 32)),
    PureM<Program@>(Assign(save_b, Ref(b), 32)),
    PureM<Program@>(Assign(save_c, Ref(c), 32)),
    PureM<Program@>(Assign(save_d, Ref(d), 32)),
    Round1(a, b, c, d, block),
    Round2(a, b, c, d, block),
    Round3(a, b, c, d, block),
    Round4(a, b, c, d, block),
    AddM(32, a, save_a, a),
    AddM(32, b, save_b, b),
    AddM(32, c, save_c, c),
    AddM(32, d, save_d, d)];
};

@ Addr8@ = Addr@;
@ Addr64@ = Addr@;

# Store --
#   Stores a single word in a 2^k-element array of n-bit words.
#
# When run, the program does:
#   memory[addr] = value;
(Int@, Int@, Addr@, Addr@, Addr@) { Program@; }
Store = (Int@ k, Int@ n, Addr@ memory, Addr@ addr, Addr@ value) {
  /Int/Int/Eq%.Eq(k, Int|0).?(
    true: Assign(memory, Ref(value), n),
    false: {
      Int@ sk = Sub(k, Int|1);
      Addr@ saddr = Add(addr, Int|1);
      IfElse(Eq(Ref(addr), Const(BitStr|0), Int|1),
        Store(sk, n, memory, saddr, value),
        Store(sk, n, Add(memory, Mul(n, Exp2(sk))), saddr, value));
    });
};

# PackWord@ --
#   Interface to the PackWord module.
#
# To use the PackWord module:
# 1. Run the 'reset' program.
# 2. For each byte of the input in order,
#   Set the 'byte' register to the value of the byte.
#   Run the 'feed' program.
# The packed 'word' should be read after every 4 bytes are fed.
# The 'packed' condition can be used to check after feeding an input byte
# whether a full word has been assembled.
@ PackWord@ = *(Program@ reset, Program@ feed, Condition@ packed);

(Addr32@, Addr8@) { Module@<PackWord@>; }
PackWord = (Addr32@ word, Addr8@ byte) {
  Addr@ addr <- AllocM<PackWord@>(Int|2);

  Program@ reset <- SharedM<PackWord@>(Assign(addr, Const(BitStr|11), Int|2));

  Program@ feed <- SharedM<PackWord@>(Seq[
    Store(Int|2, Int|8, word, addr, byte),
    DecP(Int|2, addr)
  ]);

  Condition@ packed = Eq(Ref(addr), Const(BitStr|11), Int|2);

  PureM<PackWord@>(@(reset, feed, packed));
};

# PaddedMd5@ -- 
#   Interface to a PaddedMd5 compute module.
#
# PaddedMd5 computes md5sum for a pre-padded input.
#
# To use the PaddedMd5 compute module:
# 1. Run the 'reset' program
# 2. For each byte of the input in order, 
#   Set the 'byte' register to the value of the byte.
#   Run the 'feed' program.
#
# The result of the Md5 computation will be in the 'abcd' register, which will
# be updated after every 64 bytes of input.
# The module can be reused for multiple Md5 computations by rerunning the
# above instructions for each computation.
@ PaddedMd5@ = *(Program@ reset, Program@ feed);

# PaddedMd5 -- 
#   The PaddedMd5 computation.
#
# Inputs:
#   a - The address of the 'A' value of the computed Md5.
#   b - The address of the 'B' value of the computed Md5.
#   c - The address of the 'C' value of the computed Md5.
#   d - The address of the 'D' value of the computed Md5.
#   byte - The address of the input byte passed to the feed program.
(Addr32@, Addr32@, Addr32@, Addr32@, Addr8@) { Module@<PaddedMd5@>; }
PaddedMd5 = (Addr32@ a, Addr32@ b, Addr32@ c, Addr32@ d, Addr8@ byte) {

  # Count of the number of 32-bit words of input that have been processed in
  # the current block.
  Addr@ count <- AllocM<PaddedMd5@>(Int|4);

  # Space to assemble the next 32 bit word of input.
  Addr32@ word <- AllocM<PaddedMd5@>(32);
  PackWord@ wpack <- InstM<PackWord@, PaddedMd5@>(PackWord(word, byte));

  # Space to assemble the next block of 16 32-bit words of input.
  Addr@ block <- AllocM<PaddedMd5@>(Mul(Int|16, Int|32));
  BlockOf@<Addr32@> blockof = BlockOf@<Addr32@>(
    Add(block, Mul(Int|0, Int|32)), Add(block, Mul(Int|1, Int|32)),
    Add(block, Mul(Int|2, Int|32)), Add(block, Mul(Int|3, Int|32)),
    Add(block, Mul(Int|4, Int|32)), Add(block, Mul(Int|5, Int|32)),
    Add(block, Mul(Int|6, Int|32)), Add(block, Mul(Int|7, Int|32)),
    Add(block, Mul(Int|8, Int|32)), Add(block, Mul(Int|9, Int|32)),
    Add(block, Mul(Int|10, Int|32)), Add(block, Mul(Int|11, Int|32)),
    Add(block, Mul(Int|12, Int|32)), Add(block, Mul(Int|13, Int|32)),
    Add(block, Mul(Int|14, Int|32)), Add(block, Mul(Int|15, Int|32)));
  Program@ doblock <- InstM<Program@, PaddedMd5@>(DoBlock(a, b, c, d, blockof));

  # Note: the spec lists the initial values for A, B, C, and D low-order byte
  # first, but H takes high order byte first.
  Program@ reset <- SharedM<PaddedMd5@>(Seq[
    Assign(count, Const(BitStr|0000), Int|4),
    Assign(a, H|67452301, 32),
    Assign(b, H|EFCDAB89, 32),
    Assign(c, H|98BADCFE, 32),
    Assign(d, H|10325476, 32),
    wpack.reset
  ]);

  Program@ feed <- SharedM<PaddedMd5@>(Seq[
    wpack.feed,
    If(wpack.packed,
      Seq[
        Store(Int|4, Int|32, block, count, word),
        If(Eq(Ref(count), Const(BitStr|1111), Int|4),
          doblock),
      IncP(Int|4, count)])
  ]);

  PureM<PaddedMd5@>(@(reset, feed));
};

# Md5@ -- 
#   Interface to an Md5 compute module.
#
# To use the Md5 compute module:
# 1. Run the 'reset' program
# 2. For each byte of the input in order, 
#   Set the 'input' register to the value of the byte.
#   Run the 'feed' program.
# 3. Run the 'finish' program.
#
# The result of the Md5 computation will be stored at the given output hash
# address as a sequence of 128 bits in order of the sequence of hex digits
# typically used to display an md5 hash. The module can be reused for multiple
# Md5 computations by rerunning the above instructions for each computation.
#
# Note that the 'finish' program may modified the 'input' register in
# unspecified ways.
@ Md5@ = *(Program@ reset, Program@ feed, Program@ finish);

# Md5 -- 
#   The Md5 computation.
#
# Inputs:
#   input - The address of the 8-bit input byte passed to the feed program.
#   hash - The address to store the 128 bit computed Md5 hash.
(Addr8@, Addr@) { Module@<Md5@>; }
Md5 = (Addr8@ input, Addr@ hash) {
  Addr32@ a <- AllocM<Md5@>(Int|32);
  Addr32@ b <- AllocM<Md5@>(Int|32);
  Addr32@ c <- AllocM<Md5@>(Int|32);
  Addr32@ d <- AllocM<Md5@>(Int|32);

  PaddedMd5@ padded <- InstM<PaddedMd5@, Md5@>(PaddedMd5(a, b, c, d, input));

  # Count of the number of bits of input that have been processed.
  Addr64@ length <- AllocM<Md5@>(Int|64);

  # While padding, keeps track of how many bytes have been added to the final
  # block so far.
  Addr@ padding <- AllocM<Md5@>(Int|6);

  Program@ reset <- SharedM<Md5@>(Seq[
    Assign(length, H|0000000000000000, Int|64),
    padded.reset
  ]);

  Program@ feed <- SharedM<Md5@>(Seq[
    padded.feed,

    # Increment the length by one bytes worth by incrementing all but the last
    # three bits by 1.
    IncP(Int|61, length)
  ]);

  Program@ finish <- SharedM<Md5@>(Seq[
    # Start tracking how many bytes we've added to the final block.
    Assign(padding, Ref(Add(length, Int|55)), Int|6),

    # Feed byte 0x80
    Assign(input, H|80, Int|8),
    padded.feed,
    IncP(Int|6, padding),

    # Feed byte 0x00 until 8 bytes shy of end of block.
    Assign(input, H|00, Int|8),
    While(Ne(Ref(padding), Const(BitStr|111000), Int|6), Seq[
      padded.feed,
      IncP(Int|6, padding)
    ]),

    # Feed length (in bits) as next 8 bytes, least significant byte first.
    Assign(input, Ref(Add(length, Int|56)), Int|8), padded.feed,
    Assign(input, Ref(Add(length, Int|48)), Int|8), padded.feed,
    Assign(input, Ref(Add(length, Int|40)), Int|8), padded.feed,
    Assign(input, Ref(Add(length, Int|32)), Int|8), padded.feed,
    Assign(input, Ref(Add(length, Int|24)), Int|8), padded.feed,
    Assign(input, Ref(Add(length, Int|16)), Int|8), padded.feed,
    Assign(input, Ref(Add(length, Int|8)), Int|8), padded.feed,
    Assign(input, Ref(Add(length, Int|0)), Int|8), padded.feed,

    # Extract the hash from a, b, c, d.
    # Note that the hash is output in order ABCD, least significant byte
    # first.
    Assign(Add(hash, Int|0),   Ref(Add(a, Int|24)), Int|8),
    Assign(Add(hash, Int|8),   Ref(Add(a, Int|16)), Int|8),
    Assign(Add(hash, Int|16),  Ref(Add(a, Int|8)),  Int|8),
    Assign(Add(hash, Int|24),  Ref(Add(a, Int|0)),  Int|8),
    Assign(Add(hash, Int|32),  Ref(Add(b, Int|24)), Int|8),
    Assign(Add(hash, Int|40),  Ref(Add(b, Int|16)), Int|8),
    Assign(Add(hash, Int|48),  Ref(Add(b, Int|8)),  Int|8),
    Assign(Add(hash, Int|56),  Ref(Add(b, Int|0)),  Int|8),
    Assign(Add(hash, Int|64),  Ref(Add(c, Int|24)), Int|8),
    Assign(Add(hash, Int|72),  Ref(Add(c, Int|16)), Int|8),
    Assign(Add(hash, Int|80),  Ref(Add(c, Int|8)),  Int|8),
    Assign(Add(hash, Int|88),  Ref(Add(c, Int|0)),  Int|8),
    Assign(Add(hash, Int|96),  Ref(Add(d, Int|24)), Int|8),
    Assign(Add(hash, Int|104), Ref(Add(d, Int|16)), Int|8),
    Assign(Add(hash, Int|112), Ref(Add(d, Int|8)),  Int|8),
    Assign(Add(hash, Int|120), Ref(Add(d, Int|0)),  Int|8)
  ]);

  PureM<Md5@>(Md5@(reset, feed, finish));
};

@(Md5@, Md5);
