Fbld Modules

See fbld.modules.txt for background and context.

Question: Can we naturally get polymorphic code using modules?

Example: Implement MaxFlow without knowing how Graph is defined, so long as
Graph satisfies certain properties such as having comparable nodes. Then a
different type can be used to test Graph than use Graph in practice.

Other use cases:
* Maybe<T>
* List<T>
* Multiple different implementations of some Map data structure with different
  performance characteristics.
* Ad-Hoc polymorphism: Example: Primes implementation that works for any kind
  of 'Nat' number with appropriate operations on it.

Proposal:

Goal is to build up, define and share modules.
A module is a collection of type, func, and proc definitions.

Modules can take other modules as parameters. For example, MaxFlow could be
used with TestGraph or with PingPongWinsGraph. Primes could be used with
UBNatUnary or UBNatBinary. Any module that satisfies the required interface
may be used.

Interfaces define a set of types, functions, and processes that a module
implements. An interface can be thought of as a type of module.

We say each module implements a specific interface. It's not hard to have a
module effectively implementing multiple interfaces by defining wrapper
modules for each different interface.

Multiple modules may implement the same interface. This is required for
an interface to be useful as 'a type of module'.

To support polymorphism, interfaces may be parameterized by type. Note there
is no need to parameterize interfaces by func, proc, or module more generally,
because types is the only thing an interface depends on from the outside
world. Modules may also be parameterized by type.

In other words, interfaces are parameterized by type in order to allow a
single module definition to be re-used for interfaces with different types.

A concrete interface is one without any type parameters. An abstract interface
can be made concrete by supplying all its type parameters. A type parameter is
supplied by giving a type (concrete or abstract) declared as part of some
other concrete interface, so that interfaces depend only on other interfaces.

Given interface I with type parameters a and b, any occurence of I(A, B)
refers to the same interface as I(A, B), so long as I, A, and B are all the
same.

Similarly given module M with type or module parameters a and b, any
occurence of M(A, B) refers to the same as M(A, B).

Types declared in interfaces are not comparable in general, because there is
no gaurentee they come from the same module implementing the interface. For
example, it does not make sense to try and use a Map.Map type for maps that
could be either HashMap or TreeMap. In general, whenever a type is needed, the
module that type is associated with must be supplied.

Example: Assume a Unit interface. In theory it's possible that there are
multiple modules implementing this interface, each of which defines a
different type. In an interface, if you tried to use the interface type
Unit@Unit, it would not be clear that all occurences of Unit@Unit should refer
to the same type. On the other hand, imagine you want to write a function to
convert a HashMap to a TreeMap. You couldn't describe this in an interface if
the interface only referred to interface types Map and Map.

So, wherever a type is needed, a type from a module must be supplied, such as
T@M(A, B), which uniquely defines a type, even if that type is abstract.
T@M(A, B) = T@M(A, B) if T, M, A, and B are all the same. This means
interfaces depend in some part on module definitions, but really only on
module declarations - the 'prototype' of a module, rather than its body.

Proposed syntax:

mtype Bool() {
  struct Unit();
  union Bool(Unit true, Unit false);
};

mdecl MyBool( ; ; Bool());

mdefn MyBool( ; ; Bool()) {
  struct Unit();
  union Bool(Unit true, Unit false);
};

mtype Map(K, V) {
  type Map;
  func empty( ; Map);
  func single(K key, V value; Map);
  func union(Map a, Map b; Map);
  func contains(Map m, K key; Bool@MyBool());
  ...
};

mdefn ListMap(K, V ; List(Pair(K, V)) list; Map(K, V)) {
  ...
}

Notes: 
 - No explicit dependency list. Dependencies should be clear enough from the
   code I hope. If need be, we can add extra syntax to document required
   dependencies.
 - The interface is parameterized, not the types within it.
 - module declarations and definitions are like a function: name, type args,
   module args, resulting module type. Where module args and resulting module
   type are functions of the type args.
 - Types referred to from within an interface or module must be associated
   with a specific module - either a module passed as a parameter, or a named
   module. We can still test the module is correct without knowing the
   implementation of a named module it depends on by assuming each differently
   named module defines different opaque types.
 - The mtype namespace is separate from the module namespace. We used a
   different name for Bool and MyBool in the example to highlight that the
   interface reference must be to the module, but in practice we would
   probably use Bool for the module name as well because we only expect one
   implementation of the module.
 - For now don't worry about syntactic sugar. Some form of importing will be
   needed to avoid verbose qualified names. Interface and module declarations
   that don't take parameters still have space for them, as can be seen with
   Bool and MyBool.

