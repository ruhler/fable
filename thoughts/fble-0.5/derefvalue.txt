De-RefValue
===========
Goal is to remove the need for calling StrictValue every time we access a
value. The primary motivation is to simplify access logic so we can easily
inline it into backends at the call sites. It will be nice to get a little
performance improvement from not having to do the check all the time as well.

It's not rocket science I don't think. A few approaches we could consider:
1. Have FbleAssignRefValue traverse the value, replacing any references to the
original ref value.
2. Any time we take a reference to a RefValue, add it to a list tracked by the
RefValue. In FbleAssignRefValue, traverse that list.
3. Use some crazy signal handler and memory protection to detect access to ref
values and replace them on the fly with their use.
4. Preallocate a large enough space for the allocated value and overwrite the
   contents of the RefValue on assignment.

Note that we need some way still to check for undefined values. Whatever
approach we use should ideally work with undef expressions and, if necessary,
stack unwinding.

Where ref values happen most often in practice is the definition of recursive
functions. Can I think of any other places? Certainly we could make up things
like infinite lists, but I think that's very rare in practice.

Which means, in the normal use case, we would only have to traverse the static
fields of a struct value to do the assignment. Approach (1) sounds like the
way to go. Don't worry about the rare pathological case. Sure someone can
create a really long circular list, and that would be expensive to traverse.
So what?

Sketch of proposal:
* Change RefValue to a new kind of packed value, with least significant bits
  10. The most significant bits are a unique id for the ref value.
* To assign: traverse the value and update references to the RefValue in
  place. GC should have enough info to avoid traversing previously allocated
  objects. We should only have to traverse new allocated objects.
* Check for RefValue in data access. If we see it, it's undefined. Throw an
  error.

I don't think we can get away without some kind of check during data access.
Not unless we want to do silly things with signal handlers. My proposal sounds
reasonable.

Concerns:
* Today we use ref value to know when to merge frames. We won't have that info
  anymore.
* Does anywhere in the code rely on there being ref values to detect cycles? I
  think it shouldn't, but I wouldn't be surprised if it did.

That means the first step is to remove use of ref value for deciding when to
merge frames. Either make something more explicit to detect recursive
functions, or find some other scheme.

I want to think a little bit about proposal (4). Could we pre-allocate
for the RefValue assignment and simply overwrite the RefValue on assignment? I
think not. It's possible we have no type information about the RefValue. For
example:

 <@ T@>((T@) { T@; } f) {
   T@ x = f(x);
   x;
 };

We need a RefValue for x in this case, but we have no idea what the type is.

Okay, let's continue on with proposal (1). First step: find an alternate to
RefValue for deciding on frame merges.

I probably want to have a more comprehensive benchmark suite when evaluating
this change. md5sum for sure, to cover the case of deep non-recursive
functions.

---

We are no longer using RefValue for deciding on frame merges.

Let's proceed with the update to RefValue. Here's how it will work:
* RefValue becomes packed {<id>, 'b10}
  We'll need some way to generate unique ids for RefValues. Needs thought.
* StrictValue turns all ref values to NULL (as a first step).
* FbleAssignRefValue does a traversal of value, replacing references to the
  ref value with the actual value. Check for vacuous value here still.

I think that's it. Even if we just do that, I'm hoping we'll see a noticeable
performance improvement.

How to assign ids for ref values? It should be a proper stack, right? I always
do assignment for the most recent ref value? Close. Double check the ordering
logic when we have multiple ref values defined in the same statement.

Assuming that's the case, we can have a single counter which keeps track of
the number of ref values allocated so far. Assert when we do a ref value
assignment it's of the top counter value, then decrement that top counter
value.

---

I need to change the API for ref values, because we need to do the
substitution in all values of a let. For example, if we have 3 recursively
defined variables, we have 3 ref values, we have 3 values to assign to, and we
have 3 values to traverse to do all 3 substitutions.

Proposal:
* void FbleNewRefValues(FbleValueHeap* heap, size_t n, FbleValue** dest);
  Allocates n new ref values, storing them continuously in dest.
* bool FbleAssignRefValues(FbleValueHeap* heap, size_t n, FbleValue** refs, FbleValue** values);
  Assigns n ref values at once. The ref values are stored continuously and the
  values to assign them to are stored continuously.

If we have this API, it's also easier to require ref values are assigned in
last in first out order, which is convenient for assigning unique ids to ref
values.

I can do the implementation in phases:
1. Switch to the new API.
2. Implement the traverse and replace on existing RefValue datatype.
3. Allocate and manage unique ids for ref values.
4. Pack ref values.

This idea of allocating continuous values in the compiler is new. I don't
think it's too hard, but something different. Let's review where and how we
use ref values today.

In let, we allocate n ref values in a row. Then we compute n definitions in a
row. Then we do n assignments in a row and call SetVar to update the
definitions.

Shouldn't be too hard? The most awkward part is having continuous allocations
for things. It means we may have to move memory around we otherwise wouldn't
need to. Is there a better way?

Struct value takes FbleVarV args. Let's do the same?

FbleNewRefValues can take an FbleLocalIndexV. It fills in each of the
individual indices. FBLE_REF_DEF can take FbleVarV and FbleLocalIndexV. That's
easy. That should be quite doable. Okay? Let's try that.

---

We don't need to change FbleNewRefValue to start. That's fine to split up.
We'll end up inlining that anyway. We just need to change FbleAssignRefValue
to do it all at once.

The annoying part is that we need to report vacuous value errors per
assignment. A vacuous value is currently defined as a variable being set to
itself.

For example:

a = b, b = a;

We can assign a = b. But then when we try b = a, we'll see it a vacuous. Do we
need location at the specific variable, or is the let in general okay? The
specific variable is probably important information.

Sigh. For now, let's include a list of locations with the instruction. Really,
I think best to have a vector of: loc, ref, value. Okay? First step is to get
the instruction updated. Second step is to change FbleAssignRefValue to
FbleAssignRefValues.

---

Next step is to try doing the traversal to update the ref values when we call
FbleAssignRefValues. Careful: we need to be able to handle traversal of
cycles.

I'm also slightly concerned about having to traverse a lot of objects when
defining recursive functions at the top level of complex modules, because you
might have to end up traversing everything defined in the module, in some
cases (exponentially?) repeatedly, which would be bad. But let's not worry
about this performance issue to start. Wait to see if it's a problem in
practice, or that I can force it to be a problem.

How to handle traversal of cycles? We need a way to mark if we have done a
traversal of the object or not. Some bit somewhere in the stack or GC
allocated object we can set during traversal? Or do we need to maintain a
separate data structure?

GcRealloc takes advantage of value->loc to tell if it has been traversed. We
don't have that luxury here.

In terms of info about an FbleValue:
* ValueTag - needs 3 bits for 5 different kinds of values.
* Header - 2 words: gc value and frame, or gc list and generation.
* AllocLoc - needs 1 bit for 2 different kinds of values.

Let's just add a bit saying if it's traversing or not. We can pack ValueTag,
AllocLoc, and this extra bit into a single word easily enough.

Can I use bitfields for these things? Should I not worry about that yet, worry
about it later? Let's worry about it later.

---

4 problems with the refvalue traversal code:
1. It doesn't handle vacuous values.
But this should be easy enough to fix. Use RefAssign to assign values in place
in their array. Then check that the assigned value isn't the same as the ref
value itself. Go one by one. That should let us check vacuous value.

2. If one of the values is a ref value that's being assigned, we'll fail to
update the value on the stack frame. I should add a test case for that and
figure out how to fix it. Maybe we need to pass pointers (to pointers) to the
original values instead of the values themselves.

3. Memory leak. I fear it may be because we violate some GC invariants saying
that an older dimension object will not point to a younger generation object.
Needs debug.

4. Infinite loop or slow performance on md5 and some other tests.
Needs debug to figure out if it's just slow due to some pathological case or
an infinite loop related to cycles. Don't work on this until the previous 3
issues are addressed, in case the fixes there fix this.

---

Idea on a simpler api:
  FbleValue* FbleRefValues(heap, n);
    Allocates a struct value with n fields, one for each ref value. To get to
    the individual ref values, call FbleStructValueAccess. The compiler will
    generate those calls for you.

  size_t FbleRefValuesAssign(heap, FbleValue* r, FbleValue* v);
    You give it the struct of ref values and the struct of assignments. It
    does everything all at once.

Slightly simpler this way because we can reuse struct value instruction to
pack together the values. It also lets us easily do the allocation in batch.

Anyway, let me save that idea for later. It won't change the fundamentals I
don't think.

---

How to deal with vacuous values? How to deal with updating the original
values? They are sort of related. Think about it conceptually.

We have N ref values.
We have N assignments to them.
Those assignments might themselves refer to the original N ref values, either
directly or indirectly.

I only care about the case of directly. If it goes through a func, struct, or
union constructor, we're fine.

Each value is either one of the N ref values, or its constant. We want to
propagate one at a time, right?

Going from i = 0, increasing. Maintain the invariant that for any values
before index i, we've removed all references to any ref values.

Or maybe we want to remove ref values one at a time?

How about, first step: remove right hand side references to ref value 0. If
the value for 0 is ref value 0, that's vacuous, return error. Otherwise we can
in place update any values pointing to ref value 0 to point to value 0. Easy.

Next, remove right hand side references to ref value 1. If the value for 1 is
ref value 1, that's vacuous, otherwise we can kick the can down the road.

Yeah, this seems like the right approach to use. Just at the top level. No
deeper traversal yet. Eliminate all right hand references to ref values. If
we can't, then it's vacuous.

What test case do we have that covers this, to help me zoom in on it?

spec/SpecTests/2.5-Let/Type/VacuousValue.fble.tr

Probably we want to add more advanced cases to test? Anyway, let's get this to
pass first.

Turns out it's pretty easy to implement. Cool.

---

Next issue to tackle, spec/SpecTests/2.5-Let/Regression/DeRefIssue.fble.

We have to write back our updates to the values when doing vacuous value
elimination. Here's what I'm thinking, based on the proposed new API above:

  r = FbleNewRefValues(heap, n);
  v0 = r.0
  v1 = r.1
  ...
  v = StructValue(<compute v0>, <compute v1>, ...)
  FbleRefValueAssigns(heap, r, v);
  v0 = v.0
  v1 = v.1
  ...

I think that should work. Basically we pass the modified values back through
the struct.

We should be able to accomplish the same thing without the API change, right?
The idea is, if we update a value, it must have been ref value initially,
which means it must have been allocated on the stack?

Why don't I just write back the values to the original ref locals? That way we
don't even need this SetVar thing in the compiler.

Cool. Let's try that.
  
---

We still net SetVar for the non-recursive let case. The backend code for
REF_DEF instruction is a little tedious. I had bugs in both c and aarch64
backend. Switching to an API where the compiler generates all the code to
bundle up ref values, result values, and do writebacks sounds like a good
plan.

