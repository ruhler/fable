
@ Bool@ = /Core/Bool%.Bool@;
% True = /Core/Bool%.True;
% False = /Core/Bool%.False;
% Not = /Core/Bool%.Not;

% Inc = /Core/Int%.Inc;
% Int = /Core/Int/Lit%.Int;

<@>@ List@ = /Core/List%.List@;
<@>% List = /Core/List%.List;
<@>% Nil = /Core/List%.Nil;
<@>% Cons = /Core/List%.Cons;
<@>% Append = /Core/List%.Append;

<@>@ Maybe@ = /Core/Maybe%.Maybe@;
<@>% Just = /Core/Maybe%.Just;
<@>% Nothing = /Core/Maybe%.Nothing;

<<@>@>@ Monad@ = /Core/Monad%.Monad@;

<@>@ Show@ = /Core/Show%.Show@;

<<@>@>@ OStream@ = /Core/Stream%.OStream@;

@ String@ = /Core/String%.String@;
% Strs = /Core/String%.Strs;
% Str = /Core/String%.Str;

@ Unit@ = /Core/Unit%.Unit@;
% Unit = /Core/Unit%.Unit;

<<@>@>@ Debug@ = /Sat/Debug%.Debug@;

@ Id@ = /Sat/Id%.Id@;
% EqId = /Sat/Id%.EqId;

@ VarId@ = Id@;
@ ClauseId@ = Id@;

@ Var@ = *(VarId@ id, Bool@ pos);
@ Clause@ = List@<Var@>;

# Imagine two clauses:
#   (a1 + a2 + ... + v)
#   (b1 + b2 + ... + v')
#
# These conflict in the case where:
#   (a1 + a2 + ... + b1 + b2 + ...)
#
# Conflict@ describes a pair of conflicting clauses and the variable they
# conflicted on.
@ Conflict@ = *(ClauseId@ a, ClauseId@ b, VarId@ var);

# pos - the list of clauses this variable appears positive in.
# neg - the list of clauses this variable appears negative in.
@ VarS@ = *(List@<ClauseId@> pos, List@<ClauseId@> neg);

% Vars = /Sat/Id%.Map<VarS@>;
@ Vars@ = Vars.Map@;

% Clauses = /Sat/Id%.Map<Clause@>;
@ Clauses@ = Clauses.Map@; 

% Conflicts = /Sat/Id%.Map<Conflict@>;
@ Conflicts@ = Conflicts.Map@;

# Functions for working with clauses.
# TODO: Move to a separate module?
% Clause = {
  # Adds a variable to a clause, preserving the invariant that each variable
  # appears at most once in a clause.
  #
  # Returns Nothing if the clause contains both x and x' after the insertion.
  (Var@, Clause@) { Maybe@<Clause@>; } AddVar = (Var@ v, Clause@ c) {
    c.?(nil: Just(List[v]));
    Var@ head = c.cons.head;
    EqId(v.id, head.id).?(true: {
      /Core/Bool/Eq%.Eq(v.pos, head.pos).?(true: Just(c));
      Nothing<Clause@>;
    });
    Maybe@<Clause@> tail = AddVar(v, c.cons.tail);
    tail.?(nothing: Nothing<Clause@>);
    Just(Cons(head, tail.just));
  };

  # Adds a list of variables to a clause, preserving the invariant that each
  # variable appears at most once in a clause.
  #
  # Returns Nothing if the clause contains both x and x' after the insertion.
  (List@<Var@>, Clause@) { Maybe@<Clause@>; }
  AddVars = (List@<Var@> vs, Clause@ c) {
    vs.?(nil: Just(c));
    Maybe@<Clause@> mc = AddVar(vs.cons.head, c);
    mc.?(nothing: Nothing<Clause@>);
    AddVars(vs.cons.tail, mc.just);
  };

  # Removes a variable from a clause.
  (VarId@, Clause@) { Clause@; } RemoveVar = (VarId@ vid, Clause@ c) {
    /Core/List%.ForEach(c, Nil<Var@>, (Var@ v, List@<Var@> vars) {
      EqId(vid, v.id).?(true: vars);
      Cons(v, vars);
    });
  };

  @(AddVar, AddVars, RemoveVar);
};

# The reasoning behind a variable assignment.
@ Why@ = +(
  Unit@ attempt,      # This is an attempt to rule out this variable.
  Unit@ pure,         # The variable is a pure literal, so no harm setting it.
  ClauseId@ inferred  # The value was inferred from the given clause.
);

Why@ Attempt = Why@(attempt: Unit);
Why@ Pure = Why@(pure: Unit);
(ClauseId@) { Why@; } Inferred = (ClauseId@ id) { Why@(inferred: id); };

@ Assign@ = *(Var@ var, Why@ why);

@ Solver@ = *(
  Bool@ unsat,              # if true, the formula is trivially unsatisfiable.
  ClauseId@ clause_id,
  Vars@ vars,
  Clauses@ clauses,
  Conflicts@ conflicts,
  List@<Var@> assigns,        # Assignments made so far.
  List@<Assign@> todo         # Assignments we should make.
);

Solver@ NewSolver = @(
  unsat: False,
  clause_id: Int|0,
  vars: Vars.Empty,
  clauses: Clauses.Empty,
  conflicts: Conflicts.Empty,
  assigns: Nil<Var@>,
  todo: Nil<Assign@>
);

# Add a new clause with the given clause id.
(Solver@, ClauseId@, List@<Var@>) { Solver@; }
AddClauseAt = (Solver@ s, ClauseId@ id, List@<Var@> vars) {
  Maybe@<Clause@> mc = Clause.AddVars(vars, Nil<Var@>);

  # Ignore trivial clauses.
  mc.?(nothing: s);
  Clause@ clause = mc.just;

  # Check for empty clause.
  clause.?(nil: s.@(unsat: True));

  List@<Assign@> todo = {
    # Check for unit clause.
    clause.cons.tail.?(nil: {
      Cons(@(var: clause.cons.head, why: Inferred(id)), s.todo);
    });

    s.todo;
  };

  # Update Vars@ data structure.
  Vars@ vars = /Core/List%.ForEach(clause, s.vars,
    (Var@ v, Vars@ vs) {
      Vars.InsertWith(vs, v.id, (Maybe@<VarS@> mx) {
          VarS@ x = mx.?(
            just: mx.just,
            nothing: VarS@(Nil<ClauseId@>, Nil<ClauseId@>));
          v.pos.?(
            true: VarS@(Cons(id, x.pos), x.neg),
            false: VarS@(x.pos, Cons(id, x.neg)));
        });
    });

  Clauses@ clauses = Clauses.Insert(s.clauses, id, clause);
  s.@(vars, clauses, todo);
};

# Adds a clause to the solver state for the given conflict.
(ClauseId@, Conflict@, Solver@) { Solver@; }
AddConflictClause = (ClauseId@ id, Conflict@ conflict, Solver@ s) {
  Maybe@<Clause@> ma = Clauses.Lookup(s.clauses, conflict.a);
  Clause@ a = Clause.RemoveVar(conflict.var, {
    ma.?(nothing: Nil<Var@>);
    ma.just;
  });

  Maybe@<Clause@> mb = Clauses.Lookup(s.clauses, conflict.b);
  Clause@ b = Clause.RemoveVar(conflict.var, {
    mb.?(nothing: Nil<Var@>);
    mb.just;
  });

  AddClauseAt(s, id, Append(a, b));
};

# @func[AddClause] Adds a clause to cnf state Solver@.
#  This should be done in the initial phase before starting to solve the
#  formula.
#
#  @arg[s] The cnf state to add the clause to.
#  @arg[clause] The clause to add.
#  @returns
#   An updated cnf state with clause added.
(Solver@, List@<Var@>) { Solver@; } AddClause = (Solver@ s, List@<Var@> vars) {
  ClauseId@ id = s.clause_id;
  AddClauseAt(s.@(clause_id: Inc(id)), id, vars);
};

(Solver@, List@<Clause@>) { Solver@; }
AddClauses = (Solver@ solver, List@<Clause@> clauses) {
  /Core/List%.ForEach(clauses, solver, (Clause@ c, Solver@ s) {
    AddClause(s, c);
  });
};

@ OpResult@ = +(
  Solver@ solver,     # not found to be unsat yet.
  Conflict@ conflict, # unsat due to conflict.
  Unit@ unsat         # trivially unsat.
);

# Removes a clause from a Vars@ var entry.
(ClauseId@, Var@, Solver@) { Solver@; }
RemoveClauseFromVar = (ClauseId@ clause, Var@ var, Solver@ s) {
  Maybe@<VarS@> mvs = Vars.Lookup(s.vars, var.id);
  mvs.?(nothing: s);
  VarS@ vs = mvs.just;

  List@<ClauseId@> match = var.pos.?(true: vs.pos, false: vs.neg);
  List@<ClauseId@> ncls = /Core/List%.ForEach(match, Nil<ClauseId@>,
    (ClauseId@ c, List@<ClauseId@> cls) {
      EqId(clause, c).?(true: cls);
      Cons(c, cls);
    });

  List@<Assign@> todo = {
    ncls.?(cons: s.todo);
    Cons(@(var: Var@(var.id, Not(var.pos)), why: Pure), s.todo);
  };

  VarS@ nvs = var.pos.?(
    true: @(pos: ncls, neg: vs.neg),
    false: @(pos: vs.pos, neg: ncls));

  s.@(vars: Vars.Insert(s.vars, var.id, nvs), todo);
};

# Removes a clause from the solver.
(ClauseId@, Solver@) { Solver@; }
RemoveClause = (ClauseId@ id, Solver@ s) {
  Maybe@<Clause@> mcs = Clauses.Lookup(s.clauses, id);
  mcs.?(nothing: s);

  Clause@ cs = mcs.just;
  Solver@ ns = /Core/List%.ForEach(cs, s,
    (Var@ v, Solver@ s) {
      RemoveClauseFromVar(id, v, s);
    });
  ns.@(clauses: Clauses.Delete(ns.clauses, id));
};

(ClauseId@, VarId@, Why@, Solver@) { OpResult@; }
RemoveVarFromClause = (ClauseId@ clause, VarId@ var, Why@ why, Solver@ s) {
  Maybe@<Clause@> mcs = Clauses.Lookup(s.clauses, clause);
  mcs.?(nothing: OpResult@(solver: s));

  List@<Var@> nvars = Clause.RemoveVar(var, mcs.just);
  nvars.?(nil: {
    # Assertion: clause conflicts only arise from inferred variables,
    # not attempted assignments nor pure literals.
    ClauseId@ w = why.inferred;

    Conflict@ conflict = @(a: clause, b: w, var: var);
    OpResult@(conflict: conflict);
  });

  List@<Assign@> todo = {
    nvars.cons.tail.?(cons: s.todo);
    Cons(@(var: nvars.cons.head, why: Inferred(clause)), s.todo);
  };

  OpResult@(solver:
    s.@(clauses: Clauses.Insert(s.clauses, clause, nvars), todo));
};

# Assign a value to a variable.
# Returns the updated solver state, or a Conflict@ in case of a conflict.
(Var@, Why@, Solver@) { OpResult@; }
Assign = (Var@ var, Why@ why, Solver@ s) {
  Maybe@<VarS@> mvs = Vars.Lookup(s.vars, var.id);

  # If the variable doesn't exist, we must have already made an assignment for
  # it. Ignore this assignment attempt.
  mvs.?(nothing: OpResult@(solver: s));
  VarS@ vs = mvs.just;

  Solver@ ns = s.@(
    vars: Vars.Delete(s.vars, var.id),
    assigns: Cons(var, s.assigns));

  List@<ClauseId@> match = var.pos.?(true: vs.pos, false: vs.neg);
  Solver@ match_s = /Core/List%.ForEach(match, ns, RemoveClause);
  List@<ClauseId@> unmatch = var.pos.?(true: vs.neg, false: vs.pos);

  # TODO: Break out of the loop as soon as we find a conflict rather than
  # going through the entire list?
  /Core/List%.ForEach(unmatch, OpResult@(solver: match_s),
    (ClauseId@ c, OpResult@ r) {
      r.?(conflict: r);
      RemoveVarFromClause(c, var.id, why, r.solver);
    });
};

@ Assignment@ = List@<Var@>;

@ SearchResult@ = +(
  Assignment@ sat,
  *(ClauseId@ clause_id, Conflicts@ conflicts) unsat
);

# Result@ --
#   The result of trying to solve a sat problem.
@ Result@ = +(Assignment@ sat, Unit@ unsat);

% Show = {
  Show@<Id@> Id = /Core/Int/Show%.Show;

  Show@<Var@> Var = (Var@ v) {
    String@ sign = v.pos.?(true: Str|'+', false: Str|'-');
    Append(sign, Id(v.id));
  };

  Show@<Clause@> Clause = /Core/List/Show%.Show(Var);

  Show@<Why@> Why = (Why@ w) {
    w.?(
      attempt: Str|'attempt',
      pure: Str|'pure',
      inferred: Strs[Str|'inferred from ', Id(w.inferred)]);
  };

  Show@<Assign@> Assign = (Assign@ op) {
    Strs[Str|'Assign ', Var(op.var), Str|' (', Why(op.why), Str|')'];
  };

  Show@<Conflict@> Conflict = (Conflict@ c) {
    Strs[Str|'Conflict ', Id(c.a), Str|', ', Id(c.b), Str|' on ', Id(c.var)];
  };

  @(Id, Var, Clause, Why, Assign, Conflict,
    Clauses: Clauses.Show(Clause));
};

@ Algo@ = +(Unit@ dpll, Unit@ cdcl);
Algo@ DPLL = Algo@(dpll: Unit);
Algo@ CDCL = Algo@(cdcl: Unit);

<<@>@ M@>(Monad@<M@>, Debug@<M@>, Algo@)(Solver@) { M@<Result@>; }
Solve = <<@>@ M@>(Monad@<M@> m, Debug@<M@> debug, Algo@ algo) {
  % O = /Core/Stream/OStream%(m);

  # Process todos until no more remain or unsat.
  (Solver@) { M@<OpResult@>; } Simplify = (Solver@ s) {
    s.unsat.?(true: m.return(OpResult@(unsat: Unit)));

    s.todo.?(nil: m.return(OpResult@(solver: s)));
    Assign@ assign = s.todo.cons.head;
    Unit@ _ <- m.do(debug(Int|3, (OStream@<M@> dbg) {
      O.PutLine(dbg, Show.Assign(assign));
    }));

    Solver@ ns = s.@(todo: s.todo.cons.tail);
    OpResult@ result = Assign(assign.var, assign.why, ns);
    result.?(conflict: m.return(result));
    Simplify(result.solver);
  };

  # Pick some variable that exists in the given vars map.
  (Vars@) { Maybe@<VarId@>; } PickSomeVar = (Vars@ vars) {
    # TODO: Come up with a more efficient way to pick any single existing
    # variable.
    Vars.ForEach(vars, Nothing<VarId@>,
      (VarId@ v, VarS@ _, Maybe@<VarId@> mv) {
        Just(v);
      });
  };

  (Solver@) { SearchResult@; } Unsat = (Solver@ s) {
    SearchResult@(unsat: @(clause_id: s.clause_id, conflicts: s.conflicts));
  };

  # Basic DPLL based sat solver.
  (Solver@) { M@<SearchResult@>; } SearchDPLL = (Solver@ s) {
    Unit@ _ <- m.do(debug(Int|4, (OStream@<M@> dbg) {
      O.PutLine(dbg, Strs[Str|'Search: ', Show.Clauses(s.clauses)]);
    }));

    OpResult@ ms <- m.do(Simplify(s));
    ms.?(conflict: m.return(Unsat(s)));
    ms.?(unsat: m.return(Unsat(s)));

    Solver@ s = ms.solver;

    Maybe@<VarId@> mvar = PickSomeVar(s.vars);
    mvar.?(nothing: m.return(SearchResult@(sat: s.assigns)));
    VarId@ var = mvar.just;

    Solver@ attempt = s.@(todo:
      Cons(@(var: Var@(var, True), why: Attempt), s.todo));

    SearchResult@ attempted <- m.do(SearchDPLL(attempt));
    attempted.?(unsat: {
      Solver@ ns = s.@(todo:
        Cons(@(var: Var@(var, False), why: Attempt), s.todo));
      SearchDPLL(ns);
    });

    m.return(attempted);
  };

  # Sat solver with conflict driven clause learning.
  (Solver@) { M@<SearchResult@>; } SearchCDCL = (Solver@ s) {
    Unit@ _ <- m.do(debug(Int|4, (OStream@<M@> dbg) {
      O.PutLine(dbg, Show.Clauses(s.clauses));
    }));

    OpResult@ ms <- m.do(Simplify(s));
    ms.?(
      conflict: {
        m.return(SearchResult@(unsat: @(
            clause_id: Inc(s.clause_id),
            conflicts: Conflicts.Insert(s.conflicts, s.clause_id, ms.conflict))));
      },
      unsat: m.return(Unsat(s)));

    Solver@ s = ms.solver;

    Maybe@<VarId@> mvar = PickSomeVar(s.vars);
    mvar.?(nothing: m.return(SearchResult@(sat: s.assigns)));
    VarId@ var = mvar.just;

    Var@ vattempt = Var@(var, True);
    Unit@ _ <- m.do(debug(Int|2, (OStream@<M@> dbg) {
      O.PutLine(dbg, Strs[Str|'Try ', Show.Var(vattempt)]);
    }));

    Solver@ attempt = s.@(todo: Cons(@(var: vattempt, why: Attempt), s.todo));

    SearchResult@ attempted <- m.do(SearchCDCL(attempt));
    attempted.?(unsat: {
      # Add conflict clauses for all conflicts encountered in our attempted
      # search
      Solver@ ns = s.@(
        clause_id: attempted.unsat.clause_id,
        conflicts: attempted.unsat.conflicts);
      Solver@ next_attempt = /Core/Iter%.For(
        /Core/Int/Iter%.Range(s.clause_id, ns.clause_id), ns,
        (Id@ i, Solver@ s) {
          Maybe@<Conflict@> conflict = Conflicts.Lookup(ns.conflicts, i);
          AddConflictClause(i, conflict.just, s);
        });
      SearchCDCL(next_attempt);
    });

    m.return(attempted);
  };

  (Solver@) { M@<SearchResult@>; } Search = algo.?(
    dpll: SearchDPLL,
    cdcl: SearchCDCL
  );

  (Solver@ s) {
    SearchResult@ result <- m.do(Search(s));
    m.return(result.?(
      sat: Result@(sat: result.sat),
      unsat: Result@(unsat: Unit)));
  };
};

@(VarId@, Var@, Clause@,
  Solver@, Assignment@, Result@,
  Algo@, DPLL, CDCL,
  EqId, NewSolver, AddClause, AddClauses, Solve);
