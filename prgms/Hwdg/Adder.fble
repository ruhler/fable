
@ Coord@ = /Hwdg%.Coord@;
@ Data@ = /Hwdg%.Data@;
@ Gate@ = /Hwdg%.Gate@;
@ GateEntry@ = /Hwdg%.GateEntry@;
@ Gates@ = /Hwdg%.Gates@;
@ PortSpec@ = /Hwdg%.PortSpec@;
<@>@ Ports@ = /Hwdg%.Ports@;
% InputPort = /Hwdg%.InputPort;
% OutputPort = /Hwdg%.OutputPort;
% UnusedPort = /Hwdg%.UnusedPort;
% Gates = /Hwdg%.Gates;
% Data0 = /Hwdg%.0;
% Data1 = /Hwdg%.1;
% SetGate = /Hwdg%.SetGate;
% EmptyGates = /Hwdg%.EmptyGates;
<@>% ForEachGate = /Hwdg%.ForEachGate;

@ Int@ = /Int/Int%.Int@;
% 0 = /Int/Int%.0;
% 1 = /Int/Int%.1;
% 2 = /Int/Int%.2;
% 3 = /Int/Int%.3;
% 4 = /Int/Int%.4;
% 8 = /Int/Int%.8;
% Add = /Int/Int%.Add;

<@>% List = /List%.List;

# Adder1 - A one bit full adder.
#
# Inputs: 
#   a - the first operand
#   b - the second operand
#   c - carry in
#
# Outputs:
#   z - the sum of a and b.
#   x - the carry out.
#
# Geometry:
#     0 1 2 3 4
#   0 a _ _ b
#   1 _ _ _ _
#   2 x _ _ _ c
#   3   _ _ _
#   4     _ z
Gates@ Adder1 = {
  (Int@, Int@, Gate@) { GateEntry@; } G = (Int@ x, Int@ y, Gate@ g) {
    @(coord: Coord@(x, y), gate: g);
  };

  Data@ _ = Data0;
  
  # Internal Geometry:
  #     0 1 2 3 4
  #   0 a A B b
  #   1 A B A B
  #   2 x C Z C c
  #   3   C Z C
  #   4     C z
  Gates(List<GateEntry@>[
    # Duplicate the input 'a' to cells (1, 0) and (0, 1).
    #   0 1 2 3 4
    # 0   A   b
    # 1 A      
    # 2         c
    # 3        
    # 4        
    G(0, 0, @(
        ports: Ports@<PortSpec@>(
          InputPort, OutputPort,
          OutputPort, UnusedPort),
        function: (Ports@<Data@> d) { Ports@<Data@>(
          _, d.ul,
          d.ul, _);
        })),

    # Duplicate the input 'b' to cells (2, 0) and (3, 1).
    #   0 1 2 3 4
    # 0   A B  
    # 1 A     B
    # 2         c
    # 3        
    # 4        
    G(2, 0, @(
        ports: Ports@<PortSpec@>(
          OutputPort, InputPort,
          UnusedPort, OutputPort),
        function: (Ports@<Data@> d) { Ports@<Data@>(
          d.ur, _,
          _, d.ur);
        })),

    # Duplicate the input 'c' to cells (3, 2) and (3, 3).
    #   0 1 2 3 4
    # 0   A B  
    # 1 A     B
    # 2       C  
    # 3       C
    # 4        
    G(3, 2, @(
        ports: Ports@<PortSpec@>(
          OutputPort, InputPort,
          OutputPort, UnusedPort),
        function: (Ports@<Data@> d) { Ports@<Data@>(
          d.ur, _,
          d.ur, _);
        })),

    # Cross over a and b inputs.
    #   0 1 2 3 4
    # 0        
    # 1 A B A B
    # 2       C  
    # 3       C
    # 4        
    G(1, 0, @(
        ports: Ports@<PortSpec@>(
          InputPort, InputPort,
          OutputPort, OutputPort),
        function: (Ports@<Data@> d) { Ports@<Data@>(
          _, _,
          d.ur, d.ul);
        })),

    # Compute sum out.
    #   0 1 2 3 4
    # 0        
    # 1 A B    
    # 2     Z    
    # 3       C
    # 4        
    G(2, 1, @(
        ports: Ports@<PortSpec@>(
          InputPort, InputPort,
          OutputPort, InputPort),
        function: (Ports@<Data@> d) {
          Data@ z = d.ul.?(
            0: d.ur.?(0: d.lr, 1: d.lr.?(0: Data1, 1: Data0)),
            1: d.ur.?(0: d.lr.?(0: Data1, 1: Data0), 1: d.lr));
          Ports@<Data@>( _, _, z, _);
        })),

    # Move z down to (2, 3).
    #   0 1 2 3 4
    # 0        
    # 1 A B    
    # 2          
    # 3     Z C
    # 4        
    G(2, 2, @(
        ports: Ports@<PortSpec@>(
          InputPort, UnusedPort,
          OutputPort, UnusedPort),
        function: (Ports@<Data@> d) { Ports@<Data@>(
          _, _,
          d.ul, _);
        })),

    # Cross over c and z.
    #   0 1 2 3 4
    # 0        
    # 1 A B    
    # 2          
    # 3        
    # 4     C z
    G(2, 3, @(
        ports: Ports@<PortSpec@>(
          InputPort, InputPort,
          OutputPort, OutputPort),
        function: (Ports@<Data@> d) { Ports@<Data@>(
          _, _,
          d.ur, d.ul);
        })),

    # Move c up to (1, 3).
    #   0 1 2 3 4
    # 0        
    # 1 A B    
    # 2          
    # 3   C    
    # 4       z
    G(1, 3, @(
        ports: Ports@<PortSpec@>(
          OutputPort, UnusedPort,
          UnusedPort, InputPort),
        function: (Ports@<Data@> d) { Ports@<Data@>(
          d.lr, _,
          _, _);
        })),

    # Move c up to (1, 2).
    #   0 1 2 3 4
    # 0        
    # 1 A B    
    # 2   C      
    # 3        
    # 4       z
    G(1, 2, @(
        ports: Ports@<PortSpec@>(
          OutputPort, UnusedPort,
          InputPort, UnusedPort),
        function: (Ports@<Data@> d) { Ports@<Data@>(
          d.ll, _,
          _, _);
        })),

    # Compute carry out.
    #   0 1 2 3 4
    # 0        
    # 1        
    # 2 x        
    # 3        
    # 4       z
    G(0, 1, @(
        ports: Ports@<PortSpec@>(
          InputPort, InputPort,
          OutputPort, InputPort),
        function: (Ports@<Data@> d) {
          Data@ x = d.ul.?(
            0: d.ur.?(0: Data0, 1: d.lr),
            1: d.ur.?(0: d.lr, 1: Data1));
          Ports@<Data@>( _, _, x, _);
        }))

  ]);
};

# Adder2 - A two bit adder.
#
# Inputs: 
#   A - the most significant bit of the first operand
#   a - the least significant bit of the first operand
#   B - the most significant bit of the second operand
#   b - the least significant bit of the second operand
#   c - carry in
#
# Outputs:
#   Z - the most significant bit of the sum of a and b.
#   z - the least significant bit of the sum of a and b.
#   x - the carry out.
#
# Geometry:
#     0 1 2 3 4 5 6 7 8 9
#   0 A _ _ B a _ _ b
#   1 _ _ _ _ _ _ _ _
#   2 x _ _ _ _ _ _ _ c
#   3   _ _ _   _ _ _ 
#   4     _ Z     _ z
Gates@ Adder2 = {
  ForEachGate<Gates@>(Adder1, EmptyGates, (Coord@ p, Gate@ g, Gates@ gates) {
    # Gates for the most significant bit addition.
    Gates@ g1 = SetGate(gates, p, g);

    # Gates for the least significant bit addition.
    SetGate(g1, Coord@(Add(4, p.x), p.y), g);
  });
};

# Adder4 - A four bit adder.
#
# Inputs: 
#   a3, a2, a1, a0 - the bits of the first operand.
#   b3, b2, b1, b0 - the bits of the second operand
#   c - carry in
#
# Outputs:
#   z3, z2, z1, z0 - the bits of the sum of a and b.
#   x - the carry out.
#
# Geometry:
#      0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16
#   0 a3  _  _ b3 a2  _  _ b2 a1  _  _ b1 a0  _  _ b0
#   1  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _
#   2  x  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  c
#   3     _  _  _     _  _  _     _  _  _     _  _  _
#   4        _ z3        _ z2        _ z1        _ z0
Gates@ Adder4 = {
  ForEachGate<Gates@>(Adder2, EmptyGates, (Coord@ p, Gate@ g, Gates@ gates) {
    # Gates for the most significant 2 bits of addition.
    Gates@ g1 = SetGate(gates, p, g);

    # Gates for the least significant 2 bits of addition.
    SetGate(g1, Coord@(Add(8, p.x), p.y), g);
  });
};

@(Adder1, Adder2, Adder4);

