
@ Bool@ = /Bool%.Bool@;
% True = /Bool%.True;
% False = /Bool%.False;
% AndMonoid = /Bool%.AndMonoid;

@ Char@ = /Char%.Char@;
% Chars = /Char%.Chars;

<@>@ S@ = /List%.S@;
<@>% S0 = /List%.S0;
<@>% S = /List%.S;
<@>% Append = /List%.Append;
<@>% Concat = /List%.Concat;
<@,@>% MapS = /List%.MapS;
<@>% SeqS = /List%.SeqS;

<@>@ Put@ = /Process%.Put@;

@ Str@ = /String%.Str@;
% Str = /String%.Str;

@ Unit@ = /Unit%.Unit@;
% Unit = /Unit%.Unit;

@ TestResult@ = +(Unit@ pass, Str@ fail);
@ Test@ = *(Str@ name, TestResult@! test);

# Print a string to the given output stream.
(Put@<Str@>, Str@) { Unit@!; } Print = (Put@<Str@> out, Str@ str) {
  out(str);
};

# Print a string and newline to the given output stream.
(Put@<Str@>, Str@) { Unit@!; } PrintLn = (Put@<Str@> out, Str@ str) {
  out(Append<Char@>(str, Str([Chars.nl])));
};

# Returns True if the tests all pass, false otherwise.
(Put@<Str@>, S@<Test@>) { Bool@!; } RunTests = (Put@<Str@> out, S@<Test@> tests) {
  SeqS<Bool@>(AndMonoid, {
    MapS<Test@, Bool@!>(tests, (Test@ test) {
      Unit@ _ := Print(out, test.name);
      TestResult@ tr := test.test;
      tr.?(
        pass: {
          Unit@ _ := PrintLn(out, S0<Char@>);
          !(True);
        },
        fail: {
          Unit@ _ := PrintLn(
            out,
            Concat<Char@>(S<Str@>([
              Str(Chars|': FAILED: '),
              tr.fail])));
          !(False);
        });
    });
  });
};

S@<Test@> Tests = {
  (Str@){Str@;} name = (Str@ nm) {
    Append<Char@>(Str(Chars|'Test.'), nm);
  };

  Test@ pass = Test@(name(Str(Chars|pass)), !(TestResult@(pass: Unit)));
  Test@ _fail = Test@(name(Str(Chars|fail)), !(TestResult@(fail: Str(Chars|FAILED))));

  S<Test@>([pass]);
};

@(Str@, TestResult@, Test@, RunTests, Tests);
