Library Organization
====================
The prgms directory is getting big enough now that it wants organizing. But
how should the fble library and programs be organized? Ideally there is some
notion of layering of which parts of the library can depend on which other
parts of the library. Ideally there is some way to separate things like hwdg
from the core library.

What exists today, and how I might organize it:

  Core: Bool, Char, Eq, Int, Literal, List, Loop, Maybe, Process, Show,
        String, Test, Unit

  I/O: Stdio, {App, Drawing}

  Utilities: Hex, Bits, {Map, Structured}

  Apps: DataFlow, GameOfLife, Hwdg, Invaders, Md5, Primes, Sat, Snake,
        Sudoku, TicTacToe

  Fble

I kind of wish Int didn't have to be part of Core, but it's used in Test,
which I think should be part of core? Maybe not?

Ideally each module only has visibility of those other modules that it is
allowed to. For example, GameOfLife shouldn't have any visibility of Invaders
and vice versa. Char shouldn't have any visibility of Stdio. It's like there's
a notion of visibility separate from dependence. Is there any way I can work
that into the build system? Or the search path?


Integer Division
----------------
Integer division. How should I deal with that? I'm tempted to say there is no
such thing as integer division. If you want to do integer division, use
rational numbers and approximate as integer.

Or we could have functions like:
(Int@, Int@) { Int@; } Floor;

How do we currently use integer division?
* x % 10 to convert integer to decimal digits.
* Invaders
 - given (x, y) coordinates, find the alien row, height based on StrideY and
   StrideX.
 - convert a row number 0, 1, 2, 3 to alien type A1, A1, A2, A2
 - Wrap level number around mod 6 for determining initial Y position.
* Compute the scale factor to map game coordinates to screen coordinates.
* Random number generation for snake.
* 3D graphics perspective drawing.

A bunch of these seem like very legitimate use cases to me. If I were to
summarize:
* Doing things cyclically, where we like to map a non-cyclic thing to a cyclic
  thing. In other words, mod of positive integers?
* Arithmetic in integer coordinate space, where we want to snap to integer
  values.
* Packing and unpacking bits of data into integers.

Can I come up with clearly defined, meaningful functions for all my current
use cases?

That is, division and mod of Int@ is not well defined right now. Write
functions that are well defined and use those. If appropriate, go through
rational numbers.

Proposal:
  a / b should give:
     a = q*b + r, q = floor(a/b)

Why this makes sense to me:
* If both a and b are positive:
  - This gives what I expect: division rounds towards 0, mod is between 0 and b.
* If a is negative and b is positive, 
  - We still want mod to be between 0 and b, continuing the same cycle
    uninterrupted.
  - It's nice for division to round consistently instead of having a blip
    around 0.
* If a is positive and b is negative
  - It's nice to have a / (-b) = (-a) / b.
  - I kind of like the idea of mod (-b) being between -b and 0.
* If a and b are negative
  - (-a) / (-b) = a / b
  - And still mod (-b) between -b and 0.

That's what we get if we always use floor. So really, it seems like the best
of all worlds to do it that way.

Bytes
-----
We use bytes for md5. We want it for crc, compress, files, png, etc.

So I want to do some cleanup of the interface for bits.

Thoughts:
* Support arbitrary bit lengths in a standard way.
* Have the type be different from comparison operators. So don't distinguish
  between signed and unsigned. The type is the same regardless.

So, generically, a BitN has the following interface:
  NOT, AND, OR, XOR, ADD, INC, ZERO,
  ISZERO, EQUALS, MSB, 
  FULLADD, FULLINC, SHIFTL.

Because that's what we have today. But also the type: T@ and T@ with overflow.

Some bits we'll want to also support literals, like binary and hex. Some maybe
worth supporting that for all kinds of bit literals.

How literals should work:
* If too few digits, assume most significant bits are 0.
* If too many digits, truncate.
  So, for example, if you specify 0x123 on a byte, that turns into 0x23?
  Or do we have to worry about signed vs unsigned in that case?

  Or, consider it an error. I guess we could do either way.

I want an abstract interface BitN@<T@>, where T@ is the bit type.
I'll want a type name too. So, like, Bit8@. That doesn't make sense to include
in the abstract interface.

How do we want the implementation structured? I think
  2 = 1+1
  4 = 2+2
  8 = 4+4

As opposed, to, for example: 8 = 1+1+1+1+1+1+1+1.

More generally, Z = X+Y.

So we'll want a module for Bit1 that provides Bit1@ and an instance of
BitN@<Bit1@>.

And a module for Bit8 that provides Bit8@ and an instance of BitN@<Bit8@>.
And a module for Bit_X_plus_Y that provides T@ and an instance of BitN@<T@>,
given two instances for BitN@.

Should Bit8 be a separate module, or should we have one module, like today,
that defines Bit8, Bit16, Bit32, Bit64, etc.?

What names would we use?

Bit8.Bit8@, Bit8.BitN

I guess I'm suggesting we do that. Each module defines a pair of entities: the
type and the instance of BitN@ for that type.

Then we could have a single top level module that defines Bit8, Bit16, etc.

Proposed module hierarchy:

/Core/BitN/BitN%
  Definition of BitN@ interface.
/Core/BitN%

Hmm... Maybe use Bits@ instead of BitN@?

/Core/Bits/Bits% - Definition of Bits@ interface.
/Core/Bits/Bit1% - Implementation of Bits@ for Bit1@.
/Core/Bits/BitXY% - Implementation of Bits@ for BitX@ + BitY@.
/Core/Bits/Bit8% - Implementation of Bits@ for Bit8@.
/Core/Bits/Bit16% - Implementation of Bits@ for Bit16@.
/Core/Bits/Bit32% - Implementation of Bits@ for Bit32@.

etc..

If people want to use, for example, Bit4%, they should just redefine it
themselves, even though it's defined and used in the implementation of Bit8@?

The option is to have
/Core/Bits/BitN% - That defines Bit1, Bit2, Bit4, Bit8, Bit16, Bit32, and Bit64?

No. I would prefer to import /Core/Bits/Bit8%. Or, perhaps /Core/Bits%.Bit8?

How about this:
  /Core/Bits/Bits% - @(Bits@)
  /Core/Bits/Bit1% - @(Bit1@, Bits)
  /Core/Bits/BitXY% - <@ X@, @ Y@>(Bits@<X@>, Bits@<Y@>) { @(BitXY@, Bits); }
  /Core/Bits%% - @(Bit1, Bit2, Bit4, Bit8, Bit16, Bit32, Bit64)

We can reuse /Core/Digits%.Bit@ type for Bit1@.

Summary of changes from what's currently implemented:
* Rename BitN@ to Bits@. (done)
* Change Bit2X@ to BitXY@. (done)
* Rename Result@ to Overflow@. (done)
* Clean up coding style with regards to braces. (done)
* Rename 'zero' to '0'?
* Move from Md5 package to Core package.

Let's see if I can make some of these improvements incrementally.

Can we come up with a nicer convention for 'with overflow' naming? Like,
instead of 'add', add with overflow is 'add_o', or 'add_'? Then we can change
name of Result@ to T_@? Brainstorming: 'add_overflow', 'inc_overflow',
Overflow@. 'add_ov', 'inc_ov', 'Ov@'.

Let's just be explicit: add_overflow, inc_overflow, lshift_overflow.

Ov@ is nice too? Then Ov@ = <@ T@> { *(T@ x, Bit@ ov); };

Or, 'o', where 'o' could stand for overflow or out? Or...

Overflow = <@ T@> { *(T@ x, Bit@ out); }?

