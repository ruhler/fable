
@ Int@ = /Int/Int%.Int@;
% Add = /Int/Int%.Add;

<@>@ List@ = /List%.List@;
<@>% Cons = /List%.Cons;
<@>% Nil = /List%.Nil;

<@,@>@ Lit@ = /Literal%.Lit@;

@ Program@ = /Fblf/Program%.Program@;
@ Addr@ = /Fblf/Program%.Addr@;
% SeqL = /Fblf/Program%.SeqL;

# Instance@, Module@ --
#   Module@ is a monad for tracking allocation of objects on a heap. It is
#   implemented as a state monad over an Addr@ tracking the size in bits of
#   the heap allocated so far.
#
#   Instance@ is the part of the Module@ monad that represents an instantiated
#   Module@.
<@>@ Instance@ = <@ T@> { *(Addr@ heap, T@ instance); };
<@>@ Module@ = <@ T@>(Addr@) { Instance@<T@>; };

# AllocM --
#   Allocate n bits on the heap.
#
# Example use:
#   Addr@ x <- AllocM(I(D|32));
#   ...
<@ T@>(Int@)((Addr@) { Module@<T@>; }) { Module@<T@>; }
AllocM = <@ T@>(Int@ n)((Addr@) { Module@<T@>; } f) {
  (Addr@ free) {
    f(free)(Add(free, n));
  };
};

# InstM --
#   Instantiate a module for use in another module.
#
# Example use:
#   Program@ p <- InstM(m);
#   ...
<@ A@, @ B@>(Module@<A@>)((A@) { Module@<B@>; }) { Module@<B@>; }
InstM = <@ A@, @ B@>(Module@<A@> m)((A@) { Module@<B@>; } f) {
  (Addr@ free) {
    Instance@<A@> mr = m(free);
    f(mr.instance)(mr.heap);
  };
};

# PureM --
#   A module that does not need to allocate space on the heap or instantiate
#   other modules.
<@ T@>(T@) { Module@<T@>; } PureM = <@ T@>(T@ instance) {
  (Addr@ free) { Instance@<T@>(free, instance); };
};

# SeqM --
#   Instantite a list of modules.
#
# TODO: generalize this to arbitrary T@?
(Lit@<Module@<Program@>>) { Module@<Program@>; } SeqM = (Lit@<Module@<Program@>> ms) {
  Module@<List@<Program@>> ml = ms<Module@<List@<Program@>>>((Module@<Program@> aM, Module@<List@<Program@>> bM) {
    Program@ a <- InstM<Program@, List@<Program@>>(aM);
    List@<Program@> b <- InstM<List@<Program@>, List@<Program@>>(bM);
    PureM<List@<Program@>>(Cons<Program@>(a, b));
  }, PureM<List@<Program@>>(Nil<Program@>));

  List@<Program@> l <- InstM<List@<Program@>, Program@>(ml);
  PureM<Program@>(SeqL(l));
};

<@ T@>(Module@<T@>, Addr@) { Instance@<T@>; }
Instantiate = <@ T@>(Module@<T@> m, Addr@ free) {
  m(free);
};

@(Module@, Instance@, AllocM, InstM, PureM, SeqM, Instantiate);
