The Fable of Damocrates 
=======================
Richard Uhler <ruhler@degralder.com>

Introduction
------------
Damocrates is a computer programming language from the Fable collection. It
builds on top of the Calvisus language, providing compile-time developer
features for modularity and abstraction geared at reducing the cost of
producing large fblc programs.

A core philosophy of fbld is that it can be statically compiled to fblc.
The abstractions introduced by fbld are zero-cost in the sense that they have
no overhead at runtime after compiling the program down to fblc. The developer
need not have to make a tradeoff between modularity/abstraction and runtime
performance.

Damocrates facilitates development of large scale programs by introducing two
broad features extending the existing fblc language: modules and polymorphism.
Modules allow the same peice of code to be reused in many different programs,
and polymorphism allows the same peice of code to be reused in many different
contexts within a single program. These features allow a developer to easily
leverage the existing work of others to assemble and reuse large scale
programs.

Modules
-------
A module is a collection of type, func, and proc entities that can be reused
in different programs. The entities defined in a module exist in their own
namespace to avoid name conflicts when combining modules together to form
programs. To make it simpler to use a module without having to understand its
implementation details, a module has a separate interface describing what
entities it makes publicly available for use. To allow the benefits of modules
to scale to much larger programs, modules and their interfaces can be defined
hierarchically; a module can define its own sub-interfaces and sub-modules in
addition to defining types, funcs, and procs.

Module Declaration
~~~~~~~~~~~~~~~~~~
The following shows an example of a module declaring a unary integer type and
operations:

  module IntegerM(IntegerI) {
    struct Unit();
    union Int(Unit 0, Int S);

    func Add(Int a, Int b; Int) {
      ?(a; b, Int:S(Add(a.S, b)));
    };
  };

The module declaration provides the name of the module, "IntegerM", the name
of the module's interface "IntegerI", and the collection of entities defined
by the module: types "Unit" and "Int" and function "Add" in this case.

Module Namespaces
~~~~~~~~~~~~~~~~~
The braces of a module declaration introduce a new name space. Entities
declared in a different namespace cannot be directly referred to. For example,
the following program is incorrect, because the Unit type is not available
in the namespace where Int is defined, and the Int type is not available in
the namespace where IntPair is defined:

  struct Unit();

  module IntegerM(IntegerI) {
    union Int(Unit 0, Int S);               # ERROR: 'Unit' not defined

    func Add(Int a, Int b; Int) {
      ?(a; b, Int:S(Add(a.S, b)));
    };
  };

  struct IntPair(Int first, Int second);    # ERROR: 'Int' not defined.

There are three ways to refer to entities declared in another name space:
import from parent, qualified references, and import from module.

Import from Parent
^^^^^^^^^^^^^^^^^^
A module can explicitly import entities into its own namespace from the
namespace in which the module itself is defined. For example, this can be used
to improt the Unit type in the previous example into the IntegerM namespace so
that it can be referred to when defining the Int type. To import an entity
from a parent module, an "import @" statement is used:

  struct Unit();

  module IntegerM(IntegerI) {
    import @ { Unit; };               # Unit imported from parent namespace.
    union Int(Unit 0, Int S);         # OK: 'Unit' is now in scope.

    func Add(Int a, Int b; Int) {
      ?(a; b, Int:S(Add(a.S, b)));
    };
  };

The basic form of the import @ statement is to list entities in the parent
namespace to import under the same name in the module namespace. Multiple
entities can be imported with a single import @ statement, separated by
semicolons. For example, to import entities Apple, Bannana, and Pair from a
parent namespace, you could write:

  import @ { Apple; Bannana; Pair; };

More generally, an entity can be imported from the parent namespace to the
module namespace under a different name. This allows a module to have full
control over its own namespace. For example, to import the Unit type under the
name MyParentsUnit:

  struct Unit();

  module IntegerM(IntegerI) {
    import @ { MyParentsUnit=Unit; };
    union Int(MyParentsUnit 0, Int S); # OK: 'MyParentsUnit' is now in scope.

    func Add(Int a, Int b; Int) {
      ?(a; b, Int:S(Add(a.S, b)));
    };
  };

The general syntax for the parent import statement is:

   'import' '@'  '{' [tname ['=' qref]; [tname ['=' qref]; [...]]] '}'

Only entities available in the module's immediate parent namespace may be
imported this way. An entity declared in the parent's parent namespace cannot
be imported unless it has first been imported into the parent namespace.

Entities imported this way must not recursively depend on the definition of
this module.

Qualified References
^^^^^^^^^^^^^^^^^^^^
A second way to reference entities from another namespace is to use qualified
references. Qualified references allow you to access an entity declared within
a module in your current namespace. The syntax is to put the name of the
entity, followed by '@' and the name of the module it belongs to.

For example, we can use the qualified reference Int@IntegerM to refer to the
Int type from the parent module when defining IntPair:

  struct Unit();

  module IntegerM(IntegerI) {
    import @ { Unit; };
    union Int(Unit 0, Int S);

    func Add(Int a, Int b; Int) {
      ?(a; b, Int:S(Add(a.S, b)));
    };
  };

  struct IntPair(Int@IntegerM first, Int@IntegerM second);

Import from Module
^^^^^^^^^^^^^^^^^^
Because it can be tedious to always be using qualified references to access
entities from other modules, we also provide a way to import those entities
directly into your namespace using an import statement. The import statement
behaves the same as an import '@' statement, but in place of the '@' specifies
a module currently in scope to import entities from. Using this approach, our
example becomes:


  struct Unit();

  module IntegerM(IntegerI) {
    import @ { Unit; };
    union Int(Unit 0, Int S);

    func Add(Int a, Int b; Int) {
      ?(a; b, Int:S(Add(a.S, b)));
    };
  };

  import IntegerM { Int; };
  struct IntPair(Int first, Int second);

As with the import '@' statement, entities can be renamed upon import:

  import IntegerM { MyInt=Int; };
  struct IntPair(MyInt first, MyInt second);

Interfaces
~~~~~~~~~~
Every module has an interface that describes what entities the module makes
publicly available. Only entities listed in the module interface are visible
to other modules.

Here as an example of an IntegerI interface that exposes all the entities
defined in the IntegerM module:

  interf IntegerI {
    import @ { Unit; };

    union Int(Unit 0, Int S);
    func Add(Int a, Int b; Int);
  };

An interface can be thought of as a module declaration with all the
implementation details left out. As with a module declaration, entities
declared in an interface belong to their own namespace. Use of import
statements and qualified references is required to access entities from other
namespaces.

Import statements in the interface are not considered part of the interface.
The import of the Unit type in the above example does not make the Unit type
visible as an entity made available by the module, and does not imply that a
module implementation of the interface reference the Unit type using the same
mechanism or name.

Prototypes
^^^^^^^^^^
In place of type, func, proc, module, and interf definitions in a module, the
interface contains only prototypes of those things. The prototypes provide
enough information to use the entity without any other implementation details.
The following forms of prototypes can be used in an interface.

Abstract Type
.............
The prototype for an abstract type is declared using the 'type' keyword. For
example:
  type Int;

This prototype says that Int is a type, but does not indicate whether it is a
union or field type, or what the fields of the type are. The user of this Int
type cannot directly construct values of the type, access any fields of the
type, or condition based on the type.

An abstract type can be implemented in a module by any kind of struct or union
type.

Struct Type
...........
The prototype for a struct type is a full struct type definition, because the
fields of the struct type are part of its interface. Users of a struct type
can use the constructor to construct values of the type and field access to
access members of the type.

  struct IntPair(Int first, Int second);

A struct type can be implemented in a module with a matching struct
definition. Both the type and field names must match.

Union Type
..........
The prototype for a union type is a full union type definition, because the
fields of the union type are part of its interface. Users of a union type
can use the constructor to construct values of the type, field access to
access members of the type, and conditionals to select based on the tag of the
type.

  union Fruit(Unit Apple, Unit Banana, Unit Pair);

A union type can be implemented in a module with a matching union
definition. Both the type and field names must match.

Function
........
The prototype for a function is the same as the function defininition, but
without the body of the function.

  func Add(Int a, Int b; Int);

A user can apply the function given the prototype.

Because a user does not need to know the argument names to call a function,
the argument names need not match between a prototype and implementation for
the prototype to be considered matching.

Process
.......
The prototype for a process is the same as the process definition, but without
the body of the process.

  proc Put(Data+ out; Data value; Unit);

A user can call the process given the prototype.

Because a user does not need to know the port and argument names to call a
process, the port and argument names need not match between a prototype and
implementation for the prototype to be considered matching.

Interface
.........
The prototype for an interface is a full interface declaration.

  interf IntegerI {
    import @ { Unit; };

    union Int(Unit 0, Int S);
    func Add(Int a, Int b; Int);
  };

A user can implement the interface or access entities in a module through the
interface.

Module
......
The prototype for a module is the module header.

  module IntegerM(IntegerI);

A user can access entities in the module through its interface.

Requirements for Satisfying an Interface
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
A module satisfies an interface if it defines an entity to match every
prototype in the interface. It is acceptable for a module to define additional
entities; these additional entities will not be visible to users outside of
the module itself.

A module cannot use an import statement to define an interface entity. Instead
the entity should be imported under a different name and use the proto = qref;
declaration form to define it in the module. This ensure the prototype of the
entity is explicitly included in the module.

A module cannot rely on the interface for the definition of any entities.
Because the interface prototypes will match the module definition, there will
be duplication of prototypes between the interface and module. For struct,
union, and inter entities, the entire definition must be duplicated. As with
all other entities, struct and union types from different modules are
considered different types, even if they both have the same interface
prototype. 

Polymorphism
------------
Polymorphism makes it possible to reuse the same code in multiple different
contexts in the same program. For example, with polymorphism it is possible to
provide one implementation of a list type and associated functions that work
for lists of any arbitrary type of element. Polymorphism is introduced in
Damocrates by allowing entity declarations to be parameterized by other
entities.

A generic list type and 'Last' function could be defined by introducing a type
parameter T as follows:

  struct ListP<type T>(T head, ListS<T> tail);
  union ListS<type T>(Unit nil, ListP<T> cons);

  func Last<type T>(ListP<T> list ; T) {
    ?(list.tail; list.head, Last<T>(list.tail.cons));
  };

We could also define a generic 'Contains' function to check if a list contains
a specific element, but only if we also provide a func parameter to define
what it means for two elements to be equal:
  
  func Contains<type T; func Eq(T a, T b; Bool)>(ListS<T> list, T elem; Bool) {
    ?(list;
        False(),                                    # The list is empty.
        ?(Eq(elem, list.cons.head);
          True(),                                   # head matches.
          Contains<T, Eq>(list.cons.tail, elem)));  # check the tail.
  };

Declaring Polymorphic Entities
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  params ::= ['<' [proto [',' proto [...]]] '>'] ;

To declare a polymorphic entity, supply a list of zero or more static
parameters after the entity name surrounded by angle brackets. A static
parameter is described using a prototype, as defined previously in the context
of interfaces. All kinds of prototypes are allowed, including abstract type,
struct, union, func, proc, interf, and module, though union, and interf
prototypes may not be as useful in practice.

The prototype introduces an entity into scope, visible to all later static
parameter prototypes and the body of the entity declaration.

TODO: Are static parameters visible across module namespace boundaries, or do
they need to be imported explicitly like all other entities into module
namespaces?

Note that the prototypes of arguments can themselves be prototypes for
parameterized entities.

Supplying Static Parameter Values
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
['<' [qref [',' qref [...]]] '>']

To use a parameterized entity, static parameter values must be provided. These
are provided as a list of qualified references in angle brackets. Each qref
must have a prototype matching that of the prototype specified when the entity
was declared.

The number of qref's supplied may be less than the number of static parameters
required by the entity, in which case we say partial application of static
parameters has occured. This is useful for supplying parameterized arguments
to another entity. For example, consider a monadic function:

  bind<type A, type B, type M<T>, func F(A x; M<B>)>(M<A> x; M<B>);

  This could be used with an Either monad by supplying a partial application of
  the Either type constructor:

    struct Either<type A, type B>(A left, B right);

    ... bind<Int, Bool, Either<String>, IsZero>(x) ...

Entity Aliases
~~~~~~~~~~~~~~
Reuse of parameterized entities provides another way to define an entity: by
static application of parameters to some other polymorphic entity. To support
this, we introduce another form of entity definition:

  proto '=' qref ';' ;

This form can be used in place of a standard entity declaration. For example,
we could provide a generic BitXY type for composing bit types together, then
define a Bit8 type in terms of that generic type:

  struct BitXY<type A, type B>(A hi, B lo);

  type Bit8 = BitXY<Bit4, Bit4>;

TODO: clarify the details here. Who gets to know that Bit8 is a BitXY under
the covers?

Source Statements
-----------------
To practically facilitiate reuse of code developed by different developers and
used in different programs, it is convenient to be able to split a single
program across multiple files. To allow this, we introduce a 'source'
statement that can be used in place of an entity declaration or prototype:

  'source' tname uri ';'

The source statement directs the parser to retreive and parse an entity
definition identified by the given uri as if the entity were declared in place
of the source statement.

The context for the uri is uri for the file that contains the source
statement. Any ';' character within the uri must be encoded as described by
the URI specification, because it is considered an unsafe character in this
context.

For example, instead of having a single program stored in the file
Example.fbld:

  struct Unit();

  interf IntegerI {
    import '@' { Unit; };
    union Int(Unit 0, Int S);
    func Add(Int a, Int b; Int);
  };

  module IntegerM(IntegerI) {
    import '@' { Unit; };
    union Int(Unit 0, Int S);

    func Add(Int a, Int b; Int) {
      ?(a; b, Int:S(Add(a.S, b)));
    };
  };

  import IntegerM { Int; };
  struct IntPair(Int first, Int second);

The program could be split into separate files Example.fbld, IntegerI.fbld,
and IntegerM.fbld:

Example.fbld:
  struct Unit();

  source IntegerI IntegerI.fbld;
  source IntegerM IntegerM.fbld;

  import IntegerM { Int; };
  struct IntPair(Int first, Int second);

IntegerI.fbld:
  interf IntegerI {
    import '@' { Unit; };
    union Int(Unit 0, Int S);
    func Add(Int a, Int b; Int);
  };

IntegerM.fbld:
  module IntegerM(IntegerI) {
    import '@' { Unit; };
    union Int(Unit 0, Int S);

    func Add(Int a, Int b; Int) {
      ?(a; b, Int:S(Add(a.S, b)));
    };
  };

A sourced file must define exactly one top level declaration with the same
name as provided in the source statement. This allows tools to identify which
uri to follow to find the definition of an entity. By convention, the ".fbld"
extension is used for files containing fbld programs or sourced entity
definitions.

This specification does not say whether a sourced declaration must be
eagerly parsed and type checked or whether parsing and checking the entity
can be deferred, possibly indefinately, until it is referenced. Different
tools for different use cases will wish to choose different alternatives. For
example, an interpreter may choose not to parse the entity if it is never
referenced, while a static analyzer may choose to parse all entities.

Syntax Reference
----------------
  type_proto ::= 'type' tname params ;
  struct_proto ::= 'struct' tname params '(' [qref fname [',' qref fname [...]]] ')' ;
  union_proto ::= 'union' tname params '(' qref fname [',' qref fname [...]] ')' ;
  func_proto ::= 'func' tname params '(' [qref vname [',' qref vname [...]]] ';' qref ')' ;
  proc_proto ::= 'proc' tname params '('
                     [qref polarity pname [',' qref polarity pname [...]]] ';'
                     [qref vname [',' qref vname [...]]] ';' qref ')' ;
  interf_proto ::= 'interf' tname params '{' [idecl [idecl [...]]] '}' ;
  module_proto ::= 'module' tname params ['(' qref ')'] ;

  proto ::= type_proto
         | struct_proto
         | union_proto
         | func_proto
         | proc_proto
         | interf_proto
         | module_proto
         ;

  import ::= 
     'import' '@'  '{' [tname ['=' qref]; [tname ['=' qref]; [...]]] '}'
   | 'import' qref '{' [tname ['=' qref]; [tname ['=' qref]; [...]]] '}'
   ;

  idecl ::=
     proto ';'
   | import ';'
   ;

  decl ::= struct_proto ';'
        |  union_proto ';'
        |  func_proto expr ';'
        |  proc_proto proc ';'
        |  interf_proto ';'
        |  module_proto ['{' [decl [decl [...]]] '}'] ';'
        |  proto '=' qref ';'
        |  import ';'
        ;
  
  prgm ::= decl [decl [...]] ;
 
  params ::= ['<' [proto [',' proto [...]]] '>'] ;

  qref ::= tname
        |  qref '<' [qref [',' qref [...]]] '>'
        |  qref '@' qref
        ;

  expr ::= ... (* as in fblc, with qref in place of tname *)
  proc ::= ... (* as in fblc, with qref in place of tname *)

  polarity ::= ... (* as in fblc *)
  pname ::= ... (* as in fblc *)
  tname ::= ... (* as in fblc *)
  vname ::= ... (* as in fblc *)

Style Suggestions
-----------------
* Capitalize entities, including types, functions, procs, interfaces, and
  modules.
* Lowercase field names, including for structs, unions, function and proc
  arguments.
* Lowercase variable names.
* "true/something/cons" before "false/nothing/empty/error" when ordering
  fields of that kind of union declaration, so that ?(x; a, b) is
  consistent with (x ? a : b) behavior.

  But "0" before "1" for bit, decimal, byte, hex, etc?

Changes from Fbld 3
-------------------
* Instead of <[type...] ; [module...]> for params, we have <[proto...]>.
Which is surely an improvement in simplicity and generality.

* Kinds can themselves be parameterized.
Which avoids an artificial arbitrary limitation by allowing full generality.

* Partial application of qrefs.
Needed once protos are parameterized.
Also generalizes import statements, which implicitly import parameterized
things, not fully applied things.

* protos = 'qref'
Which really is needed for full generality.

* Allow modules to be specified in different files.

* An fblc program is a valid fbld program.

I approve these changes as improving the overall simplicity and generality of
the language. Parameterized protos, partial application, and protos = 'qref'
do add complexity, but they do so in a simple way and provide important
capabilities.

TODO
----
Rewrite spec to incorporate the following changes:
* module's can have implicit interfaces.
* Use of 'priv' and 'abst' keywords in a module implementation.
* A module proto for module Foo within a module Bar can be used to say: read
  the body of Foo from the file Bar/Foo.fbld.
* Module parameters are subject to the same namespace controls as other
  entities.
* Kinds between interf and module must be equal.
  Kinds when passing arguments must match, where match means:
   - the name of the entity doesn't matter.
   - func and proc arg and port names don't matter.
* handling of top level programs.

