
% Add = /Int/Int%.Add;
% D = /Int/Int/Lit%.D;
% I = /Int/Int/Lit%.I;

@ Addr@ = /Fblf/Program%.Addr@;
@ ProgramM@ = /Fblf/Program%.ProgramM@;
@ Module@ = /Fblf/Program%.Module@;
% Seq = /Fblf/Program%.Seq;

% AddF = /Fblf/Lib/Add%.AddF;
% AndF = /Fblf/Lib/Bitwise%.AndF;
% OrF = /Fblf/Lib/Bitwise%.OrF;
% XorF = /Fblf/Lib/Bitwise%.XorF;
% NotF = /Fblf/Lib/Bitwise%.NotF;

(Addr@, Addr@, Addr@, Addr@) { Module@; }
RoundF = (Addr@ x, Addr@ y, Addr@ z, Addr@ r)(Addr@ free) {
  # r = or(and(x, y), and(not(x), z));
  Addr@ nx = free;
  Addr@ anxz = Add(free, I(D|32));
  Addr@ xy = Add(free, I(D|64));

  ProgramM@ nxM = NotF(I(D|32), x, nx)(Add(free, I(D|96)));
  ProgramM@ anxzM = AddF(I(D|32), nx, z, anxz)(nxM.free);
  ProgramM@ xyM = AndF(I(D|32), x, y, xy)(anxzM.free);
  ProgramM@ rM = OrF(I(D|32), xy, anxz, r)(xyM.free);
  ProgramM@(rM.free, Seq([
      nxM.program,
      anxzM.program,
      xyM.program,
      rM.program
  ]));
};

(Addr@, Addr@, Addr@, Addr@) { Module@; }
RoundG = (Addr@ x, Addr@ y, Addr@ z, Addr@ r)(Addr@ free) {
  # r = or(and(x, z), and(y, not(z)));
  Addr@ nz = free;
  Addr@ aynz = Add(free, I(D|32));
  Addr@ xz = Add(free, I(D|64));

  ProgramM@ nzM = NotF(I(D|32), z, nz)(Add(free, I(D|96)));
  ProgramM@ anyzM = AddF(I(D|32), y, nz, aynz)(nzM.free);
  ProgramM@ xzM = AndF(I(D|32), x, z, xz)(anyzM.free);
  ProgramM@ rM = OrF(I(D|32), xz, aynz, r)(xzM.free);
  ProgramM@(rM.free, Seq([
      nzM.program,
      anyzM.program,
      xzM.program,
      rM.program
  ]));
};

(Addr@, Addr@, Addr@, Addr@) { Module@; }
RoundH = (Addr@ x, Addr@ y, Addr@ z, Addr@ r)(Addr@ free) {
  # r = xor(x, xor(y, z));
  Addr@ yz = free;

  ProgramM@ yzM = XorF(I(D|32), y, z, yz)(Add(free, I(D|32)));
  ProgramM@ rM = XorF(I(D|32), x, yz, r)(yzM.free);
  ProgramM@(rM.free, Seq([
      yzM.program,
      rM.program
  ]));
};

(Addr@, Addr@, Addr@, Addr@) { Module@; }
RoundI = (Addr@ x, Addr@ y, Addr@ z, Addr@ r)(Addr@ free) {
  # r = xor(y, or(x, not(z)));
  Addr@ nz = free;
  Addr@ xnz = Add(free, I(D|32));

  ProgramM@ nzM = NotF(I(D|32), z, nz)(Add(free, I(D|64)));
  ProgramM@ xnzM = OrF(I(D|32), x, nz, xnz)(nzM.free);
  ProgramM@ rM = XorF(I(D|32), y, xnz, r)(xnzM.free);
  ProgramM@(rM.free, Seq([
      nzM.program,
      xnzM.program,
      rM.program
  ]));
};

@(RoundF, RoundG, RoundH, RoundI);
