
import @ { StdLib; DrawM=Draw; UBNat@UBNat; };
import StdLib { Unit; BoolM=Bool; List; };
import BoolM { Bool; True; False; And; };
import List { P; S; InitP; LastP; };
import UBNat { Nat; 0; 1; 2; 6; Lit2; Eq@EqNat; Inc; Dec; };
import DrawM { Color; Draw; };

priv func MinRow( ; Nat) 0();
priv func MaxRow( ; Nat) Lit2(2(), 0());
priv func MinCol( ; Nat) 0();
priv func MaxCol( ; Nat) Lit2(6(), 0());

priv struct Pos(Nat row, Nat col);

priv func EqPos(Pos a, Pos b; Bool) {
  And(Eq(a.row, b.row), Eq(a.col, b.col));
};

union Direction(Unit up, Unit down, Unit left, Unit right);
union Input(Direction dir, Unit tick);


priv union Cell(Unit empty, Unit snake, Unit food);

priv func DrawCell(Pos pos, Cell cell ; Draw) {
  Color c = ?(cell; Color:black(Unit()),
                    Color:blue(Unit()),
                    Color:green(Unit()));
  Draw(pos.col, pos.row, 1(), 1(), c);
};


# State --
#   The state of the game.
# 
# Fields:
#   dir - The current direction of the snake.
#   food - The current position of the food.
#   nfood - The position of the next food.
#   snake - The positions of the snake, in order from head to tail.
priv struct State(Direction dir, Pos food, Pos nfood, P<Pos> snake);

priv func DrawSnakeS(S<Pos> s ; S<Draw>) {
  # TODO: Use MapS for this.
  ?(s; S<Draw>:cons(DrawSnakeP(s.cons)), S<Draw>:nil(Unit()));
};

priv func DrawSnakeP(P<Pos> s ; P<Draw>) {
  # TODO: Use MapP for this.
  P<Draw>(DrawCell(s.head, Cell:snake(Unit())), DrawSnakeS(s.tail));
};

priv func DrawState(State s ; S<Draw>) {
  S<Draw>:cons(P<Draw>(DrawCell(s.food, Cell:food(Unit())),
  S<Draw>:cons(DrawSnakeP(s.snake))));
};

priv func InitialState( ; State) {
  Nat c0 = MinCol();
  Nat c1 = Inc(c0); Nat c2 = Inc(c1);
  Nat c3 = Inc(c2); Nat c4 = Inc(c3);
  Nat r0 = MinRow();
  Nat r1 = Inc(r0); Nat r2 = Inc(r1);
  Nat r3 = Inc(r2); Nat r4 = Inc(r3);
  State(
      Direction:right(Unit()),
      Pos(r4, c1),
      Pos(r1, c0),
      P<Pos>(Pos(r1, c4), S<Pos>:cons(P<Pos>(
           Pos(r1, c3), S<Pos>:cons(P<Pos>(
           Pos(r1, c2), S<Pos>:cons(P<Pos>(
           Pos(r1, c1), S<Pos>:nil(Unit())))))))));
};

priv struct MoveResult(State state, S<Draw> draw);
priv union MoveResultM(Unit dead, MoveResult mr);

priv union PosM(Unit dead, Pos pos);

# Return true if the given position is found in the list of positions.
priv func InPosS(S<Pos> s, Pos p ; Bool) {
  ?(s ; InPosP(s.cons, p), False());
};

# Return true if the given position is found in the list of positions.
priv func InPosP(P<Pos> s, Pos p ; Bool) {
  ?(EqPos(s.head, p); True(), InPosS(s.tail, p));
};

priv func Move(State s; MoveResultM) {
  PosM pm = ?(s.dir;
    ?(Eq(s.snake.head.row, MaxRow()); PosM:dead(Unit()), 
        PosM:pos(Pos(Inc(s.snake.head.row), s.snake.head.col))),
    ?(Eq(s.snake.head.row, MinRow()); PosM:dead(Unit()), 
        PosM:pos(Pos(Dec(s.snake.head.row), s.snake.head.col))),
    ?(Eq(s.snake.head.col, MinCol()); PosM:dead(Unit()), 
        PosM:pos(Pos(s.snake.head.row, Dec(s.snake.head.col)))),
    ?(Eq(s.snake.head.col, MaxCol()); PosM:dead(Unit()), 
        PosM:pos(Pos(s.snake.head.row, Inc(s.snake.head.col)))));
  ?(pm; MoveResultM:dead(Unit()),
      ?(EqPos(pm.pos, s.food);
          {
            # TODO: Properly handle the case where the snake eats food at its
            # tail.
            P<Pos> nsnake = P<Pos>(s.food, S<Pos>:cons(s.snake));
            State ns = State(s.dir, s.nfood, s.nfood, nsnake);
            S<Draw> draw = S<Draw>:cons(P<Draw>(DrawCell(s.food, Cell:snake(Unit())),
                         S<Draw>:cons(P<Draw>(DrawCell(s.nfood, Cell:food(Unit())),
                         S<Draw>:nil(Unit())))));
            MoveResultM:mr(MoveResult(ns, draw));
          },
          ?(InPosP(s.snake, pm.pos); MoveResultM:dead(Unit()),
            {
              # TODO: Combine calls to Init and Last so we only have to
              # iterate over the list of elements once instead of twice?
              P<Pos> nsnake = P<Pos>(pm.pos, InitP<Pos>(s.snake));
              Pos nfood = LastP<Pos>(s.snake);
              State ns = State(s.dir, s.food, nfood, nsnake);
              S<Draw> draw = S<Draw>:cons(P<Draw>(DrawCell(pm.pos, Cell:snake(Unit())),
                           S<Draw>:cons(P<Draw>(DrawCell(nfood, Cell:empty(Unit())),
                           S<Draw>:nil(Unit())))));
              MoveResultM:mr(MoveResult(ns, draw));
            })));
};

priv proc Snake(Input- in, S<Draw>+ out; State s ; Unit) {
  Input x = -in();
  ?(x; Snake(in, out; State(x.dir, s.food, s.nfood, s.snake)),
       {
           MoveResultM m = $(Move(s));
           ?(m;
              $(Unit()),
              {
                 S<Draw> drawn = +out(m.mr.draw);
                 Snake(in, out; m.mr.state);
              });
       });
};

proc Main(Input- in, S<Draw>+ out; ; Unit) {
  State s = $(InitialState());
  S<Draw> drawn = +out(DrawState(s));
  Snake(in, out; s);
};
