
@ Bit@ = /Digits%.Bit@;
@ Hex@ = /Digits%.Hex@;
% HexToBits = /Digits/String%.HexToBits;

@ Int@ = /Int/Int%.Int@;
% Add = /Int/Int%.Add;

<@>@ List@ = /List%.List@;

<@>@ Maybe@ = /Maybe%.Maybe@;
<@>% Just = /Maybe%.Just;
<@>% Nothing = /Maybe%.Nothing;

@ String@ = /String%.String@;

@ Unit@ = /Unit%.Unit@;
% Unit = /Unit%.Unit;

@ VarId@ = Int@;

@ ProcId@ = String@;

# Var@ --
#   Identifies an address on the heap relative to a procedure variable.
#
# Fields:
#   id - the index of the procedure argument in the list of args to the
#        procedure. The first argument is index 0, the second index 1, and so
#        on.
#   offset - the offset relative to apply relative to the argument value.
#
# For example, @(id: 3, offset: 5) means 5 bits after whatever is pointed to
# by the fourth argument to the procedure.
@ Var@ = *(VarId@ id, Int@ offset);

# Offset a var by the given number of bits.
(Var@, Int@) { Var@; } Offset = (Var@ v, Int@ n) {
  Var@(v.id, Add(v.offset, n));
};

# Const@ --
#   A constant sequence of bits.
@ Const@ = List@<Bit@>;

# Value@ --
#   A value that is specified as either a reference to a sequence of bits on
#   the heap or a literal sequence of bits.
@ Value@ = +(Var@ var, Const@ const);

(Var@) { Value@; } Var = (Var@ v) {
  Value@(var: v);
};

# A binary constant.
(Const@) { Value@; } Binary = (Const@ c) {
  Value@(const: c);
};

# A hex constant.
(List@<Hex@>) { Value@; } Hex = (List@<Hex@> h) {
  Binary(HexToBits(h));
};

# CondOp@ --
#   A conditional operator.
#
# Fields:
#   eq - The condition is satisfied if the arguments are equal.
#   ne - The condition is satisfied if the arguments are not equal.
@ CondOp@ = +(Unit@ eq, Unit@ ne);

# Cond@ --
#   A conditional expression: a == b or a != b
#
# Fields:
#   op - The operation to use.
#   a - The first operand.
#   b - The second operand.
#   n - The number of bits to compare.
@ Cond@ = *(CondOp@ op, Value@ a, Value@ b, Int@ n);

(Value@, Value@, Int@) { Cond@; } Eq = (Value@ a, Value@ b, Int@ n) {
  Cond@(CondOp@(eq: Unit), a, b, n);
};

(Value@, Value@, Int@) { Cond@; } Ne = (Value@ a, Value@ b, Int@ n) {
  Cond@(CondOp@(ne: Unit), a, b, n);
};

# Assign@ --
#   Set the contents of ref to the given value.
#
# If value is a variable, behavior is undefined of the sequences of bits of
# the var and value are overlapping.
#
# Fields:
#   var - Reference to the sequence of bits to be assigned to.
#   value - The value of the bits to set.
#   n - The number of bits to be assigned.
@ Assign@ = *(Var@ var, Value@ value, Int@ n);

# Sequence@ -- 
#   Executes a sequence of zero or more programs in order.
@ Sequence@ = List@<Stmt@>,

# IfElse@ --
#   Executes the if_body if the condition is satisfied, the else_body
#   otherwise.
@ IfElse@ = *(Cond@ condition, Stmt@ if_body, Stmt@ else_body),

# While@ --
#   Executes the body repeatedly for as long as the condition is satisfied.
@ While@ = *(Cond@ condition, Stmt@ body),

# Call@ --
#   Execute the procedure with the given id.
@ Call@ = *(ProcId@ proc, List@<Var@> args),

# Stmt@ --
@ Stmt@ = +(
  Assign@ assign,
  Sequence@ sequence,
  IfElse@ ifelse,
  While@ while,
  Call@ call
);

(Var@, Value@, Int@) { Stmt@; } Assign = (Var@ x, Value@ v, Int@ n) {
  Stmt@(assign: Assign@(x, v, n));
};

(Cond@, Stmt@, Stmt@) { Stmt@; }
IfElse = (Cond@ p, Stmt@ if_body, Stmt@ else_body) {
  Stmt@(ifelse: IfElse@(p, if_body, else_body));
};

(List@<Stmt@>) { Stmt@; } Seq = (List@<Stmt@> stmts) {
  Stmt@(sequence: stmts);
};

(Cond@, Stmt@) { Stmt@; } If = (Cond@ p, Stmt@ body) {
  IfElse(p, body, Seq[]);
};

(Cond@, Stmt@) { Stmt@; } While = (Cond@ p, Stmt@ body) {
  Stmt@(while: While@(p, body));
};

(ProcId@)(List@<Var@>) { Stmt@; } Call = (ProcId@ id)(List@<Var@> args) {
  Stmt@(call: Call@(id, args));
};

@ Proc@ = *(ProcId@ id, Int@ argc, Stmt@ body);

@ Program@ = List@<Proc@>;

# Look up a procedure in the program.
(ProcId@, Program@) { Maybe@<Proc@>; }
LookupProc = (ProcId@ id, Program@ p) {
  p.?(
    cons: {
      /String/Eq%.Eq(id, p.cons.head.id).?(
        true: Just<Proc@>(p.cons.head),
        false: LookupProc(id, p.cons.tail));
    },
    nil: Nothing<Proc@>);
};

@(
  Bit@, VarId@, ProcId@, Var@, Const@, Value@, CondOp@, Cond@,
  Assign@, Sequence@, IfElse@, While@, Call@, Stmt@,
  Proc@, Program@,
  Binary, Hex, Var, Offset, Eq, Ne, Assign, If, IfElse, Seq, While, Call,
  LookupProc
);
