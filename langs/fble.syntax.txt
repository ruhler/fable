11. Abstract Syntax Reference
-----------------------------
Name ::= (* A string of characters *)

Kind ::=
   basic_kind
 | poly_kind (arg :: Kind) (result :: Kind)
 ;

Type ::=
   struct_type (type_fields :: [(Kind, Name, Type)]) (fields :: [(Type, Name)])
 | struct_type_access (obj :: type) (field :: Name)

 | union_type (fields :: [(Type, Name)])

 | func_type (arg :: Type) (result :: Type)

 | proc_type (result :: Type)
 | input_type (type :: Type)
 | output_type (type :: Type)

 | type_var (name :: Name)
 | poly_type (arg :: Kind) (body :: Type)
 | poly_type_apply (poly :: Type) (arg :: Type)
 | type_let_type (bindings :: [(Kind, Name, Type)]) (body :: Type)
 | expr_let_type (bindings :: [(Name, Type, Expr]) (body :: Type)
 | namespace_eval_type (namespace :: Expr) (body :: Type)
 | namespace_import_type (namespace :: Expr) (body :: Type)
 | type_include (name :: Name)
 ;

Expr ::=
   struct_value (type :: Type) (args :: [Expr])
 | anon_struct (type_args :: [(Name, Type)]) (args :: [(Name, Expr)])
 | struct_access (object :: Expr) (field :: Name)

 | union_value (type :: Type) (field :: Name) (arg :: Expr)
 | union_access (object :: Expr) (field :: Name)
 | cond (condition :: Expr) (choices :: [(Name, Expr)])

 | func_value (args :: [(Type, Name)]) (body :: Expr)
 | apply (func :: Expr) (arg :: Expr)

 | get (port :: Expr)
 | put (port :: Expr) (value :: Expr)
 | eval (expr :: Expr)
 | link (type :: Type) (get :: Name) (put :: Name) (body :: Expr)
 | exec (bindings :: [(Type, Name, Expr)]) (body :: Expr)

 | var (name :: Name)
 | poly_expr (arg :: Kind) (body :: Expr)
 | poly_expr_apply (poly :: Expr) (arg :: Type)
 | type_let_expr (bindings :: [(Kind, Name, Type)]) (body :: Expr)
 | expr_let_expr (bindings :: [(Type, Name, Expr)]) (body :: Expr)
 | namespace_eval (namespace :: Expr) (body :: Expr)
 | namespace_import (namespace :: Expr) (body :: Expr)
 | include (name :: Name)
 ;

12. Concrete Syntax Reference
-----------------------------
name ::= (* [a-zA-Z--9_]+ *)

type_name ::= name '@'

kind ::=
   '@'                                        (* basic_kind *)
 | '\<' kind [',' kind [...]] ';' kind '>'    (* poly_kind *)
 ;

type ::= 
   '*(' [type name [',' type name [...]]] ')'                            (* struct_type *)
 | '*(' kind type_name '=' type [',' kind type_name '=' type [',' ...]   (* struct_type with type fields *)
        [',' type name [',' type name [...]]] ')'
 | '+(' type name [',' type name [...]] ')'                              (* union_type *)
 | '\(' type [',' type [...]] ';' type ')'                               (* func_type *)
 | type '!'                                                              (* proc_type *)
 | type '-'                                                              (* input_type *)
 | type '+'                                                              (* output_type *)
 | type_name                                                             (* type_var *)
 | '\<' kind type_name [',' kind type_name [...]] '>' '{' type_stmt '}'  (* poly_type *)
 | type '<' [type [',' type [...]]] '>'                                  (* poly_type_apply *)
 | '{' type_stmt '}'                                                     (* type_stmt *)
 | '&' type_name                                                         (* type_include *)
 | expr '.' type_name                                                    (* type_field_access *)
 ;

type_stmt ::=
   type ';'                                                                   (* type *)
 | kind type_name '=' type [',' kind type_name '=' type [...]] ';' type_stmt  (* type_let_type *)
 ;

expr ::=
   type '(' [expr [',' expr [...]]] ')'                             (* struct_value *)
 | '@' '(' [name [':' expr] [',' ...]] ')'                          (* anon_struct *)
 | '@' '(' type_name [':' type] [',' ...]                           (* anon_struct with type fields *)
           [',' name [':' expr] [',' ...]] ')'
 | type '(' name ':' expr ')'                                       (* union_value *)
 | expr '.' name                                                    (* access *)
 | '?(' expr ';' name ':' expr [',' name ':' expr [...]] ')'        (* cond *)
 | '\(' [type name [',' type name [...]]] ')' '{' stmt '}'          (* func_value *)
 | expr '(' [expr [',' expr [...]]] ')'                             (* apply *)
 | '$(' expr ')'                                                    (* eval *)
 | name                                                             (* var *)
 | '\<' kind type_name [',' kind type_name [...]] '>' '{' stmt '}'  (* poly_expr *)
 | expr '<' [type [',' type [...]]] '>'                             (* poly_expr_apply *)
 | '{' stmt '}'                                                     (* statement *)
 | expr '{' stmt '}'                                                (* namespace_eval *)
 | '&' name                                                         (* include *)
 ;

stmt ::=
   expr ';'                                                             (* expr *)
 | type name [',' type name [...]] '<-' expr ';' stmt                   (* bind *)
 | type '~' name ',' name ';' stmt                                      (* link *)
 | type name ':=' expr [',' type name ':=' expr [...]] ';' stmt         (* exec *)
 | type name '=' expr [',' type name = expr [...]] ';' stmt             (* let *)
 | kind type_name '=' type [',' kind type_name '=' type [...]] ';' stmt (* type_let_expr *)
 | stmt ::= expr ';' stmt                                               (* namespace_import *)
 ;
