Sat Game
========
Making sure we have enough experience programming in fble this release, let's
implement a sat game.

First step: have a nicer Random@ interface. Because I'd like to reuse code for
things like random integers and shuffling lists.

The current interface for Random is LFSR@. You can shift out a Bit@. I'd like
something monadic. Like:

<<@>@>@ Random@ = <<@>@ M@> { *(
  M@<Bit@> bit
);

Something like that. Build on top of that:

<<@>@ M@> {
  (Random@<M@>) { M@<Bool@>; } Bool;
  (Random@<M@>) { M@<Int@>; } Int;
  (Random@<M@>)<@ A@>(List@<A@>) { M@<List@<A@>>; } Shuffle;
  ...
};

---

The key to start is I don't want to have to reference LFSR@ or Shifted@.

Maybe start by defining Random@ as part of SatGame package. We can move it to
core if it turns out to be useful.

---

Draft of puzzle generation is done. It compiles, but crashes in a bad way at
runtime.

Three issues to investigate:
1. How it's getting tag 2 for a List@ value. This should be impossible. It's
not a bug in the satgame implementation. It must be a bug in the fble
implementation somewhere.

2. Why the stack trace for (1) says undefined function in multiple places.

3. Why number of clauses is 3 when asked for 6 using params 6 6 3 0.

Let's deal with the easy one first.

Clauses added should be:

num_free_vars = num_vars - num_vars_per_clause = 6 - 3 = 3.
clauses_per_variable = (3 + 3 - 1) / 3 = 1.

That's clearly wrong. We didn't even ask how many clauses we wanted here. It
should be: num_clauses / num_free_vars rounded up.

Let's add a test suite and then fix this.




