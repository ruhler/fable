
module Md5M(Md5I) {
  import @ { BitM; Bit8M; Bit32M; Bit64M; BoolM; HexM; ListM; MaybeM; UnitM; };
  import BitM { Bit; };
  import Bit8M { Bit8; H2; };
  import Bit32M { Bit32; };
  import BitN@Bit32M { eq; and; or; not; xor; clshift; add; };
  import Bit64M { Bit64; };
  import BoolM { Bool; True; False; And; };
  import HexM { Hex; 0; 1; 2; 3; 4; 5; 6; 7; 8; 9; a; b; c; d; e; f; };
  import ListM { SL=S; PL=P; };
  import MaybeM { Maybe; };
  import UnitM { Unit; };

  struct Md5Hash(
    Hex  0, Hex  1, Hex  2, Hex  3, Hex  4, Hex  5, Hex  6, Hex  7,
    Hex  8, Hex  9, Hex 10, Hex 11, Hex 12, Hex 13, Hex 14, Hex 15,
    Hex 16, Hex 17, Hex 18, Hex 19, Hex 20, Hex 21, Hex 22, Hex 23,
    Hex 24, Hex 25, Hex 26, Hex 27, Hex 28, Hex 29, Hex 30, Hex 31
  );

  struct ABCD(Bit32 a, Bit32 b, Bit32 c, Bit32 d);

  struct Block(
    Bit32 0, Bit32 1, Bit32 2, Bit32 3,
    Bit32 4, Bit32 5, Bit32 6, Bit32 7,
    Bit32 8, Bit32 9, Bit32 10, Bit32 11,
    Bit32 12, Bit32 13, Bit32 14, Bit32 15);

  union S(
    Unit  0, Unit  1, Unit  2, Unit  3, Unit  4, Unit  5, Unit  6, Unit  7,
    Unit  8, Unit  9, Unit 10, Unit 11, Unit 12, Unit 13, Unit 14, Unit 15,
    Unit 16, Unit 17, Unit 18, Unit 19, Unit 20, Unit 21, Unit 22, Unit 23
  );

  func NextS(S s; Maybe<S>) {
    ?(s; Maybe<S>:nothing(Unit()),
         Maybe<S>:just(S:0(Unit())), Maybe<S>:just(S:1(Unit())),
         Maybe<S>:just(S:2(Unit())), Maybe<S>:just(S:3(Unit())),
         Maybe<S>:just(S:4(Unit())), Maybe<S>:just(S:5(Unit())),
         Maybe<S>:just(S:6(Unit())), Maybe<S>:just(S:7(Unit())),
         Maybe<S>:just(S:8(Unit())), Maybe<S>:just(S:9(Unit())),
         Maybe<S>:just(S:10(Unit())), Maybe<S>:just(S:11(Unit())),
         Maybe<S>:just(S:12(Unit())), Maybe<S>:just(S:13(Unit())),
         Maybe<S>:just(S:14(Unit())), Maybe<S>:just(S:15(Unit())),
         Maybe<S>:just(S:16(Unit())), Maybe<S>:just(S:17(Unit())),
         Maybe<S>:just(S:18(Unit())), Maybe<S>:just(S:19(Unit())),
         Maybe<S>:just(S:20(Unit())), Maybe<S>:just(S:21(Unit())),
         Maybe<S>:just(S:22(Unit())));
  };

  func cls(Bit32 a, S s; Bit32) {
    Maybe<S> next = NextS(s);
    ?(next; cls(clshift(a), next.just), a);
  };

  func F(Bit32 x, Bit32 y, Bit32 z; Bit32) or(and(x, y), and(not(x), z));
  func G(Bit32 x, Bit32 y, Bit32 z; Bit32) or(and(x, z), and(y, not(z)));
  func H(Bit32 x, Bit32 y, Bit32 z; Bit32) xor(x, xor(y, z));
  func I(Bit32 x, Bit32 y, Bit32 z; Bit32) xor(y, or(x, not(z)));

  func FF(Bit32 a, Bit32 b, Bit32 c, Bit32 d, Bit32 x, S s, Bit32 t ; Bit32) {
    add(b, cls(add(add(a, F(b, c ,d)), add(x, t)), s));
  };

  func GG(Bit32 a, Bit32 b, Bit32 c, Bit32 d, Bit32 x, S s, Bit32 t ; Bit32) {
    add(b, cls(add(add(a, G(b, c ,d)), add(x, t)), s));
  };

  func HH(Bit32 a, Bit32 b, Bit32 c, Bit32 d, Bit32 x, S s, Bit32 t ; Bit32) {
    add(b, cls(add(add(a, H(b, c ,d)), add(x, t)), s));
  };

  func II(Bit32 a, Bit32 b, Bit32 c, Bit32 d, Bit32 x, S s, Bit32 t ; Bit32) {
    add(b, cls(add(add(a, I(b, c ,d)), add(x, t)), s));
  };

  func Round1(Bit32 a0, Bit32 b0, Bit32 c0, Bit32 d0, Block block; ABCD) {
    Bit32 a1 = FF(a0, b0, c0, d0, block.0, S:7(Unit()), t1());
    Bit32 d1 = FF(d0, a1, b0, c0, block.1, S:12(Unit()), t2());
    Bit32 c1 = FF(c0, d1, a1, b0, block.2, S:17(Unit()), t3());
    Bit32 b1 = FF(b0, c1, d1, a1, block.3, S:22(Unit()), t4());

    Bit32 a2 = FF(a1, b1, c1, d1, block.4, S:7(Unit()), t5());
    Bit32 d2 = FF(d1, a2, b1, c1, block.5, S:12(Unit()), t6());
    Bit32 c2 = FF(c1, d2, a2, b1, block.6, S:17(Unit()), t7());
    Bit32 b2 = FF(b1, c2, d2, a2, block.7, S:22(Unit()), t8());

    Bit32 a3 = FF(a2, b2, c2, d2, block.8, S:7(Unit()), t9());
    Bit32 d3 = FF(d2, a3, b2, c2, block.9, S:12(Unit()), t10());
    Bit32 c3 = FF(c2, d3, a3, b2, block.10, S:17(Unit()), t11());
    Bit32 b3 = FF(b2, c3, d3, a3, block.11, S:22(Unit()), t12());

    Bit32 a4 = FF(a3, b3, c3, d3, block.12, S:7(Unit()), t13());
    Bit32 d4 = FF(d3, a4, b3, c3, block.13, S:12(Unit()), t14());
    Bit32 c4 = FF(c3, d4, a4, b3, block.14, S:17(Unit()), t15());
    Bit32 b4 = FF(b3, c4, d4, a4, block.15, S:22(Unit()), t16());

    ABCD(a4, b4, c4, d4);
  };

  func Round2(Bit32 a0, Bit32 b0, Bit32 c0, Bit32 d0, Block block; ABCD) {
    Bit32 a1 = GG(a0, b0, c0, d0, block.1, S:5(Unit()), t17());
    Bit32 d1 = GG(d0, a1, b0, c0, block.6, S:9(Unit()), t18());
    Bit32 c1 = GG(c0, d1, a1, b0, block.11, S:14(Unit()), t19());
    Bit32 b1 = GG(b0, c1, d1, a1, block.0, S:20(Unit()), t20());

    Bit32 a2 = GG(a1, b1, c1, d1, block.5, S:5(Unit()), t21());
    Bit32 d2 = GG(d1, a2, b1, c1, block.10, S:9(Unit()), t22());
    Bit32 c2 = GG(c1, d2, a2, b1, block.15, S:14(Unit()), t23());
    Bit32 b2 = GG(b1, c2, d2, a2, block.4, S:20(Unit()), t24());

    Bit32 a3 = GG(a2, b2, c2, d2, block.9, S:5(Unit()), t25());
    Bit32 d3 = GG(d2, a3, b2, c2, block.14, S:9(Unit()), t26());
    Bit32 c3 = GG(c2, d3, a3, b2, block.3, S:14(Unit()), t27());
    Bit32 b3 = GG(b2, c3, d3, a3, block.8, S:20(Unit()), t28());

    Bit32 a4 = GG(a3, b3, c3, d3, block.13, S:5(Unit()), t29());
    Bit32 d4 = GG(d3, a4, b3, c3, block.2, S:9(Unit()), t30());
    Bit32 c4 = GG(c3, d4, a4, b3, block.7, S:14(Unit()), t31());
    Bit32 b4 = GG(b3, c4, d4, a4, block.12, S:20(Unit()), t32());

    ABCD(a4, b4, c4, d4);
  };

  func Round3(Bit32 a0, Bit32 b0, Bit32 c0, Bit32 d0, Block block; ABCD) {
    Bit32 a1 = HH(a0, b0, c0, d0, block.5, S:4(Unit()), t33());
    Bit32 d1 = HH(d0, a1, b0, c0, block.8, S:11(Unit()), t34());
    Bit32 c1 = HH(c0, d1, a1, b0, block.11, S:16(Unit()), t35());
    Bit32 b1 = HH(b0, c1, d1, a1, block.14, S:23(Unit()), t36());

    Bit32 a2 = HH(a1, b1, c1, d1, block.1, S:4(Unit()), t37());
    Bit32 d2 = HH(d1, a2, b1, c1, block.4, S:11(Unit()), t38());
    Bit32 c2 = HH(c1, d2, a2, b1, block.7, S:16(Unit()), t39());
    Bit32 b2 = HH(b1, c2, d2, a2, block.10, S:23(Unit()), t40());

    Bit32 a3 = HH(a2, b2, c2, d2, block.13, S:4(Unit()), t41());
    Bit32 d3 = HH(d2, a3, b2, c2, block.0, S:11(Unit()), t42());
    Bit32 c3 = HH(c2, d3, a3, b2, block.3, S:16(Unit()), t43());
    Bit32 b3 = HH(b2, c3, d3, a3, block.6, S:23(Unit()), t44());

    Bit32 a4 = HH(a3, b3, c3, d3, block.9, S:4(Unit()), t45());
    Bit32 d4 = HH(d3, a4, b3, c3, block.12, S:11(Unit()), t46());
    Bit32 c4 = HH(c3, d4, a4, b3, block.15, S:16(Unit()), t47());
    Bit32 b4 = HH(b3, c4, d4, a4, block.2, S:23(Unit()), t48());

    ABCD(a4, b4, c4, d4);
  };

  func Round4(Bit32 a0, Bit32 b0, Bit32 c0, Bit32 d0, Block block; ABCD) {
    Bit32 a1 = II(a0, b0, c0, d0, block.0, S:6(Unit()), t49());
    Bit32 d1 = II(d0, a1, b0, c0, block.7, S:10(Unit()), t50());
    Bit32 c1 = II(c0, d1, a1, b0, block.14, S:15(Unit()), t51());
    Bit32 b1 = II(b0, c1, d1, a1, block.5, S:21(Unit()), t52());

    Bit32 a2 = II(a1, b1, c1, d1, block.12, S:6(Unit()), t53());
    Bit32 d2 = II(d1, a2, b1, c1, block.3, S:10(Unit()), t54());
    Bit32 c2 = II(c1, d2, a2, b1, block.10, S:15(Unit()), t55());
    Bit32 b2 = II(b1, c2, d2, a2, block.1, S:21(Unit()), t56());

    Bit32 a3 = II(a2, b2, c2, d2, block.8, S:6(Unit()), t57());
    Bit32 d3 = II(d2, a3, b2, c2, block.15, S:10(Unit()), t58());
    Bit32 c3 = II(c2, d3, a3, b2, block.6, S:15(Unit()), t59());
    Bit32 b3 = II(b2, c3, d3, a3, block.13, S:21(Unit()), t60());

    Bit32 a4 = II(a3, b3, c3, d3, block.4, S:6(Unit()), t61());
    Bit32 d4 = II(d3, a4, b3, c3, block.11, S:10(Unit()), t62());
    Bit32 c4 = II(c3, d4, a4, b3, block.2, S:15(Unit()), t63());
    Bit32 b4 = II(b3, c4, d4, a4, block.9, S:21(Unit()), t64());

    ABCD(a4, b4, c4, d4);
  };

  func DoBlock(ABCD abcd, Block block; ABCD) {
    ABCD r1 = Round1(abcd.a, abcd.b, abcd.c, abcd.d, block);
    ABCD r2 = Round2(r1.a, r1.b, r1.c, r1.d, block);
    ABCD r3 = Round3(r2.a, r2.b, r2.c, r2.d, block);
    ABCD r4 = Round4(r3.a, r3.b, r3.c, r3.d, block);
    ABCD(add(abcd.a, r4.a), add(abcd.b, r4.b), add(abcd.c, r4.c), add(abcd.d, r4.d));
  };

  struct Streamed<T>(T data, Bool last);

  # Gets the next word from a pre-padded input
  proc GetWord(Streamed<Bit8>- padded; ; Streamed<Bit32>) {
    Streamed<Bit8> a = -padded();
    Streamed<Bit8> b = -padded();
    Streamed<Bit8> c = -padded();
    Streamed<Bit8> d = -padded();
    $(Streamed<Bit32>(Bit32(d.data, c.data, b.data, a.data), d.last));
  };

  # Gets the next block from a pre-padded input
  proc GetBlock(Streamed<Bit8>- padded; ; Streamed<Block>) {
    Streamed<Bit32> 0 = GetWord(padded;);
    Streamed<Bit32> 1 = GetWord(padded;);
    Streamed<Bit32> 2 = GetWord(padded;);
    Streamed<Bit32> 3 = GetWord(padded;);
    Streamed<Bit32> 4 = GetWord(padded;);
    Streamed<Bit32> 5 = GetWord(padded;);
    Streamed<Bit32> 6 = GetWord(padded;);
    Streamed<Bit32> 7 = GetWord(padded;);
    Streamed<Bit32> 8 = GetWord(padded;);
    Streamed<Bit32> 9 = GetWord(padded;);
    Streamed<Bit32> 10 = GetWord(padded;);
    Streamed<Bit32> 11 = GetWord(padded;);
    Streamed<Bit32> 12 = GetWord(padded;);
    Streamed<Bit32> 13 = GetWord(padded;);
    Streamed<Bit32> 14 = GetWord(padded;);
    Streamed<Bit32> 15 = GetWord(padded;);
    $(Streamed<Block>(
       Block(0.data, 1.data, 2.data, 3.data,
             4.data, 5.data, 6.data, 7.data,
             8.data, 9.data, 10.data, 11.data,
             12.data, 13.data, 14.data, 15.data),
       15.last));
  };

  # Computes the MD5 checksum of a pre-padded sequence of bytes.
  proc PaddedMd5(Streamed<Bit8>- padded; ABCD abcd; ABCD) {
    Streamed<Block> block = GetBlock(padded;);
    ABCD md5 = $(DoBlock(abcd, block.data));
    ?(block.last; $(md5), PaddedMd5(padded; md5));
  };

  # Note: length is in units of bytes
  proc Pad(Maybe<Bit8>- input, Streamed<Bit8>+ output; Bit64 length; Unit) {
    Maybe<Bit8> x = -input();
    ?(x; {
           Streamed<Bit8> _ = +output(Streamed<Bit8>(x.just, False()));
           Pad(input, output; Inc64(length));
         }, {
           Streamed<Bit8> _ = +output(Streamed<Bit8>(H2(8(), 0()), False()));
           PadZ(output; length, Inc64(length));
         });
  };

  func Inc64(Bit64 a; Bit64) {
    fulladd@BitN@Bit64M(a, zero@BitN@Bit64M(), Bit:1(Unit())).z;
  };

  func shl64(Bit64 a; Bit64) {
    lshift@BitN@Bit64M(a, Bit:0(Unit())).z;
  };

  func H2_64(Hex a, Hex b; Bit64) {
    Bit8 0 = H2(0(), 0());
    Bit64(0, 0, 0, 0, 0, 0, 0, H2(a, b));
  };

  # Add zeros as needed, then the final length to the output message.
  proc PadZ(Streamed<Bit8>+ output; Bit64 msglen, Bit64 length; Unit) {
    ?(iszero@BitN@Bit64M(
        and@BitN@Bit64M(H2_64(3(), f()),
                        add@BitN@Bit64M(H2_64(0(), 8()), length))); {
         Bit64 bits = $(shl64(shl64(shl64(msglen))));
         Streamed<Bit8> _0 = +output(Streamed<Bit8>(bits.0, False()));
         Streamed<Bit8> _1 = +output(Streamed<Bit8>(bits.1, False()));
         Streamed<Bit8> _2 = +output(Streamed<Bit8>(bits.2, False()));
         Streamed<Bit8> _3 = +output(Streamed<Bit8>(bits.3, False()));
         Streamed<Bit8> _4 = +output(Streamed<Bit8>(bits.4, False()));
         Streamed<Bit8> _5 = +output(Streamed<Bit8>(bits.5, False()));
         Streamed<Bit8> _6 = +output(Streamed<Bit8>(bits.6, False()));
         Streamed<Bit8> _7 = +output(Streamed<Bit8>(bits.7, True()));
         $(Unit());
       }, {
         Streamed<Bit8> _ = +output(Streamed<Bit8>(H2(0(), 0()), False()));
         PadZ(output; msglen, Inc64(length));
       });
  };

  func ABCD0( ; ABCD) ABCD(
      # Note: the spec lists these low-order byte first, but H8 takes high
      # order byte first.
      H8(6(), 7(), 4(), 5(), 2(), 3(), 0(), 1()),
      H8(e(), f(), c(), d(), a(), b(), 8(), 9()),
      H8(9(), 8(), b(), a(), d(), c(), f(), e()),
      H8(1(), 0(), 3(), 2(), 5(), 4(), 7(), 6()));

  proc Md5(Maybe<Bit8>- input; ; Md5Hash) {
    Streamed<Bit8> +- put_padded, get_padded;
    Unit _ = Pad(input, put_padded; zero@BitN@Bit64M()),
    ABCD md5 = PaddedMd5(get_padded; ABCD0());
    $(HexFromABCD(md5));
  };

  # Construct a Bit32 in hex, with high-order byte first.
  func H8(Hex 7, Hex 6, Hex 5, Hex 4, Hex 3, Hex 2, Hex 1, Hex 0; Bit32) {
    Bit32(H2(7, 6), H2(5, 4), H2(3, 2), H2(1, 0));
  };

  func t1( ; Bit32) H8(d(), 7(), 6(), a(), a(), 4(), 7(), 8());
  func t2( ; Bit32) H8(e(), 8(), c(), 7(), b(), 7(), 5(), 6());
  func t3( ; Bit32) H8(2(), 4(), 2(), 0(), 7(), 0(), d(), b());
  func t4( ; Bit32) H8(c(), 1(), b(), d(), c(), e(), e(), e());
  func t5( ; Bit32) H8(f(), 5(), 7(), c(), 0(), f(), a(), f());
  func t6( ; Bit32) H8(4(), 7(), 8(), 7(), c(), 6(), 2(), a());
  func t7( ; Bit32) H8(a(), 8(), 3(), 0(), 4(), 6(), 1(), 3());
  func t8( ; Bit32) H8(f(), d(), 4(), 6(), 9(), 5(), 0(), 1());
  func t9( ; Bit32) H8(6(), 9(), 8(), 0(), 9(), 8(), d(), 8());
  func t10( ; Bit32) H8(8(), b(), 4(), 4(), f(), 7(), a(), f());
  func t11( ; Bit32) H8(f(), f(), f(), f(), 5(), b(), b(), 1());
  func t12( ; Bit32) H8(8(), 9(), 5(), c(), d(), 7(), b(), e());
  func t13( ; Bit32) H8(6(), b(), 9(), 0(), 1(), 1(), 2(), 2());
  func t14( ; Bit32) H8(f(), d(), 9(), 8(), 7(), 1(), 9(), 3());
  func t15( ; Bit32) H8(a(), 6(), 7(), 9(), 4(), 3(), 8(), e());
  func t16( ; Bit32) H8(4(), 9(), b(), 4(), 0(), 8(), 2(), 1());
  func t17( ; Bit32) H8(f(), 6(), 1(), e(), 2(), 5(), 6(), 2());
  func t18( ; Bit32) H8(c(), 0(), 4(), 0(), b(), 3(), 4(), 0());
  func t19( ; Bit32) H8(2(), 6(), 5(), e(), 5(), a(), 5(), 1());
  func t20( ; Bit32) H8(e(), 9(), b(), 6(), c(), 7(), a(), a());
  func t21( ; Bit32) H8(d(), 6(), 2(), f(), 1(), 0(), 5(), d());
  func t22( ; Bit32) H8(0(), 2(), 4(), 4(), 1(), 4(), 5(), 3());
  func t23( ; Bit32) H8(d(), 8(), a(), 1(), e(), 6(), 8(), 1());
  func t24( ; Bit32) H8(e(), 7(), d(), 3(), f(), b(), c(), 8());
  func t25( ; Bit32) H8(2(), 1(), e(), 1(), c(), d(), e(), 6());
  func t26( ; Bit32) H8(c(), 3(), 3(), 7(), 0(), 7(), d(), 6());
  func t27( ; Bit32) H8(f(), 4(), d(), 5(), 0(), d(), 8(), 7());
  func t28( ; Bit32) H8(4(), 5(), 5(), a(), 1(), 4(), e(), d());
  func t29( ; Bit32) H8(a(), 9(), e(), 3(), e(), 9(), 0(), 5());
  func t30( ; Bit32) H8(f(), c(), e(), f(), a(), 3(), f(), 8());
  func t31( ; Bit32) H8(6(), 7(), 6(), f(), 0(), 2(), d(), 9());
  func t32( ; Bit32) H8(8(), d(), 2(), a(), 4(), c(), 8(), a());
  func t33( ; Bit32) H8(f(), f(), f(), a(), 3(), 9(), 4(), 2());
  func t34( ; Bit32) H8(8(), 7(), 7(), 1(), f(), 6(), 8(), 1());
  func t35( ; Bit32) H8(6(), d(), 9(), d(), 6(), 1(), 2(), 2());
  func t36( ; Bit32) H8(f(), d(), e(), 5(), 3(), 8(), 0(), c());
  func t37( ; Bit32) H8(a(), 4(), b(), e(), e(), a(), 4(), 4());
  func t38( ; Bit32) H8(4(), b(), d(), e(), c(), f(), a(), 9());
  func t39( ; Bit32) H8(f(), 6(), b(), b(), 4(), b(), 6(), 0());
  func t40( ; Bit32) H8(b(), e(), b(), f(), b(), c(), 7(), 0());
  func t41( ; Bit32) H8(2(), 8(), 9(), b(), 7(), e(), c(), 6());
  func t42( ; Bit32) H8(e(), a(), a(), 1(), 2(), 7(), f(), a());
  func t43( ; Bit32) H8(d(), 4(), e(), f(), 3(), 0(), 8(), 5());
  func t44( ; Bit32) H8(0(), 4(), 8(), 8(), 1(), d(), 0(), 5());
  func t45( ; Bit32) H8(d(), 9(), d(), 4(), d(), 0(), 3(), 9());
  func t46( ; Bit32) H8(e(), 6(), d(), b(), 9(), 9(), e(), 5());
  func t47( ; Bit32) H8(1(), f(), a(), 2(), 7(), c(), f(), 8());
  func t48( ; Bit32) H8(c(), 4(), a(), c(), 5(), 6(), 6(), 5());
  func t49( ; Bit32) H8(f(), 4(), 2(), 9(), 2(), 2(), 4(), 4());
  func t50( ; Bit32) H8(4(), 3(), 2(), a(), f(), f(), 9(), 7());
  func t51( ; Bit32) H8(a(), b(), 9(), 4(), 2(), 3(), a(), 7());
  func t52( ; Bit32) H8(f(), c(), 9(), 3(), a(), 0(), 3(), 9());
  func t53( ; Bit32) H8(6(), 5(), 5(), b(), 5(), 9(), c(), 3());
  func t54( ; Bit32) H8(8(), f(), 0(), c(), c(), c(), 9(), 2());
  func t55( ; Bit32) H8(f(), f(), e(), f(), f(), 4(), 7(), d());
  func t56( ; Bit32) H8(8(), 5(), 8(), 4(), 5(), d(), d(), 1());
  func t57( ; Bit32) H8(6(), f(), a(), 8(), 7(), e(), 4(), f());
  func t58( ; Bit32) H8(f(), e(), 2(), c(), e(), 6(), e(), 0());
  func t59( ; Bit32) H8(a(), 3(), 0(), 1(), 4(), 3(), 1(), 4());
  func t60( ; Bit32) H8(4(), e(), 0(), 8(), 1(), 1(), a(), 1());
  func t61( ; Bit32) H8(f(), 7(), 5(), 3(), 7(), e(), 8(), 2());
  func t62( ; Bit32) H8(b(), d(), 3(), a(), f(), 2(), 3(), 5());
  func t63( ; Bit32) H8(2(), a(), d(), 7(), d(), 2(), b(), b());
  func t64( ; Bit32) H8(e(), b(), 8(), 6(), d(), 3(), 9(), 1());

  func HexFromBits(Bit 3, Bit 2, Bit 1, Bit 0; Hex) {
    ?(3; ?(2; ?(1; ?(0; 0(), 1()), ?(0; 2(), 3())),
              ?(1; ?(0; 4(), 5()), ?(0; 6(), 7()))),
         ?(2; ?(1; ?(0; 8(), 9()), ?(0; a(), b())),
              ?(1; ?(0; c(), d()), ?(0; e(), f()))));
  };

  struct HexPair(Hex hi, Hex lo);

  func HexFromByte(Bit8 byte; HexPair) {
    HexPair(HexFromBits(byte.7, byte.6, byte.5, byte.4),
            HexFromBits(byte.3, byte.2, byte.1, byte.0));
  };

  func HexFromABCD(ABCD x; Md5Hash) {
    HexPair a0 = HexFromByte(x.a.0); HexPair a1 = HexFromByte(x.a.1);
    HexPair a2 = HexFromByte(x.a.2); HexPair a3 = HexFromByte(x.a.3);
    HexPair b0 = HexFromByte(x.b.0); HexPair b1 = HexFromByte(x.b.1);
    HexPair b2 = HexFromByte(x.b.2); HexPair b3 = HexFromByte(x.b.3);
    HexPair c0 = HexFromByte(x.c.0); HexPair c1 = HexFromByte(x.c.1);
    HexPair c2 = HexFromByte(x.c.2); HexPair c3 = HexFromByte(x.c.3);
    HexPair d0 = HexFromByte(x.d.0); HexPair d1 = HexFromByte(x.d.1);
    HexPair d2 = HexFromByte(x.d.2); HexPair d3 = HexFromByte(x.d.3);
    Md5Hash(a0.hi, a0.lo, a1.hi, a1.lo, a2.hi, a2.lo, a3.hi, a3.lo,
            b0.hi, b0.lo, b1.hi, b1.lo, b2.hi, b2.lo, b3.hi, b3.lo,
            c0.hi, c0.lo, c1.hi, c1.lo, c2.hi, c2.lo, c3.hi, c3.lo,
            d0.hi, d0.lo, d1.hi, d1.lo, d2.hi, d2.lo, d3.hi, d3.lo);
  };

  func EqHex(Hex a, Hex b; Bool) {
    eq@BitN@Bit8M(H2(0(), a), H2(0(), b));
  };

  func Eq(Md5Hash a, Md5Hash b; Bool) {
    And(And(And(And(And(EqHex(a.0, b.0), EqHex(a.1, b.1)),
                    And(EqHex(a.2, b.2), EqHex(a.3, b.3))),
                And(And(EqHex(a.4, b.4), EqHex(a.5, b.5)),
                    And(EqHex(a.6, b.6), EqHex(a.7, b.7)))),
            And(And(And(EqHex(a.8, b.8), EqHex(a.9, b.9)),
                    And(EqHex(a.10, b.10), EqHex(a.11, b.11))),
                And(And(EqHex(a.12, b.12), EqHex(a.13, b.13)),
                    And(EqHex(a.14, b.14), EqHex(a.15, b.15))))),
        And(And(And(And(EqHex(a.16, b.16), EqHex(a.17, b.17)),
                    And(EqHex(a.18, b.18), EqHex(a.19, b.19))),
                And(And(EqHex(a.20, b.20), EqHex(a.21, b.21)),
                    And(EqHex(a.22, b.22), EqHex(a.23, b.23)))),
            And(And(And(EqHex(a.24, b.24), EqHex(a.25, b.25)),
                    And(EqHex(a.26, b.26), EqHex(a.27, b.27))),
                And(And(EqHex(a.28, b.28), EqHex(a.29, b.29)),
                    And(EqHex(a.30, b.30), EqHex(a.31, b.31))))));
  };
};
