<@>@ List@ = /Core/List%.List@;

<<@>@>@ Monad@ = /Core/Monad%.Monad@;

@ Unit@ = /Core/Unit%.Unit@;
% Unit = /Core/Unit%.Unit;

@ Command@ = /Fbld/Command%.Command@;

@ StringL@ = /Fbld/StringL%.StringL@;

<@>@ Result@ = /Fbld/Result%.Result@;
<@>% Ok = /Fbld/Result%.Ok;
<@>% Err = /Fbld/Result%.Err;


<<@>@ M@>(Monad@<M@> m) {
  @ Invoke@ = /Fbld/Invoke%<M@>.Invoke@;

  % ResultM = /Fbld/ResultM%<M@>;
  <@>@ MR@ = ResultM.MR@;
  Monad@<MR@> mr = ResultM.Monad(m);

  # Interprets and executes inline structured text.
  (Invoke@, Invoke@, StringL@) { MR@<Unit@>; }
  Inline = (Invoke@ inline, Invoke@ block, StringL@ text) {
    Result@<List@<Command@>> parsed = /Fbld/Parse%.Inline(text);
    parsed.?(err: m.return(Err<Unit@>(parsed.err)));

    /Core/List%.ForEach(parsed.ok, m.return(Ok(Unit)),
      (Command@ cmd, MR@<Unit@> mx) {
        Unit@ _ <- mr.do(mx);
        inline(inline, block, cmd);
      });
  };

  # Interprets and executes block structured text.
  (Invoke@, Invoke@, StringL@) { MR@<Unit@>; }
  Block = (Invoke@ inline, Invoke@ block, StringL@ text) {
    Result@<List@<Command@>> parsed = /Fbld/Parse%.Block(text);
    parsed.?(err: m.return(Err<Unit@>(parsed.err)));

    /Core/List%.ForEach(parsed.ok, m.return(Ok(Unit)),
      (Command@ cmd, MR@<Unit@> mx) {
        Unit@ _ <- mr.do(mx);
        block(inline, block, cmd);
      });
  };

  @(Inline, Block);
};
