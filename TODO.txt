
* Clean up how we track io activity?

* Allow zero-argument functions in the language spec?

* [profile] Remove special block 0
 - Add block data at the profile level representing 'total' and special case
   that way instead. So that literally it is impossible for anyone to call
   into the root block except via new profile thread.

* [profile] Separate from main eval
 - Switch to convention that caller is responsible for enter block.
 - Replace AutoExitBlock with ReplaceBlock.

* [type] Inline fields and args data into FbleType objects?
* [gc] Implement generational gc?

* [test] Check if 6.4-proc-exec/eval/propagate-abort-blocking test fails when
  unused 'true' variable definition is removed.

* [eval] Thread management cleanup
 - Use fair thread traversal by starting over from root when yield occurs.

* [invaders] Implement space invaders game.
 - Add single alien to the game.
 - Figure out how they know when to move forward as a group.

* [compile] Figure out why Normal is called so often
 - See if we can fix that to reduce the now annoyingly long compile times.
 - Profiling said its all in TypeEquals. Maybe something pathological?

* [lang] Set up cindent properly for fble.vim
 - For example, so you can do newline in a comment block and have it auto add
   the comment character.

* [compile] Optimization: Avoid REF_INSTR if we aren't going to ever use it.
 - Maybe have a way to list free vars in an expression and use that to compute
   'recursive' ahead of time? Not sure.
 - gcov suggests we'll save on the order of 4 million instructions and 4
   million allocations in fble bench. Surely that's good for something.

* [cc] Implement .fble -> .o compiler
 - Goal is to significantly increase performance by removing the instruction
   fetch decode logic.

* [snake] Switch to a target 60 FPS?
* [snake] Test and fix bug when snake eats its tail.
* [snake] Ignore moves that aren't orthogonal to current snake direction.
* [snake] Keep track of and report score.
* [snake] Figure out why the background box gets lost some times.
* [pingpong] Render a static 3D table tennis scene.
* [gameoflife] Switch to a target 60 FPS?
* [invaders] Optimize space invaders game.
 - Figure out how I'm going to get to 60 FPS.
   Maybe try getting 60 FPS on the C implementation to see if it's reasonable?
 - Implement and test Alien simulation

* [lib] Add test coverage for the Int routines.
 - In particular, test Div and Mod.
* [lib] Separate Map from DataMap and EqMap.
* [lib] Add unit tests for /Map%.Equals.
* [lib] Separate List@ from S@ and P@ module wise.

* [api] Can fble-stdio check that the function has the right type?

* [compile] Consider tracking memory for proper cleanup?
  I wonder how much of what we allocate ends up unused. If we could track and
  clean up allocations when we are done with them, maybe we can save some
  memory.

* [compile] Is there a way to clean up compile.c, in terms of orders of setting fields
  of instructions vs scopes vs locals? It all seems very confused to me.

* [compile] Test and fix error message for type of anonymous type let values.
 - The type should be the computed type for the value, not the introduced
   abstract type?

* [eval] Make child thread execution fair.
  Children should be time multiplexed, where priority is assigned based on how
  far down the family tree the child belongs. The amount of time a family gets
  to spend evaluating should be independent of the number of children in the
  family.

* [lang] Can a module reference itself? Clarify in the spec and test this case.
* [lang] Add support for abstract types?
* [lang] Document the runtime memory model,
  - Including that tail recursive functions should not smash the stack.
* [lang] Document and test that put ports don't retain link values.

* [release] Better error messages on types that have the same name but different values?
* [release] Write man pages for fble and friends?
* [release] Better error message for importing something from a module that
  is not defined in the module?

* [arena] Rethink arenas and documentation, because some cases appear to assume you
  have a bulk-free arena. Other cases its not well specified what is freed
  explicitly and what is expected to be freed implicitly.
  I claim a good model is: pass an arena to a function to say: the function
  allocates its result in this arena. The function creates and uses a separate
  arena for its intermediate allocations.

* [debugger] Implement an fble debugger. Features:
 - Set a breakpoint at a line in a file.
 - Step through code line by line.
 - Evaluate expressions in the context of the current scope and print the
   results.
 - Auto breakpoint at undefined behavior?
 
 Use cases:
 - Debug why sudoku solver isn't working properly by stepping through a line
   at a time and printing intermediate values.

   Turns out it wasn't too hard to figure out the problem in this case without
   a debugger.

 - Debug why snake AI wasn't working.

   It turns out we were using the wrong direction. A debugger to step through
   code and print variable values would have found this more quickly than my
   guess and check approach, which was pretty tedious.

