Functions Revised
-----------------
Goals: Naturally support partial application of functions.

In particular, the following functions should have the same type:

 \x, y -> { f(x,y) }
 \x -> { \y -> { f(x,y) }}

Proposal for syntax that makes it easy to do multi-arg functions:

Abstract Syntax:
  Type ::= func_type (arg :: Type) (result :: Type)
  Expr ::= func_value (arg :: (Type, Name)) (body :: Expr)
  Expr ::= apply (func :: Expr) (arg :: Expr)

Concrete Syntax:
  type ::= '[' type ']' type
  expr ::= '[' type name ']' expr
  expr ::= expr '[' expr ']'

Examples:
  [Int@][Int@]Bool@ lt = [Int@ a][Int@ b] {
    a < b;    # or whatever logic you would use here.
  }

  lt[3][4] is true.

Note that lt[3] would have type [Int@]Bool@. So partial application is fairly
natural.

Easy!

Trouble: ambiguity with the process types:

  [A@]B@!

Is this: ([A@]B@)!   or [A@](B@!)   ?

Otherwise, I really like the syntax actually. I think it's certainly an
improvement over what we have today. Nicer concrete syntax, and much simpler
abstract syntax.

How to avoid that ambiguity though?

Put the process types at the beginning I guess:

 ![A@]B@   versus  [A@]!B@

Works perfectly! Yay! And I think that makes more sense anyway.

Uh oh. Other ambiguity:

[A@]B@<C@>   is  ([A@]B@)<C@>  or [A@](B@<C@>)?

Looks like I'll want to rethink the entire type syntax from bottom up.
Or, if we are using the suffix based approach for everything... No. I like a
prefix approach for everything. It makes sense. Just will have to work out
details.

Perhaps we say you can only use the <...> type application on type names or
type poly. Because in the above, [A@]B@ is a function type, meaning it can't
be a poly. So poly type is a slightly higher level syntax, and you have:

poly ::= type_name
      | poly '<' ... '>'
      ;

type ::= poly
      | ...
      ;

I think that fixes the ambiguity and is still sane.

