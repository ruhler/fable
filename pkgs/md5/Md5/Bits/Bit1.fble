
@ Bool@ = /Core/Bool%.Bool@;
% True = /Core/Bool%.True;
% False = /Core/Bool%.False;

@ Bit@ = /Core/Digits%.Bit@;
<@>@ Bits@ = /Md5/Bits/Bits%.Bits@;

Bit@ 0 = /Core/Digits%.Bit.0;
Bit@ 1 = /Core/Digits%.Bit.1;

@ Bit1@ = Bit@;
@ Result@ = *(Bit@ z, Bit@ cout);

(Bit1@) { Bit1@; } not = (Bit1@ a) {
  a.?(0: 1, 1: 0);
};

(Bit1@, Bit1@) { Bit1@; } and = (Bit1@ a, Bit1@ b) {
  a.?(0: a, 1: b);
};

(Bit1@, Bit1@) { Bit1@; } or = (Bit1@ a, Bit1@ b) {
  a.?(0: b, 1: a);
};

(Bit1@, Bit1@) { Bit1@; } xor = (Bit1@ a, Bit1@ b) {
  a.?(0: b, 1: not(b));
};

(Bit1@, Bit1@, Bit1@) { Result@; } fulladd = (Bit1@ a, Bit1@ b, Bit1@ c) {
  Bit1@ x = xor(a, b);
  Result@(xor(x, c), x.?(0: a, 1: c));
};

(Bit1@, Bit1@) { Bit1@; } add = (Bit1@ a, Bit1@ b) {
  fulladd(a, b, 0).z;
};

(Bit1@) { Result@; } fullinc = (Bit1@ a) {
  Result@(not(a), a);
};

(Bit1@) { Bit1@; } inc = (Bit1@ a) {
  fullinc(a).z;
};

Bit1@ zero = 0;

(Bit1@) { Bool@; } iszero = (Bit1@ a) {
  a.?(0: True, 1: False);
};

(Bit1@, Bit1@) { Bool@; } eq = (Bit1@ a, Bit1@ b) {
  a.?(0: b.?(0: True,  1: False),
      1: b.?(0: False, 1: True));
};

(Bit1@) { Bit1@; } msb = (Bit1@ a) {
  a;
};

(Bit1@, Bit1@) { Result@; } lshift = (Bit1@ a, Bit@ cin) {
  Result@(cin, a);
};

Bits@<Bit1@> Bits = @(
  Result@,
  not, and, or, xor,
  add, inc,
  zero, iszero, eq,
  msb,
  fulladd, fullinc, lshift
);

@(Bit1@, Bits);
