
@ Bit@ = /Digits%.Bit@;
@ Hex@ = /Digits%.Hex@;
% HexToBits = /Digits/String%.HexToBits;

@ Int@ = /Int/Int%.Int@;

<@>@ List@ = /List%.List@;
<@>% Nil = /List%.Nil;

@ Unit@ = /Unit%.Unit@;
% Unit = /Unit%.Unit;

# Bits@ --
#   A sequence of bits.
@ Bits@ = List@<Bit@>;

# Addr@ --
#   A reference to a bit on the bit heap.
@ Addr@ = Int@;

# Value@ --
#   A value that is specified as either a reference to a sequence of bits on
#   the heap or a literal sequence of bits.
@ Value@ = +(Addr@ ref, Bits@ const);

(Addr@) { Value@; } Ref = (Addr@ x) {
  Value@(ref: x);
};

# Const --
#   A constant value.
#
# Example Use:
#   Value@ v = Const(Bit|01110001);
(List@<Bit@>) { Value@; } Const = (List@<Bit@> bits) {
  Value@(const: bits);
};

# ConstHex --
#   A constant value from Hex.
#
# Example Use:
#   Value@ v = Const(Bit|A71);
(List@<Hex@>) { Value@; } ConstHex = (List@<Hex@> l) {
  Const(HexToBits(l));
};

# ConditionOp@ --
#   A conditional operator.
#
# Fields:
#   eq - The condition is satisfied if the arguments are equal.
#   ne - The condition is satisfied if the arguments are not equal.
@ ConditionOp@ = +(Unit@ eq, Unit@ ne);

# Condition@ --
#   A conditional expression: a == b or a != b
#
# Fields:
#   op - The operation to use.
#   a - The first operand.
#   b - The second operand.
#   n - The number of bits to compare.
@ Condition@ = *(ConditionOp@ op, Value@ a, Value@ b, Int@ n);

(Value@, Value@, Int@) { Condition@; } Eq = (Value@ a, Value@ b, Int@ n) {
  Condition@(ConditionOp@(eq: Unit), a, b, n);
};

(Value@, Value@, Int@) { Condition@; } Ne = (Value@ a, Value@ b, Int@ n) {
  Condition@(ConditionOp@(ne: Unit), a, b, n);
};

# Assign@ --
#   Set the contents of ref to the given value.
#
# If value is a reference, behavior is undefined of the sequences of bits of
# the ref and value are overlapping.
#
# Fields:
#   ref - Reference to the sequence of bits to be assigned to.
#   value - The value of the bits to set.
#   n - The number of bits to be assigned.
@ Assign@ = *(Addr@ ref, Value@ value, Int@ n);

# Sequence@ -- 
#   Executes a sequence of zero or more programs in order.
@ Sequence@ = List@<Program@>,

# IfElse@ --
#   Executes the if_body if the condition is satisfied, the else_body
#   otherwise.
@ IfElse@ = *(Condition@ condition, Program@ if_body, Program@ else_body),

# While@ --
#   Executes the body repeatedly for as long as the condition is satisfied.
@ While@ = *(Condition@ condition, Program@ body),

# Program@ --
#   A program that performs computation on the bit heap.
@ Program@ = +(
  Assign@ assign,
  Sequence@ sequence,
  IfElse@ ifelse,
  While@ while
);

(Addr@, Value@, Int@) { Program@; } Assign = (Addr@ x, Value@ v, Int@ n) {
  Program@(assign: Assign@(x, v, n));
};

(Condition@, Program@, Program@) { Program@; }
IfElse = (Condition@ p, Program@ if_body, Program@ else_body) {
  Program@(ifelse: IfElse@(p, if_body, else_body));
};

(List@<Program@>) { Program@; } Seq = (List@<Program@> prgms) {
  Program@(sequence: prgms);
};

Program@ Noop = Program@(sequence: Nil<Program@>);

(Condition@, Program@) { Program@; } If = (Condition@ p, Program@ body) {
  IfElse(p, body, Noop);
};

(Condition@, Program@) { Program@; } While = (Condition@ p, Program@ body) {
  Program@(while: While@(p, body));
};

@(
  Bit@, Bits@, Addr@, Value@, ConditionOp@, Condition@,
  Assign@, Sequence@, IfElse@, While@, Program@,
  Const, ConstHex, Ref, Eq, Ne, Assign, If, IfElse, Seq, Noop, While
);
