
@ App@ = /App%.App@;
@ AppIO@ = /App%.AppIO@;
@ Event@ = /App%.Event@;
@ Effect@ = /App%.Effect@;

@ Drawing@ = /Drawing%.Drawing@;
@ Point@ = /Drawing%.Point@;
% Blank = /Drawing%.Blank;
% Color = /Drawing%.Color;
% Over = /Drawing%.Over;
% Rect = /Drawing%.Rect;
% Affine = /Drawing%.Affine;
% Drawings = /Drawing%.Drawings;
% Translate = /Drawing%.Translate;

% Circle = /Graphics/2D/Circle%.Circle;
% Triangle = /Graphics/2D/Triangle%.Triangle;

@ Int@ = /Int%.Int@;

<@>% List = /List%.List;

<@>@ Get@ = /Process%.Get@;
<@>@ Put@ = /Process%.Put@;


@ Unit@ = /Unit%.Unit@;
% Unit = /Unit%.Unit;

@ Num@ = /Pinball/Num%.Num@;
% Floor = /Pinball/Num%.Floor;
% Neg = /Pinball/Num%.Neg;
% Div = /Pinball/Num%.Div;
% Int = /Pinball/Num%.Int;

@ Ball@ = /Pinball/Physics%.Ball@;
@ Edge@ = /Pinball/Physics%.Edge@;
@ Paddle@ = /Pinball/Physics%.Paddle@;
@ Vec@ = /Pinball/Physics%.Vec@;
@ World@ = /Pinball/Physics%.World@;
% AddV = /Pinball/Physics%.AddV;
% SubV = /Pinball/Physics%.SubV;
% MulVS = /Pinball/Physics%.MulVS;
% Tick = /Pinball/Physics%.Tick;

(Vec@) { Point@; } Point = (Vec@ a) {
  Point@(Floor(a.x), Floor(a.y));
};

# Radius --
#   The radius of the ball.
Num@ Radius = Int|8;

Num@ PaddleVelocity = Div(Int|1, Int|4);

World@ Initial = World@(
  Vec@(Int|0, Neg(Div(Int|1, Int|8))),
  Ball@(Vec@(Int|0, Int|100), Vec@(Int|1, Int|0), Radius),
  List<Edge@>[
    # Floor
    Edge@(Vec@(Int|0, Int|1),
          Vec@(Neg(Int|16), Neg(Int|104)),
          Int|32),

    # Slopes
    Edge@(Vec@(Neg(Div(Int|3, Int|5)), Div(Int|4, Int|5)),
          Vec@(Int|16, Neg(Int|104)),
          Int|160),
    Edge@(Vec@(Div(Int|3, Int|5), Div(Int|4, Int|5)),
          Vec@(Neg(Int|144), Neg(Int|8)),
          Int|80),

    # Side walls
    Edge@(Vec@(Int|1, Int|0),
          Vec@(Neg(Int|144), Int|104),
          Int|112),
    Edge@(Vec@(Neg(Int|1), Int|0),
          Vec@(Int|144, Neg(Int|8)),
          Int|112),

    # Ceiling
    Edge@(Vec@(Int|0, Neg(Int|1)),
          Vec@(Int|144, Int|104),
          Int|288)
  ],
  List<Paddle@>[
    # Left Paddle.
    Paddle@(
      Vec@(Neg(Int|16), Neg(Int|104)),
      Vec@(Neg(Int|16), Neg(Int|8)),
      Int|0,
      Neg(PaddleVelocity),
      Edge@(Vec@(Div(Int|3, Int|5), Div(Int|4, Int|5)),
          Vec@(Neg(Int|80), Neg(Int|56)),
          Int|80))
  ]);

(Edge@) { Drawing@; } DrawEdge = (Edge@ edge) {
  Vec@ s = SubV(edge.start, MulVS(edge.normal, Int|2));

  Point@ a = Point(edge.start);
  Point@ b = Point(s);
  Vec@ tangent = Vec@(edge.normal.y, Neg(edge.normal.x));
  Point@ c = Point(AddV(edge.start, MulVS(tangent, edge.length)));
  Point@ d = Point(AddV(s, MulVS(tangent, edge.length)));
  Drawings[
    Triangle(a, b, c, Color.Green),
    Triangle(c, b, d, Color.Green)
  ];
};

Drawing@ Background = {
  /List%.ForEach<Edge@, Drawing@>(Initial.edges, Blank, (Edge@ e, Drawing@ d) {
    Over(d, DrawEdge(e));
  });
};

Drawing@ DrawnBall = Circle(Point@(Floor(Int|0), Floor(Int|0)), Floor(Radius), Color.Cyan);

(World@) { Drawing@; } Draw = (World@ world) {
  Point@ ball = Point(world.ball.pos);
  /List%.ForEach<Paddle@, Drawing@>(
    world.paddles,
    Over(Background, Translate(ball.x, ball.y, DrawnBall)),
    (Paddle@ paddle, Drawing@ d) {
      Over(d, DrawEdge(paddle.edge));
    });
};

(Num@, World@) { World@; } SetPaddleVelocity = (Num@ v, World@ w) {
  Paddle@ p = w.paddles.cons.head;
  World@(w.gravity, w.ball, w.edges, 
    List<Paddle@>[Paddle@(p.end_down, p.end_up, p.pos, v, p.edge)]);
};

(Get@<Event@>, Put@<World@>, Unit@!, World@) { Unit@!; }
Run = (Get@<Event@> in, Put@<World@> draw, Unit@! tick, World@ world) {
  Event@ e := in;

  e.?(tick: {
    Unit@ _ := tick;
    Unit@ _ := draw(world);
    Run(in, draw, tick, Tick(world));
  });

  e.?(key_down: {
    e.key_down.?(q: !(Unit));
    e.key_down.?(s: {
      Run(in, draw, tick, Initial);
    });
    e.key_down.?(space: {
      Run(in, draw, tick, SetPaddleVelocity(PaddleVelocity, world));
    });
    Run(in, draw, tick, world);
  });

  e.?(key_up: {
    e.key_up.?(space: {
      Run(in, draw, tick, SetPaddleVelocity(Neg(PaddleVelocity), world));
    });
    Run(in, draw, tick, world);
  });

  Run(in, draw, tick, world);
};

App@ Main = (AppIO@ app) {
  Point@ a = @(x: Floor(Int|1), y: Floor(Neg(Int|1)));
  Point@ b = @(x: Floor(Int|320), y: Floor(Int|240));
  Int@ frame_period = Floor(Int|16);
  Unit@! tick = app.effect(Effect@(tick: frame_period));

  (World@) { Unit@!; } draw = (World@ s) {
    app.effect(Effect@(draw: Over(
      Rect(Floor(Int|0), Floor(Int|0), app.width, app.height, Color.Black),
      Affine(a, b, Draw(s)))));
  };

  Unit@ _ := app.effect(Effect@(tick: Floor(Int|0)));
  Run(app.event, draw, tick, Initial); 
};

Main;

