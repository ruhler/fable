% True = /Bool%.True;

% Chars = /Char%.Chars;

% EqIntP = /Int/IntP/Eq%.Eq;
% 1 = /Int/IntP%.1;

<@>% S = /List%.S;

<@>@ Maybe@ = /Maybe%.Maybe@;

% Str = /String%.Str;

@ Test@ = /Test%.Test@;
@ TestResult@ = /Test%.TestResult@;
@ TestSuite@ = /Test%.TestSuite@;
% TestSuite = /Test%.TestSuite;

% Unit = /Unit%.Unit;

@ Formula@ = /Sat%.Formula@;
@ Clause@ = /Sat%.Clause@;
@ Var@ = /Sat%.Var@;
@ Assignment@ = /Sat%.Assignment@;
% Solve = /Sat%.Solve;

TestSuite@ Tests = TestSuite(Chars|Sat, [
  Test@(Str(Chars|x), !({
    Formula@ f = S<Clause@>([S<Var@>([Var@(1, True)])]);
    Maybe@<Assignment@> solved = Solve(f);
    # TODO: Use an equality assertion to confirm the result is as expected,
    # with pretty printing to report the actual result if it doesn't match.
    solved.?(
      just: {
        solved.just.?(
          cons: {
            solved.just.cons.tail.?(
              cons: TestResult@(fail: Str(Chars|'too many vars in assignment')),
              nil: {
                EqIntP(solved.just.cons.head.id, 1).?(
                  true: solved.just.cons.head.polarity.?(
                    true: TestResult@(pass: Unit),
                    false: TestResult@(fail: Str(Chars|'bad assignment'))),
                  false: TestResult@(fail: Str(Chars|'wrong var id')));
              });
          },
          nil: TestResult@(fail: Str(Chars|'empty assignment')));
      },
      nothing: TestResult@(fail: Str(Chars|'failed to find assignment')));
  }))
]);

@(Tests);
