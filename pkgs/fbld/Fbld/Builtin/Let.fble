
@ Int@ = /Core/Int%.Int@;
% Int = /Core/Int/Lit%.Int;
% Div = /Core/Int/Div%.Div;

<@>@ List@ = /Core/List%.List@;
<@>% Length = /Core/List/Length%.Length;

@ String@ = /Core/String%.String@;
% Str = /Core/String%.Str;
% Strs = /Core/String%.Strs;

@ Command@ = /Fbld/Command%.Command@;

<@>@ Fbld@ = /Fbld/Fbld%.Fbld@;
<@>% Do = /Fbld/Fbld%.Do;
<@>% Error = /Fbld/Fbld%.Error;

@ Markup@ = /Fbld/Markup%.Markup@;
% Entries = /Fbld/Markup%.Entries;
% Entry = /Fbld/Markup%.Entry;

% Run = /Fbld/Run%;

@ Map@ = /Fbld/Subst%.Map@;
% Subst = /Fbld/Subst%.Subst;
% Insert = /Fbld/Subst%.Insert;
% Empty = /Fbld/Subst%.Empty;

@ Text@ = /Fbld/Text%.Text@;
% StringOf = /Fbld/Text%.StringOf;
% LocOf = /Fbld/Text%.LocOf;

(List@<Text@>, Map@) { Fbld@<Text@>; }
Let = (List@<Text@> args, Map@ map) {
  args.cons.tail.?(nil: {
    # This is the last argument: the body. Do the final substitution into the
    # body.
    Run.Block(Subst(map, args.cons.head));
  });

  String@ key = StringOf(args.cons.head);
  Text@ value = args.cons.tail.cons.head;
  List@<Text@> tail = args.cons.tail.cons.tail;
  Text@ evaluated <- Do(Run.Block(Subst(map, value)));
  Let(tail, Insert(map, key, evaluated));
};

Markup@ Markup = Entries[
  # @let[k1][v1][k2][v2]...[kN][vN][body]
  #  Evaluates values v1 through vN as block structured text. Assigns the
  #  results to variable names k1 through kN which are substituted into the v2
  #  through vN and the body using $ syntax before evaluting v2 through vN and
  #  the body as block structured text.
  #
  #  Bindings are evaluated and substituted in sequential order. The value vi
  #  has access to variable definitions for kj where j < i.
  Entry(Str|'let', (Command@ cmd) {
    Int@ num_args = Length(cmd.args);
    /Core/Int/Eq%.Eq(Div(num_args, Int|2).r, Int|1).?(false: {
      String@ msg = Strs[
        Str|'expected an odd number of arguments, but got ',
        /Core/Int/Show%.Show(num_args)];
      Error<Text@>(LocOf(cmd.name), msg);
    });

    Let(cmd.args, Empty);
  })
];

@(Markup);
