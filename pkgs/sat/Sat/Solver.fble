
@ Bool@ = /Core/Bool%.Bool@;
% True = /Core/Bool%.True;
% False = /Core/Bool%.False;
% Not = /Core/Bool%.Not;

@ Int@ = /Core/Int%.Int@;
% Inc = /Core/Int%.Inc;
% Int = /Core/Int/Lit%.Int;

<@>@ Fifo@ = /Core/Fifo%.Fifo@;
<@>% Empty = /Core/Fifo%.Empty;
<@>% First = /Core/Fifo%.First;
<@>% Put = /Core/Fifo%.Put;
<@>% Next = /Core/Fifo%.Next;

<@>@ List@ = /Core/List%.List@;
<@>% Nil = /Core/List%.Nil;
<@>% Cons = /Core/List%.Cons;

<@>@ Maybe@ = /Core/Maybe%.Maybe@;
<@>% Just = /Core/Maybe%.Just;
<@>% Nothing = /Core/Maybe%.Nothing;

@ Unit@ = /Core/Unit%.Unit@;
% Unit = /Core/Unit%.Unit;


@ Id@ = Int@;
% EqId = /Core/Int/Eq%.Eq;
% LtId = /Core/Int/Eq%.Lt;

@ VarId@ = Id@;
@ ClauseId@ = Id@;

@ Var@ = *(VarId@ id, Bool@ pos);
@ Clause@ = List@<Var@>;

# pos - the list of clauses this variable appears positive in.
# neg - the list of clauses this variable appears negative in.
@ VarS@ = *(List@<ClauseId@> pos, List@<ClauseId@> neg);

@ ClauseS@ = Clause@;

@ Vars@ = /Core/Map%.Map@<VarId@, VarS@>;
% EmptyVars = /Core/Map%.Empty<VarId@, VarS@>;
% InsertVar = /Core/Map%.Insert<VarId@>(LtId)<VarS@>;
% InsertVarWith = /Core/Map%.InsertWith<VarId@>(LtId)<VarS@>;
% LookupVar = /Core/Map%.Lookup<VarId@>(LtId)<VarS@>;
% DeleteVar = /Core/Map%.Delete<VarId@>(LtId)<VarS@>;
<@>% ForEachVar = /Core/Map%.ForEach<VarId@, VarS@>;

@ Clauses@ = /Core/Map%.Map@<ClauseId@, ClauseS@>;
% EmptyClauses = /Core/Map%.Empty<ClauseId@, ClauseS@>;
% InsertClause = /Core/Map%.Insert<ClauseId@>(LtId)<ClauseS@>;
% LookupClause = /Core/Map%.Lookup<ClauseId@>(LtId)<ClauseS@>;
% DeleteClause = /Core/Map%.Delete<ClauseId@>(LtId)<ClauseS@>;
<@>% ForEachClause = /Core/Map%.ForEach<ClauseId@, ClauseS@>;

# The reasoning behind a variable assignment.
@ Why@ = +(
  Unit@ attempt,      # This is an attempt to rule out this variable.
  Unit@ pure,         # The variable is a pure literal, so no harm setting it.
  ClauseId@ inferred  # The value was inferred from the given clause.
);

Why@ Attempt = Why@(attempt: Unit);
Why@ Pure = Why@(attempt: Unit);
(ClauseId@) { Why@; } Inferred = (ClauseId@ id) { Why@(inferred: id); };

@ AssignOp@ = *(Var@ var, Why@ why);
@ RemoveClauseOp@ = *(ClauseId@ clause);

@ RemoveVarFromClauseOp@ = *(
  ClauseId@ clause,   # The clause to remove the var from.
  VarId@ var,         # The var to remove.
  Why@ why            # Why we are removing the clause.
);

@ RemoveClauseFromVarOp@ = *(ClauseId@ clause, Var@ var);

@ Op@ = +(
  AssignOp@ Assign,
  RemoveClauseOp@ RemoveClause,
  RemoveVarFromClauseOp@ RemoveVarFromClause,
  RemoveClauseFromVarOp@ RemoveClauseFromVar,
  Unit@ Unsat
);

@ Solver@ = *(
  ClauseId@ clause_id,
  Vars@ vars,
  Clauses@ clauses,
  List@<Var@> assigns,
  Fifo@<Op@> ops
);

Solver@ NewSolver = Solver@(Int|0, EmptyVars, EmptyClauses, Nil<Var@>, Empty<Op@>);

# @func[AddClause] Adds a clause to cnf state Solver@.
#  This should be done in the initial phase before starting to solve the
#  formula.
#
#  @arg[s] The cnf state to add the clause to.
#  @arg[clause] The clause to add.
#  @returns
#   An updated cnf state with clause added.
(Solver@, Clause@) { Solver@; } AddClause = (Solver@ s, Clause@ clause) {
  ClauseId@ id = s.clause_id;
  Vars@ nvars = /Core/List%.ForEach(clause, s.vars,
    (Var@ v, Vars@ vs) {
      InsertVarWith(vs, v.id, (Maybe@<VarS@> mx) {
          VarS@ x = mx.?(
            just: mx.just,
            nothing: VarS@(Nil<ClauseId@>, Nil<ClauseId@>));
          v.pos.?(
            true: VarS@(Cons(id, x.pos), x.neg),
            false: VarS@(x.pos, Cons(id, x.neg)));
        });
    });
  Clauses@ nclauses = InsertClause(s.clauses, id, clause);
  Solver@(Inc(id), nvars, nclauses, s.assigns, s.ops);
};

# @func[SeedOps] Seed assign operations to start solving a formula.
#  This should be called after all clauses are added to the formula, to seed
#  the initial set of operations for processing.
#
#  It looks for pure literals and unit clauses, generating a list of assign
#  operations corresponding to those.
(Solver@) { Fifo@<Op@>; } SeedOps = (Solver@ s) {
  Fifo@<Op@> pures = ForEachVar(s.vars, Empty<Op@>,
    (VarId@ id, VarS@ vs, Fifo@<Op@> ops) {
      vs.pos.?(nil: Put(Op@(Assign: @(var: Var@(id, False), why: Pure)), ops));
      vs.neg.?(nil: Put(Op@(Assign: @(var: Var@(id, True), why: Pure)), ops));
      ops;
    });

  ForEachClause(s.clauses, pures,
    (ClauseId@ id, ClauseS@ cs, Fifo@<Op@> ops) {
      cs.?(nil: Put(Op@(Unsat: Unit), ops));
      cs.cons.tail.?(nil: {
        Put(Op@(Assign: @(var: cs.cons.head, why: Inferred(id))), ops);
      });
      ops;
    });
};

# @func[DoAssign] Do an assign operation.
#  Remove VarId from Variables map. If it's there:
#  @i Add variable assignment.
#  @i For each + clause, add a RemoveClause operation.
#  @i For each - clause, add a RemoveVarFromClause operation.
(Solver@, AssignOp@) { Maybe@<Solver@>; } DoAssign = (Solver@ s, AssignOp@ op) {
  Var@ var = op.var;
  Maybe@<VarS@> mvs = LookupVar(s.vars, var.id);
  mvs.?(nothing: Just(s));

  VarS@ vs = mvs.just;

  List@<ClauseId@> match = var.pos.?(true: vs.pos, false: vs.neg);
  Fifo@<Op@> match_ops = /Core/List%.ForEach(match, s.ops,
    (ClauseId@ c, Fifo@<Op@> ops) {
      Put(Op@(RemoveClause: @(clause: c)), ops);
    });

  List@<ClauseId@> unmatch = var.pos.?(true: vs.neg, false: vs.pos);
  Fifo@<Op@> unmatch_ops = /Core/List%.ForEach(unmatch, match_ops,
    (ClauseId@ c, Fifo@<Op@> ops) {
      Put(Op@(RemoveVarFromClause: @(clause: c, var: var.id, why: op.why)), ops);
    });

  Just(@(
      clause_id: s.clause_id, 
      vars: DeleteVar(s.vars, var.id),
      clauses: s.clauses,
      assigns: Cons(var, s.assigns),
      ops: unmatch_ops));
};

# @func[DoRemoveClause] Do a remove clause operation.
#  Remove clause from clauses. If it's there:
#  @i For each variable
#   @i Add a RemoveClauseFromVar operation.
(Solver@, RemoveClauseOp@) { Maybe@<Solver@>; }
DoRemoveClause = (Solver@ s, RemoveClauseOp@ op) {
  ClauseId@ c = op.clause;
  Maybe@<ClauseS@> mcs = LookupClause(s.clauses, c);
  mcs.?(nothing: Just(s));

  ClauseS@ cs = mcs.just;
  Fifo@<Op@> nops = /Core/List%.ForEach(cs, s.ops,
    (Var@ v, Fifo@<Op@> ops) {
      Put(Op@(RemoveClauseFromVar: @(clause: c, var: v)), ops);
    });

  Just(@(
      clause_id: s.clause_id,
      vars: s.vars,
      clauses: DeleteClause(s.clauses, c),
      assigns: s.assigns,
      ops: nops));
};

# @func[DoRemoveVarFromClause] Do a remove var from clause operation.
#  Remove the var from the clause if the clause is there.
#  @i If clause ends up with single var, add Assign operation.
#  @i If clause ends up with no vars, mark unsat and exit.
(Solver@, RemoveVarFromClauseOp@) { Maybe@<Solver@>; }
DoRemoveVarFromClause = (Solver@ s, RemoveVarFromClauseOp@ op) {
  ClauseId@ c = op.clause;
  Maybe@<ClauseS@> mcs = LookupClause(s.clauses, c);
  mcs.?(nothing: Just(s));

  List@<Var@> nvars = /Core/List%.ForEach(mcs.just, Nil<Var@>,
    (Var@ v, List@<Var@> vars) {
      EqId(op.var, v.id).?(true: vars);
      Cons(v, vars);
      });

  nvars.?(nil: Nothing<Solver@>);

  Fifo@<Op@> nops = {
    nvars.cons.tail.?(cons: s.ops);
    Put(Op@(Assign: @(var: nvars.cons.head, why: Inferred(c))), s.ops);
  };

  Just(@(
      clause_id: s.clause_id,
      vars: s.vars,
      clauses: InsertClause(s.clauses, c, nvars),
      assigns: s.assigns,
      ops: nops));
};

# @func[DoRemoveClauseFromVar] Do a remove clause from var operation.
#  Remove clause from var if the var is there.
#  @i If the var ends up with a single polarity, add an Assign operation.
(Solver@, RemoveClauseFromVarOp@) { Maybe@<Solver@>; }
DoRemoveClauseFromVar = (Solver@ s, RemoveClauseFromVarOp@ op) {
  Var@ var = op.var;
  Maybe@<VarS@> mvs = LookupVar(s.vars, var.id);
  mvs.?(nothing: Just(s));
  VarS@ vs = mvs.just;

  List@<ClauseId@> match = var.pos.?(true: vs.pos, false: vs.neg);
  List@<ClauseId@> ncls = /Core/List%.ForEach(match, Nil<ClauseId@>,
    (ClauseId@ c, List@<ClauseId@> cls) {
      EqId(op.clause, c).?(true: cls);
      Cons(c, cls);
    });

  Fifo@<Op@> nops = {
    ncls.?(cons: s.ops);
    Put(Op@(Assign: @(var: Var@(var.id, Not(var.pos)), why: Pure)), s.ops);
  };

  VarS@ nvs = var.pos.?(
    true: @(pos: ncls, neg: vs.neg),
    false: @(pos: vs.pos, neg: ncls));

  Just(@(
      clause_id: s.clause_id,
      vars: InsertVar(s.vars, var.id, nvs),
      clauses: s.clauses,
      assigns: s.assigns,
      ops: nops));
};

# @func[DoOp] Apply an operation.
#  @arg[Solver@][s] The formula state to process the op on.
#  @returns[Maybe@<Solver@>]
#   @i Nothing if the op shows the formula is unsatisfiable.
#   @i The updated state of processing the op otherwise.
(Op@, Solver@) { Maybe@<Solver@>; } DoOp = (Op@ op, Solver@ s) {
  op.?(
    Assign: DoAssign(s, op.Assign),
    RemoveClause: DoRemoveClause(s, op.RemoveClause),
    RemoveVarFromClause: DoRemoveVarFromClause(s, op.RemoveVarFromClause),
    RemoveClauseFromVar: DoRemoveClauseFromVar(s, op.RemoveClauseFromVar),
    Unsat: Nothing<Solver@>);
};

# @func[DoOps] Process ops until no more ops remain or unsat.
(Solver@) { Maybe@<Solver@>; } DoOps = (Solver@ s) {
  Maybe@<Op@> mop = First(s.ops);
  mop.?(nothing: Just(s));

  Solver@ ns = Solver@(s.clause_id, s.vars, s.clauses, s.assigns, Next(s.ops));
  Maybe@<Solver@> ms = DoOp(mop.just, ns);

  ms.?(nothing: ms);
  DoOps(ms.just);
};

@ Assignment@ = List@<Var@>;

# Result@ --
#   The result of trying to solve a sat problem.
@ Result@ = +(Assignment@ sat, Unit@ unsat);

(Solver@) { Result@; }
Search = (Solver@ s) {
  Maybe@<Solver@> ms = DoOps(s);
  ms.?(nothing: Result@(unsat: Unit));
  Solver@ s = ms.just;

  # TODO: Come up with a more efficient way to pick any single existing
  # variable.
  Maybe@<VarId@> mvar = ForEachVar(s.vars, Nothing<VarId@>,
    (VarId@ v, VarS@ _, Maybe@<VarId@> mv) {
      Just(v);
    });
  mvar.?(nothing: Result@(sat: s.assigns));
  VarId@ var = mvar.just;

  Solver@ attempt = Solver@(s.clause_id, s.vars, s.clauses, s.assigns,
    Put(Op@(Assign: @(var: Var@(var, True), why: Attempt)), s.ops));

  Result@ attempted = Search(attempt);
  attempted.?(unsat: {
    Solver@ attempt = Solver@(s.clause_id, s.vars, s.clauses, s.assigns,
    Put(Op@(Assign: @(var: Var@(var, False), why: Attempt)), s.ops));
    Search(attempt);
  });

  attempted;
};

(Solver@) { Result@; } Solve = (Solver@ s) {
  Solver@ seeded = Solver@(s.clause_id, s.vars, s.clauses, s.assigns, SeedOps(s));
  Search(seeded);
};

@(VarId@, Var@, Clause@,
  Solver@, Assignment@, Result@,
  EqId, NewSolver, AddClause,
  Solve);
