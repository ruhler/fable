* Test that tail recursive functions and procedures don't smash the stack.
* Replace ParseFoo, FillFoo, FooList with GC_REALLOC approach?
* Test process call port arguments are valid
* Rest process call expr arguments are valid
* Test that a link's type is valid.
* Test that a put process actually returns its argument.
* Test that a link action's ports can't shadow ports already in scope.
* Test that a link can't use the same name for the get and put ports.
* Test that a proc can't have multiple ports of the same name, with or without
  the same polarity.
* Should FblcExecute take a const FblcActn*?
  Should we use const FblcActn* instead of FblcActn* everywhere there?
* ParseActn calls GC_MALLOC in many paths. Should we just do that up front?
* Test that process port types are valid.
* Make sure we are consistent about variable sized arguments.
  I think we need to use foo* instead of foo[] because in some cases we need
  multiple variable sized bits in the same struct.
* It would be nice if 'Wrong number of arguments to ...' reported the opening
  '(' as the location of the error.
* Test what happens when we try to access the wrong field of a union.
  And check if we can easily show the location in the runtime error message.
* Clean up the error messages.
   - Put names in single quotes always.
   - Say 'expecting expression of type X' instead of 'expecting type X' when
     we are expecting an expression.
* Be able to parse from a string as well as a file.
  - Then add a '-e' option to fblc to specify an arbitrary expression to
    evaluate in the context of the given program.
* Be able to parse from a list of files instead of just one?
  This will help for tests or other programs that share some common functions.
* Implement support for processes.
* Write a man page for fblc?
* Write tests to get 100% code coverage, or reasonably close.
  - Manually review reported errors for 'e' test cases to make sure the test
    case works and the error reported is correct.
    (any better way to automate this kind of testing?)

