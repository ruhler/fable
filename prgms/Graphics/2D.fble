
@ Bool@ = /Bool%.Bool@;

@ Drawing@ = /Drawing%.Drawing@;
@ Color@ = /Drawing%.Color@;
@ Point@ = /Drawing%.Point@;
% Affine = /Drawing%.Affine;
% Blank = /Drawing%.Blank;
% Over = /Drawing%.Over;
% Rect = /Drawing%.Rect;
% Translate = /Drawing%.Translate;

@ Int@ = /Int/Int%.Int@;
% Abs = /Int/Int%.Abs;
% Add = /Int/Int%.Add;
% Sub = /Int/Int%.Sub;
% Neg = /Int/Int%.Neg;
% Mul = /Int/Int%.Mul;
% Int = /Int/Int/Lit%.Int;
% Eq = /Int/Int/Eq%.Eq;
% Le = /Int/Int/Eq%.Le;
% Lt = /Int/Int/Eq%.Lt;
% Max = /Int/Int/Eq%.Max;
% Min = /Int/Int/Eq%.Min;
% Div = /Int/Int/Div%.Div;
% Mod = /Int/Int/Div%.Mod;
% Range = /Int/Int/Iter%.Range;

<@,@>% For = /Iter%.For;

# Point --
#   Draw a point.
(Point@, Color@) { Drawing@; }
Point = (Point@ point, Color@ color) {
  Rect(point.x, point.y, Int|1, Int|1, color);
};

# DivR --
#   Division with rounding.
#
# Does a/b, rounding to the nearest whole number.
# Assumes both a and b are non-negative.
(Int@, Int@) { Int@; } DivR = (Int@ a, Int@ b) {
  Int@ q = Div(a, b);
  Int@ r = Mod(a, b);
  Int@ p = Div(b, Int|2);
  Le(r, p).?(true: q);
  Add(Int|1, q);
};

# LineX --
#   Draw a line from the origin to (x, y) by putting a pixel at every x
#   coordinate. x and y are assumed to be non-negative.
(Int@, Int@, Color@) { Drawing@; }
LineX = (Int@ x, Int@ y, Color@ color) {
  x.?(0: Point(Point@(Int|0, Int|0), color));

  For<Int@, Drawing@>(Range(Int|0, Add(Int|1, x)), Blank,
    (Int@ xi, Drawing@ d) {
      Int@ yi = DivR(Mul(xi, y), x);
      Over(d, Point(Point@(xi, yi), color));
    });
};

# LineY --
#   Draw a line from the origin to (x, y) by putting a pixel at every y
#   coordinate. x and y are assumed to be non-negative.
(Int@, Int@, Color@) { Drawing@; }
LineY = (Int@ x, Int@ y, Color@ color) {
  y.?(0: Point(Point@(Int|0, Int|0), color));

  For<Int@, Drawing@>(Range(Int|0, Add(Int|1, y)), Blank,
    (Int@ yi, Drawing@ d) {
      Int@ xi = DivR(Mul(x, yi), y);
      Over(d, Point(Point@(xi, yi), color));
    });
};

# Line --
#   Draw a line from point a to point b.
(Point@, Point@, Color@) { Drawing@; }
Line = (Point@ a, Point@ b, Color@ color) {
  % s = @(dx: Sub(b.x, a.x), dy: Sub(b.y, a.y), ax: Int|1, ay: Int|1);

  % s_ = {
    Lt(s.dx, Int|0).?(true: {
      @(dx: Neg(s.dx), dy: s.dy, ax: Neg(s.ax), ay: s.ay);
    });
    s;
  };
  % s = s_;

  % s_ = {
    Lt(s.dy, Int|0).?(true: {
      @(dx: s.dx, dy: Neg(s.dy), ax: s.ax, ay: Neg(s.ay));
    });
    s;
  };
  % s = s_;

  % LineF = Lt(Abs(s.dx), Abs(s.dy)).?(true: LineY, false: LineX);
  Translate(a.x, a.y,
    Affine(Point@(s.ax, s.ay), Point@(Int|0, Int|0), LineF(s.dx, s.dy, color)));
};

# RightOf -- 
#   Return true if the point 'x' is to the right of the line going in the
#   direction from point a to point b. False otherwise.
(Point@, Point@, Point@) { Bool@; }
RightOf = (Point@ a, Point@ b, Point@ x) {
  Int@ b_x = Sub(b.x, a.x);
  Int@ b_y = Sub(b.y, a.y);
  Int@ x_x = Sub(x.x, a.x);
  Int@ x_y = Sub(x.y, a.y);

  Int@ l = Mul(b_y, x_x);
  Int@ p = Mul(b_x, x_y);

  Le(p, l);
};

@ Sorted@ = *(Point@ 0, Point@ 1, Point@ 2);

(Point@, Point@, Point@) { Sorted@; }
SortByY = (Point@ a, Point@ b, Point@ c) {
  Le(a.y, b.y).?(
    true: Le(b.y, c.y).?(
      true: Sorted@(a, b, c),
      false: Le(a.y, c.y).?(
        true: Sorted@(a, c, b),
        false: Sorted@(c, a, b))),
    false: Le(a.y, c.y).?(
      true: Sorted@(b, a, c),
      false: Le(b.y, c.y).?(
        true: Sorted@(b, c, a),
        false: Sorted@(c, b, a))));
};

# Triangle --
#   Draw a filled triangle between the points a, b, and c.
#
# The points should be specified in order going clockwise around the triangle,
# otherwise nothing is drawn.
(Point@, Point@, Point@, Color@) { Drawing@; }
Triangle = (Point@ a, Point@ b, Point@ c, Color@ color) {
  # If the points don't go around in clockwise order, there is nothing to do.
  RightOf(a, b, c).?(false: Blank);

  Sorted@ s = SortByY(a, b, c);
  Point@ a = s.0;
  Point@ b = s.1;
  Point@ c = s.2;

  Drawing@ bottom = For<Int@, Drawing@>(Range(a.y, b.y), Blank,
    (Int@ y, Drawing@ d) {
      Int@ xb = Add(a.x, Div(Mul(Sub(y, a.y), Sub(b.x, a.x)), Sub(b.y, a.y)));
      Int@ xc = Add(a.x, Div(Mul(Sub(y, a.y), Sub(c.x, a.x)), Sub(c.y, a.y)));
      Int@ xmin = Min(xb, xc);
      Int@ xmax = Max(xb, xc);
      Over(d, Rect(xmin, y, Sub(xmax, xmin), Int|1, color));
    });

  Drawing@ top = For<Int@, Drawing@>(Range(b.y, c.y), Blank,
    (Int@ y, Drawing@ d) {
      Int@ xa = Add(c.x, Div(Mul(Sub(c.y, y), Sub(a.x, c.x)), Sub(c.y, a.y)));
      Int@ xb = Add(c.x, Div(Mul(Sub(c.y, y), Sub(b.x, c.x)), Sub(c.y, b.y)));
      Int@ xmin = Min(xa, xb);
      Int@ xmax = Max(xa, xb);
      Over(d, Rect(xmin, y, Sub(xmax, xmin), Int|1, color));
    });

  Drawing@ extra = {
    Eq(a.y, c.y).?(true: {
      Int@ xmin = Min(a.x, c.x);
      Int@ xmax = Max(a.x, c.x);
      Rect(xmin, a.y, Sub(xmax, xmin), Int|1, color);
    });

    Eq(b.y, c.y).?(true: {
      Int@ xmin = Min(b.x, c.x);
      Int@ xmax = Max(b.x, c.x);
      Rect(xmin, b.y, Sub(xmax, xmin), Int|1, color);
    });

    Blank;
  };

  Over(bottom, Over(top, extra));
};

@(Point@, Point, Line, Triangle);
