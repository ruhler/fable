
@ Bool@ = /Bool%.Bool@;
% True = /Bool%.True;
% False = /Bool%.False;
% And = /Bool%.And;
<@>@ Eq@ = /Eq%.Eq@;
<@,@>@ Map@ = /Map%.Map@;
@ Unit@ = /Unit%.Unit@;

# Eq --
#   Implementation of Eq@ for Map@. See documentation of /Eq%.Eq@.
<@ K@, @ V@>(Eq@<V@>) { Eq@<Map@<K@, V@>>; }
Eq = <@ K@, @ V@>(Eq@<V@> eq)(Map@<K@, V@> a, Map@<K@, V@> b) {
  a.?(
    # TODO: Don't assume map.map means a non-empty map.
    # Define an IsEmpty function and use that to test b for empty instead.
    empty: b.?(empty: True, map: False),
    map: b.?(
      empty: False,
      map: {
        Bool@ unit_eq = a.map.unit.?(
          just: b.map.unit.?(
            just: eq(a.map.unit.just.value, b.map.unit.just.value),
            nothing: False),
          nothing: b.map.unit.?(just: False, nothing: True)
        );

        Bool@ sum_eq = And(
          Eq<K@, V@>(eq)(a.map.either.a, b.map.either.a),
          Eq<K@, V@>(eq)(a.map.either.b, b.map.either.b)
        );

        Bool@ pair_eq = 
          Eq<Unit@, Map@<K@, V@>>(
            (Map@<K@, V@> a, Map@<K@, V@> b) {
              Eq<K@, V@>(eq)(a, b);
            })(a.map.pair, b.map.pair);
        And(unit_eq, And(sum_eq, pair_eq));
      }));
};

@(Eq);
