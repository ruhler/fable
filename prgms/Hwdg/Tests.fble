
@ Bool@ = /Bool%.Bool@;
% True = /Bool%.True;
% False = /Bool%.False;

<@>@ Eq@ = /Eq%.Eq@;

% 0 = /Int/Int%.0;
% 1 = /Int/Int%.1;
% 2 = /Int/Int%.2;
% 3 = /Int/Int%.3;

<@>% List = /List%.List;

<@>@ Maybe@ = /Maybe%.Maybe@;
<@>% Just = /Maybe%.Just;
<@>% Nothing = /Maybe%.Nothing;

<@>@ Show@ = /Show%.Show@;

% Str = /String%.Str;
% Strs = /String%.Strs;

@ Test@ = /Test%.Test@;
<@>% AssertEquals = /Test%.AssertEquals;
% Test = /Test%.Test;
% TestSuite = /Test%.TestSuite;

@ Gate@ = /Hwdg%.Gate@;
@ GateEntry@ = /Hwdg%.GateEntry@;
@ Gates@ = /Hwdg%.Gates@;
<@>@ Ports@ = /Hwdg%.Ports@;
@ PortSpec@ = /Hwdg%.PortSpec@;
% InputPort = /Hwdg%.InputPort;
% OutputPort = /Hwdg%.OutputPort;
% UnusedPort = /Hwdg%.UnusedPort;
% Gates = /Hwdg%.Gates;
% Run = /Hwdg%.Run;

@ Coord@ = /Hwdg/Coord%.Coord@;

@ Data@ = /Hwdg/Data%.Data@;
% Data0 = /Hwdg/Data%.0;
% Data1 = /Hwdg/Data%.1;

@ Memory@ = /Hwdg/Memory%.Memory@;
% Empty = /Hwdg/Memory%.Empty;
% Clear = /Hwdg/Memory%.Clear;
% Get = /Hwdg/Memory%.Get;
% Set = /Hwdg/Memory%.Set;

Eq@<Data@> EqData = (Data@ a, Data@ b) {
  a.?(
    0: b.?(0: True, 1: False),
    1: b.?(0: False, 1: True));
};

Show@<Data@> ShowData = (Data@ x) {
  x.?(0: Str|0, 1: Str|1);
};

Show@<Coord@> ShowCoord = (Coord@ x) {
  Strs[Str|'(', /Int/Int/Show%.Show(x.x), Str|',', /Int/Int/Show%.Show(x.y), Str|')'];
};

(Memory@, Memory@) { Bool@; } EqCells = (Memory@ a, Memory@ b) {
  /Map/Eq%.Eq<Coord@, Data@>(/Hwdg/Coord%.Eq, EqData)(a, b);
};

Show@<Memory@> ShowCells = (Memory@ x) {
  /Map/Show%.Show<Coord@, Data@>(ShowCoord, ShowData)(x);
};

Test@ Tests = TestSuite(Str|Hwdg, List<Test@>[
  Test(Str|'empty no data', !({
    Memory@ cells = Empty;
    Maybe@<Data@> got = Get(cells, Coord@(3, 2));
    Maybe@<Data@> wnt = Nothing<Data@>;

    AssertEquals<Maybe@<Data@>>(
      /Maybe/Eq%.Eq<Data@>(EqData),
      /Maybe/Show%.Show<Data@>(ShowData),
      wnt, got);
  })),

  Test(Str|'set this data to 0', !({
    Memory@ cells = Set(Empty, Coord@(3, 2), Data0);
    Maybe@<Data@> got = Get(cells, Coord@(3, 2));
    Maybe@<Data@> wnt = Just<Data@>(Data0);

    AssertEquals<Maybe@<Data@>>(
      /Maybe/Eq%.Eq<Data@>(EqData),
      /Maybe/Show%.Show<Data@>(ShowData),
      wnt, got);
  })),

  Test(Str|'set this data to 1', !({
    Memory@ cells = Set(Empty, Coord@(3, 2), Data1);
    Maybe@<Data@> got = Get(cells, Coord@(3, 2));
    Maybe@<Data@> wnt = Just<Data@>(Data1);

    AssertEquals<Maybe@<Data@>>(
      /Maybe/Eq%.Eq<Data@>(EqData),
      /Maybe/Show%.Show<Data@>(ShowData),
      wnt, got);
  })),

  Test(Str|'set other data', !({
    Memory@ cells = Set(Empty, Coord@(2, 3), Data1);
    Maybe@<Data@> got = Get(cells, Coord@(3, 2));
    Maybe@<Data@> wnt = Nothing<Data@>;

    AssertEquals<Maybe@<Data@>>(
      /Maybe/Eq%.Eq<Data@>(EqData),
      /Maybe/Show%.Show<Data@>(ShowData),
      wnt, got);
  })),

  Test(Str|'clear data', !({
    Memory@ cells = Clear(Set(Empty, Coord@(3, 2), Data1), Coord@(3, 2));
    Maybe@<Data@> got = Get(cells, Coord@(3, 2));
    Maybe@<Data@> wnt = Nothing<Data@>;

    AssertEquals<Maybe@<Data@>>(
      /Maybe/Eq%.Eq<Data@>(EqData),
      /Maybe/Show%.Show<Data@>(ShowData),
      wnt, got);
  })),

  Test(Str|'clear other data', !({
    Memory@ cells = Clear(Set(Empty, Coord@(3, 2), Data1), Coord@(2, 3));
    Maybe@<Data@> got = Get(cells, Coord@(3, 2));
    Maybe@<Data@> wnt = Just<Data@>(Data1);

    AssertEquals<Maybe@<Data@>>(
      /Maybe/Eq%.Eq<Data@>(EqData),
      /Maybe/Show%.Show<Data@>(ShowData),
      wnt, got);
  })),

  Test(Str|'empty gate', !({
    # Make sure we don't get stuck in an infinite loop if there is an empty
    # gate.
    Gate@ gate = @(
      ports: Ports@<PortSpec@>(UnusedPort, UnusedPort, UnusedPort, UnusedPort),
      function: (Ports@<Data@> unused) { unused; });
    Gates@ gates = Gates(List<GateEntry@>[@(coord: Coord@(0, 0), gate: gate)]);
    Memory@ cells = Set(Empty, Coord@(0, 0), Data1);

    Memory@ wnt = Set(Empty, Coord@(0, 0), Data1);
    Memory@ got = Run(gates, cells);
    AssertEquals<Memory@>(EqCells, ShowCells, wnt, got);
  })),

  Test(Str|'identity ul to lr', !({
    Gate@ gate = @(
      ports: Ports@<PortSpec@>(
        InputPort, UnusedPort,
        UnusedPort, OutputPort),
      function: (Ports@<Data@> x) {
        Ports@<Data@>(Data0, Data0, Data0, x.ul);
      });
    Gates@ gates = Gates(List<GateEntry@>[@(coord: Coord@(0, 0), gate: gate)]);
    Memory@ cells = Set(Empty, Coord@(0, 0), Data1);

    Memory@ wnt = Set(Empty, Coord@(1, 1), Data1);
    Memory@ got = Run(gates, cells);
    AssertEquals<Memory@>(EqCells, ShowCells, wnt, got);
  })),

  Test(Str|'identity ul to lr input blocked', !({
    Gate@ gate = @(
      ports: Ports@<PortSpec@>(
        InputPort, UnusedPort,
        UnusedPort, OutputPort),
      function: (Ports@<Data@> x) {
        Ports@<Data@>(Data0, Data0, Data0, x.ul);
      });
    Gates@ gates = Gates(List<GateEntry@>[@(coord: Coord@(0, 0), gate: gate)]);
    Memory@ cells = Set(Empty, Coord@(1, 0), Data1);

    # The gate doesn't have it's input available, so we don't expect it to
    # trigger.
    Memory@ wnt = cells;
    Memory@ got = Run(gates, cells);
    AssertEquals<Memory@>(EqCells, ShowCells, wnt, got);
  })),

  Test(Str|'identity ul to lr output blocked', !({
    Gate@ gate = @(
      ports: Ports@<PortSpec@>(
        InputPort, UnusedPort,
        UnusedPort, OutputPort),
      function: (Ports@<Data@> x) {
        Ports@<Data@>(Data0, Data0, Data0, x.ul);
      });
    Gates@ gates = Gates(List<GateEntry@>[@(coord: Coord@(0, 0), gate: gate)]);
    Memory@ cells = Set(Set(Empty,
        Coord@(0, 0), Data1),
        Coord@(1, 1), Data0);

    # The gate's output port is blockd, so we don't expect it to trigger.
    Memory@ wnt = cells;
    Memory@ got = Run(gates, cells);
    AssertEquals<Memory@>(EqCells, ShowCells, wnt, got);
  })),

  Test(Str|'identity chain', !({
    # Test a chain of identity gates.
    # -> -> -| .
    # .  .   v .
    # <- <- -| .
    # .  .  .  .
    Gate@ ul_to_ur = @(
      ports: Ports@<PortSpec@>(InputPort, OutputPort, UnusedPort, UnusedPort),
      function: (Ports@<Data@> x) { Ports@<Data@>(Data0, x.ul, Data0, Data0); });
    Gate@ ul_to_ll = @(
      ports: Ports@<PortSpec@>( InputPort, UnusedPort, OutputPort, UnusedPort),
      function: (Ports@<Data@> x) { Ports@<Data@>(Data0, Data0, x.ul, Data0); });
    Gate@ ur_to_ul = @(
      ports: Ports@<PortSpec@>( OutputPort, InputPort, UnusedPort, UnusedPort),
      function: (Ports@<Data@> x) { Ports@<Data@>(x.ur, Data0, Data0, Data0); });

    Gates@ gates = Gates(List<GateEntry@>[
      @(coord: Coord@(0, 0), gate: ul_to_ur),
      @(coord: Coord@(1, 0), gate: ul_to_ur),
      @(coord: Coord@(2, 0), gate: ul_to_ll),
      @(coord: Coord@(2, 1), gate: ul_to_ll),
      @(coord: Coord@(1, 2), gate: ur_to_ul),
      @(coord: Coord@(0, 2), gate: ur_to_ul)]);

    # Send '0' and '1' down the wire together.
    Memory@ cells = Set(Set(Empty,
          Coord@(0, 0), Data1),
          Coord@(1, 0), Data0);

    Memory@ wnt = Set(Set(Empty,
          Coord@(0, 2), Data0),
          Coord@(1, 2), Data1);
    Memory@ got = Run(gates, cells);
    AssertEquals<Memory@>(EqCells, ShowCells, wnt, got);
  }))
]);

@(Tests);
