* Switch from FbleTypeArena to FbleArena for NewLocal and LocalRelease?
* Remove /Nat%, which should be obsolete by now.
 - Add Mod to /Int%, and switch Primes to use /Int% instead of /Nat%.
 - Switch App% to use Int@ for drawing instead of Nat@. Or IntS@?
* Clearly define orientation of coordinate system for Draw@ in App%.
* Pass width and height to App and scale up or down as necessary in fble code.
* Come up with a nicer timer interface for App.
* Debug flaky deadlock in fble-app?
  - SDL docs say the multithreading of OnTimer is safe.
* Separate Map from DataMap and EqMap.
* Improve error message for private module reference access.
 - Print the paths to source and target at least.
* Check that FbleLoad doesn't leak memory in error cases.
 - Maybe use a separate alloc arena for temporary allocations?
* Figure out why GameOfLife is so absurdly slow.
* Add support for Int@ literals. Replace Lit2, Lit3, Lit4, etc.
* Optimization: Avoid REF_INSTR if we aren't going to ever use it.
* Why is statics for Bit2X.fulladd! 3 long when only entry 0 is used?
* Can children clean themselves up when they finish now that they return their
  result directly to their parent?
* Is there a way to clean up compile.c, in terms of orders of setting fields
  of instructions vs scopes vs locals? It all seems very confused to me.
* It might be nice to have a tool that lists, for each module, all of the
  modules it directly or indirectly depends on. To help guide when to split up
  modules or not.
* Is there a way to avoid emitting instructions after a return instruction?
* Add test that we don't hold on to a condition value while running the
  selected branch of a union select expression.
* Add test that we don't hold on to an exec binding expression longer than
  necessary.
* Add unit tests for /Map%.Equals.
* [clean] Reorganize functions in fble/compile.c
* Don't duplicate evaluation of literal type per letter.
* Add test that the literal type must be a struct, not a union value.
* Don't give duplicate error messages if the literal type is malformed.
* Remove struct import syntax in favor of let or a new multi-import format.
* Add support for abstract types?
* Fix syntax highlighting of paths
  For example: *(@<DataMap%.Map@>Map@ 
* Make Foo@: highlight like a field instead of like a type?
* Remove excess !!! in block names.
  Maybe addressed naturally when we inline link and exec bindings into the
  parent proc?
* Label blocks in exec process bindings by binding name?
* Step through code via gdb for a Bit2XN addition to get a sense of how
  involved that is?
* Consider factoring out code in compile.c for computing modeled profile time.
* Consider using put and get to synchronize EXEC processes rather than JOIN?
* Add an option to automatically determine performance model parameters based
  on wall clock time profiling of benchmarks.
* Ensure the implementation satisfies the performance spec. Add perf spec
  tests as necessary to catch bugs.
* [perf] Eval in compile.c is called a ton. Shouldn't we only need to call
  eval after a let binding? Can't we use subst or other eval-by-construction
  for everything else?
* Document the runtime memory model,
  - Including that tail recursive functions should not smash the stack.
* Test that we get a reasonable error message if we do something like:
    <@>@ Id = <@ T@> { T@; };
* Test that poly types with different arg kinds aren't equal.
* [test] Add detection of vacuous values.
* [clean] Can fble-stdio check that the function has the right type?
* Better error messages on types that have the same name but different values.
* Write man pages for fble and friends?
* Better error message when the difference between a type is accidentally
  defining + vs. *, and it contains substituted polymorphic type variables.
* Rethink arenas and documentation, because some cases appear to assume you
  have a bulk-free arena. Other cases its not well specified what is freed
  explicitly and what is expected to be freed implicitly.
  I claim a good model is: pass an arena to a function to say: the function
  allocates its result in this arena. The function creates and uses a separate
  arena for its intermediate allocations.
* Make child thread execution fair.
  Children should be time multiplexed, where priority is assigned based on how
  far down the family tree the child belongs. The amount of time a family gets
  to spend evaluating should be independent of the number of children in the
  family.
* Change reference counting to be incrementally done on allocation.
  Maybe write a test that shows how something that should take no time gets
  charged for a big deallocation time today?
* Figure out how to handle profiling threads better
 - Separate EXIT_BLOCK from EXIT_COPE to remove spurious calls to enter block
   0 in fble/eval?
 - Remove special case handling of block 0 in fble/profile?
 - How to maintain the profile stack when forking new threads?

Future:
* Implement compiler to C. Idea is translate a function body into a sequence
  of commands like we have in the current interpreter. Split the command
  sequence into blocks any place there is a function call. Gather up all the
  blocks of all the command sequences in the program, give each a unique name
  starting from zero, then generate a loop containing one large switch
  statement with a case for each block. Global state is a list of thread
  contexts. Thread context is a frame, which has variables, ports, the id of
  the block that currently needs to be executed, and a pointer to the frame to
  execute after executing this block.

* Implement compiler to hardware. Same idea as compiler to C: break up into
  blocks. Now each block can be its own hardware block. Frames are queued up
  at their block, all blocks can execute in parallel as inputs are available,
  and we can pipeline or duplicate the blocks to allow for even more
  parallelism.

* Implement an fble debugger. Features:
 - Set a breakpoint at a line in a file.
 - Step through code line by line.
 - Evaluate expressions in the context of the current scope and print the
   results.
 - Auto breakpoint at undefined behavior?
 
 Use cases:
 - Debug why sudoku solver isn't working properly by stepping through a line
   at a time and printing intermediate values.

   Turns out it wasn't too hard to figure out the problem in this case without
   a debugger.

Snake:
* Make food appear randomly instead of at the tail.
* Speed up the snake every time it eats something.
* Test and fix bug when snake eats its tail.
* Ignore moves that aren't orthogonal to current snake direction.
* Keep track of and report score.

Md5:
* Remove Bits cls implementation, as it is no longer used and not very useful.
* Improve performance of Bit2XN.add, though it's not obvious how.

Table Tennis:
* Render a static 3D table tennis scene.

Sudoku:

Game of Life:

Space Invaders:
* Render objects - how to test?
  manual test: Draw all objects to the screen as a gallery of them.
* Game loop driven by timer - how to test? 
  manual test: Have app with just ship that can be moved left and right (and
  fire bullets into space?)
* Pseudo-random bullet attack, UFO - how to test?
* Collision detection
