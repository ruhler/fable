
* [test] Implement support for FbleRefDelete of cycles.
* [test] Figure out source of /Snake/Bench% memory leak.
  - looks like we are leaking a proc put value that's holding on to a link.
  - question: when does the game end? Could we be silently hitting a deadlock
    condition and failing to clean up?

* [snake] Test and fix bug when snake eats its tail.
* [snake] Ignore moves that aren't orthogonal to current snake direction.
* [snake] Keep track of and report score.
* [snake] Figure out why the background box gets lost some times.
* [pingpong] Render a static 3D table tennis scene.
* [invaders] Implement space invaders game.

* [lib] Add test coverage for the Int routines.
 - In particular, test Div and Mod.
* [lib] Separate Map from DataMap and EqMap.
* [lib] Add unit tests for /Map%.Equals.
* [lib] Separate List@ from S@ and P@ module wise.

* [api] Can fble-stdio check that the function has the right type?

* [compile] Is there a way to clean up compile.c, in terms of orders of setting fields
  of instructions vs scopes vs locals? It all seems very confused to me.
* [compile] Is there a way to avoid emitting instructions after a return/exit instruction?
* [compile] Optimization: Avoid REF_INSTR if we aren't going to ever use it.
 - Maybe have a way to list free vars in an expression and use that to compute
   'recursive' ahead of time?

* [compile] Test and fix error message for type of anonymous type let values.
 - The type should be the computed type for the value, not the introduced
   abstract type?

* [profile] Figure out how to handle profiling threads better
 - Separate EXIT_BLOCK from EXIT_SCOPE to remove spurious calls to enter block
   0 in fble/eval?
 - Remove special case handling of block 0 in fble/profile?
 - How to maintain the profile stack when forking new threads?
* [profile] Label blocks in exec process bindings by binding name?

* [eval] Experiment with alternate garbage collection implementations.
 - For the purpose of improving memory and runtime performance.
* [eval] Make child thread execution fair.
  Children should be time multiplexed, where priority is assigned based on how
  far down the family tree the child belongs. The amount of time a family gets
  to spend evaluating should be independent of the number of children in the
  family.

* [lang] Add support for abstract types?
* [lang] Document the runtime memory model,
  - Including that tail recursive functions should not smash the stack.
* [lang] Document and test that put ports don't retain link values.

* [release] Better error messages on types that have the same name but different values?
* [release] Write man pages for fble and friends?
* [release] Better error message for importing something from a module that
  is not defined in the module?

* [ref] Change reference counting to be incrementally done on allocation.
  Maybe write a test that shows how something that should take no time gets
  charged for a big deallocation time today?

* [arena] Rethink arenas and documentation, because some cases appear to assume you
  have a bulk-free arena. Other cases its not well specified what is freed
  explicitly and what is expected to be freed implicitly.
  I claim a good model is: pass an arena to a function to say: the function
  allocates its result in this arena. The function creates and uses a separate
  arena for its intermediate allocations.

* [debugger] Implement an fble debugger. Features:
 - Set a breakpoint at a line in a file.
 - Step through code line by line.
 - Evaluate expressions in the context of the current scope and print the
   results.
 - Auto breakpoint at undefined behavior?
 
 Use cases:
 - Debug why sudoku solver isn't working properly by stepping through a line
   at a time and printing intermediate values.

   Turns out it wasn't too hard to figure out the problem in this case without
   a debugger.

 - Debug why snake AI wasn't working.

   It turns out we were using the wrong direction. A debugger to step through
   code and print variable values would have found this more quickly than my
   guess and check approach, which was pretty tedious.

