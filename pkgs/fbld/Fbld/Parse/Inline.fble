
@ Bool@ = /Core/Bool%.Bool@;
% True = /Core/Bool%.True;

@ Char@ = /Core/Char%.Char@;
% Chars = /Core/Char%.Chars;
% IsAlNum = /Core/Char/Type%.IsAlNum;

<@>@ List@ = /Core/List%.List@;
<@>% Nil = /Core/List%.Nil;
<@>% Cons = /Core/List%.Cons;

<@>@ Maybe@ = /Core/Maybe%.Maybe@;

@ String@ = /Core/String%.String@;
% Str = /Core/String%.Str;
% Strs = /Core/String%.Strs;

@ Unit@ = /Core/Unit%.Unit@;
% Unit = /Core/Unit%.Unit;

@ Loc@ = /Fbld/Loc%.Loc@;

@ Markup@ = /Fbld/Markup%.Markup@;
% Empty = /Fbld/Markup%.Empty;
% Plain = /Fbld/Markup%.Plain;
% Append = /Fbld/Markup%.Append;

<@>@ M@ = /Fbld/Parse/M%.M@;
<@>% Do = /Fbld/Parse/M%.Do;
<@>% Return = /Fbld/Parse/M%.Return;
<@>% Error = /Fbld/Parse/M%.Error;
<@>% Try_ = /Fbld/Parse/M%.Try_;
<@>% Test = /Fbld/Parse/M%.Test;
<@>% Test_ = /Fbld/Parse/M%.Test_;
% Loc = /Fbld/Parse/M%.Loc;
% Get = /Fbld/Parse/M%.Get;
% String = /Fbld/Parse/M%.String;

(Char@) { Bool@; } IsNameChar = (Char@ c) {
  c.?('_': True);
  IsAlNum(c);
};

# Parses a sequence of zero or more name characters from the start of the
# string.
M@<String@> Name = {
  Maybe@<Char@> mc <- Do(Test(Get));
  mc.?(nothing: Return(Str|''));
  IsNameChar(mc.just).?(false: Return(Str|''));

  Char@ _ <- Do(Get);
  String@ tail <- Do(Name);
  Return(Cons(mc.just, tail));
};

# Parses raw text up to and including '}' for literal args.
M@<String@> Literal = {
  Char@ head <- Do(Get);
  head.?('}': Return(Str|''));

  String@ tail <- Do(Literal);
  Return(Cons(head, tail));
};

M@<Markup@> LiteralArg = {
  Unit@ _ <- Do(String|'{');
  Loc@ l <- Do(Loc);
  String@ text <- Do(Literal);
  Return(Plain(l, text));
};

@ Markup_@ = *(String@ plain, Markup@ markup);

M@<Markup@> RegularArg = {
  Unit@ _ <- Do(String|'[');
  M@<Unit@> end = {
    Loc@ l <- Do(Loc);
    Char@ c <- Do(Get);
    c.?(']': Return(Unit));
    Error<Unit@>(l, Str|'Expected '']''');
  };
  Inline(end);
},

# Parses a sequence of zero or more inline args.
M@<List@<Markup@>> Args = {
  Bool@ regular <- Do(Test_(String|'['));
  regular.?(true: {
    Markup@ head <- Do(RegularArg);
    List@<Markup@> tail <- Do(Args);
    Return(Cons(head, tail));
  });

  Bool@ literal <- Do(Test_(String|'{'));
  literal.?(true: {
    Markup@ head <- Do(LiteralArg);
    List@<Markup@> tail <- Do(Args);
    Return(Cons(head, tail));
  });

  Return(Nil<Markup@>);
},

# Parses an inline command, starting just after the '@' character.
M@<Markup@> Command = {
  Loc@ l <- Do(Loc);
  String@ name <- Do(Name);
  name.?(nil: Error<Markup@>(l, Str|'missing command name'));

  List@<Markup@> args <- Do(Args);
  Return(/Fbld/Markup%.Command(l, name)(args));
},

# Helper function for Inline. Returns parsed markup as plain text followed by
# the rest of the markup.
(M@<Unit@>) { M@<Markup_@>; } Inline_ = (M@<Unit@> end) {
  Bool@ done <- Do(Try_(end));
  done.?(true: Return(@(plain: Str|'', markup: Empty)));

  Char@ c <- Do(Get);
  c.?('@': {
    Markup@ command <- Do(Command);
    Markup@ tail <- Do(Inline(end));
    Return(@(plain: Str|'', markup: Append(command, tail)));
  });

  Char@ h <- Do({
    c.?('\': {
      Loc@ le <- Do(Loc);
      Char@ e <- Do(Get);
      e.?(
        '@': Return(Chars.'@'),
        '[': Return(Chars.'['),
        '\': Return(Chars.'\'),
        ']': Return(Chars.']'),
        'n': Return(Chars.nl));
      Error<Char@>(le, Strs[Str|'Unsupported escape sequence: ''\', Str[e, Chars.'''']]);
    });
    Return(c);
  });
  Markup_@ tail <- Do(Inline_(end));
  Return(@(plain: Cons(h, tail.plain), markup: tail.markup));
},

# Parses inline text.
#
# @arg[end] - Something that parses the end of the inline text.
(M@<Unit@>) { M@<Markup@>; } Inline = (M@<Unit@> end) {
  Loc@ l <- Do(Loc);
  Markup_@ result <- Do(Inline_(end));
  result.plain.?(nil: Return(result.markup));
  Return(Append(Plain(l, result.plain), result.markup));
};

@(Inline, Name, Args);
