
@ Int@ = /Int/Int%.Int@;
% Add = /Int/Int%.Add;

<@,@>@ Lit@ = /Literal%.Lit@;

@ Program@ = /Fblf/Program%.Program@;
@ Addr@ = /Fblf/Program%.Addr@;
% Noop = /Fblf/Program%.Noop;
% Seq = /Fblf/Program%.Seq;

# Instance@, Module@ --
#   Module@ is a monad for tracking allocation of objects on a heap. It is
#   implemented as a state monad over an Addr@ tracking the size in bits of
#   the heap allocated so far.
#
#   Instance@ is the part of the Module@ monad that represents an instantiated
#   Module@.
<@>@ Instance@ = <@ T@> { *(Addr@ heap, T@ instance); };
<@>@ Module@ = <@ T@>(Addr@) { Instance@<T@>; };

# AllocM --
#   Allocate n bits on the heap.
#
# Example use:
#   Addr@ x <- AllocM(I(D|32));
#   ...
<@ T@>(Int@)((Addr@) { Module@<T@>; }) { Module@<T@>; }
AllocM = <@ T@>(Int@ n)((Addr@) { Module@<T@>; } f) {
  (Addr@ free) {
    f(free)(Add(free, n));
  };
};

# InstM --
#   Instantiate a module for use in another module.
#
# Example use:
#   Program@ p <- InstM(m);
#   ...
<@ A@, @ B@>(Module@<A@>)((A@) { Module@<B@>; }) { Module@<B@>; }
InstM = <@ A@, @ B@>(Module@<A@> m)((A@) { Module@<B@>; } f) {
  (Addr@ free) {
    Instance@<A@> mr = m(free);
    f(mr.instance)(mr.heap);
  };
};

# PureM --
#   A module that does not need to allocate space on the heap or instantiate
#   other modules.
<@ T@>(T@) { Module@<T@>; } PureM = <@ T@>(T@ instance) {
  (Addr@ free) { Instance@<T@>(free, instance); };
};

# SeqM --
#   Instantite a list of modules.
#
# TODO: generalize this to arbitrary T@.
(Lit@<Module@<Program@>>) { Module@<Program@>; } SeqM = (Lit@<Module@<Program@>> ms) {
  ms<Module@<Program@>>((Module@<Program@> aM, Module@<Program@> bM) {
    Program@ a <- InstM<Program@, Program@>(aM);
    Program@ b <- InstM<Program@, Program@>(bM);
    PureM<Program@>(Seq([a, b]));
  }, PureM<Program@>(Noop));
};

<@ T@>(Module@<T@>, Addr@) { Instance@<T@>; }
Instantiate = <@ T@>(Module@<T@> m, Addr@ free) {
  m(free);
};

@(Module@, Instance@, AllocM, InstM, PureM, SeqM, Instantiate);
