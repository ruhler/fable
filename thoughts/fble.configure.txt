Fble Configuration
==================
Goal is to provide a configure mechanism of some sort to tell where
dependencies are and what dependencies to disable when building fble.

Configure has the following responsibilities:
* Check whether the required dependencies are satisfied.
  - This can be simple, best effort, sanity check. Doesn't need to be
    exhaustive in any sense.
* Allow users to disable dependencies.
* Allow users to specify explicit paths for dependencies.
* Attempt to automatically identify paths for dependencies.
  - This can be simple, best effort. Doesn't need to be fancy.
* Report somewhere what features are disabled due to missing dependencies.
* Allow user to specify install directories.

Some misc thoughts:
* I like the idea of requiring a user to explicitly disable dependencies they
  don't want, rather than silently disabling things for them unexpectedly.
* Note that some dependencies are for test purposes only. We should allow
  disabling those, which will disable the corresponding tests.

Traditional approach is to have a ./configure script for this. User runs it,
specifies things via command line argument, it generates some file that's
input to the build.

Seems tedious to me to have to call configure to generate a file, when perhaps
we could ask the user to directly modify the file.

---

What are the big dependencies that are likely to get in the way of users?

* Ninja - we need that for everything, so it should be required.
* OpenGL/SDL
* Aarch64

Honestly, I think all the rest, like bison, gcc, tcl, grep, diffutils, etc.
are reasonable to expect people have installed or are willing to install.

OpenGL/SDL:
  fble-app
  FbleAppMain (aka 'app')
  games, graphics, hwdg, invaders, pinball

I don't see any reason to require OpenGL/SDL for these apps and test cases. We
should just avoid building the fble-app and final compiled FbleAppMain
executable. Because there are some games that don't need sdl, and you can
still run test cases. In the future you could imagine other ways to display
the games, like ncurses or something.

Aarch64 is the big one. If we don't have that, we want to remove any calls to
the assembler. And remove any tests that depend on it.

Cool. So here is what I propose in terms of functionality:
* If user is not on aarch64, or user explicitly opts out, we disable compiled
  code and tests therefore.
* User can specify OpenGL/SDL as auto, explicit config, or disabled. We find
  the path to SDL as best we can and either disable building of the final apps
  or not based on that.

Should we support a somewhat normal ./configure script approach?

Options would be something like:
* Eventually standard prefix directory options, once we support install.
* Optional feature --without-sdl
* --target= option to specify aarch64?
* Influential environment variables: CC, CFLAGS, LDFLAGS, etc.

Anyway, we can separate the interface from the implementation. Maybe start on
the implementation.

Implementation, start by manually specifying:
* HAVE_AARCH64 (or some such)
* HAVE_SDL (or some such)

Be able to switch those on and off, and test manually that it works. Maybe
easiest way to test is try on another computer that has neither, or uninstall
SDL, rebuild, and see if we can make that work.

Not sure how we can make an automated test for all these variations as part of
the build.

An important point here: I'm suggesting I always run as many tests as I can.
There's no option to 'run without tests'.

---

Next steps: review how standard gnu configuration scripts work. In particular,
look out for:

* How does information about existence and location of a package get passed to
  the program? Can we use the same naming scheme?
* How are targets specified? Can we use the same naming scheme?

Notes from https://www.gnu.org/prep/standards/html_node/Configuration.html:
* 'configure' is the name of the script
* don't allow people to build the program without running configure first.
* Generated files should have a comment saying they were generated by
  configure.
* config.status should be generated to rerun a configuration.
 - I'm not sure I care about this requirement.
* In theory we should support building with sources in a different location.
  Maybe a v2 kind of feature to try and support.
* target is specified as something like i686-pc-linux-gnu, or "all plausible
  alternatives'.
* --enable-* for enabling or disabling a feature.

Design strawperson:
* configure is a tcl script. It generates a config.tcl file read by build.tcl.
* Should we have a config.tcl.in file, to document what is expected?
* Q: should it generate Makefile too?
 Options:
  - Makefile exists before hand. Build fails without config.tcl.
  - No makefile exists before hand. It's generated by configure.
    + No Makefile.in
    + Using Makefile.in.

Honestly, I think best to generate the Makefile from configure. It's simple
enough. Forces people to run configure. No need for Makefile.in, because the
makefile will be so simple. It's just a wrapper around ninja.

configure can check for tcl, ninja, etc.

Question: Should SDL/GL be a feature or a with-package?
 - If it's a feature, then we don't have to worry about having SDL but not GL,
   or having GL but not SDL.
 - If it's with package... I'm not sure how that's intended to be used.

Samples from autoconf manual
* HAVE_UNISTD_H to say if that header is present.
* For libraries, prepend -lFoo to LIBS and set HAVE_LIBlibrary 

Hmm... So it's not very clearly specified what names to use for things. Let's
just pick my own.

In general, looks like we want --enable-* for turning something on and off, and
--with-* for using something else in place of the default. So, for me, almost
certainly we want --enable. I like following the model of vlc configure
script.

Design proposal:
* configure is a tcl script.
* configure generates Makefile.
* No Makefile.in.
* configure generates config.tcl. 
* config.tcl.example exists, in case people want to write their own, and to
  better document the expected format.
* --enable option for sdl/opengl. Maybe call it --enable-sdl?
  SDL_LIBS, SDL_CFLAGS, GL_LIBS, GL_CFLAGS variables.
  ENABLE_SDL variable set to true or false.
* TODO: how to handle aarch64? I think as an enable flag, not as a target
  flag? Hard to tell.

aarch64 doesn't make sense as an enable flag. It's more like, if you have
aarch64, we can run those tests. Otherwise we have to skip those tests.
There's no choice for the user to make here.

---

Now we have a generate_c option as well as generate_aarch64. The build system
is set up to pick aarch64 if available, otherwise fall back to generate_c. So
let's revisit what I want to do for configure in the context of making a
release.

Features to support:
* build anywhere, in or out of tree.
* specify directories to install things in
  - And as a corollary, have options to install things.
* Support make, make install, and make check.
  - Question: should make check be an extra step, or always do it?
  - Answer: ... probably worth making it a separate extra step?
* Support env variable settings: CC, CPP, LDFLAGS, whatever options are
  standard and relevant.
* Option to enable or disable sdl/gl.
  - This can be the only option for now. Everything else we may as well
    just always include.

Interface should be as a user would expect for basic use case:
  ./configure, takes standard options, generates a Makefile.
  make, make install, make check, make clean does all the right things.

I still like the design proposal from before. Some questions:
* Should we make configure a shell script, so it can detect if we have tcl? Or
  is it okay to make it a tcl script directly, and leave that bit to the
  README? If we make it a shell script, I vote we have a configure.tcl script
  that we call into very soon in the process.

Anyway, what's the path to implement this?
1. Add manual config.tcl script and add features to that to make things
compile with the options I want.
2. Simplify and clean up the makefile to be what I want to generate.
3. Write configure script.

In terms of features, what's a good order? I don't think it matters too much
what order to do things in.

* make sdl optional.
* be able to change build directory.
* Add env variable overrides.
* add different ninja targets for make, make install, make check.
* Add install directory overrides.

Cool. Easy. No?

Where to start?

I feel like the option to build from a different directory would be a good
place to start.

So we have separate source and build directories that could be the same in
practice. The build directory contains config.tcl and Makefile. Everything
else is in the source directory to start.

What names should we give to these in terms of variables in the build script?
* Looks like VPATH is used for source path
* I also see: top_builddir, top_srcdir. Those seem like useful names to me.

I don't have recursive builds, so I think also fine to shorten to srcdir and
builddir.

So, immediate next steps would be:
* rename ::out to ::builddir.
* add a ::srcdir variable and start using it.
* define ::builddir and ::srcdir in config.tcl, source config.tcl in
  build.tcl, and remember to put a dependency of build.ninja on build.tcl.

Note: builddir will be same as current working directory. I'll just have to
get used to either building in place or build in a different directory.

---

Looks like Makefile will need access to $srcdir at least. How should I do
that? Via subst?

Is there an easy way to implement subst? Like, given a file, replace all
occurrences of @FOO@ in the file? Either from shell (sed?) or from tcl.
Ideally all in one go instead of one at a time.

Sed works fine. For example:

  sed -e s/@FOO@/foo/ -e s/@BAR@/bar/ foo.in > foo

---

Do I need make? It seems hard to wrap ninja in a make interface. How about we
just ask users to use ninja instead? So, instead of:

  ./configure && make

Users run:
  ./configure && ninja

To implement it, configure generates a skeleton build.ninja file that says it
should regenerate itself from build.tcl. Then you could do all fancy options
and direct targets.

The only real inconvenience for me would be setting makeprg properly in vim.
Could I add a local ninja command to my vim that says set makeprg to ninja and
then call make? Why even pretend to use make?

My thought:
* Let's use ninja without make. It's time to move on to an age where make no
  longer has dominance.
* I can set up personal vim commands, like Makef or some such that know the
  right directories and commands to use for building fble.

---

Some troubles with the implementation:
* Can we make it more robust against errors in build.tcl? Like, never put
  build.ninja into a bad state? You can always re-run configure. But maybe it
  would be better to generate build.ninja.full or some such, and then copy
  over the bootstrap build.ninja file only when the full one is done?

---

Initial sketch of configure && ninja is in place. I suspect a lot of corner
cases around when to rebuild things like configure, build.ninja, etc. When to
rerun configure?

Anyway, next step is make targets. I'm thinking at least default, check, and
eventually install. Any others, and anything more specific? I think default
should be anything that would be installed by install.

From GNU standard targets:

all - the entire program. This is default.
install - install executables, etc, and run a simple test to verify they are
  properly installed. Shouldn't modify anything after 'make all'.
install-<doc> for doc format.
uninstall - deletes installed targets.
install-strip - install with executable files stripped.
clean - delete files, except don't delete configuration or files included in
  the distributions.
distclean - Delete all files created by config and build of program, including
  config.
maintainer-clean - Delete everything that can possibly be rebuilt, except
  configure.
TAGS - for tags.
<doc> - Build info, dvi, html, pdf, ps, etc. These are not built by default.
dist - build a tar file.
check - run tests assuming program is built but not installed.
installcheck - run tests against installation.

Which ones do I want to start?
 - all, check.

I think that's good enough for now.

What if you run 'check' before running 'all'? The GNU doc suggests users
need to run all first. But what if you don't? Let's just build whatever needs
to be built for that.

---

What features to work on next? Brainstorm:
* install
* sdl enable/disable
* env vars for things like CC, FLAGS, etc.

---

First thing to install: fble-test in bindir.

Default prefix is /usr/local, override with --prefix=...
Bin dir via --bindir=..., default to <prefix>/bin

Do we support --prefix <...>, or just --prefix=<...>? Let's support both.

Approach:

* Define ::bindir in config.tcl.
* Add an install command for fble-test
  install fble/test/fble-test $::bindir
* Add support for parsing --prefix and --bindir options to configure.

---

How to get build dependencies right for configure?

* configure generates: config.tcl, build.ninja, Doxyfile.
* depending on: configure, config.tcl.in, build.ninja.in, Doxyfile.in
  And on whatever args were passed to configure.

Also, build.ninja depends on config.tcl.

So, what we need is a build rule to run configure to generate config.tcl and
have build.ninja depend on that. And we need to know the configure args to be
able to re-run configure automatically. But there's only one arg, and we know
what that is.

Do I want to bootstrap build.ninja? Or should I run build.tcl as part of
configure to initially generate build.ninja?

If we do it that way, then maybe configure is responsible for generating
build.ninja implicitly? In that case, is build.tcl the same as configure?

Otherwise, we need to have the dependencies right for rebuilding the bootstrap
ninja file, right?

I think I should try generating build.ninja in configure. It takes like no
time at all. Is there anything else we need after that? Everything works great
then, no?

---

Cleanup idea:

Now that we use a ::config namespace for all config options, why not use that
to iterate over all the options automatically to display the current options
and write out config.tcl?

In other words, the configure script sets up the ::config namespace, it
reports those entries to users, writes them out to config.tcl, and then
invokes build.tcl.

No need for config.tcl.in. No need for calling sed to do substition. Document
all the configuration options in the configure script.

Note, by the way, config.tcl is a great back door for users to manually craft
their configuration.

Let's try it.

