Fble Modules Revisited
----------------------
Yet another revisiting of modules. Specifically I want to work out the
appropriate language features and conventions to be used with modules to
address the following:

* Avoid introducing false dependencies.
  For example, I just added an Equals function to Map. That brings in a
  dependency on Bool that wasn't there before. And if I want to reuse EqMaybe,
  that would bring in a dependency on Maybe too. It was not obvious at the
  time how I could easily avoid that.

* Where to put different bits of code.
  For example, Foo vs. Foo_Tests vs. Foo/Tests, vs. Foo/Foo, Foo/Tests.
  I want to know how I ought to organize modules consistently. And clarify
  the conventional relationship is between a parent module and its children.
  Does the parent depend on the children? The children depend on the parent?
  Is there no conventional dependency relationship between parent and child?
  Are the children internal or public? Do they have access to internals or
  access to public stuff?

  For example, I would expect Foo/Tests not to have access to the internal
  data type for Foo, because they are testing the public API. But it's nice to
  put them in a subdirectory along with Foo just for organizational purposes.

* Abstract type support.
  I should be able to make types abstract, perhaps using the ?= statement
  suggested. But make sure this still allows me to give access to the
  definition of the type to multiple internal modules without giving access to
  the type externally.

* Add and test implementation support for private modules.


Proposal:
* How big a module is is determined by dependencies. If you use a module, you
  should only bring in dependencies you have to have to use the module. You
  shouldn't bring in other false dependencies.

* It should be possible to refine a large module into smaller submodules
  without users of the module noticing. Where the submodules can be private.
  This means a parent module has privileged access to its immediate children.

* If a module is marked as private, it produces private things.
  Ideas for how to mark a module as private:
   Foo!.fble
   Foo!/
   Foo._.fble
   Foo~.fble
   Foo~/ 
   Foo~

  Yeah, I like the last one. So if a file is Foo~.fble, the module Foo is
  marked as private. If a directory is Foo~/, it is marked as private. The
  module is referred to without the trailing tilde. There must not be both
  private and public versions of the same module.

* If a module is in a directory, it has privileged access to things in that
  directory and immediate child directories.

* Modules in the same directory are developed by the same developer.

* Use directories for organizing modules as well as privilege.
  For example, prefer Foo/Tests.fble over Foo_Tests.fble, just because it
  shows the relationship between the two better.


There are 4 kinds of modules, depending on whether they are privileged or not,
and whether they produce private stuff or not:

* private, privileged: put in subdirectory.
* private, non-privileged: put in subdirectory.
* public, privileged: put in subdirectory or at root.
* public, non-privileged: ??

My proposal, though this mixes up two different kinds of concerns, is to
group modules in the same directory that refer to the same thing, even if some
of those modules make use of privileged access while others don't.

Note: Any private stuff that needs to be shared by multiple modules must be
defined in a private module. You can only mix private and public in the same
module if only the public bits of that module are to be accessed.

Random idea: Could we use Foo/Tests.fble to say Tests does not have private
access to Foo~/FooInternal~.fble?  Uh... that looks confusing to me. It
suggests a module has the following:

  value
  privileged children - can access private children
  non-privileged children - can't access private children

In other words, we explicitly label the four kinds of children:
  privileged, private:      e.g. Foo~/FooInternal~.fble
  privileged, public:       e.g. Foo~/Data.fble
  non-privileged, private:  e.g. ???
  non-privileged, public:   e.g. Foo/Tests.fble

If that's the case, could we have two different symbols to track this in the
file system? Assume by default non-privileged, public? Then have, for example:

+ means privileged
- means private

So we have:
  Foo/Internal+-.fble
  Foo/Data+.fble
  Foo/Tests.fble

Or: '*' for read and write, '+' for read only, '-' for write only?
  Foo/Internal*.fble
  Foo/Data+.fble
  Foo/Tests.fble

Or: '-' for read and write. e.g. internal only private.
    '+' for public with private access.
        blank for public with public access.

That sounds like a nice proposal to me. Let's try it and see how it feels.
Then the only thing left is to figure out abstract data types.

---

When writing the spec for the above access controls, I realize having separate
privileged and non-privileged makes for an awkward situation.

If you just have public and private, then we assume a parent has private
access to its children and private access to its siblings. And children have
access to their parent.

If you add non-privileged, then there are two groups that a parent is involved
with: its children and its siblings. Then you need two specifications. Does it
have privileged access to its children? Does it have privileged access to its
siblings?

If all you get from privileged/non-privileged is an extra compile time check,
maybe it's not worth it? It doesn't really fit in the notion that a directory
is all owned by the same organization. It adds a strange corner case to the
spec.

Potentially you could work around it too, for example:

  Foo/
    Tests.fble
    Impl*/Impl.fble

Well, no. That doesn't really work. Because if Tests.fble doesn't have the
access it needs, neither does Foo. Unless Foo is just a re-export of an
internal module:
  
  Foo.fble        // re-exports Private.fble
  Foo/            
    Tests.fble    // uses Private.fble
    Private*.fble // re-exports API.fble
    Private*/
      Impl.fble
      API.fble
    
So yeah, worst case, using reexport, which is trivial, you could separate the
access into privileged and non-privileged just using directory structure with
public and private. My vote is to get rid of the notion of privileged and
non-privileged for the first implementation.

---

Experience Report: It feels like module organization is a hard problem.
Consider integers. I figure I want IntP, IntS, and Int. But IntP decrement
wants to use IntS and IntP subtraction wants to use Int. Then IntS division
wants to use Int subtraction, and so on. We end up with a long dependency
chain if we split everything up:

  IntP -> IntS -> Int -> IntP.Sub -> Int.Sub -> IntP.Div -> Int.Div

It is nice to have each module be a small focused thing. None of them really
have any private internal functions, so the only practical value at the moment
for using separate modules seems to be to separate them into small focused
things and for namespace support, so that we can have an Eq function for IntP,
an Eq function for IntS, and an Eq function for Int.

This is actually a deeper question I think. Is it better to define separate
IntP, IntS, and Int types that constrain the data type, or is it better to use
a generic Int type? It's certainly proving inconvenient to keep track of which
types all the functions are used for and converting between them when I have
IntP, IntS, and Int types.

Or: is it better to define these across a bunch of modules to avoid false
dependencies, or better to just define them all in one module and avoid the
headache of splitting them up?

---

Things I want to try to see how well they work:
* Lots of little modules. Because what, really, is the cost of that? I think
it's just being able to remember what module to import. It doesn't reduce the
number of import statements you would use.

* Don't require modules to all be imported at the top of the file. I'm not
convinced it adds much. For example, /Bool/Show%.Show is just as good or
better to use than locally defining ShowBool. Take a little more risk here and
see if it leads to any problems.

---

In practice, splitting things up into very fine modules hasn't caused me any
problems for things like separate Show, Eq, List/Sort, List/Length. It's nice
to have them separate. They are still organized. It doesn't really cost
anything in import statements in practice I don't think.

But I will say, picking between IntP@, IntS@, and Int@ is annoying. For
example, I want to print the number of tests ran, passed, and failed in the
test runner. A simple thing like computing passed = ran - failed suddenly runs
into problems if I'm using IntS@ as the type instead of Int@.

---

Experience after a fair bit of time has gone by:
* Little modules are fine and nice. Slightly inconvenient sometimes to
  remember where something is defined, and in the case of Abs, I ended up
  defining it twice in two different places. Otherwise, I like it.
* For the Int@ question, I'm very much trending towards always use Int@, and
  think of IntP@ and IntS@ as internal implementation detail. The potential
  runtime savings are not worth the inability to easily compose functions
  involving IntP@, IntS@, and Int@.

---

Now that we've added an initial form of abstract types to fble, it begs
revisiting modules. Some time back I removed support for expressing and
controlling access to private modules, because it seemed messy and worth
revisiting later rather than maintaining. I think now is a good time to
revisit, at least in thought, what to do about modules.

Modules are many things, which makes it confusing at times:
* A way to load things without bringing in unused dependencies.
* A way to organize code.
* A way to control who has access to what parts of code, primarily to make it
  possible to update the internal implementation of a module without breaking
  users.
* A way to package, share, and deliver code to users?
* A way to improve compilation times?
* A way to deliver code to users without sharing source code?

Conceptually an organization wants to deliver a collection of modules, call it
a package. A package ideally is hierarchical, i.e. made up of a number
of sub-packages delivered by sub-organizations. The package will include
public interface modules and internal modules used in the implementation of
the public interface.

Organizations will want to be able to update their package and make new
releases. Users will want to download new releases compatible with their code
and switch to using those. Users may want to make use of packages X and Y that
both depend on package Z, and share the package Z between X and Y instead of
duplicating it.

Packages will depend on other packages at particular versions or ranges of
versions. You probably want it to be possible to have more than one version of
a package at a time in the same executable, for example if X depends on Z
version 1 and Y depends on Z version 2, and you want both X and Y in the same
program.

Package management sounds hard. Does it make sense to make it a part of the
language, or does it make sense to let people use whatever package management
mechanism they want? Let's do a survey of some existing languages.

C/C++
  Tends to rely on OS distribution for package management. You ship a library,
  user has to download the write version of the library. pkgconfig can help
  organize things a little bit.

Python
  Has a whole bunch of stuff. It looks confusing and complicated.

Let's look at this another way. What's important for me as a developer is:
* Can I easily install packages I can compile against for development of my
  package?
* Can I easily publish my package for others to install?
* Note that distributing libraries may have different requirements than
  distributing end applications.

From the language point of view, you are writing source code. Your source code
refers to types and entities of the package you want to use. You should only
be able to access public entities of the package in your source code. You
should have a way to describe what is public or private to your package.

How do you know what is exported by the package? I have this idea that
anything private to the package can just be omitted from the public
interface. For example, you compile in internal stuff when compiling your
package, but don't let users have access to that internal stuff when using
your package. But you don't always want to compiler your dependencies into the
package. If you use a common library, you want users to provide the library.

So, what is a package?
* An interface for use in compiling source code.
* An implementation for use in running
 - depends on if you run with interpreter or native machine code for example.
* A list of dependencies your package has that the user is responsible for
  providing.

In fble, I suppose module is the link unit. You link against modules, not
functions. That means at runtime you access the module value, and if it is a
struct, any entities inside it.

So we could use something like an ELF format, where there are public and
private symbols, for public and private modules.

That suggests we may want to have multiple modules compiled to a single
library file. As it gets bigger, we would want to have multiple library files
representing a collection of packages.

How do we generate these library files? Because that's where we will want to
specify what is public and private. And we'll want some way to specify the
interface to a package.

Perhaps I can think of fble as responsible for describing a single module. And
we want some other language or mechanism for describing how to compile modules
together into reusable packages. That other mechanism is where we would
specify what modules are public or private.

---

ld has an option --exclude-libs which I think can be used to mark certain
modules as internal only. For example, we could link together a bunch of .o
files for compiled modules using ld, and indicate then which modules are
public and which modules are private. If we distribute the resulting .so file
as a package, then you can only access exported modules.

It would be strange if your program could compile but not link though. The
compiler needs to know types for all the modules you reference. How can it get
that information?

I think the original plan for module compilation was to have the compiler
generate Foo.fble.@ files describing the type of a module using restricting
fble syntax that doesn't allow for module references. If we have that, then
when we distribute a package, we could distribute a .so file with the compiled
code and a collection of Foo.fble.@ files, where we remove .@ files for
internal modules.

There is a subtle consequence to this approach: access to internal modules is
no longer based on location in the hierarchy. It's based on an explicit list
of things when compiled. In other words, you have visibility to everything you
are compiled together with. That seems entirely reasonable to me. The
assumption being the group of modules you are compiled with is the same group
of modules that a single organization has sufficient control over.

I don't necessarily want elf files to be part of the language spec. That
depends very much on the language implementation. If you are using an
interpreter, you would want .fble source files, including internal modules, as
part of the package distribution. Or maybe compile to some other format the
interpreter understands.

I guess the question for packages in fble is what I want to include as part of
the language specification in terms of package formats.

