
@ Bool@ = /Bool%.Bool@;
% True = /Bool%.True;
% False = /Bool%.False;
% And = /Bool%.And;
% Or = /Bool%.Or;
% Not = /Bool%.Not;

% Inc = /Int/Int%.Inc;

<@>@ List@ = /List%.List@;

<@>@ Maybe@ = /Maybe%.Maybe@;
<@>% Just = /Maybe%.Just;
<@>% Nothing = /Maybe%.Nothing;

@ Coord@ = /Hwdg/Coord%.Coord@;
@ Data@ = /Hwdg/Data%.Data@;

@ Memory@ = /Hwdg/Memory%.Memory@;
% Get = /Hwdg/Memory%.Get;
% Set = /Hwdg/Memory%.Set;
% Clear = /Hwdg/Memory%.Clear;

# PortSpec@ --
#   Describes how a given port is used in a gate.
@ PortSpec@ = *(Bool@ input, Bool@ output);
PortSpec@ InputPort = PortSpec@(True, False);
PortSpec@ OutputPort = PortSpec@(False, True);
PortSpec@ IOPort = PortSpec@(True, True);
PortSpec@ UnusedPort = PortSpec@(False, False);

<@>@ Ports@ = <@ T@> { *(T@ ul, T@ ur, T@ ll, T@ lr); };

# GateFunction@ --
#   Describes the behavior of a gate when it is triggered. The input is the
#   data value for each port, where 0 is passed for any non-input port. The
#   output is a new data value for each port, where values for non-output
#   ports are ignored. This allows us to have a uniform gate function
#   specification regardless of how the gate's ports are configured as
#   input/output/unused ports.
@ GateFunction@ = (Ports@<Data@>) { Ports@<Data@>; };

@ Gate@ = *(Ports@<PortSpec@> ports, GateFunction@ function);

@ GateEntry@ = *(Coord@ coord, Gate@ gate);
@ Gates@ = /List%.List@<GateEntry@>;

# EmptyGates --
#  An empty array of gates.
Gates@ EmptyGates = /List%.Nil<GateEntry@>;

# SetGate --
#   Configure the gate whose upper left corner is at the given coordinates of
#   the layout.
(Gates@, Coord@, Gate@) { Gates@; }
SetGate = (Gates@ gates, Coord@ coord, Gate@ gate) {
  /List%.Cons<GateEntry@>(@(coord, gate), gates);
};

# Gates --
#   Specify a complete Gates configuration.
#
# Example Use:
#   Gates@ gates = Gates(List<GateEntry@>[@(coord: c1, gate: g1), @(coord: c2, gate: g2), ...]);
(List@<GateEntry@>) { Gates@; } Gates = (List@<GateEntry@> l) { l; };

# ForEachGate --
#   Iterate over a set of gates.
#
# Conceptually:
#   B@ b = base
#   foreach (coord, gate) in gates:
#     b = body(coord, gates, b)
#   return b
<@ B@>(Gates@, B@, (Coord@, Gate@, B@) { B@; }) { B@; }
ForEachGate = <@ B@>(Gates@ gates, B@ base, (Coord@, Gate@, B@) { B@; } body) {
  /List%.ForEach<GateEntry@, B@>(gates, base, (GateEntry@ ge, B@ b) {
    body(ge.coord, ge.gate, b);
  });
};

# Step --
#   Run a single step of the hardware.
#
# Returns the update data cells, or Nothing if no gates are enabled. The exact
# meaning of a single step is not currently well specified.
#
# TODO: Test and fix the case when conflicting gates are simultaneously
# enabled.
(Gates@, Memory@) { Maybe@<Memory@>; } Step = {
  (PortSpec@, Maybe@<Data@>) { Bool@; } Blocked = (PortSpec@ ps, Maybe@<Data@> d) {
    Bool@ empty = d.?(just: False, nothing: True);
    And(ps.input, empty).?(true: True);
    And(ps.output, And(Not(ps.input), Not(empty)));
  };

  (PortSpec@, Maybe@<Data@>) { Data@; } InputData = (PortSpec@ ps, Maybe@<Data@> d) {
    Not(ps.input).?(true: /Hwdg/Data%.0);
    d.?(nothing: /Hwdg/Data%.0);
    d.just;
  };

  @ B@ = *(Memory@ cells, Bool@ updated);
  (B@, Coord@, PortSpec@, Data@) { B@; } UpdateResult = (B@ b, Coord@ c, PortSpec@ ps, Data@ d) {
    ps.output.?(true: @(cells: Set(b.cells, c, d), updated: True));
    ps.input.?(true: @(cells: Clear(b.cells, c), updated: True));
    b;
  };

  (Gates@ gates, Memory@ cells) {
    B@ b = ForEachGate<B@>(gates, B@(cells, False),
      (Coord@ c, Gate@ g, B@ b) {
        Ports@<Coord@> coords = Ports@<Coord@>(
          Coord@(c.x, c.y),
          Coord@(Inc(c.x), c.y),
          Coord@(c.x, Inc(c.y)),
          Coord@(Inc(c.x), Inc(c.y)));

        Ports@<Maybe@<Data@>> data = Ports@<Maybe@<Data@>>(
          Get(cells, coords.ul), Get(cells, coords.ur),
          Get(cells, coords.ll), Get(cells, coords.lr));

        Bool@ blocked_ul = Blocked(g.ports.ul, data.ul);
        Bool@ blocked_ur = Or(blocked_ul, Blocked(g.ports.ur, data.ur));
        Bool@ blocked_ll = Or(blocked_ur, Blocked(g.ports.ll, data.ll));
        Bool@ blocked_lr = Or(blocked_ll, Blocked(g.ports.lr, data.lr));

        blocked_lr.?(
          true: b,
          false: {
            Ports@<Data@> inputs = Ports@<Data@>(
              InputData(g.ports.ul, data.ul),
              InputData(g.ports.ur, data.ur),
              InputData(g.ports.ll, data.ll),
              InputData(g.ports.lr, data.lr));

            Ports@<Data@> outputs = g.function(inputs);
            B@ b_ul = UpdateResult(b, coords.ul, g.ports.ul, outputs.ul);
            B@ b_ur = UpdateResult(b_ul, coords.ur, g.ports.ur, outputs.ur);
            B@ b_ll = UpdateResult(b_ur, coords.ll, g.ports.ll, outputs.ll);
            B@ b_lr = UpdateResult(b_ll, coords.lr, g.ports.lr, outputs.lr);
            b_lr;
          });
      });
    b.updated.?(true: Just<Memory@>(b.cells), false: Nothing<Memory@>);
  };
};

# Run --
#   Run the given hardware layout as long as any gates are enabled.
(Gates@, Memory@) { Memory@; } Run = (Gates@ gates, Memory@ cells) {
  Maybe@<Memory@> mc = Step(gates, cells);
  mc.?(just: Run(gates, mc.just), nothing: cells);
};

@(Gates@, GateEntry@, Gate@, Ports@, PortSpec@,
  InputPort, OutputPort, IOPort, UnusedPort,
  EmptyGates, Gates, SetGate, ForEachGate,
  Step, Run);
