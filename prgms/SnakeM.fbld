mdefn SnakeM(SnakeI) {
  using UnitM { Unit; };
  using BoolM { Bool; True; False; And; };
  using UBNatM { Nat; 0; 1; 2; 6; Lit2; Eq; Inc; Dec; };
  using DrawM { Color; Draw; };
  using ListM { P; S; InitP; LastP; };

  func MinRow( ; Nat) 0();
  func MaxRow( ; Nat) Lit2(2(), 0());
  func MinCol( ; Nat) 0();
  func MaxCol( ; Nat) Lit2(6(), 0());

  struct Pos(Nat row, Nat col);

  func EqPos(Pos a, Pos b; Bool) {
    And(Eq(a.row, b.row), Eq(a.col, b.col));
  };

  union Direction(Unit up, Unit down, Unit left, Unit right);
  union Input(Direction dir, Unit tick);


  union Cell(Unit empty, Unit snake, Unit food);

  func DrawCell(Pos pos, Cell cell ; Draw) {
    Color c = ?(cell; Color:black(Unit()),
                      Color:blue(Unit()),
                      Color:green(Unit()));
    Draw(pos.col, pos.row, 1(), 1(), c);
  };


  # State --
  #   The state of the game.
  # 
  # Fields:
  #   dir - The current direction of the snake.
  #   food - The current position of the food.
  #   nfood - The position of the next food.
  #   snake - The positions of the snake, in order from head to tail.
  struct State(Direction dir, Pos food, Pos nfood, P<Pos> snake);

  func DrawSnakeS(S<Pos> s ; S<Draw>) {
    ?(s; S<Draw>:nil(Unit()), S<Draw>:cons(DrawSnakeP(s.cons)));
  };

  func DrawSnakeP(P<Pos> s ; P<Draw>) {
    P<Draw>(DrawCell(s.head, Cell:snake(Unit())), DrawSnakeS(s.tail));
  };

  func DrawState(State s ; S<Draw>) {
    S<Draw>:cons(P<Draw>(DrawCell(s.food, Cell:food(Unit())),
    S<Draw>:cons(DrawSnakeP(s.snake))));
  };

  func InitialState( ; State) {
    Nat c0 = MinCol();
    Nat c1 = Inc(c0); Nat c2 = Inc(c1);
    Nat c3 = Inc(c2); Nat c4 = Inc(c3);
    Nat r0 = MinRow();
    Nat r1 = Inc(r0); Nat r2 = Inc(r1);
    Nat r3 = Inc(r2); Nat r4 = Inc(r3);
    State(
        Direction:right(Unit()),
        Pos(r4, c1),
        Pos(r1, c0),
        P<Pos>(Pos(r1, c4), S<Pos>:cons(P<Pos>(
             Pos(r1, c3), S<Pos>:cons(P<Pos>(
             Pos(r1, c2), S<Pos>:cons(P<Pos>(
             Pos(r1, c1), S<Pos>:nil(Unit())))))))));
  };

  struct MoveResult(State state, S<Draw> draw);
  union MoveResultM(Unit dead, MoveResult mr);

  union PosM(Unit dead, Pos pos);

  # Return true if the given position is found in the list of positions.
  func InPosS(S<Pos> s, Pos p ; Bool) {
    ?(s ; False(), InPosP(s.cons, p));
  };

  # Return true if the given position is found in the list of positions.
  func InPosP(P<Pos> s, Pos p ; Bool) {
    ?(EqPos(s.head, p); True(), InPosS(s.tail, p));
  };

  func Move(State s; MoveResultM) {
    PosM pm = ?(s.dir;
      ?(Eq(s.snake.head.row, MaxRow()); PosM:dead(Unit()), 
          PosM:pos(Pos(Inc(s.snake.head.row), s.snake.head.col))),
      ?(Eq(s.snake.head.row, MinRow()); PosM:dead(Unit()), 
          PosM:pos(Pos(Dec(s.snake.head.row), s.snake.head.col))),
      ?(Eq(s.snake.head.col, MinCol()); PosM:dead(Unit()), 
          PosM:pos(Pos(s.snake.head.row, Dec(s.snake.head.col)))),
      ?(Eq(s.snake.head.col, MaxCol()); PosM:dead(Unit()), 
          PosM:pos(Pos(s.snake.head.row, Inc(s.snake.head.col)))));
    ?(pm; MoveResultM:dead(Unit()),
        ?(EqPos(pm.pos, s.food);
            {
              # TODO: Properly handle the case where the snake eats food at its
              # tail.
              P<Pos> nsnake = P<Pos>(s.food, S<Pos>:cons(s.snake));
              State ns = State(s.dir, s.nfood, s.nfood, nsnake);
              S<Draw> draw = S<Draw>:cons(P<Draw>(DrawCell(s.food, Cell:snake(Unit())),
                           S<Draw>:cons(P<Draw>(DrawCell(s.nfood, Cell:food(Unit())),
                           S<Draw>:nil(Unit())))));
              MoveResultM:mr(MoveResult(ns, draw));
            },
            ?(InPosP(s.snake, pm.pos); MoveResultM:dead(Unit()),
              {
                # TODO: Combine calls to Init and Last so we only have to
                # iterate over the list of elements once instead of twice?
                P<Pos> nsnake = P<Pos>(pm.pos, InitP<Pos>(s.snake));
                Pos nfood = LastP<Pos>(s.snake);
                State ns = State(s.dir, s.food, nfood, nsnake);
                S<Draw> draw = S<Draw>:cons(P<Draw>(DrawCell(pm.pos, Cell:snake(Unit())),
                             S<Draw>:cons(P<Draw>(DrawCell(nfood, Cell:empty(Unit())),
                             S<Draw>:nil(Unit())))));
                MoveResultM:mr(MoveResult(ns, draw));
              })));
  };

  proc Snake(Input- in, S<Draw>+ out; State s ; Unit) {
    Input x = -in();
    ?(x; Snake(in, out; State(x.dir, s.food, s.nfood, s.snake)),
         {
             MoveResultM m = $(Move(s));
             ?(m;
                $(Unit()),
                {
                   S<Draw> drawn = +out(m.mr.draw);
                   Snake(in, out; m.mr.state);
                });
         });
  };

  proc Main(Input- in, S<Draw>+ out; ; Unit) {
    State s = $(InitialState());
    S<Draw> drawn = +out(DrawState(s));
    Snake(in, out; s);
  };
};
