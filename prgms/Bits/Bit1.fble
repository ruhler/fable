@(BitN@, StdLib, Bit) {
  StdLib { @(Unit@, Bool); };
  Bool { @(Bool@, True, False); };
  Bit { @(Bit@); };

  @ Result@ = *(Bit@ z, Bit@ cout);

  \(Bit@; Bit@) not = \(Bit@ a) {
    ?(a; 0: Bit@(1: Unit@()), 1: Bit@(0: Unit@()));
  };

  \(Bit@, Bit@; Bit@) and = \(Bit@ a, Bit@ b) {
    ?(a; 0: a, 1: ?(b; 0: b, 1: a));
  };

  \(Bit@, Bit@; Bit@) or = \(Bit@ a, Bit@ b) {
    ?(a; 0: ?(b; 0: a, 1: b), 1: a);
  };

  \(Bit@, Bit@; Bit@) xor = \(Bit@ a, Bit@ b) {
    ?(a; 0: b, 1: not[b]);
  };

  \(Bit@, Bit@, Bit@; Result@) fulladd = \(Bit@ a, Bit@ b, Bit@ cin) {
    ?(xor[a][b]; 0: Result@(cin, a), 1: Result@(not[cin], cin));
  };

  \(Bit@, Bit@; Bit@) add = \(Bit@ a, Bit@ b) {
    fulladd[a][b][Bit@(0: Unit@())].z;
  };

  Bit@ zero = Bit@(0: Unit@());

  \(Bit@; Bool@) iszero = \(Bit@ a) {
    ?(a; 0: True, 1: False);
  };

  \(Bit@, Bit@; Bool@) eq = \(Bit@ a, Bit@ b) {
    ?(a; 0: ?(b; 0: True, 1: False),
        1: ?(b; 0: False, 1: True));
  };

  \(Bit@; Bit@) msb = \(Bit@ a) {
    a;
  };

  \(Bit@; Bit@) clshift = \(Bit@ a) {
    a;
  };

  \(Bit@, Bit@; Result@) lshift = \(Bit@ a, Bit@ cin) {
    Result@(cin, a);
  };

  BitN@<Bit@>(not, and, or, xor, add, zero, iszero, eq, msb, clshift, fulladd, lshift);
};
