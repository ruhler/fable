Damocrates is a meta-language built on top of Androcles, Bathylus, and Calvisus
designed to be programmed by human, with features for modularity and
development.

Damocrates should be statically compilable into Androcles/Bathylus/Calvisus.
Abstractions introduced by the Damocrates language should be zero-cost in the
sense that they will have no overhead at runtime after compiling the program
down to Androcles/Bathylus/Calvisus. The developer should not have to make a
tradeoff between modularity/abstraction and runtime performance.

Overview
--------
Damocrates adds support for modularity and polymorphism on top of the
Calvisus language. The purpose of these features is to facilitate reuse of
code across multiple programs, expanding the scale of programs that can be
developed.

Fbld shifts a focus on implementing programs that exists in fblc to a focus on
implementing reusable pieces of programs. These pieces of programs are called
modules and include type, function, and process definitions.

For example, many programs make use of some form of integer arithmetic. Rather
than re-implement and re-test integer arithmetic for each program, a single
integer arithmetic module can be developed and reused. The integer arithmetic
module will define an integer type and functions that operate on integer
values.

To effectively reuse a piece of code, it must be very easy to understand what
that code does at a high level and how it should be used; it should not be
import to understand implementation details of the code. Fbld has the notion
of a module interface, which provides an abstract view of the code provided by
a module to make it easy to understand what the code does at a high level and
how to use it without having to understand excess implementation details.

For example, the integer arithmetic module could be used knowing there is some
type Int with operations to add two Ints together, but the user need not know
whether the Int type is implemented using a unary, binary, 2s-complement or
other representation.

Interfaces allow modules to be developed independent of their use and reused
independent of their development. Modules can be understood and developed in
isolation then combined to form large programs that would otherwise be too
complex and costly to develop.

Interfaces make it possible to write code that is agnostic to the details of
how types, functions, and processes are defined and implemented. To take full
advantage of this, fbld supports polymorphic interfaces and modules, which
allows the code to be reused in multiple different contexts with different
definitions of the types, functions, and processes it interfaces with within
the same program. Polymorphism is supported by having interfaces be
parameterized by types and having modules parameters by types and other
modules.

For example, there are common data structures, such as lists, which can be
used with many different element types. Fbld's polymorphism allows an
interface to be defined that is a function of a given type parameter. For
example, a single List interface can be defined that is used for lists of
Ints, Lists of booleans, Lists of Lists, or any other type. This is a form of
parametric polymorphism.

As another example, some computation involving numbers can be defined that
works on any type of number satisfying a required set of operations. A module
involving polynomials, for example, could be reused with natural numbers,
integers, real numbers, or booleans. This is a form of ad-hoc polymorphism.

Concepts
--------
Fbld adds two new top level constructs to fblc: modules and interfaces. All
type, function, and process declarations occur within modules.

A module defines a collection of types, functions, and processes that are
parameterized by any number of types and any number of other modules. Each
implements some interface.

An interface is an abstraction of a module that includes only type, function,
and process declarations, without their implementations. For a module to
properly implement an interface, every type, function, and process declared in
the interface must have a corresponding implementation supplied by the module.

Interfaces
----------
mtype <interface_name> '<' <type_parameters> '>' {
  <interface_declarations>
};

Interfaces are named. They take zero or more type parameters, and contain zero
or more interface_declaration elements. Type parameters are specified using a
comma-separated list of simple names. These names can be used within the
interface_declarations to refer to the types passed to the interface when the
interface is instantiated.

Angle brackets are used to denote interface and module parameters, analgous to
how parentheses are used to denote function patameters.

There are 6 kinds of interface_declaration items: using, type, struct, union,
func, and proc.

Qualified References
-^^^^^^^^^^^^^^^^^^^
The struct, union, func, and proc declarations are as in fblc, except that
references to types, functions, and processes can be qualified using the
syntax <name>@<mref>. For example, to refer to a function 'True' in a module
named Bool that takes no type or module parameters:
   True@Bool<;>

If the module takes type or module parameters, those can be specified as well.
For example, the following references the contains function for a hash map
from Ints to Strings that uses the IntHash module to compute the hash.
   contains@HashMap<Int@Int<;>, String@String<;> ; IntHash<;>>

The 'using' declaration described later can greatly reduce the quantity of
syntax needed to describe references to external entities.

Interfaces and modules must not recursively reference any other modules. In
other words, the graph of interface and module dependencies should be a
directed acyclic graph. The reason for this is to avoid complex and confusing
module dependencies.

Abstract Type Declarations
^^^^^^^^^^^^^^^^^^^^^^^^^^
The 'type' declaration is used to declare an abstract type that is defined
internally by modules implementing the interface. For example:

   type Int;

Defines an abstract Int type. The 'Int' type can be used anywhere a type is
expected. Values of abstract types cannot be used as objects of member access
or arguments to conditional expressions or processes.

Using Declarations
^^^^^^^^^^^^^^^^^^
The 'using' declaration provides a syntactic sugar to make it easier to refer
to entities declared within another module. Each 'using' declaration creates
a simple local alias for one or more entities from an another module.

By default entities are imported using the same name they are declared with,
but it is possible to specify an alternate name when importing an entity in
order to avoid name conflicts.

For example:
  using Bool<;> { Bool; true=True; false=False; };

The above statement imports three entities from the Bool module. In this case
the Bool module does not have any type parameters, so no type arguments are
provided. If the module has type parameters, then type arguments must be
specified for every type parameter. The entities that are imported are
specific to the type arguments provided.

Following the module is a list of entities to give local names to, each entity
terminated with a semicolon. The entity can either be a single name,
indicating that entity from the module is being imported under its same name,
and can be referred to elsewhere by that simple name. Or the entity can have
the form 'name' = 'name', where the first name is the name the entity is
imported under, and the second name is the name of the entity as declared in
the module it is being imported from.

As a more complex example, consider a polymorphic List implementation, which
is reused both as an integer list and a boolean list. This entities from the
List implementation would need to be imported using multiple 'using'
declarations, with different names chosen to avoid name conflict:
  using List<Int;> { IntList=List; IntHead = head; IntTail = tail; };
  using List<Bool;> { BoolList=List; BoolHead = head; BoolTail = tail; };

The result is as if two types IntList and BoolList have been defined and four
functions, IntHead, IntTail, BoolHead, and BooLTail have been defined and can
be referenced from elsewhere in the interface.

Here is an example of of importing from a module with module parameters:
  using HashMap<Int, String ; IntHash<;>> { Map; };

It is legal to have multiple using statements for the same concrete module and
to import the same external entity multiple times under the same or different
names, either within a single using statement or spanning across multiple
using statements for the same concrete module. It is not required to have a
using statement for all references to external entities.

Modules
--------
mdefn <module_name> '<' <type_parameters> ; <module_parameters> ; <interface> '>' {
  <module_declarations>
};

Module are named. Modules have type parameters and module parameters. The type
paramaters are as in interfaces, a comma separate list of simple names of
types that can be referred to from within the module.

Module names belong to a different namespace than interface names. It is
acceptable to have a module with the same name as an interface. This is common
practice for interfaces that are expected to have a single implementation.

Each module parameter is specified as an interface and a module parameter
name. The module parameter can be used by providing any concrete module that
implements the given interface. Module parameters may refer to the type
parameters of the module.

Each module has a single interface type.

Every module implements a specific interface. This means the module will
provide definitions for all components declared in the interface. The
concrete interface specification can refer to type parameters and module
parameter types.

Here are some examples of the initial parts of module definitions, called
module declarations:

A Bool module implementing a Bool interface with no parameters:
  mdefn Bool< ; ; Bool<>>;

A Maybe module implementing the Maybe interface with type parameter T:
  mdefn Maybe<T ; ; Maybe<T>);

HashMap and TreeMap modules, parameters by the key and value type, and with
module parameters to compute the hash value or compare key values as
appropriate. Both of these modules implement the same Map interface:
  mdefn HashMap<K, V; Hash<K;> hash; Map<K, V>>;
  mdefn TreeMap<K, V; Ord<K;> ord; Map<K, V>>;

A module that implements a specific kind of interface without being fully
polymorphic:
  mdefn BoolHashMap<V; ; Map<Bool@Bool<;>, V>>;

Following the module declaration is a list of module declaration items. These
include 'using', 'struct', 'union', 'func', and 'proc' declarations. The
'using' declaration is as for module interfaces. The 'union', 'func', and
'proc' declarations are as for fblc with additional support for qualified
references to external entities.

Syntax Reference
----------------
  mtype ::= 'mtype' mname '<' [tname [',' tname [...]]] '>' '{'
                [mtype_decl [mtype_decl [...]]] '}' ';' ;

  mdefn ::= 'mdefn' mname '<' [tname [',' tname [...]]] ';'
                              [mref [',' mref [...]]] ';'
                              iref '>' {
                [mdefn_decl [mdefn_decl [...]]] '}' ';' ;

  iref ::= mname '<' [qname [',' qname [...]]] ')' ;
  mref ::= mname '<' [qname [',' qname [...]]] '; [mref [',' mref [...]]] ')' ;

  qname ::= tname ['@' mref] ;
  
  mtype_decl ::= 'type' tname ';'
              |  'using' mref '{' [tname ['=' tname]; [tname ['=' tname]; [...]]] '}' ';'
              |  'struct' tname '(' [qname fname [',' qname fname [...]]] ')' ';'
              |  'union' tname '(' [qname fname [',' qname fname [...]]] ')' ';'
              |  'func' tname '(' [qname vname [',' qname vname [...]]] ';' qname ')' ';'
              |  'proc' tname '('
                    [qname polarity pname [',' qname polarity pname [...]]] ';'
                    [qname vname [',' qname vname [...]]] ';' qname ')' ';'
              ;

  mdefn_decl ::= 'using' mref '{' [tname ['=' tname]; [tname ['=' tname]; [...]]] '}' ';'
              |  'struct' tname '(' [qname fname [',' qname fname [...]]] ')' ';'
              |  'union' tname '(' [qname fname [',' qname fname [...]]] ')' ';'
              |  'func' tname '(' [qname vname [',' qname vname [...]]] ';' qname ')' expr ';'
              |  'proc' tname '('
                    [qname polarity pname [',' qname polarity pname [...]]] ';'
                    [qname vname [',' qname vname [...]]] ';' qname ')' proc ';'
              ;

  mname ::= name ;  (* A name referring to an interface or module *)

  expr ::= ... (* as in fblc, with qname in place of tname *)
  proc ::= ... (* as in fblc, with qname in place of tname *)

  polarity ::= ... (* as in fblc *)
  fname ::= ... (* as in fblc *)
  pname ::= ... (* as in fblc *)
  tname ::= ... (* as in fblc *)
  vname ::= ... (* as in fblc *)
