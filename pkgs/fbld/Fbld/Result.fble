
@ String@ = /Core/String%.String@;

@ Unit@ = /Core/Unit%.Unit@;
% Unit = /Core/Unit%.Unit;

@ Loc@ = /Fbld/Loc%.Loc@;

@ Text@ = /Fbld/Text%.Text@;
% Text = /Fbld/Text%.Text;

# Having an option for an 'unknown' error makes it possible to avoid extra
# allocations at runtime in case we don't care about the error message.
@ Error@ = +(Unit@ unknown, Text@ message);

# A result of an operation that may fail.
<@>@ Result@ = <@ T@> { +(T@ ok, Error@ err); };

<@ T@>(T@) { Result@<T@>; } Ok = <@ T@>(T@ x) {
  Result@<T@>(ok: x);
};

# Assuming the given result is an error, change its type.
# Behavior is undefined if the provided result isn't an error.
<@ B@><@ A@>(Result@<A@>) { Result@<B@>; }
Raise = <@ B@><@ A@>(Result@<A@> r) {
  Result@<B@>(err: r.err);
};

# Indicate an error with text error message. 
<@ T@>(Text@) { Result@<T@>; }
Error_ = <@ T@>(Text@ e) {
  Result@<T@>(err: Error@(message: e));
};

# Indicate an error with location and string error message.
<@ T@>(Loc@, String@) { Result@<T@>; }
Err = <@ T@>(Loc@ l, String@ msg) {
  Error_<T@>(Text(l, msg));
};

# Indicate an error with no error message.
<@ T@> { Result@<T@>; }
Fail = <@ T@> {
  Result@<T@>(err: Error@(unknown: Unit));
};

<@ T@>(T@) { Result@<T@>; } Return = Ok;

<@ A@>(Result@<A@>)<@ B@>((A@) { Result@<B@>; }) { Result@<B@>; }
Do = <@ A@>(Result@<A@> ra)<@ B@>((A@) { Result@<B@>; } f) {
  ra.?(err: Raise<B@>(ra));
  f(ra.ok);
};

/Core/Monad%.Monad@<Result@> Monad = @(return: Return, do: Do);

@(Result@, Error@, Ok, Raise, Error_, Err, Fail, Monad);
