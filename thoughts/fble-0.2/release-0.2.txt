Fble Release 0.2
================

Too early days to think about a release, but we can think about what to work
on. Priority should be writing some serious fble apps. I propose the
following:

* fbld - implement it in fble. I bet some interesting things come out of this.
* sat - improve the sat solver. Maybe from what we learn we could implement a
  decent enough sat solver in C for smten?
* png viewer.
* floating point benchmark game.
* Hardware language something or other.

That is plenty to keep me busy. It won't stress the language too much. Once we
are done with those we can think about stressing the language with things like
persistent storage and other OS related functionality.

Next question is: which of these to focus on first? Because I'll have trouble
if I try to do them all at once.

My vote is: get some work in on sat, and think about fbld in the background.
Worry about png, floating point, and hardware language something or other
later.

---

We've come far enough now I think it's time to focus on getting the next
release out. In particular, this release has a lot of work done on the sat
solver and fbld applications in fble. The main fble language improvements are
performance, struct copy, and stack size.

There's a long way to go to clean up loose ends to get the release out. All
the more reason to switch focus on release instead of thinking about new
topics.

Documentation is the biggest thing. Getting parity with what we had before we
replaced the fbld implementation:

* Rewrite the fbld spec.
* Fix issues with generated documentation.
* Support for syntax highlighting.
 - Which may want improvements to html escaping.

---

Question on how to set tabstop/shiftwidth for .fbld files:
* I want shiftwidth=1 so that '>>' indents by one space.
* I want tabstop or softtabstop=1 so that tab is one space?

But you can always use space for that. And what if I want to go over faster
than one space at a time? I think better for tab to do whatever the user
prefers. Maybe they want it for traversing into the document, not for
indenting level by level.

It sounds like 'smarttab' is an option to have tab at the beginning of a line
behave like shiftwidth. That suggests tabstop really should be user
preference, but we may want to define shiftwidth.

README.txt for ftplugin says it should not set shiftwidth, which is a
personal preference. I think fbld is slightly difference in that it assumes
single space indent. Most other languages let users pick their own indent. So
I think it's okay to ignore the 'personal preference' part of that.

"The default filetype plugin files contain settings that 95% of the users will
want to use.".

shiftwidth is clearly not syntax. So it shouldn't go into the syntax file.

Is shiftwidth part of indent? It sounds like no. The job of 'indent' is to
figure out number of spaces to indent a new line given the setting of
shiftwidth.

So, proposal is: set shiftwidth=1 in ftplugin.

---

Should we compress man pages on install?
* Does that add a dependence on gzip we wouldn't otherwise need?
* How much space does it save?
  Without compression today: 582K for all man pages.
  With compression today: 528K for all man pages.
  So not really much improvement. I have a lot of short man pages.
* Is there anything about it being standard to be compressed or not?
  There's nothing in GNU standard about compressing them. The author of the
  gnu coding standards clearly doesn't like man pages.

I don't think the 54K savings is worth taking a dependency on gzip. Let's skip
the idea of compressing man pages until some decent motivation comes along.

---

Decision on empty path for package types:
* Have a special syntax %() for 'any module' package type.
* Continue to require / WORD ... / %  for module path.

Because you can imagine for testing purposes or uniformity, we want to have a
package path that doesn't restrict who can access it. But it doesn't make
sense to have module paths like /% or /foo//bar%.

---

Todo burndown item: 
* Warn about unused arguments in function values?

It should be trivial to implement. I'm just not sure if it makes sense to do.
Does it provide any value to the user? Or is it just tedious having to add _
for every function value that's not used?

Let's try it out and see what it reports and how onerous it is.

The one case I can think where it would be useful is if you are refactoring
and no longer need to pass an argument to a function. But if the function is
self recursive, it wouldn't be able to detect that.

Some observations:
* It's really easy just to add '_' in front of the argument to silence the
  warning.
* In one case for spec tests, I had to think about why the argument was
  unused. Which is probably a good thing.
* This catches unused monadic do results, which is kind of cool.
* It's nice having the documentation of '_' that an argument is (potentially)
  unused I think. It conveys more info to the reader of the code.
* I found two real unused arguments this way I would have never found otherwise.

Given the low cost of this to the user, the consistent benefit to
documentation, and the potential benefit to identifying real unused arguments,
I vote we take this change.
