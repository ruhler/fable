
% True = /Bool%.True;
% False = /Bool%.False;

<@>@ Eq@ = /Eq%.Eq@;

<@>% List = /List%.List;
<@>% Nil = /List%.Nil;

% Neg = /Pinball/Num%.Neg;
% Int = /Pinball/Num%.Int;
% Div = /Pinball/Num%.Div;
% Eq = /Pinball/Num%.Eq;
% Show = /Pinball/Num%.Show;

@ Ball@ = /Pinball/Physics%.Ball@;
@ Edge@ = /Pinball/Physics%.Edge@;
@ Paddle@ = /Pinball/Physics%.Paddle@;
@ Vec@ = /Pinball/Physics%.Vec@;
@ World@ = /Pinball/Physics%.World@;
% Tick = /Pinball/Physics%.Tick;

<@>@ Show@ = /Show%.Show@;

% Strs = /String%.Strs;
% Str = /String%.Str;

@ Test@ = /Test%.Test@;
% Test = /Test%.Test;
% TestSuite = /Test%.TestSuite;
<@>% AssertEquals = /Test%.AssertEquals;

Eq@<Ball@> EqBall = (Ball@ a, Ball@ b) {
  /Pinball/Vec%.Eq(a.pos, b.pos).?(false: False);
  /Pinball/Vec%.Eq(a.vel, b.vel).?(false: False);
  Eq(a.radius, b.radius).?(false: False);
  True;
};

Show@<Ball@> ShowBall = (Ball@ a) {
  Strs[Str|'Ball@(pos=',
    /Pinball/Vec%.Show(a.pos), Str|', vel=',
    /Pinball/Vec%.Show(a.vel),
    Str|', radius=', Show(a.radius), Str|')'];
};

Test@ Tests = TestSuite(Str|'Pinball', List<Test@>[
  Test(Str|'Move Ball No Collision', !({
    # The ball moves freely to the right 10 units per tick.
    World@ start = @(
      gravity: Vec@(Int|0, Int|0),
      ball: Ball@(Vec@(Int|0, Int|0), Vec@(Int|10, Int|0), Int|1),
      edges: Nil<Edge@>,
      paddles: Nil<Paddle@>);
    World@ end = Tick(start);
    Ball@ want = @(
      pos: Vec@(Int|10, Int|0),
      vel: Vec@(Int|10, Int|0),
      radius: Int|1);
    Ball@ got = end.ball;
    AssertEquals<Ball@>(EqBall, ShowBall, want, got);
  })),
  
  Test(Str|'Move Ball Collision', !({
    # The ball moves to the right, hits a wall, then bounces back.
    World@ start = @(
      gravity: Vec@(Int|0, Int|0),
      ball: Ball@(Vec@(Int|0, Int|0), Vec@(Int|10, Int|0), Int|1),
      edges: List<Edge@>[
        Edge@(Vec@(Neg(Int|1), Int|0), Vec@(Int|6, Neg(Int|4)), Int|8, Int|1)
      ],
      paddles: Nil<Paddle@>);
    World@ end = Tick(start);

    Ball@ want = @(
      pos: Vec@(Int|0, Int|0),
      vel: Vec@(Neg(Int|10), Int|0),
      radius: Int|1);
    Ball@ got = end.ball;
    AssertEquals<Ball@>(EqBall, ShowBall, want, got);
  })),

  Test(Str|'Move Ball Avoid Collision', !({
    # The ball moves to the right, passing beneath a wall.
    # Regression test for when we failed to check collision happens within the
    # bounds of a wall.
    World@ start = @(
      gravity: Vec@(Int|0, Int|0),
      ball: Ball@(Vec@(Int|0, Int|0), Vec@(Int|10, Int|0), Int|1),
      edges: List<Edge@>[
        Edge@(Vec@(Neg(Int|1), Int|0), Vec@(Int|5, Int|3), Int|8, Int|1)
      ],
      paddles: Nil<Paddle@>);
    World@ end = Tick(start);
    Ball@ want = @(
      pos: Vec@(Int|10, Int|0),
      vel: Vec@(Int|10, Int|0),
      radius: Int|1);
    Ball@ got = end.ball;
    AssertEquals<Ball@>(EqBall, ShowBall, want, got);
  })),

  Test(Str|'Stationary Paddle Collision', !({
    # The ball moves down at constant velocity onto a stationary paddle.
    World@ start = @(
      gravity: Vec@(Int|0, Int|0),
      ball: @(
        pos: Vec@(Int|2, Int|2),
        vel: Vec@(Int|0, Neg(Int|2)),
        radius: Int|1),
      edges: Nil<Edge@>,
      paddles: List<Paddle@>[
        @(end_down: Vec@(Int|4, Neg(Int|2)),
          end_up: Vec@(Int|4, Int|2),
          pos: Div(Int|1, Int|2),
          vel: Int|0,
          edge: @(
            normal: Vec@(Int|0, Int|1),
            start: Vec@(Int|0, Int|0),
            length: Int|4,
            restitution: Int|1))
      ]);
    World@ end = Tick(start);
    Ball@ want = @(
      pos: Vec@(Int|2, Int|2),
      vel: Vec@(Int|0, Int|2),
      radius: Int|1);
    Ball@ got = end.ball;
    AssertEquals<Ball@>(EqBall, ShowBall, want, got);
  })),

  Test(Str|'Stationary Paddle Collision Restitution', !({
    # Test that restitution of the paddle is taken into account during
    # collision.
    World@ start = @(
      gravity: Vec@(Int|0, Int|0),
      ball: @(
        pos: Vec@(Int|2, Int|2),
        vel: Vec@(Int|0, Neg(Int|2)),
        radius: Int|1),
      edges: Nil<Edge@>,
      paddles: List<Paddle@>[
        @(end_down: Vec@(Int|4, Neg(Int|2)),
          end_up: Vec@(Int|4, Int|2),
          pos: Div(Int|1, Int|2),
          vel: Int|0,
          edge: @(
            normal: Vec@(Int|0, Int|1),
            start: Vec@(Int|0, Int|0),
            length: Int|4,
            restitution: Div(Int|1, Int|2)))
      ]);
    World@ end = Tick(start);
    Ball@ want = @(
      pos: Vec@(Int|2, Div(Int|3, Int|2)),
      vel: Vec@(Int|0, Int|1),
      radius: Int|1);
    Ball@ got = end.ball;
    AssertEquals<Ball@>(EqBall, ShowBall, want, got);
  })),

  Test(Str|'Stationary Ball With Paddle', !({
    # Regression test for a divide by zero that happens if the ball is
    # stationary relative to the paddle.
    World@ start = @(
      gravity: Vec@(Int|0, Int|0),
      ball: @(
        pos: Vec@(Int|2, Int|2),
        vel: Vec@(Int|0, Int|0),
        radius: Int|1),
      edges: Nil<Edge@>,
      paddles: List<Paddle@>[
        @(end_down: Vec@(Int|4, Neg(Int|2)),
          end_up: Vec@(Int|4, Int|2),
          pos: Div(Int|1, Int|2),
          vel: Int|0,
          edge: @(
            normal: Vec@(Int|0, Int|1),
            start: Vec@(Int|0, Int|0),
            length: Int|4,
            restitution: Int|1))
      ]);
    World@ end = Tick(start);
    Ball@ want = start.ball;
    Ball@ got = end.ball;
    AssertEquals<Ball@>(EqBall, ShowBall, want, got);
  })),

  Test(Str|'End-Stationary Paddle Collision', !({
    # The ball moves down at constant velocity onto a paddle that becomes
    # stationary before the ball hits it.
    # This is a regression test for a case where velocity of the paddle was
    # being treated as non-zero in this case.
    World@ start = @(
      gravity: Vec@(Int|0, Int|0),
      ball: @(
        pos: Vec@(Int|2, Int|2),
        vel: Vec@(Int|0, Neg(Int|2)),
        radius: Int|1),
      edges: Nil<Edge@>,
      paddles: List<Paddle@>[
        @(end_down: Vec@(Int|4, Neg(Int|1)),
          end_up: Vec@(Int|4, Int|0),
          pos: Int|0,
          vel: Int|4,
          edge: @(
            normal: Vec@(Int|0, Int|1),
            start: Vec@(Int|0, Int|0),
            length: Int|4,
            restitution: Int|1))
      ]);
    World@ end = Tick(start);
    Ball@ want = @(
      pos: Vec@(Int|2, Int|2),
      vel: Vec@(Int|0, Int|2),
      radius: Int|1);
    Ball@ got = end.ball;
    # TODO: Set paddle velocity to zero when it hits the end of its range.
    /Test%.ExpectFails(AssertEquals<Ball@>(EqBall, ShowBall, want, got), Str|'');
  }))
]);

@(Tests);
