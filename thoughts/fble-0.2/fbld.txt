Fbld Improvements
=================

I'm happy with the syntax for fbld. The implementation needs work.

One idea is to try implementing fbld in fble. Partly as an excuse to write
more real world fble programs, partly because it almost feels nicer to use
fble than tcl given things like tracking error locations.

I see two big challenges with using fble for fbld:
1. How to make it easily extensible. Can users write their own front ends and
back ends? Would they have to write fble? Is that too much to ask? How can we
compose with other existing programs like groff?

2. How to deal with bootstrapping dependency of fble on fbld and fbld on fble?
It's a bit annoying, because it's just the help text for fble-stdio. Maybe
have an option to compile fble with and without that usage text and do a mini
bootstrap that way in the build system.

Big things I want to improve for fbld (regardless of what language we use to
implement it):
* Location tracking, so we can point to the exact place in a file where an
  error occurs.

* Composition: so we can easily implement commands directly in terms of other
  commands if we want to, instead of having to convert back into strings and
  re-parsing.

Both those things come down to this challenging aspect of fbld:

The commands have to parse args using fbld, the fbld parser has to execute
commands using the commands. That creates this cycle going back and forth
between the parser and commands where we have to keep track of and pass
location information back and forth. We can't just parse the whole thing all
at once and then execute commands all at once.

---

This should be pretty straight forward I think.

Assume some monad for computation/side effects.

We have generic commands that don't care about the monad. They can be
parametrized by it. The monad lets you call a sequence of commands.

Define fble functions that take typed (post-parsed) arguments.
Define a generic command map that takes non-typed List@<String@> arguments,
parses the arguments appropriately, and forwards that to the typed fble
functions.

The implementation of a command can call either the raw fble function it
wants, or invoke a command via the generic command map.

Typed fble functions for backends can work with specific monads. For example,
maybe we have an HtmlM@ for generating html documents.

We have a block parser and an inline parser that both work solely with generic
monad via the generic command map.

For composition, you create a command map that works for a particular
specialized HtmlM@ monad. You invoke the block parser, which causes all the
commands to be executed recursively in the monad. You can do what you want
with the results of that. Easy.

Note: instead of List@<String@>, we'll want List@<StringL@>, or some variation
that tracks locations for strings. And the block and inline parsers should
operate on StringL@ to maintain file location information.

I think this will be nice, straight forward, very composable. The two issues
I see are:

1. How to get the filename for what we are parsing.
Ideally we can open named files rather than just stdin. Then that's solved. We
want that for fble-md5 too.

2. How to let people write their own extensions to fbld without using fble.
They need some programming language to be flexible enough. For ease of use, it
would be nice to have a programming language with an interpreter. Some options
are: tcl, python, fble, some custom new fbld language. I think, let's not
worry about this now.

