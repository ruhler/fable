
{ Data%; @(Data@, Left, Right, DUnit: Unit, Product); };
{ Unit%; @(Unit@); };
{ UBNat%; @(Nat@); };

@ Coord@ = *(Nat@ row, Nat@ col);

(Nat@){ Data@; } DNat = (Nat@ n) {
  ?(n; 0: Left(Left(DUnit)),
       1: Left(Right(DUnit)),
       2p0: Right(Left(DNat(n.2p0))),
       2p1: Right(Right(DNat(n.2p1))));
};

(Coord@) { Data@; } DCoord = (Coord@ c) {
  Product(DNat(c.row), DNat(c.col));
};

# The world is a set of Coord@ where there are live cells.
@ World@ = Map@<Unit@>;

# A count of neighboring cells. 4p stands for anything greater than or equal
# to 4.
@ Count@ = +(Unit@ 0, Unit@ 1, Unit@ 2, Unit@ 3, Unit@ 4p);

(Count@) { Count@; } Inc = (Count@ c) {
  ?(c; 0: Count@(1: Unit),
       1: Count@(2: Unit),
       2: Count@(3: Unit),
       3: Count@(4p: Unit),
       4p: Count@(4p: Unit));
};

@ Status@ = *(Bool@ alive, Count@ neighbors);

# Map from Coord to the status of the cell.
@ Cand@ = Map@<Status@>

# Advance the world by one unit of time.
(World@) { World@; } Step = (World@ w) {
  # 1. Create the candidate map.
  #   For each cell in world,
  #     Set this cell alive in candidate
  #     Inc neighbors for each neighbor cell

  # 2. Filter live cells from the map.
};
