module ListM(ListI) {
  import @ { UnitM; FunctionI; };
  import UnitM { Unit; };

  struct P<T>(T head, S<T> tail);
  union S<T>(Unit nil, P<T> cons); 

  # InitP - Return all but the last element in 'list'.
  func InitP<T>(P<T> list; S<T>) {
    ?(list.tail; S<T>:nil(Unit()), S<T>:cons(P<T>(list.head, InitP<T>(list.tail.cons))));
  };

  # LastP - Return the last element in 'list'.
  func LastP<T>(P<T> list; T) {
    ?(list.tail; list.head, LastP<T>(list.tail.cons));
  };

  # Append list b to the end of list a.
  func Append<T>(S<T> a, S<T> b ; S<T>) {
    ?(a; b, S<T>:cons(P<T>(a.cons.head, Append<T>(a.cons.tail, b))));
  };

  func MapS<A, B; FunctionI<A, B> F>(S<A> a; S<B>) {
    ?(a; S<B>:nil(Unit()), S<B>:cons(MapP<A, B; F>(a.cons)));
  };

  func MapP<A, B; FunctionI<A, B> F>(P<A> a; P<B>) {
    P<B>(f@F(a.head), MapS<A, B; F>(a.tail));
  };
};
