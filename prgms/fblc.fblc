
struct Unit();

# An Id is a binary representation of non-negative integers used to refer to
# declarations, fields, variables, and ports.  
#
# Declarations are identified using the order in which they are defined in
# the program. The first declaration has id 0, the second declaration id 1,
# and so on.
#
# Fields are identified using the order in which they are defined in their
# type declaration. The first field has id 0, the second field has id 1, and
# so on.
#
# Variables are identified using De Bruijn indices. The inner most bound
# variable has id 0, the next inner most bound variable has id 1, and so on.
# For variables introduced as function arguments or exec actions, the
# right-most argument is considered inner most.
#
# Ports are similarly identified using De Bruijn indices. The inner most
# bound port has id 0, the next inner most bound variable has id 1, and so
# on. For ports introduced as process arguments, the right-most port is
# considered inner most. For ports declared as part of link actions, the put
# port is considered inner most with respect to the get port. Both put and
# get ports belong to the same namespace of indices.
union Id(Unit 0, Unit 1, Id 2x, Id 2xp1);
union DeclId(Unit 0, Unit 1, DeclId 2x, DeclId 2xp1);

struct NonEmptyTypeList(DeclId head, TypeList tail);
union TypeList(Unit nil, NonEmptyTypeList cons);

struct NonEmptyExprList(Expr head, ExprList tail);
union ExprList(Unit nil, NonEmptyExprList cons);

struct NonEmptyActnList(Actn head, ActnList tail);
union ActnList(Unit nil, NonEmptyActnList cons);

union Polarity(Unit get, Unit put);
struct NonEmptyPortList(DeclId type, Polarity polarity, PortList tail);
union PortList(Unit nil, NonEmptyPortList cons);

struct NonEmptyIdList(Id head, IdList tail);
union IdList(Unit nil, NonEmptyIdList cons);

struct VarExpr(Id var);
struct AppExpr(DeclId func, ExprList args);
struct UnionExpr(DeclId type, Id field, Expr body);
struct AccessExpr(Expr object, Id field);
struct CondExpr(Expr select, NonEmptyExprList args);

# A let expression in the text syntax has the form:
#  tname vname '=' expr ';' stmt
# For the binary syntax, we omit the type of the variable, because it can be
# inferred from the type of the defining expression. This is different from
# the text syntax because we assume the text syntax will be read by humans,
# in which case it is nice to see the type of the variable when declared. The
# binary syntax is not intended to be read by humans, so it's fine to infer
# the variable type instead of stating it explicitly.
#
# We also omit the name of the variable, instead using De Bruijn indices to
# identify variables.
#
# The body of the let expression is a regular expression instead of a
# statement, because statements are artifacts of the text syntax, and are not
# necessary in the binary syntax.
struct LetExpr(Expr def, Expr body);

union Expr(
    VarExpr var,
    AppExpr apply,
    UnionExpr union,
    AccessExpr access,
    CondExpr cond,
    LetExpr let
);

struct FuncDecl(TypeList args, DeclId return, Expr body);

struct PutActn(Id port, Expr arg);
struct CondActn(Expr select, NonEmptyActnList args);
struct CallActn(DeclId proc, IdList ports, ExprList args);
struct LinkActn(DeclId type, Actn body);

# Omit the type and name of variables declared in an exec action for the
# same reason we omit the type and name of variables declared in let
# expressions.
struct NonEmptyExecList(Actn def, ExecList tail);
union ExecList(Unit nil, NonEmptyExecList cons);
struct ExecActn(NonEmptyExecList execs, Actn body);

union Actn(
    Expr eval,
    Id get,
    PutActn put,
    CondActn cond,
    CallActn call,
    LinkActn link,
    ExecActn exec
);

struct ProcDecl(PortList ports, TypeList args, DeclId return, Actn body);

union Decl(
    TypeList struct,
    NonEmptyTypeList union,
    FuncDecl func,
    ProcDecl proc
);

struct NonEmptyDeclList(Decl head, DeclList tail);
union DeclList(Unit nil, NonEmptyDeclList cons);

struct Program(NonEmptyDeclList decls);

