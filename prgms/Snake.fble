
{ /App%; @(App@, Event@, Effect@); };
{ /Bool%; @(Bool@, True, False, And); };
{ /Drawing%; @(Color@, Drawing@, Point@, Blank, Rect, Over, Transform); };
{ /List%; @(P@, S@, InitP, LastP); };
{ /Process%; @(Get@, Put@); };
{ /Int/Int%; @(Int@, 0, 1, 2, 3, 4, 6, Inc, Dec, Add, Mul, Neg); };
{ /Int/Int/Eq%; @(Eq); };
{ /Int/Int/Lit%; @(I, D); };
{ /Int/Int/Div%; @(Div, Mod); };
{ /Unit%; @(Unit@, Unit); };

Int@ MinRow = 0;
Int@ MaxRow = I(D|20);
Int@ MinCol = 0;
Int@ MaxCol = I(D|60);

@ Pos@ = *(Int@ row, Int@ col);

(Pos@, Pos@){Bool@;} EqPos = (Pos@ a, Pos@ b) {
  And(Eq(a.row, b.row), Eq(a.col, b.col));
};

@ Direction@ = +(Unit@ up, Unit@ down, Unit@ left, Unit@ right);
@ Input@ = +(Direction@ dir, Unit@ quit, Unit@ tick);


@ Cell@ = +(Unit@ empty, Unit@ snake, Unit@ food);

(Pos@, Cell@){Drawing@;} DrawCell = (Pos@ pos, Cell@ cell) {
  Color@ c = ?(cell; empty: Color@(blue: Unit),
                     snake: Color@(cyan: Unit),
                     food: Color@(green: Unit));
  Rect(pos.col, pos.row, 1, 1, c);
};


# State --
#   The state of the game.
# 
# Fields:
#   dir - The current direction of the snake.
#   food - The current position of the food.
#   rand - Random bits for use in determining the next food position.
#   snake - The positions of the snake, in order from head to tail.
@ State@ = *(
  Direction@ dir,
  Pos@ food,
  Int@ rand,
  P@<Pos@> snake
);

# TODO: Use MapS or some other combinator for this.
(S@<Pos@>){Drawing@;} DrawSnakeS = (S@<Pos@> s) {
  ?(s; cons: DrawSnakeP(s.cons), nil: Blank);
},
(P@<Pos@>){Drawing@;} DrawSnakeP = (P@<Pos@> s) {
  Over(DrawCell(s.head, Cell@(snake: Unit)), DrawSnakeS(s.tail));
};

(State@){Drawing@;} DrawState = (State@ s) {
  Over(DrawCell(s.food, Cell@(food: Unit)), DrawSnakeP(s.snake));
};

State@ InitialState = {
  Int@ c0 = MinCol;
  Int@ c1 = Inc(c0); Int@ c2 = Inc(c1);
  Int@ c3 = Inc(c2); Int@ c4 = Inc(c3);
  Int@ r0 = MinRow;
  Int@ r1 = Inc(r0); Int@ r2 = Inc(r1);
  Int@ r3 = Inc(r2); Int@ r4 = Inc(r3);
  State@(
      Direction@(right: Unit),
      Pos@(r4, c1),
      I(D|1),
      P@<Pos@>(Pos@(r1, c4), S@<Pos@>(cons: P@<Pos@>(
              Pos@(r1, c3), S@<Pos@>(cons: P@<Pos@>(
              Pos@(r1, c2), S@<Pos@>(cons: P@<Pos@>(
              Pos@(r1, c1), S@<Pos@>(nil: Unit)))))))));
};

@ MoveResult@ = *(State@ state, Drawing@ draw);
@ MoveResultM@ = +(Unit@ dead, MoveResult@ mr);
@ PosM@ = +(Unit@ dead, Pos@ pos);

# Return true if the given position is found in the list of positions.
(S@<Pos@>, Pos@){Bool@;} InPosS = (S@<Pos@> s, Pos@ p) {
  ?(s ; cons: InPosP(s.cons, p), nil: False);
},
(P@<Pos@>, Pos@){Bool@;} InPosP = (P@<Pos@> s, Pos@ p) {
  ?(EqPos(s.head, p); true: True, false: InPosS(s.tail, p));
};

# Update the random number for where the next food will be generate.
# Takes the current direction of the snake to add some randomness to the
# update.
Int@ Max64 = I(D|18446744073709551616);
(Direction@, Int@) { Int@; } StepRand = (Direction@ d, Int@ s) {
  Int@ offset = ?(d; up: 0, down: 1, left: 2, right: 3);
  Mod(Add(Mul(s, I(D|1103515245)), Add(I(D|12345), offset)), Max64);
};

# Pick the position of the next food randomly, given the random bits and the
# snakes position.
(Int@, P@<Pos@>) { Pos@; } GetNextFood = (Int@ rand, P@<Pos@> snake) {
  Int@ x = Mod(Div(rand, I(D|65536)), I(D|32768));
  Int@ row = Inc(Mod(x, Dec(MaxRow)));
  Int@ col = Inc(Mod(Div(x, MaxRow), Dec(MaxCol)));
  Pos@ pos = Pos@(row, col);
  ?(InPosP(snake, pos);
     true: GetNextFood(StepRand(Direction@(up: Unit), rand), snake),
     false: pos);
};

(State@){MoveResultM@;} Move = (State@ s) {
  Int@ nrand = StepRand(s.dir, s.rand);
  PosM@ pm = ?(s.dir;
    up:
    ?(Eq(s.snake.head.row, MaxRow);
        true: PosM@(dead: Unit),
       false: PosM@(pos: Pos@(Inc(s.snake.head.row), s.snake.head.col))),

    down:
    ?(Eq(s.snake.head.row, MinRow);
        true: PosM@(dead: Unit),
       false: PosM@(pos: Pos@(Dec(s.snake.head.row), s.snake.head.col))),

    left:
    ?(Eq(s.snake.head.col, MinCol);
        true: PosM@(dead: Unit),
       false: PosM@(pos: Pos@(s.snake.head.row, Dec(s.snake.head.col)))),

    right:
    ?(Eq(s.snake.head.col, MaxCol);
        true: PosM@(dead: Unit),
       false: PosM@(pos: Pos@(s.snake.head.row, Inc(s.snake.head.col)))));

  ?(pm; dead: MoveResultM@(dead: Unit), pos:
      ?(EqPos(pm.pos, s.food);
          true: {
            # TODO: Properly handle the case where the snake eats food at its
            # tail.
            P@<Pos@> nsnake = P@<Pos@>(s.food, S@<Pos@>(cons: s.snake));
            Pos@ nfood = GetNextFood(nrand, nsnake);
            State@ ns = State@(s.dir, nfood, nrand, nsnake);
            Drawing@ draw = Over(DrawCell(s.food, Cell@(snake: Unit)),
                                 DrawCell(nfood, Cell@(food: Unit)));
            MoveResultM@(mr: MoveResult@(ns, draw));
          },
          false:
          ?(InPosP(s.snake, pm.pos); true: MoveResultM@(dead: Unit),
            false: {
              # TODO: Combine calls to Init and Last so we only have to
              # iterate over the list of elements once instead of twice?
              P@<Pos@> nsnake = P@<Pos@>(pm.pos, InitP<Pos@>(s.snake));
              Pos@ last = LastP<Pos@>(s.snake);
              State@ ns = State@(s.dir, s.food, nrand, nsnake);
              Drawing@ draw = Over(DrawCell(pm.pos, Cell@(snake: Unit)),
                                   DrawCell(last, Cell@(empty: Unit)));
              MoveResultM@(mr: MoveResult@(ns, draw));
            })));
};

(Get@<Input@>, Put@<Effect@>, State@){Unit@!;}
Snake = (Get@<Input@> in, Put@<Effect@> out, State@ s) {
  Input@ x := in;
  ?(x; dir: Snake(in, out, State@(x.dir, s.food, s.rand, s.snake)),
       quit: $(Unit),
       tick: {
           MoveResultM@ m = Move(s);
           ?(m;
              dead: $(Unit),
              mr: {
                 Unit@ _ := out(Effect@(draw: m.mr.draw));
                 Unit@ _ := out(Effect@(tick: I(D|200)));
                 Snake(in, out, m.mr.state);
              });
       });
};

(Get@<Event@>){ Get@<Input@>; } GetInput = (Get@<Event@> in) {
  Event@ e := in;
  ?(e;
    tick: $(Input@(tick: Unit)),
    key: ?(e.key;
      H: $(Input@(dir: Direction@(left: Unit))),
      J: $(Input@(dir: Direction@(down: Unit))),
      K: $(Input@(dir: Direction@(up: Unit))),
      L: $(Input@(dir: Direction@(right: Unit))),
      Q: $(Input@(quit: Unit)),
      : GetInput(in)));
};

App@ Main = (Int@ width, Int@ height, Get@<Event@> in, Put@<Effect@> out) {
  State@ s = InitialState;
  
  # Map game coordinates into screen coordinates.
  Int@ ax = Div(width, Add(2, MaxCol));
  Int@ bx = Mul(2, ax);
  Int@ ay = Neg(Div(height, Add(2, MaxRow)));
  Int@ by = Add(height, Mul(2, ay));

  (Point@) { Point@; } f = (Point@ p) {
    @(x: Add(Mul(ax, p.x), bx), 
      y: Add(Mul(ay, p.y), by));
  };

  Put@<Effect@> game_out = (Effect@ e) {
    Effect@ transformed = ?(e;
      tick: e,
      draw: Effect@(draw: Transform(f, e.draw)));
    out(transformed);
  };

  Unit@ _ := game_out(Effect@(draw: Rect(0, 0, MaxCol, MaxRow, Color@(blue: Unit))));
  Unit@ _ := game_out(Effect@(draw: DrawState(s)));
  Unit@ _ := out(Effect@(tick: I(D|0)));
  Unit@ _ := Snake(GetInput(in), game_out, s);

  Unit@! WaitForKeyPress = {
    Event@ e := in;
    ?(e; tick: WaitForKeyPress, key: $(Unit));
  };
  WaitForKeyPress;
};

Main;
