
% True = /Core/Bool%.True;
% False = /Core/Bool%.False;

@ Char@ = /Core/Char%.Char@;
% IsSpace = /Core/Char/Type%.IsSpace;
% IsNewline = /Core/Char/Type%.IsNewline;

@ Int@ = /Core/Int%.Int@;
% Incr = /Core/Int%.Incr;
% Int = /Core/Int/Lit%.Int;

<@>@ List@ = /Core/List%.List@;
<@>% List = /Core/List%.List;
<@>% Cons = /Core/List%.Cons;
<@>% Nil = /Core/List%.Nil;
<@>% Split = /Core/List/Eq%.Split;

<@>@ Maybe@ = /Core/Maybe%.Maybe@;
<@>% Just = /Core/Maybe%.Just;

<<@>@>@ Monad@ = /Core/Monad%.Monad@;

<<@>@>@ IStream@ = /Core/Stream%.IStream@;

@ String@ = /Core/String%.String@;
% Str = /Core/String%.Str;


@ Profile@ = /Pprof/Profile%.Profile@;
@ Location@ = /Pprof/Profile%.Location@;
@ LocId@ = /Pprof/Profile%.LocId@;
@ Sample@ = /Pprof/Profile%.Sample@;

% M = /Core/String/Map%;
@ Map@ = M.Map@<LocId@>;
% Empty = M.Empty<LocId@>;
% Lookup = M.Lookup<LocId@>;
% Insert = M.Insert<LocId@>;

# Extracts the next word in a string, separated by space.
(String@) { String@; }
GetWord = (String@ s) {
  s.?(nil: s);
  IsSpace(s.cons.head).?(true: Str|'');
  Cons(s.cons.head, GetWord(s.cons.tail));
};

# Drops the next word in a string.
(String@) { String@; }
DropWord = (String@ s) {
  s.?(nil: s);
  IsSpace(s.cons.head).?(true: s.cons.tail);
  DropWord(s.cons.tail);
};

# Parse a profile from the output of running:
#   perf report -q -g folded,count,0 
#
# For use with linux perf profiles.
<<@>@ M@>(Monad@<M@>, IStream@<M@>) { M@<Maybe@<Profile@>>; }
Parse = <<@>@ M@>(Monad@<M@> m, IStream@<M@> in) {
  % I = /Core/Stream/IStream%(m);

  @ S@ = *(
    Int@ next_id,
    Map@ locations,
    Profile@ profile
  );

  @ PathS@ = *(List@<LocId@> path, S@ s);
  (List@<String@>, S@) { PathS@; }
  Path = (List@<String@> path, S@ s) {
    path.?(nil: @(path: Nil<LocId@>, s));

    PathS@ tail = Path(path.cons.tail, s);
    String@ loc = path.cons.head;
    Maybe@<LocId@> mid = Lookup(tail.s.locations, loc);
    mid.?(just: @(path: Cons(mid.just, tail.path), s: tail.s));

    Int@ id = tail.s.next_id;
    Location@ location = @(
      id: id, name: loc,
      file: Str|'???', line: Int|0, col: Int|0
    );

    @(path: Cons(id, tail.path),
      s: tail.s.@(
        next_id: Incr(id),
        locations: Insert(tail.s.locations, loc, id),
        profile: tail.s.profile.@(
          locations: Cons(location, tail.s.profile.locations))));
  };

  # Adds a sample to the profile.
  # Fabricates locations on the fly as needed.
  (Int@, List@<String@>, S@) { S@; }
  AddSample = (Int@ value, List@<String@> path, S@ s) {
    PathS@ ps = Path(path, s);
    ps.s.@(profile: ps.s.profile.@(
        samples: Cons(Sample@(List[value], ps.path), ps.s.profile.samples)));
  };

  (S@) { M@<Maybe@<Profile@>>; } ParseS = (S@ s) {
    String@ line <- m.do(I.GetLine(in));

    # We're done once we reach the next line of the form:
    #    100.00%     0.00%  <cmd>  <ex>      [.] __libc_start_main
    line.?(nil: m.return(Just(s.profile)));
    line.cons.head.?(' ': m.return(Just(s.profile)));

    # We expect a line of the form:
    # 3694 foo;bar;sludge\n
    Int@ value = /Core/Int/Show%.Read(GetWord(line));
    List@<String@> path = Split(DropWord(line), (Char@ c) {
      c.?(';': True);
      IsNewline(c).?(true: True);
      False;
    });

    ParseS(AddSample(value, path, s));
  };

  # Skip the first line of the form:
  #   100.00%     0.00%  <cmd>  <exe>        [.] _start
  String@ _ <- m.do(I.GetLine(in));

  ParseS(@(
      next_id: Int|0,
      locations: Empty,
      profile: @(
        metrics: List[Str|'samples'],
        samples: Nil<Sample@>,
        locations: Nil<Location@>)));
};

@(Parse);
