
# DataFlow describes computation as a graph of modules. A module has some
# number of input ports and some number of output ports. The behavior of a
# module is to consume values on its input ports and produce corresponding
# values on its output ports.

# A DataFlow module is described in fble as a process that takes output ports
# as arguments and returns input ports to the module. It has the effect of
# instantiating a computation that runs asynchronously. In particular, putting
# a value onto an input port is a non-blocking operation.

<@,@>@ List@ = /List%.List@;

<@>@ Get@ = /Process%.Get@;
<@>@ Put@ = /Process%.Put@;

@ Unit@ = /Unit%.Unit@;
% Unit = /Unit%.Unit;

# DataFlow@ --
#   A data flow computation.
@ DataFlow@ = Unit@!;

# End@ --
#   Data to send to a data flow computation that can indicate end of
#   computation.
#
# Often we want to either send data to a data flow computation, or tell it to
# finish running. The End@ type should be used for that.
<@>@ End@ = <@ T@> { +(T@ data, Unit@ end); };

<@ T@> { End@<T@>; } End = <@ T@> { End@<T@>(end: Unit); };
<@ T@>(T@) { End@<T@>; } Data = <@ T@>(T@ x) { End@<T@>(data: x); };

# Input and output wires, from the perspective of the DataFlow computation.
<@>@ In@ = <@ T@> { Get@<End@<T@>>; };
<@>@ Out@ = <@ T@> { Put@<End@<T@>>; };

# Compose --
#   Compose together a bunch of data flow computations.
#
# The resulting data flow computation behaves as if all argument data flow
# computations were run in parallel. It completes when all argument data flow
# computations have completed.
(List@<DataFlow@>) { DataFlow@; } Compose = (List@<DataFlow@> args) {
  args<DataFlow@>(
    (DataFlow@ x, DataFlow@ y) {
      Unit@ _ := x, Unit@ _ := y;
      !(Unit);
    },
    !(Unit));
};

# Run --
#   Execute a data flow computation.
(DataFlow@) { Unit@!; } Run = (DataFlow@ x) {
  x;
};

# Input --
#   Inject input into a data flow computation.
<@ T@>(Get@<End@<T@>>, Out@<T@>) { DataFlow@; }
Input = <@ T@>(Get@<End@<T@>> in, Out@<T@> out) {
  End@<T@> x := in;
  Unit@ _ := out(x);
  x.?(data: Input<T@>(in, out), end: !(Unit));
};

# Output --
#   Get output from a data flow computation.
<@ T@>(Put@<End@<T@>>, In@<T@>) { DataFlow@; }
Output = <@ T@>(Put@<End@<T@>> out, In@<T@> in) {
  Input<T@>(in, out);
};

# Const --
#   Output a constant value for every input.
<@ T@>(T@, In@<Unit@>, Out@<T@>) { DataFlow@; }
Const = <@ T@>(T@ x, In@<Unit@> in, Out@<T@> out) {
  End@<Unit@> i := in;
  i.?(
    data: {
      Unit@ _ := out(Data<T@>(x));
      Const<T@>(x, in, out);
    },
    end: out(End<T@>));
};

# Once
#   Output a constant value once.
<@ T@>(T@, Out@<T@>) { DataFlow@; }
Once = <@ T@>(T@ x, Out@<T@> out) {
  out(Data<T@>(x));
};

# Copy --
#   Copy an input to multiple outputs.
<@ T@>(In@<T@>, List@<Out@<T@>>) { DataFlow@; }
Copy = <@ T@>(In@<T@> in, List@<Out@<T@>> outs) {
  End@<T@> i := in;
  Unit@ _ := outs<Unit@!>((Out@<T@> o, Unit@! t) {
    Unit@ _ := o(i), Unit@ _ := t;
    !(Unit);
  }, !(Unit));

  i.?(data: Copy<T@>(in, outs), end: !(Unit));
};

# Forward --
#   Forward data from 'in' to 'out' every time there is 'send' input.
<@ T@>(In@<Unit@>, In@<T@>, Out@<T@>) { DataFlow@; }
Forward = <@ T@>(In@<Unit@> send, In@<T@> in, Out@<T@> out) {
  End@<Unit@> s := send;
  s.?(
    data: {
      End@<T@> i := in;
      Unit@ _ := out(i);
      Forward<T@>(send, in, out);
    },
    end: out(End<T@>));
};

@(DataFlow@, In@, Out@, End@,
  End, Data,
  Input, Output, Once, Copy, Const, Forward,
  Compose, Run);
