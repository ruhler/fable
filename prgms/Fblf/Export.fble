
@ Assign@ = /Fblf/Program%.Assign@;
@ Call@ = /Fblf/Program%.Call@;
@ Cond@ = /Fblf/Program%.Cond@;
@ IfElse@ = /Fblf/Program%.IfElse@;
@ Sequence@ = /Fblf/Program%.Sequence@;
@ Stmt@ = /Fblf/Program%.Stmt@;
@ Value@ = /Fblf/Program%.Value@;
@ Var@ = /Fblf/Program%.Var@;
@ While@ = /Fblf/Program%.While@;

<@,@>% Map = /List%.Map;

# Export@ -- 
#   Class of types T@ that can be exported from an fblf module.
#
# To make a type T@ exportable, implement the Export@ function by transforming
# all variables that appear in T@ using the provided function.
<@>@ Export@ = <@ T@>((Var@) { Var@; }, T@) { T@; };

Export@<Var@> ExportVar = ((Var@) { Var@; } f, Var@ v) { f(v); };

Export@<Value@> ExportValue = ((Var@) { Var@; } f, Value@ x) {
  x.?(var: Value@(var: f(x.var)), const: x);
};

Export@<Cond@> ExportCond = ((Var@) { Var@; } f, Cond@ x) { 
  Cond@(x.op, ExportValue(f, x.a), ExportValue(f, x.b), x.n);
};

Export@<Assign@> ExportAssign = ((Var@) { Var@; } f, Assign@ x) {
  Assign@(f(x.var), x.value, x.n);
};

Export@<Sequence@> ExportSequence = ((Var@) { Var@; } f, Sequence@ x) {
  Map<Stmt@, Stmt@>(x, (Stmt@ s) { ExportStmt(f, s); });
},

Export@<IfElse@> ExportIfElse = ((Var@) { Var@; } f, IfElse@ x) {
  IfElse@(
    ExportCond(f, x.condition),
    ExportStmt(f, x.if_body),
    ExportStmt(f, x.else_body));
},

Export@<While@> ExportWhile = ((Var@) { Var@; } f, While@ x) {
  While@(ExportCond(f, x.condition), ExportStmt(f, x.body));
},

Export@<Call@> ExportCall = ((Var@) { Var@; } f, Call@ x) {
  Call@(x.proc, Map<Var@, Var@>(x.args, f));
},

Export@<Stmt@> ExportStmt = ((Var@) { Var@; } f, Stmt@ s) {
  s.?(
    assign: Stmt@(assign: ExportAssign(f, s.assign)),
    sequence: Stmt@(sequence: ExportSequence(f, s.sequence)),
    ifelse: Stmt@(ifelse: ExportIfElse(f, s.ifelse)),
    while: Stmt@(while: ExportWhile(f, s.while)),
    call: Stmt@(call: ExportCall(f, s.call)));
};

@(Export@, ExportVar, ExportCond, ExportStmt);
