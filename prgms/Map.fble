
@ Structure@ = /Structure%.Structure@;
<@>@ Structured@ = /Structured%.Structured@;

@ Unit@ = /Unit%.Unit@;
% Unit = /Unit%.Unit;

<@>@ Maybe@ = /Maybe%.Maybe@;
<@>% Nothing = /Maybe%.Nothing;
<@>% Just = /Maybe%.Just;

<@,@>@ Entry@ = <@ K@, @ V@> { *(K@ key, V@ value); };

<@ K@, @ V@>(Maybe@<Entry@<K@, V@>>) { Maybe@<V@>; }
MValue = <@ K@, @ V@>(Maybe@<Entry@<K@, V@>> m) {
  m.?(just: Just<V@>(m.just.value), nothing: Nothing<V@>);
};

# A map from K@ to V@, using Data@ as the lookup hash for K@.
<@,@>@ Map@ = <@ K@, @ V@>{ +(Unit@ empty, MapP@<K@, V@> map); },
<@,@>@ MapP@ = <@ K@, @ V@>{ 
  *(Maybe@<Entry@<K@,V@>> unit,
    *(Map@<K@, V@> a, Map@<K@, V@> b) sum,
    Map@<Unit@, Map@<K@, V@>> product);
};

<@ K@, @ V@>{ Map@<K@, V@>; } Empty = <@ K@, @ V@>{
  Map@<K@, V@>(empty: Unit);
};

<@ K@, @ V@>(Map@<K@, V@>, Structure@) { Maybe@<V@>; }
LookupS = <@ K@, @ V@>(Map@<K@, V@> map, Structure@ hash) {
  map.?(
     empty: Nothing<V@>,
     map: {
       hash.?(
          unit: MValue<K@, V@>(map.map.unit),
          either: hash.either.?(
                   a: LookupS<K@, V@>(map.map.sum.a, hash.either.a),
                   b: LookupS<K@, V@>(map.map.sum.b, hash.either.b)),
          pair: {
            Maybe@<Map@<K@, V@>> mm = LookupS<Unit@, Map@<K@, V@>>(map.map.product, hash.pair.a);
            mm.?(
                just: LookupS<K@, V@>(mm.just, hash.pair.b),
                nothing: Nothing<V@>);
          });
     });
};

<@ K@>(Structured@<K@>)<@ V@>(Map@<K@, V@>, K@) { Maybe@<V@>; }
Lookup = <@ K@>(Structured@<K@> s)<@ V@>(Map@<K@, V@> m, K@ k) {
  LookupS<K@, V@>(m, s(k));
};

# Insert that transforms the existing value, if any.
<@ K@, @ V@>(Map@<K@, V@>, K@, Structure@, (Maybe@<V@>){ V@; }) { Map@<K@, V@>; }
InsertWithS = <@ K@, @ V@>(Map@<K@, V@> map, K@ key, Structure@ hash, (Maybe@<V@>){ V@; } with) {
  MapP@<K@, V@> p =
    map.?(
       empty: MapP@<K@, V@>(
         Nothing<Entry@<K@, V@>>,
         @(a: Empty<K@, V@>, b: Empty<K@, V@>),
         Empty<Unit@, Map@<K@, V@>>),
       map: map.map);
  Map@<K@, V@>(map:
   hash.?(
     unit: MapP@<K@, V@>(
       Just<Entry@<K@, V@>>(Entry@<K@, V@>(key, with(MValue<K@, V@>(p.unit)))),
       p.sum,
       p.product
     ),
     either: hash.either.?(
              a: MapP@<K@, V@>(p.unit, @(a: InsertWithS<K@, V@>(p.sum.a, key, hash.either.a, with), b: p.sum.b), p.product),
              b: MapP@<K@, V@>(p.unit, @(a: p.sum.a, b: InsertWithS<K@, V@>(p.sum.b, key, hash.either.b, with)), p.product)),
     pair: {
       MapP@<K@, V@>(p.unit, p.sum,
         InsertWithS<Unit@, Map@<K@, V@>>(p.product, Unit, hash.pair.a, (Maybe@<Map@<K@, V@>> mm) {
           InsertWithS<K@, V@>(mm.?(just: mm.just, nothing: Empty<K@, V@>), key, hash.pair.b, with);
         }));
     }));
};

<@ K@>(Structured@<K@>)<@ V@>(Map@<K@, V@>, K@, V@) { Map@<K@, V@>; }
Insert = <@ K@>(Structured@<K@> s)<@ V@>(Map@<K@, V@> map, K@ key, V@ value) {
  InsertWithS<K@, V@>(map, key, s(key), (Maybe@<V@> _) { value; });
};

<@ K@>(Structured@<K@>)<@ V@>(Map@<K@, V@>, K@, (Maybe@<V@>){ V@; }) { Map@<K@, V@>; }
InsertWith = <@ K@>(Structured@<K@> s)<@ V@>(Map@<K@, V@> m, K@ k, (Maybe@<V@>) { V@; } w) {
  InsertWithS<K@, V@>(m, k, s(k), w);
};

<@ K@, @ V@, @ B@>(Map@<K@, V@>, B@, (K@, V@, B@) { B@;}) { B@; }
For = <@ K@, @ V@, @ B@>(Map@<K@, V@> m, B@ base, (K@, V@, B@) { B@;} body) {
  m.?(
    empty: base,
    map: {
      B@ b2 = m.map.unit.?(
                  just: body(m.map.unit.just.key, m.map.unit.just.value, base),
                  nothing: base);
      B@ b3 = For<K@, V@, B@>(m.map.sum.a, b2, body);
      B@ b4 = For<K@, V@, B@>(m.map.sum.b, b3, body);
      B@ b5 = For<Unit@, Map@<K@, V@>, B@>(m.map.product, b4,
        (Unit@ _, Map@<K@, V@> v, B@ b) {
          For<K@, V@, B@>(v, b, body);
      });
      b5;
    });
};

@(Map@, Empty, Lookup, Insert, InsertWith, For);
