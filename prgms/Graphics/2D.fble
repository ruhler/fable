
@ Bool@ = /Bool%.Bool@;
% True = /Bool%.True;
% False = /Bool%.False;

@ Drawing@ = /Drawing%.Drawing@;
@ Color@ = /Drawing%.Color@;
@ Point@ = /Drawing%.Point@;
% Affine = /Drawing%.Affine;
% Blank = /Drawing%.Blank;
% Over = /Drawing%.Over;
% Rect = /Drawing%.Rect;
% Translate = /Drawing%.Translate;

@ Int@ = /Int/Int%.Int@;
% Abs = /Int/Int%.Abs;
% Add = /Int/Int%.Add;
% Sub = /Int/Int%.Sub;
% Neg = /Int/Int%.Neg;
% Mul = /Int/Int%.Mul;
% Int = /Int/Int/Lit%.Int;
% Le = /Int/Int/Eq%.Le;
% Lt = /Int/Int/Eq%.Lt;
% Max = /Int/Int/Eq%.Max;
% Min = /Int/Int/Eq%.Min;
% Div = /Int/Int/Div%.Div;
% Mod = /Int/Int/Div%.Mod;
% Range = /Int/Int/Iter%.Range;

<@,@>% For = /Iter%.For;

# Point --
#   Draw a point.
(Point@, Color@) { Drawing@; }
Point = (Point@ point, Color@ color) {
  Rect(point.x, point.y, Int|1, Int|1, color);
};

# DivR --
#   Division with rounding.
#
# Does a/b, rounding to the nearest whole number.
# Assumes both a and b are non-negative.
(Int@, Int@) { Int@; } DivR = (Int@ a, Int@ b) {
  Int@ q = Div(a, b);
  Int@ r = Mod(a, b);
  Int@ p = Div(b, Int|2);
  Le(r, p).?(true: q);
  Add(Int|1, q);
};

# LineX --
#   Draw a line from the origin to (x, y) by putting a pixel at every x
#   coordinate. x and y are assumed to be non-negative.
(Int@, Int@, Color@) { Drawing@; }
LineX = (Int@ x, Int@ y, Color@ color) {
  x.?(0: Point(Point@(Int|0, Int|0), color));

  For<Int@, Drawing@>(Range(Int|0, Add(Int|1, x)), Blank,
    (Int@ xi, Drawing@ d) {
      Int@ yi = DivR(Mul(xi, y), x);
      Over(d, Point(Point@(xi, yi), color));
    });
};

# LineY --
#   Draw a line from the origin to (x, y) by putting a pixel at every y
#   coordinate. x and y are assumed to be non-negative.
(Int@, Int@, Color@) { Drawing@; }
LineY = (Int@ x, Int@ y, Color@ color) {
  y.?(0: Point(Point@(Int|0, Int|0), color));

  For<Int@, Drawing@>(Range(Int|0, Add(Int|1, y)), Blank,
    (Int@ yi, Drawing@ d) {
      Int@ xi = DivR(Mul(x, yi), y);
      Over(d, Point(Point@(xi, yi), color));
    });
};

# Line --
#   Draw a line from point a to point b.
(Point@, Point@, Color@) { Drawing@; }
Line = (Point@ a, Point@ b, Color@ color) {
  % s = @(dx: Sub(b.x, a.x), dy: Sub(b.y, a.y), ax: Int|1, ay: Int|1);

  % s_ = {
    Lt(s.dx, Int|0).?(true: {
      @(dx: Neg(s.dx), dy: s.dy, ax: Neg(s.ax), ay: s.ay);
    });
    s;
  };
  % s = s_;

  % s_ = {
    Lt(s.dy, Int|0).?(true: {
      @(dx: s.dx, dy: Neg(s.dy), ax: s.ax, ay: Neg(s.ay));
    });
    s;
  };
  % s = s_;

  % LineF = Lt(Abs(s.dx), Abs(s.dy)).?(true: LineY, false: LineX);
  Translate(a.x, a.y,
    Affine(Point@(s.ax, s.ay), Point@(Int|0, Int|0), LineF(s.dx, s.dy, color)));
};

# RightOf -- 
#   Return true if the point 'x' is to the right of the line going in the
#   direction from point a to point b. False otherwise.
(Point@, Point@, Point@) { Bool@; }
RightOf = (Point@ a, Point@ b, Point@ x) {
  Int@ b_x = Sub(b.x, a.x);
  Int@ b_y = Sub(b.y, a.y);
  Int@ x_x = Sub(x.x, a.x);
  Int@ x_y = Sub(x.y, a.y);

  Int@ l = Mul(b_y, x_x);
  Int@ p = Mul(b_x, x_y);

  Le(p, l);
};

# Enclosed --
#   Return true if point 'x' is enclosed in the triangle described by points
#   a, b, and c.
(Point@, Point@, Point@, Point@) { Bool@; }
Enclosed = (Point@ a, Point@ b, Point@ c, Point@ x) {
  RightOf(a, b, x).?(false: False);
  RightOf(b, c, x).?(false: False);
  RightOf(c, a, x).?(false: False);
  True;
};

# Triangle --
#   Draw a filled triangle between the points a, b, and c.
#
# The points should be specified in order going clockwise around the triangle,
# otherwise nothing is drawn.
(Point@, Point@, Point@, Color@) { Drawing@; }
Triangle = (Point@ a, Point@ b, Point@ c, Color@ color) {
  Int@ x_min = Min(a.x, Min(b.x, c.x));
  Int@ x_max = Max(a.x, Max(b.x, c.x));
  Int@ y_min = Min(a.y, Min(b.y, c.y));
  Int@ y_max = Max(a.y, Max(b.y, c.y));

  For<Int@, Drawing@>(Range(x_min, Add(Int|1, x_max)), Blank,
    (Int@ x, Drawing@ d) {
      For<Int@, Drawing@>(Range(y_min, Add(Int|1, y_max)), d,
        (Int@ y, Drawing@ dd) {
          Point@ p = Point@(x, y);
          Enclosed(a, b, c, p).?(false: dd);
          Over(dd, Point(p, color));
        });
    });
};

@(Point@, Point, Line, Triangle);
