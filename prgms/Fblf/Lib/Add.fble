
% ExportStmt = /Fblf/Export%.ExportStmt;

@ Stmt@ = /Fblf/Program%.Stmt@;
@ Var@ = /Fblf/Program%.Var@;
% Assign = /Fblf/Program%.Assign;
% Eq = /Fblf/Program%.Eq;
% IfElse = /Fblf/Program%.IfElse;
% Seq = /Fblf/Program%.Seq;
% Binary = /Fblf/Program%.Binary;
% Offset = /Fblf/Program%.Offset;
% Var = /Fblf/Program%.Var;

<@>@ Module@ = /Fblf/Module%.Module@;
@ Method@ = /Fblf/Module%.Method@;
<@>% Module1 = /Fblf/Module%.Module1;
<@>% Module3 = /Fblf/Module%.Module3;
% Method = /Fblf/Module%.Method;
<@>% DoAlloc = /Fblf/Module%.DoAlloc;

@ Int@ = /Int/Int%.Int@;
% Sub = /Int/Int%.Sub;
% Le = /Int/Int/Eq%.Le;

% Int = /Int/Int/Lit%.Int;

% CountDownFrom = /Int/Int/Iter%.CountDownFrom;

<@,@>% For = /Iter%.For;

@ String@ = /String%.String@;
% Str = /String%.Str;
% Strs = /String%.Strs;

# Add1 --
#   A pure 1-bit adder.
#
# Inputs:
#   a - The address of the first operand.
#   b - The address of the second operand.
#   c - The address of carry bit in.
#   x - The address of the carry bit out.
#   z - The address of where to store the result of the addition.
#
# Results:
#   A statment that sets x and z based on the one bit addition a + b + c.
(Var@, Var@, Var@, Var@, Var@) { Stmt@; }
Add1 = (Var@ a, Var@ b, Var@ c, Var@ x, Var@ z) {
  IfElse(Eq(Var(a), Binary|0, Int|1),
    IfElse(Eq(Var(b), Binary|0, Int|1),
      Seq[Assign(z, Var(c), Int|1), Assign(x, Binary|0, Int|1)],
      IfElse(Eq(Var(c), Binary|0, Int|1),
        Seq[Assign(z, Binary|1, Int|1), Assign(x, Binary|0, Int|1)],
        Seq[Assign(z, Binary|0, Int|1), Assign(x, Binary|1, Int|1)])),
    IfElse(Eq(Var(b), Binary|0, Int|1),
      IfElse(Eq(Var(c), Binary|0, Int|1),
        Seq[Assign(z, Binary|1, Int|1), Assign(x, Binary|0, Int|1)],
        Seq[Assign(z, Binary|0, Int|1), Assign(x, Binary|1, Int|1)]),
      Seq[Assign(z, Var(c), Int|1), Assign(x, Binary|1, Int|1)]));
};

# Add -- 
#   An n-bit adder, with most significant bit first.
#
# Inputs:
#   n - The number of bits to add together.
#   a - The address of the first operand.
#   b - The address of the second operand.
#   z - The address of where to store the result of the addition.
(Int@)(Var@, Var@, Var@) { Module@<Method@>; }
Add = (Int@ n) {
  String@ name = Strs[Str|'Add/Add', /Int/Int/Show%.Show(n)];
  Module3<Method@>(ExportStmt, name, (Var@ a, Var@ b, Var@ z) {
    # We need a single bit of internal state to store the carry bit as we do
    # the addition.
    Var@ carry <- DoAlloc<Method@>(Int|1);

    Method(Str|'main', For<Int@, Stmt@>(CountDownFrom(n), Assign(carry, Binary|0, Int|1),
      (Int@ i, Stmt@ s) {
        Seq[s, Add1(Offset(a, i), Offset(b, i), carry, carry, Offset(z, i))];
      }));
  });
};

(Var@, Var@, Var@) { Module@<Method@>; } Add32 = Add(Int|32);

# IncStmt --
#   Increment an n-bit number by 1.
#
# Inputs:
#   n - The number of bits of the number to increment.
#   a - The address of the value to increment. The value is most significant
#       bit first.
(Int@, Var@) { Stmt@; } IncI = (Int@ n, Var@ a) {
  Le(n, Int|0).?(
    true: Seq[],
    false: {
      Int@ nm1 = Sub(n, Int|1);
      Var@ lsb = Offset(a, nm1);
      IfElse(Eq(Var(lsb), Binary|0, Int|1),
        Assign(lsb, Binary|1, Int|1),
        Seq[Assign(lsb, Binary|0, Int|1), IncI(nm1, a)]);
    });
};

# Inc --
#   Increment an n-bit number by 1.
#
# Inputs:
#   n - The number of bits of the number to increment.
#   a - The address of the value to increment. The value is most significant
#       bit first.
(Int@)(Var@) { Module@<Method@>; } Inc = (Int@ n) {
  String@ name = Strs[Str|'/Fblf/Lib/Add%.Inc', /Int/Int/Show%.Show(n)];
  Module1<Method@>(ExportStmt, name, (Var@ a) { Method(Str|'main', IncI(n, a)); });
};

# DecI --
#   Decrement an n-bit number by 1.
#
# Inputs:
#   n - The number of bits of the number to decrement.
#   a - The address of the value to decrement. The value is most significant
#       bit first.
(Int@, Var@) { Stmt@; }
DecI = (Int@ n, Var@ a) {
  Le(n, Int|0).?(
    true: Seq[],
    false: {
      Int@ nm1 = Sub(n, Int|1);
      Var@ lsb = Offset(a, nm1);
      IfElse(Eq(Var(lsb), Binary|1, Int|1),
        Assign(lsb, Binary|0, Int|1),
        Seq[Assign(lsb, Binary|1, Int|1), DecI(nm1, a)]);
    });
};

# Dec --
#   Increment an n-bit number by 1.
#
# Inputs:
#   n - The number of bits of the number to decrement.
#   a - The address of the value to decrement. The value is most significant
#       bit first.
(Int@)(Var@) { Module@<Method@>; } Dec = (Int@ n) {
  String@ name = Strs[Str|'/Fblf/Lib/Add%.Dec', /Int/Int/Show%.Show(n)];
  Module1<Method@>(ExportStmt, name, (Var@ a) { Method(Str|'main', DecI(n, a)); });
};

@(Add, Add32, IncI, Inc, DecI, Dec);
