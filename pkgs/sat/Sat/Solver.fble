
@ Bool@ = /Core/Bool%.Bool@;
% True = /Core/Bool%.True;
% False = /Core/Bool%.False;
% Not = /Core/Bool%.Not;

% Inc = /Core/Int%.Inc;
% Int = /Core/Int/Lit%.Int;

<@>@ Fifo@ = /Core/Fifo%.Fifo@;
<@>% Empty = /Core/Fifo%.Empty;
<@>% First = /Core/Fifo%.First;
<@>% Put = /Core/Fifo%.Put;
<@>% Next = /Core/Fifo%.Next;

<@>@ List@ = /Core/List%.List@;
<@>% List = /Core/List%.List;
<@>% Nil = /Core/List%.Nil;
<@>% Cons = /Core/List%.Cons;

<@>@ Maybe@ = /Core/Maybe%.Maybe@;
<@>% Just = /Core/Maybe%.Just;
<@>% Nothing = /Core/Maybe%.Nothing;

@ Unit@ = /Core/Unit%.Unit@;
% Unit = /Core/Unit%.Unit;

@ Id@ = /Sat/Id%.Id@;
% EqId = /Sat/Id%.EqId;

@ VarId@ = Id@;
@ ClauseId@ = Id@;

@ Var@ = *(VarId@ id, Bool@ pos);
@ Clause@ = List@<Var@>;

# Imagine two clauses:
#   (a1 + a2 + ... + v)
#   (b1 + b2 + ... + v')
#
# These conflict in the case where:
#   (a1 + a2 + ... + b1 + b2 + ...)
#
# Conflict@ describes a pair of conflicting clauses and the variable they
# conflicted on.
@ Conflict@ = *(ClauseId@ a, ClauseId@ b, VarId@ var);

# pos - the list of clauses this variable appears positive in.
# neg - the list of clauses this variable appears negative in.
@ VarS@ = *(List@<ClauseId@> pos, List@<ClauseId@> neg);

@ ClauseS@ = Clause@;

% Vars = /Sat/Id%.Map<VarS@>;
@ Vars@ = Vars.Map@;

% Clauses = /Sat/Id%.Map<ClauseS@>;
@ Clauses@ = Clauses.Map@; 

% Conflicts = /Sat/Id%.Map<Conflict@>;
@ Conflicts@ = Conflicts.Map@;

# Functions for working with clauses.
# TODO: Move to a separate module?
% Clause = {
  # Adds a variable to a clause, preserving the invariant that each variable
  # appears at most once in a clause.
  #
  # Returns Nothing if the clause contains both x and x' after the insertion.
  (Var@, Clause@) { Maybe@<Clause@>; } AddVar = (Var@ v, Clause@ c) {
    c.?(nil: Just(List[v]));
    Var@ head = c.cons.head;
    EqId(v.id, head.id).?(true: {
      /Core/Bool/Eq%.Eq(v.pos, head.pos).?(true: Just(c));
      Nothing<Clause@>;
    });
    Maybe@<Clause@> tail = AddVar(v, c.cons.tail);
    tail.?(nothing: Nothing<Clause@>);
    Just(Cons(head, tail.just));
  };

  # Adds a list of variables to a clause, preserving the invariant that each
  # variable appears at most once in a clause.
  #
  # Returns Nothing if the clause contains both x and x' after the insertion.
  (List@<Var@>, Clause@) { Maybe@<Clause@>; }
  AddVars = (List@<Var@> vs, Clause@ c) {
    vs.?(nil: Just(c));
    Maybe@<Clause@> mc = AddVar(vs.cons.head, c);
    mc.?(nothing: Nothing<Clause@>);
    AddVars(vs.cons.tail, mc.just);
  };

  # Removes a variable from a clause.
  (VarId@, Clause@) { Clause@; } RemoveVar = (VarId@ vid, Clause@ c) {
    /Core/List%.ForEach(c, Nil<Var@>, (Var@ v, List@<Var@> vars) {
      EqId(vid, v.id).?(true: vars);
      Cons(v, vars);
    });
  };

  @(AddVar, AddVars, RemoveVar);
};

# The reasoning behind a variable assignment.
@ Why@ = +(
  Unit@ attempt,      # This is an attempt to rule out this variable.
  Unit@ pure,         # The variable is a pure literal, so no harm setting it.
  ClauseId@ inferred  # The value was inferred from the given clause.
);

Why@ Attempt = Why@(attempt: Unit);
Why@ Pure = Why@(attempt: Unit);
(ClauseId@) { Why@; } Inferred = (ClauseId@ id) { Why@(inferred: id); };

@ AssignOp@ = *(Var@ var, Why@ why);
@ RemoveClauseOp@ = *(ClauseId@ clause);

@ RemoveVarFromClauseOp@ = *(
  ClauseId@ clause,   # The clause to remove the var from.
  VarId@ var,         # The var to remove.
  Why@ why            # Why we are removing the clause.
);

@ RemoveClauseFromVarOp@ = *(ClauseId@ clause, Var@ var);

@ Op@ = +(
  AssignOp@ Assign,
  RemoveClauseOp@ RemoveClause,
  RemoveVarFromClauseOp@ RemoveVarFromClause,
  RemoveClauseFromVarOp@ RemoveClauseFromVar
);

@ Solver@ = *(
  ClauseId@ clause_id,
  Vars@ vars,
  Clauses@ clauses,
  Conflicts@ conflicts,
  List@<Var@> assigns,
  Fifo@<Op@> ops
);

Solver@ NewSolver = Solver@(
  Int|0, Vars.Empty, Clauses.Empty, Conflicts.Empty, Nil<Var@>, Empty<Op@>);

# @func[AddClause] Adds a clause to cnf state Solver@.
#  This should be done in the initial phase before starting to solve the
#  formula.
#
#  @arg[s] The cnf state to add the clause to.
#  @arg[clause] The clause to add.
#  @returns
#   An updated cnf state with clause added.
(Solver@, List@<Var@>) { Solver@; } AddClause = (Solver@ s, List@<Var@> vars) {
  vars.?(nil: {
    # An empty clause immediately makes the formula unsatisfiable. Model that
    # as two contradictory clauses to avoid the need to handle this case
    # specially elsewhere.
    AddClause(AddClause(s, List[Var@(Int|0, True)]), List[Var@(Int|0, False)]);
  });

  Maybe@<Clause@> mc = Clause.AddVars(vars, Nil<Var@>);
  mc.?(nothing: s);
  Clause@ clause = mc.just;

  ClauseId@ id = s.clause_id;
  Vars@ nvars = /Core/List%.ForEach(clause, s.vars,
    (Var@ v, Vars@ vs) {
      Vars.InsertWith(vs, v.id, (Maybe@<VarS@> mx) {
          VarS@ x = mx.?(
            just: mx.just,
            nothing: VarS@(Nil<ClauseId@>, Nil<ClauseId@>));
          v.pos.?(
            true: VarS@(Cons(id, x.pos), x.neg),
            false: VarS@(x.pos, Cons(id, x.neg)));
        });
    });
  Clauses@ nclauses = Clauses.Insert(s.clauses, id, clause);
  Solver@(Inc(id), nvars, nclauses, s.conflicts, s.assigns, s.ops);
};

# @func[SeedOps] Seed assign operations to start solving a formula.
#  This should be called after all clauses are added to the formula, to seed
#  the initial set of operations for processing.
#
#  It looks for pure literals and unit clauses, generating a list of assign
#  operations corresponding to those.
(Solver@) { Fifo@<Op@>; } SeedOps = (Solver@ s) {
  Fifo@<Op@> pures = Vars.ForEach(s.vars, Empty<Op@>,
    (VarId@ id, VarS@ vs, Fifo@<Op@> ops) {
      vs.pos.?(nil: Put(Op@(Assign: @(var: Var@(id, False), why: Pure)), ops));
      vs.neg.?(nil: Put(Op@(Assign: @(var: Var@(id, True), why: Pure)), ops));
      ops;
    });

  Clauses.ForEach(s.clauses, pures,
    (ClauseId@ id, ClauseS@ cs, Fifo@<Op@> ops) {
      # Assertion: There should be no empty clauses, because AddClause doesn't
      # allow that.
      cs.cons.tail.?(nil: {
        Put(Op@(Assign: @(var: cs.cons.head, why: Inferred(id))), ops);
      });

      ops;
    });
};

@ OpResult@ = +(Solver@ solver, Conflict@ conflict);

# @func[DoAssign] Do an assign operation.
#  Remove VarId from Variables map. If it's there:
#  @i Add variable assignment.
#  @i For each + clause, add a RemoveClause operation.
#  @i For each - clause, add a RemoveVarFromClause operation.
(Solver@, AssignOp@) { OpResult@; } DoAssign = (Solver@ s, AssignOp@ op) {
  Var@ var = op.var;
  Maybe@<VarS@> mvs = Vars.Lookup(s.vars, var.id);
  mvs.?(nothing: OpResult@(solver: s));

  VarS@ vs = mvs.just;

  List@<ClauseId@> match = var.pos.?(true: vs.pos, false: vs.neg);
  Fifo@<Op@> match_ops = /Core/List%.ForEach(match, s.ops,
    (ClauseId@ c, Fifo@<Op@> ops) {
      Put(Op@(RemoveClause: @(clause: c)), ops);
    });

  List@<ClauseId@> unmatch = var.pos.?(true: vs.neg, false: vs.pos);
  Fifo@<Op@> unmatch_ops = /Core/List%.ForEach(unmatch, match_ops,
    (ClauseId@ c, Fifo@<Op@> ops) {
      Put(Op@(RemoveVarFromClause: @(clause: c, var: var.id, why: op.why)), ops);
    });

  OpResult@(solver: @(
      clause_id: s.clause_id, 
      vars: Vars.Delete(s.vars, var.id),
      clauses: s.clauses,
      conflicts: s.conflicts,
      assigns: Cons(var, s.assigns),
      ops: unmatch_ops));
};

# @func[DoRemoveClause] Do a remove clause operation.
#  Remove clause from clauses. If it's there:
#  @i For each variable
#   @i Add a RemoveClauseFromVar operation.
(Solver@, RemoveClauseOp@) { OpResult@; }
DoRemoveClause = (Solver@ s, RemoveClauseOp@ op) {
  ClauseId@ c = op.clause;
  Maybe@<ClauseS@> mcs = Clauses.Lookup(s.clauses, c);
  mcs.?(nothing: OpResult@(solver: s));

  ClauseS@ cs = mcs.just;
  Fifo@<Op@> nops = /Core/List%.ForEach(cs, s.ops,
    (Var@ v, Fifo@<Op@> ops) {
      Put(Op@(RemoveClauseFromVar: @(clause: c, var: v)), ops);
    });

  OpResult@(solver: @(
      clause_id: s.clause_id,
      vars: s.vars,
      clauses: Clauses.Delete(s.clauses, c),
      conflicts: s.conflicts,
      assigns: s.assigns,
      ops: nops));
};

# @func[DoRemoveVarFromClause] Do a remove var from clause operation.
#  Remove the var from the clause if the clause is there.
#  @i If clause ends up with single var, add Assign operation.
#  @i If clause ends up with no vars, mark unsat and exit.
(Solver@, RemoveVarFromClauseOp@) { OpResult@; }
DoRemoveVarFromClause = (Solver@ s, RemoveVarFromClauseOp@ op) {
  ClauseId@ c = op.clause;
  Maybe@<ClauseS@> mcs = Clauses.Lookup(s.clauses, c);
  mcs.?(nothing: OpResult@(solver: s));

  List@<Var@> nvars = Clause.RemoveVar(op.var, mcs.just);

  nvars.?(nil: {
    # Claim: clause conflicts only arise from inferred variables,
    # not attempted assignments nor pure literals.
    ClauseId@ w = op.why.inferred;

    OpResult@(conflict: @(a: c, b: w, var: op.var));
  });

  Fifo@<Op@> nops = {
    nvars.cons.tail.?(cons: s.ops);
    Put(Op@(Assign: @(var: nvars.cons.head, why: Inferred(c))), s.ops);
  };

  OpResult@(solver: @(
      clause_id: s.clause_id,
      vars: s.vars,
      clauses: Clauses.Insert(s.clauses, c, nvars),
      conflicts: s.conflicts,
      assigns: s.assigns,
      ops: nops));
};

# @func[DoRemoveClauseFromVar] Do a remove clause from var operation.
#  Remove clause from var if the var is there.
#  @i If the var ends up with a single polarity, add an Assign operation.
(Solver@, RemoveClauseFromVarOp@) { OpResult@; }
DoRemoveClauseFromVar = (Solver@ s, RemoveClauseFromVarOp@ op) {
  Var@ var = op.var;
  Maybe@<VarS@> mvs = Vars.Lookup(s.vars, var.id);
  mvs.?(nothing: OpResult@(solver: s));
  VarS@ vs = mvs.just;

  List@<ClauseId@> match = var.pos.?(true: vs.pos, false: vs.neg);
  List@<ClauseId@> ncls = /Core/List%.ForEach(match, Nil<ClauseId@>,
    (ClauseId@ c, List@<ClauseId@> cls) {
      EqId(op.clause, c).?(true: cls);
      Cons(c, cls);
    });

  Fifo@<Op@> nops = {
    ncls.?(cons: s.ops);
    Put(Op@(Assign: @(var: Var@(var.id, Not(var.pos)), why: Pure)), s.ops);
  };

  VarS@ nvs = var.pos.?(
    true: @(pos: ncls, neg: vs.neg),
    false: @(pos: vs.pos, neg: ncls));

  OpResult@(solver: @(
      clause_id: s.clause_id,
      vars: Vars.Insert(s.vars, var.id, nvs),
      clauses: s.clauses,
      conflicts: s.conflicts,
      assigns: s.assigns,
      ops: nops));
};

# @func[DoOp] Apply an operation.
#  @arg[Solver@][s] The formula state to process the op on.
#  @returns[OpResult]
#   @i conflict if the op shows the formula is unsatisfiable.
#   @i The updated state of processing the op otherwise.
(Op@, Solver@) { OpResult@; } DoOp = (Op@ op, Solver@ s) {
  op.?(
    Assign: DoAssign(s, op.Assign),
    RemoveClause: DoRemoveClause(s, op.RemoveClause),
    RemoveVarFromClause: DoRemoveVarFromClause(s, op.RemoveVarFromClause),
    RemoveClauseFromVar: DoRemoveClauseFromVar(s, op.RemoveClauseFromVar));
};

# @func[DoOps] Process ops until no more ops remain or unsat.
(Solver@) { OpResult@; } DoOps = (Solver@ s) {
  Maybe@<Op@> mop = First(s.ops);
  mop.?(nothing: OpResult@(solver: s));

  Solver@ ns = Solver@(s.clause_id, s.vars, s.clauses, s.conflicts, s.assigns, Next(s.ops));
  OpResult@ result = DoOp(mop.just, ns);

  result.?(conflict: result);
  DoOps(result.solver);
};

@ Assignment@ = List@<Var@>;
@ SearchResult@ = +(
  Assignment@ sat,
  *(ClauseId@ clause_id, Conflicts@ conflicts) unsat
);

(Solver@) { SearchResult@; }
Search = (Solver@ s) {
  OpResult@ ms = DoOps(s);
  ms.?(conflict: {
    SearchResult@(unsat: @(
        clause_id: Inc(s.clause_id),
        conflicts: Conflicts.Insert(s.conflicts, s.clause_id, ms.conflict)));
  });

  Solver@ s = ms.solver;

  # TODO: Come up with a more efficient way to pick any single existing
  # variable.
  Maybe@<VarId@> mvar = Vars.ForEach(s.vars, Nothing<VarId@>,
    (VarId@ v, VarS@ _, Maybe@<VarId@> mv) {
      Just(v);
    });
  mvar.?(nothing: SearchResult@(sat: s.assigns));
  VarId@ var = mvar.just;

  Solver@ attempt = Solver@(s.clause_id, s.vars, s.clauses, s.conflicts, s.assigns,
    Put(Op@(Assign: @(var: Var@(var, True), why: Attempt)), s.ops));

  SearchResult@ attempted = Search(attempt);
  attempted.?(unsat: {
    Solver@ attempt = Solver@(
      attempted.unsat.clause_id,
      s.vars,
      s.clauses,
      attempted.unsat.conflicts,
      s.assigns,
      Put(Op@(Assign: @(var: Var@(var, False), why: Attempt)), s.ops));
    Search(attempt);
  });

  attempted;
};

# Result@ --
#   The result of trying to solve a sat problem.
@ Result@ = +(Assignment@ sat, Unit@ unsat);

(Solver@) { Result@; } Solve = (Solver@ s) {
  Solver@ seeded = Solver@(s.clause_id, s.vars, s.clauses, s.conflicts, s.assigns, SeedOps(s));
  SearchResult@ result = Search(seeded);
  result.?(
    sat: Result@(sat: result.sat),
    unsat: Result@(unsat: Unit));
};

@(VarId@, Var@, Clause@,
  Solver@, Assignment@, Result@,
  EqId, NewSolver, AddClause,
  Solve);
