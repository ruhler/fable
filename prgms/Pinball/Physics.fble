
<@>@ List@ = /List%.List@;

@ Num@ = /Pinball/Num%.Num@;
% Add = /Pinball/Num%.Add;
% Sub = /Pinball/Num%.Sub;
% Neg = /Pinball/Num%.Neg;
% Mul = /Pinball/Num%.Mul;
% Div = /Pinball/Num%.Div;
% Gt = /Pinball/Num%.Gt;
% Lt = /Pinball/Num%.Lt;
% Le = /Pinball/Num%.Le;
% Int = /Pinball/Num%.Int;

@ Vec@ = *(Num@ x, Num@ y);

(Vec@, Vec@) { Vec@; } AddV = (Vec@ a, Vec@ b) {
  Vec@(Add(a.x, b.x), Add(a.y, b.y));
};

(Vec@, Vec@) { Vec@; } SubV = (Vec@ a, Vec@ b) {
  Vec@(Sub(a.x, b.x), Sub(a.y, b.y));
};

(Vec@, Num@) { Vec@; } MulVS = (Vec@ a, Num@ s) {
  Vec@(Mul(a.x, s), Mul(a.y, s));
};

# RotateTo --
#   Given unit normal vector n and arbitrary vector v, rotate the vector v
#   to a coordinate system where n is at (0, 1).
(Vec@, Vec@) { Vec@; } RotateTo = (Vec@ n, Vec@ v) {
  Num@ x = Sub(Mul(n.y, v.x), Mul(n.x, v.y));
  Num@ y = Add(Mul(n.x, v.x), Mul(n.y, v.y));
  @(x, y);
};

# RotateFrom --
#   Given unit normal vector n and arbitrary vector v, rotate the vector v
#   out of a coordinate system where n is at (0, 1).
(Vec@, Vec@) { Vec@; } RotateFrom = (Vec@ n, Vec@ v) {
  Num@ x = Add(Mul(n.y, v.x), Mul(n.x, v.y));
  Num@ y = Sub(Mul(n.y, v.y), Mul(n.x, v.x));
  @(x, y);
};

@ Ball@ = *(Vec@ pos, Vec@ vel, Num@ radius);

@ Edge@ = *(
  Vec@ normal,     # Unit normal vector.
  Vec@ start,      # Starting position of the edge.
  Num@ length      # Length of the edge.
);

@ World@ = *(Ball@ ball, List@<Edge@> edges);

# HALF_G --
#   Half the acceleration due to gravity.
Vec@ HALF_G = Vec@(Int|0, Neg(Div(Int|1, Int|8)));

# R --
#   The coefficient of restitution: the fraction of energy preserved during a
#   collision.
Num@ R = Div(Int|10, Int|10);

# BallT@ --
#   A ball at a particular point in time.
@ BallT@ = *(Ball@ ball, Num@ time);

# Collide -- 
#   Check for and apply collision of ball with edge between start and end.
#
# If there is no collision, end is returned as is. If there is a collision,
# returns the ball in the state just after the collision at the time of
# collision.
(Ball@, BallT@, Edge@) { BallT@; }
Collide = (Ball@ start, BallT@ end, Edge@ edge) {
  Num@ radius = start.radius;

  # For there to be considered a collision, the ball must start above the
  # edge and end below the edge.
  # TODO: what if the ball starts just below the edge. Could that be a case
  # where it is falling through the edge due to imprecision? Can we consider
  # it a collision if the ball starts just below the edge too to prevent that?
  Vec@ s = RotateTo(edge.normal, SubV(start.pos, edge.start));
  Lt(s.y, radius).?(true: end);

  Vec@ e = RotateTo(edge.normal, SubV(end.ball.pos, edge.start));
  Gt(e.y, radius).?(true: end);

  # Potential collision detected.
  # r = y0 + vt ==>  t = (r-y0)/v
  Vec@ v0 = RotateTo(edge.normal, start.vel);
  Num@ t = Div(Sub(radius, s.y), v0.y);

  # Verify the collision happens within the segment of the edge.
  Num@ x = Add(s.x, Mul(v0.x, t));
  Lt(x, Int|0).?(true: end);
  Gt(x, edge.length).?(true: end);

  # Compute the new state just after the collision.
  Vec@ vc = Vec@(v0.x, Neg(v0.y));
  Vec@ end_pos = AddV(start.pos, MulVS(start.vel, t));
  Vec@ vel = RotateFrom(edge.normal, vc);
  BallT@(Ball@(end_pos, MulVS(vel, R), radius), t);
};

# CollideS --
#   Check for and apply collision between ball and a list of edges.
#
# If there is no collision, end is returned as is. If there is a collision,
# returns the ball in the state just after the collision at the time of
# collision.
(Ball@, BallT@, List@<Edge@>) { BallT@; }
CollideS = (Ball@ start, BallT@ end, List@<Edge@> edges) {
  edges.?(nil: end);
  CollideS(start, Collide(start, end, edges.cons.head), edges.cons.tail);
};

# Move --
#   Move the ball by the given amount of time, assuming velocity stays
#   constant.
#
# In case of collision, we break down the time period into smaller bits. The
# assumption that velocity is constant is intended to prevent the case where
# we break down the time period into smaller and smaller bits and end up never
# reaching the end of the time period as a result. This is also assumes we
# don't have any super tight corners that would cause us to collide an
# excessive number of times in a single time period.
(Ball@, Num@, List@<Edge@>) { Ball@; } Move = (Ball@ b, Num@ t, List@<Edge@> edges) {
  Le(t, Int|0).?(true: b);

  Vec@ end_pos = AddV(b.pos, MulVS(b.vel, t));
  BallT@ end = BallT@(Ball@(end_pos, b.vel, b.radius), t);
  BallT@ cr = CollideS(b, end, edges);
  Move(cr.ball, Sub(t, cr.time), edges);
};

# Tick --
#   Advance the world by one unit of time.
(World@) { World@; } Tick = (World@ w) {
  # 1. Compute average expected velocity over the time period.
  Vec@ v_avg = AddV(w.ball.vel, HALF_G);

  # 2. Move the ball assuming constant velocity.
  Ball@ b_moved = Move(Ball@(w.ball.pos, v_avg, w.ball.radius), Int|1, w.edges);

  # 3. Compute final velocity.
  Vec@ v = AddV(b_moved.vel, HALF_G);

  World@(Ball@(b_moved.pos, v, w.ball.radius), w.edges);
};

@(Vec@, Ball@, Edge@, World@, Tick,
  AddV, SubV, MulVS);
