Fble Docs
=========
In the process of writing tutorials and trying to generate man pages, the
question has come up of whether we should use markdown or asciidoc. Let's
discuss.

Markdown is fairly standard and reasonable enough to use. But it doesn't
consistently support advanced features I would want for real documentation or
anything more basic than headings, links, and lists. I want things like
includes and definition lists.

I would love a tool that can check the syntax of my docs. And also be able to
convert to man pages in a fairly standard way.

I feel like asciidoc is more likely to have well defined syntax, advanced
features for more complicated docs, and conversion to man pages.

The potential downsides of asciidoc:
* Another dependency to add to the project. Though it could be set up as a
  dist dependency rather than a build or run dependency.
* Potentially less appealing syntax? Need to double check.
* Less standard, for example, integration with github readme.

Where I'm thinking about using docs:
* Project README - how does it show up on github?
* Tutorials - how easy to connect tutorials together?
* Book - booklike stuff wanted.
* Program help text to convert to man pages.
* Library function doc comments to convert to man pages.

I would like to check the syntax of asciidoc too:
* Support for '##' style headers instead of '~~~~~~~'?
  == Title ==, === Title === looks like is what we would use.
  Not consistent with markdown.
* Support for definition lists?
  Yes. For example:
   x:: ...

See /usr/share/doc/asciidoc/userguide.html for asciidoc docs.

In general, it's pretty clear that asciidoc will not be compatible with
markdown.

Apparently github does support asciidoc? Yes. I just need to use '.adoc',
'.ad', or .asciidoc extension.

I don't see an obvious syntax checker for asciidoc yet, but maybe we could
enable warnings and give an error if there is a warning generating some
format for asciidoc.

My vote: let's give asciidoc a shot. I know how I feel about markdown. It's
been a while since I tried asciidoc.

To start:
* Update README, tutorials
  - Add build commands to call asciidoc or asciidoctor as seems best for
    syntax checks.
* Consider generating man pages for --help via asciidoc fragments instead of
  using help2man.

Oh, I guess one question is how a doc comment would look as an asciidoc.

// Foo --
// Inputs::
// * ...
// Side effects::
// * ...
// Returns::

I think it works via definition list just fine. Cool. Is it worth changing the
header too?

// = Foo =
// Inputs::
// * ...
// Side effects::
// * ...
// Returns::

That's just as easy to parse as // Foo --. I think it looks fine.

---

Initial reactions after converting README.md to README.adoc:
* asciidoc does give an error in some cases.
* Reading the asciidoc.txt sample file, it's not quite as easy for me to read
  in ascii format as I would have liked.
* I don't like having 'XXXXXXXXXXXXXXXXXXXXXXXXXXXX' delimiters for things.
  Seems like arbitrary length lines are asked for. Just use 4 chars to start?
* It's nice having definition lists. I like that.

---

I wonder if I can write help usage for programs directly in asciidoc, and
import the rendered text to use in --help. Wouldn't that be nicer? Then we
could read it separately, include in a bigger manual, generate man pages, all
that from the raw source documentation?

Trouble is, manpage input format has special requirements different from help
text and generic asciidoc description.

Also, trying to generate text output from asciidoc is a pain. And I don't like
the generated output style at the moment (lots of horizontal rules for no
apparent reason?).

Ugh. I'm going to be honest. I feel like really all I want is:
* title, section headers, paragraphs, unordered lists, ordered lists,
  definition lists, code blocks, inline code blocks, comments, callouts (todo,
  warning, note, etc.), references to other docs, links.

Markdown and asciidoc are both so close, but not quite there?
* markdown is missing definition lists, callouts, references to other docs?
* asciidoc is missing... none of these? But it doesn't do nested indenting
  well. Like, definition lists can't be indented, right? No, it looks like you
  can indent them.

---

The real problem is, I don't have enough control over how things are
generated, because I don't have my own programmatic representation of a
document. Imagine I could parse a document and represent it abstractly. Then I
could easily generate whatever I want in terms of man pages and checking
proper document format.

But, guess what? I have a programming language that I could use for this. Why
not write a doc package in fble? Generating man pages is not going to be
difficult.

How things could work:
* fble program to parse header files and generate man pages.
* fble program to parse help text and generate man pages.
 - I don't think we want to generate help text from an fble program, because
   that gives us an annoying bootstrapping problem.

But that still leaves open the question: what syntax do we use? Do we keep
README as a markdown format? What syntax do we use for tutorials, markdown?
Asciidoc?

I'll tell you the syntax I like: markdown plus definition lists. I guess
technically we could use asciidoc for that, because I think asciidoc,
technically, supports the '## ...' style section titles (though vim doesn't
syntax highlight that).

My documentation needs are not complex. If I want to go for a standard
approach, asciidoc is better because it supports everything I could want in a
more standard way than markdown. For man pages, I really would prefer to
generate them myself.

So, here is what I propose: Use a strict, small, subset of asciidoc. Write an
fble program that can parse that subset of asciidoc. Use it for the following:
* To extract doc comments on header files and generate man pages.
* To extract help text on main program and generate man pages.
* To syntax check my README file and tutorials.

How about if I don't want to write my own program? If I don't want to be
restricted to a subset of asciidoc?
* README file and tutorials can be fullblown asciidoc.
* Write code to extract general description and convert to custom format man
  page for library code. As in, everything in the doc comment goes to the
  description section of the man page. Ignore RETURN VALUE section of man
  page. Write my own wrapper around the asciidoc.
* Continue to use help2man for commands? Or write them in such a way that I
  can extract asciidoc directly?
 - The hard part is separating synopsys and options? Honestly, I don't really
   want asciidoc syntax in the output of --help.

Perhaps another option is to write my own asciidoc backend to generate text
to use as input to --help and for man pages? That's an idea worth exploring I
think.

So, here's where we stand at the moment:
* Continue to push ahead with asciidoc approach, but explore more advanced
  options. Don't give up on asciidoc yet.

Proposal:
* README and tutorials in asciidoc.
* --help text for commands generated automatically from fble-foo.adoc file
  using a custom asciidoc backend.
* man page for commands generated automatically from fble-foo.adoc file using
  another custom asciidoc backend.
* Use tcl to extract header file doc info and generate man pages from them via
  asciidoc using another custom asciidoc backend.


Let's start by seeing if we can generate useful --help from an asciidoc file.

Features to look for:
* attribute to define brief format for man page.
* attribute to define synopsys/usage text.

Ug. It's just hard. Asciidoc is so complicated. I really am tempted to just
write my own. It can't possibly be that hard to parse basic formatting, can
it?

---

Before going down that route, let's just double check if there isn't some
other standard document format that meets my requirements.

creole - no definition lists
github flavored markdown - no definition lists
mediawiki - no definition lists
reStructuredText - no definition lists, overly verbose.

No, I don't see any that I like. Best bet, I feel like, is to use a subset of
asciidoc, call it asciidoc, but implement my own parser for the subset.
Hopefully that gets me the best of most worlds:
* Standard doc format that can be read by things like github and vim syntax
  highlighting.
* Full control over generated output.
* Can implement my own checker.
* No need to have asciidoc installed.

With the plus of having another fble program to try to write.

Let's be honest about what this really means:
* For doc comments and --help text, use a subset of asciidoc.
* For everything else, may as well use full asciidoc.

Because I only need to generate man pages from doc comments and --help
text.

---

Every time I try to do asciidoc, it feels like a slog. I'm playing around with
labelled lists using fairly commonly accepted syntax of:

label
: definition
label
: definition

It's actually not so bad.

Oh, and I should remember I probably want the language spec to be turned into
a doc with whatever format I choose.

I'm not sure if github supports definition lists in its markdown.

Options:
* markdown with definition lists
 - custom parser and man page generator for a subset?
 - or use pandoc or some such for generating man pages.
* asciidoc 
 - custom parser and man page generator for a subset?

---

Screw it. Let's me have some fun and do my own doc format from scratch. It can
be whatever I want: as similar or different from markdown or asciidoc. No
worry about standards or anything like that. How would I do it?

We have a lot of docs existing to work with. Let's start with adding minimal
features needed for those. Starting with README:

* Title (or section 0?)
* Sections (each with a title)
* Paragraphs
* Definition list.
* Verbatim blocks.
* Inline verbatim.

Start with those.

The syntax I'm thinking about:
* section syntax, paragraphs, verbatim blocks, inline verbatim from markdown.
  Ish.
* definition list is:  '@ <label>: <definition>'.

Let's see how that might look.

What extension should I use for my doc format? .txt perhaps? .fbld, short for
fbledoc? Let's stick with .txt for now. README.txt looks okay to me for now.
It would look even better with syntax highlighting.

Anyway, more important than the concrete syntax is the abstract syntax.

First question: is everything in a section, or can there be things not in a
section? Explicit sections have titles. If you had something in an implicit
section, would it be a section without a title?

Once you start a section, the only way out is to start a new section or end
the document. We don't have explicit section end markers. That, to me,
suggests a section has a title, optional (non subsection) content, followed by
a list of subsections.

Then it makes sense for a whole doc to be a top level section. The title of
the top level section is the title of the doc?

Question: what's the difference between the 'root' section, and a top level
section? For example, if we use:

# Foo
...

To give the title of the doc, what if you say:

# Foo
...

# Bar
...

Then we don't have a document title, but rather two level 1 subsections in the
document. Options:
* Don't allow level 1 section anywhere in doc except at the beginning.
* Use a separate syntax to describe the title of the doc.

I'm leaning towards using separate syntax for the document title.

Historically I've used:

Title
=====
Author

Anyway, that's back to a concrete syntax issue. Sounds like sections are clear
to me.

Section:
  (title :: String)
  (content :: Maybe Content)
  (subsections :: [Section])

Where a top level document is of type Section.

Question: Can we use inline formatting in titles? I don't think I personally
tend to do that in practice. Let's simplify and say no for now. We can add
that back later.

What is content?

Content is a list of (non-section) blocks.

Content: (blocks :: [Block])

Block: ParagraphBlock | CodeBlock | DefinitionListBlock
ParagraphBlock: (spans :: [Span])
CodeBlock: (text :: String)
DefinitionListBlock: [(label :: String, content :: Content)]

Span: TextSpan | CodeSpan
TextSpan: (text :: String)
CodeSpan: (text :: String)

Note, in particular, the body of a labelled list element is Content, which
could be multiple paragraphs. At minimum it is at least a single paragraph.
I'm not sure if that's right, but it's a good place to start. It's only wrong
if we have reason to distinguish between a paragraph and a list of spans. I
don't see a reason to.

Cool. We have a draft spec for documents. Shall I codify it? Then we can dig
into the nitty gritty of the concrete syntax.

Section:
* '#' in left column, number of consecutive '#' is section level. Whitespace 
  after last '#'. Everything following the whitespace to the end of the line
  is the name of the title.
* Let's say line before and after have to be blank lines. So blank lines form
  a kind of delimiter here.
* Content is everything that follows up until the next section that's not at a
  subsection level from this one.

Document title brainstorm:

Foo
===

# Foo

% Foo

Honestly, I like the first one from a human reader point of view. It gives
weight enough to make it look like a title, and leaves room for metadata
beneath it. I think better to be entirely separate from section syntax, even
though the whole doc is meant to be one big section.

Okay, so, ignore any initial blank lines in the document.
The first non-blank line should be followed by a line of '===...' of same
length as previous line? Let's say it's an error not to include a title? Or
should the title be optional? Can the title be empty?

Food Thought
====

Food
=========

I don't like having to match the number of '=' to the length of the title. I
don't like it being mismatched. Anything better we could do instead?

= Foo =
Richard Uhler <...>

Actually, I think a single '=' sign beneath looks okay.

Foo
=
Richard Uhler <...>


Okay, let's say title is first non-blank line, and it must be followed by a
line consisting of one or more consecutive '=' signs, of any number.

To have an empty tile? A section title could be empty by just not providing
one. How about same here: empty title by having the line of '=' be the first
thing.

What about no title at all? Like, no '=' at all? I don't like it. I want it to
be required.

Okay, so, start of document is:
  <blank lines>
  non-blank line followed by '==' line
  or '==' line

And content starts after a blank line, then beyond.

That's sections for you. Next is blocks, which could be at some indent level,
because we may want nested lists. We keep track of a current indent level and
read blocks relative to that.

Skip blank lines. Interesting question: can we always use blank lines for
delimiters? Is there ever a time we don't want to do that? I'm thinking of a
code block with blank lines in it. If we treat blank line as delimiter, that
would mean we have multiple code blocks back to back rather than a single code
block.

I certainly have code blocks in question with blank lines in them. Potentially
multiple blank lines. Imagine we want to highlight a code block a different
color. I think we need to consider code blocks with blank lines inside them
all as one code block. Don't get rid of the blank line. Especially if there
are multiple.

How about start and end of a code block? Strip blank lines? Then, is it not
possible to have an initial blank line?

How about this: code blocks are always indented. That's the concrete syntax
for them. So, if you want to continue the code block, continue the indent.

So, a single code block:

....@ Unit@ = *();
....@ Bit@ = +(Unit@ 0, Unit@ 1);
....@ Bit4@ = *(Bit@ 3, Bit@ 2, Bit@ 1, Bit@ 0);
....
....Unit@ Unit = Unit@();
....
....Bit@ 0 = Bit@(0: Unit);
....Bit@ 1 = Bit@(1: Unit);

And three adjacent code blocks:

....@ Unit@ = *();
....@ Bit@ = +(Unit@ 0, Unit@ 1);
....@ Bit4@ = *(Bit@ 3, Bit@ 2, Bit@ 1, Bit@ 0);

....Unit@ Unit = Unit@();

....Bit@ 0 = Bit@(0: Unit);
....Bit@ 1 = Bit@(1: Unit);

From a viewer's perspective, they look the same. No harm. The hardest part
will be writing them and remembering to indent if you want it to be a single
block.

This way you can do blank lines before and after the same way. I like that.

And this way, we can treat blank lines as delimiters of content.

In terms of blocks, taking into account the indent level to know how much of
the stack of current elements to close:
* '# ' starts a new section.
* '* ' is a list element.
* '@ ' denotes a labeled list element.
* '  ' or other indent is a code block.
* Anything else is a paragraph. Hopefully you don't want to start a paragraph
  with '#', '*', or '@'. If you do, uh... We should have a paragraph symbol
  you can use to escape those? Or, just escape with a '\' character? But what
  if we want, for example, bold to start the paragraph, versus '*' to start
  the paragraph? Maybe have '$ ' or '^ ' be an optional paragraph marker for
  those special cases? Or '*' versus \*? No, I like '$ ' or '^ ' for an
  explicit paragraph, as opposed to an implicit paragraph. Then *foo* could
  still be a bolded thing at the front a paragraph, and \* foo could be a
  literal '*' character at the start of a paragraph.

* this is a list item
$ *this* is a bolded first word of a paragraph.
$ \*\*\* is three asterisks at the start of a paragraph.
$ *\** is a bold asterisk at the start of a paragraph.

---

An important challenge is going to be allowing special characters to show up
as regular characters in paragraphs. Here is what I propose:
* A blank line is required after a paragraph before you consider anything a
  special character. Blank line between paragraph and section, list, etc.
* Option, or maybe always have it be, so the first line clearly denotes a
  paragraph.

For example, maybe paragraphs always have a single space to start? Is that
sufficient? So we don't have to worry about what may be a special character,
and we can add all sorts of new special characters later on like, 1, 2, 3, a,
b, c, A, B, C, i, I, etc.

I don't know. Single space to start each paragraph feels weird to me. Too
subtle perhaps. Awkward with single line paragraphs. Maybe for now stick with
the idea of '$' optional to start? Or, think about it more.

Maybe a better approach would be to make special characters more special. They
don't show up too often. Not as much as paragraphs. For example, maybe '@' is
in front of every special character, and we just need to escape @@?

@## Section
@* list item 1
@* list item 2
   @* nested list item
@. X: labeled.

Who puts '@' in a paragraph anyway?

No. I think go with what we had before. No special '@' character. Take our
changes with having to know what to escape. Allow '$' as an explicit paragraph
marker to support those escapes.

---

Next topic of discussion: whitespace and the vagaries thereof.

Is it okay to align, for example, definition lists? I'm pretty sure I would
want to. For example:

  -I DIR::                     add DIR to the module search path
  -m, --module MODULE_PATH::   the path of the module to compile

The definitions are left aligned. That means there is an arbitrary amount of
space between the label and the definition.

According to our abstract syntax, the definition is <Content>. Content can be
a code block, and a code block is denoted by using indent. If we support
arbitrary whitespace between label and definition, how could we possibly code
block content for that definition?

Options:
* Don't allow arbitrary whitespace. Always use a single space.
* Use '> ...' as an indicator for code block instead of indent.
* Have some sort of invisible hack, for example, where we put the verbatim
  text on the next line.

That also begs the question: for definition lists:
* What is the indent level set to for subsequent lines.
* How to put the definition on a separate line?

For example:
   @ foo: this is a really long example text in
          a short window
   @ bar: here is a another example that is
     slightly different
   @ sludge:
     here is a definition on a different line.
   @ also:             left aligned definition
     that wraps back to the beginning.
   @ and also:         left aligned definition
                       that wraps back to the 
                       alignment
  
More examples:
  @ -I DIR:                     add DIR to the module search path
  @ -m, --module MODULE_PATH:   the path of the module to compile

  @ -I DIR: add DIR to the module search path
  @ -m, --module MODULE_PATH: the path of the module to compile

  @ -I DIR:
    add DIR to the module search path
  @ -m, --module MODULE_PATH:
    the path of the module to compile

  @ bin/:
    Source code for fble compiler binaries.
  @ book/:
    Drafts for a book about the design of the fble language.
  @ include/:
    Public header files for the fble library.
  @ lib/:
    Source code for an fble interpreter and compiler implemented in C.
  @ pkgs/:
    Sample fble library and application packages.
  @ spec/:
    Specification of the fble language, including spec tests.
  @ test/:
    Source code for fble test binaries and other test utilities.
  @ thoughts/:
    A collection of running discussions about fble.
  @ tutorials/:
    Tutorials for getting started with fble.

Okay. That's actually growing on me. In this case, we require the label to be
on its own line. The content starts at 2 space indent on the next line. The
above examples are worst case examples where you might want compact definition
lists. They aren't so bad. They are all aligned. And now, in theory, we could
have a code block:

  @ foo:
        code block is here

Question: do we need the colon at all now?

  @ -I DIR
    add DIR to the module search path
  @ -m, --module MODULE_PATH
    the path of the module to compile


  @ test/
    Source code for fble test binaries and other test utilities.
  @ thoughts/
    A collection of running discussions about fble.
  @ tutorials/
    Tutorials for getting started with fble.

I feel like no, we don't.

---

Next topic: how many spaces to indent?
* always 2 spaces?
* let the user decide?

It's related to the above discussion. If it's not a fixed number of spaces,
then code blocks aren't obvious to start when entering a new indent level.

I personally would always decide 2 spaces. This is for me. Let's just require
2 space indent everywhere.

---

Idea: let's call this format fbld. Recycle the name. Where 'd' stands for doc.
You could imagine having 'fblt' for my 'test' format.

---

Question: how do you have two back-to-back lists? For example:

* l1.1
* l1.2

* l2.1
* l2.2

Is that one list or two? Now, consider instead:

* l1.1

* l1.2

* l2.1

* l2.2

That's clearly one list. How about:

* l1.1

* l1.2


* l2.1

* l2.2

How about:

* l1.1

* l1.2 

  which in this case is a multi-line list item.

  Which makes it much harder to keep track of the end.

* l2.1

* l2.2

Actually, it's not too hard. If we want to support multiple lists back to
back, put two blank lines before the list element instead of a single blank
line. This suggests we can't coalesce blank lines together into generic
delimiters, because we want to allow blank lines between list items, but also,
in this case, between lists.

Whitespace means so much in this language. I guess that's not surprising,
given the goal is to have something structured and uncluttered. So we use
whitespace for the structure without having it clutter things up.

---

Anyway, I think we have enough worked out to get going. I think it could be
easier to write the spec after first writing an implementation. This spec
sounds hard to me to write, given the effect of whitespace, indent, and
context on the meaning of the syntax.

Things to do:
* Draft fbld.txt spec.
* Start pkgs/fbld with definition of Doc@ types.
* Implement printer for Doc@.
  - Do it right, so we can use this to see if there are any kinds of documents
    you can't express in the concrete syntax.
* Implement parser for Doc@.
* Write a vim syntax file.

Summary of decisions so I don't forget:
* title\n=== for title, where any number of '=' characters allowed.
* '#' for section
* '*' for unordered list
* '@ <label>\n  <content>' for definition list.
* '$' optionally for paragraph
* paragraph requires blank line to end.
* 2 space indent for code block
* 2 space indent for continuation.
* 2 blank lines splits lists in two.
* `...` for code inline

Future work:
* *...* for bold inline? italic inline? mixed bold/italic?
* Numbered lists.
* link to other file.
* 'include' other file (with some handling of section levels).

---

Interesting side note: github renders markdown files nicely, and asciidoc
files. It would be nice if links between files worked for that. Presumably
using my own markup language will not work with github.

Looks like links in theory would be: [display](tutorials/Tutorials.md). So
that would be, uh, [tutorials/Tutorials.md](tutorials/Tutorials.md)? Could I
just do (tutorials/Tutorials.md) instead? In asciidoc, you can do
link:tutorial/Tutorials.md[]. Maybe markdown can do
[](tutorials/Tutorials.md)? Apparently not.

In that case, maybe I want to use asciidoc primarily while in the progress of
switching to my own format? Now because it has definition lists and more
convenient local reference links.

---

Let me give asciidoc another chance. It seems to be okay for tutorials,
readme. Can we use it reasonably for man pages is the question. I think it's
worth having the same discussion again that we had before, in case anything
different comes out of it.

First commands:
* Writing the man page in asciidoc creates a reasonable description to read. I
  have no complaints with, for example, bin/fble-compile.adoc.
* The generated man page is not great, but it's serviceable.
  - Examples don't render very well.
  - No bold/italics in synopsis.
  - But aside from minor things like that, it's fine.
  - I guess this is because I haven't manually done the markup. I can add
    that.
* Any way to get --help text from this?
  - The default generated text is not nearly concise enough. Table of
    contents, lots of blank lines, lots of -------------- lines.

The question, then, is how can I change the style of the output? Maybe now's a
good time to read the documentation for asciidoc in detail, with an eye for
how to do my own output formatting.

Notes from reading asciidoc docs:
* Learn about DocBook.
* In theory I can change the input language by changing config files.
* DocBook is XML. XSLT is a style sheet. Looks like we could provide custom
  XSLT and CSS stylesheets.
* See manpage.xsl for the manpage style sheet.
* There is something called themes, which changes .css and .js for generated
  html?
* It's possible to annotate a section with a template name, which appears to
  get processed in a template-specific way in the backend. For example:
  'bibliography' section.
* We can automatically set the template for a section based on its title using
  [specialsections] part of an asciidoc .conf file. But this use is not
  recommended. They say it is deprecated.
* Looks like the .conf file contains templates for generating documents.

Okay, so how does the text backend work when invoking a2x? Does asciidoc
generate docbook via docbook backend, and then use xslt to turn that into
text? Or does it go straight asciidoc to text?

It goes:
foo.adoc =(asciidoc)=> foo.xml =(xsltproc)=> foo.text.html =(w3m)=> foo.text

In this case, a lot of the junk is brought in by xsltproc.

So, we have options. We could try to add special config file to go straight to
text from foo.adoc. Or we could try to improve xsltproc.

How do man pages work right now? It generates a different foo.xml file that is
a refentry format instead of article format. Then uses xsltproc with a manpage
xslt sytlesheet to generate the man page.

Let's first understand the asciidoc conf files and how the .xml file is
generated. For man pages:

/etc/asciidoc/asciidoc.conf
- defines input language format.

/etc/asciidoc/docbook45.conf
- generates the xml tags using templates.

Then a bunch of mostly irrelevant filters:
  /etc/asciidoc/filters/graphviz/graphviz-filter.conf
  /etc/asciidoc/filters/source/source-highlight-filter.conf
  /etc/asciidoc/filters/music/music-filter.conf
  /etc/asciidoc/filters/latex/latex-filter.conf
  /etc/asciidoc/filters/code/code-filter.conf

/etc/asciidoc/lang-en.conf
  English language stuff.

Can I try doing my own configuration files to start? Or, are there any other
configuration files available I could use instead? No. But I bet I could write
my own.

How about we start here then? How would I turn my man-page structured
fble-compile.adoc file into help-text suitable output?

* <NAME> section
* Add 'Usage:' in front of synopsys section text, same line.
* Render description in as-is formatted text, limited to 80 cols.
  Maybe go through roff or something to do the formatting for me?
* Change sect2 titles to '<Title>'
* Change sect3 titles to '<Title>:'

It's all the same info. I think it's reasonable to try and generate help text
from the man page asciidoc input.

Shall I try?

Looks like I could use:
  asciidoc -v -e -f /etc/asciidoc/asciidoc.conf -f ruhler.conf fble-compile.adoc

To try and pass my own custom .conf file. I'm not sure how to use my own
backend otherwise.

---

Working through how to make a config file that would translate
fble-compile.adoc to a reasonable usage help text:
* How to add Usage: as special case for SYNOPSIS section?
* How to get rid of &#8230; for '...' in synopsis?
* How to add blank lines between paragraphs in the description?
* How to get list item numbers?
  - {listindex} is the attribute (found by reading /usr/bin/asciidoc).
* How to put first list line on the same line as list index?
  - I don't think I can.
* Indent options. How to put definition on same line?
* How to show 'EXIT STATUS', 'EXAMPLE' titles as special case for those
  sections?
  - Or maybe remove NAME, SYNOPSYS, DESCRIPTION, OPTIONs as special cases?
* Remove footer text. DONE.
  
The generated output from asciidoc includes raw text from the input file. That
means I can't do direct processing on that text, like stripping newlines,
reflowing to fit column width, etc. Things like aligning list definitions will
be hard. This suggests I'll want to pass the output through some post
processor that can do wrapping and alignment for me.

Two post-processors come to mind:
1. Whatever is used for man pages. roff?
2. xsltproc.

Perhaps it's worth learning about xsltproc first.

Okay, I guess let's read about xslt:
* Ugh. It's a template language in xml syntax. I'm not convinced it will be
  sufficient to address the problem I'm having. That is, I don't think it will
  provide layout functionality. If it doesn't, then there is no value using it
  instead of using asciidoc for that part.

Why is this so hard? Why can't we just have a data structure that I can write
python code to generate output from, for example? I could probably write a raw
xml backend to asciidoc, and then use xml libraries in python to generate
output.

Maybe now is a good time to step back and ask what I'm trying to accomplish in
this case anyway. I want to have a single source of truth for the
documentation of an fble binary program that can be reused in the man page and
--help text. I've said asciidoc is nice to use to describe the single source
of truth, because it has the structure elements for lists, sections, etc. In
that case, however, we would require asciidoc to generate the executable. Is
that really what I want? Like, is this worth the complexity and overhead? Just
duplicate the usage info. It's not that much.

I could, of course, go the other direction, like I have now. Custom structured
usage text that I generate asciidoc and/or man pages from. It's limited
because I want to use the compact text form as the source of truth, which
makes it hard to extract structure.

There are a few cruxes here:
* How to capture structure in compact text?
  - For if I want --help to be source of truth.
  - For library function doc comments.
* How to avoid bootstrap problem for fble binaries
  - To minimize dependencies needed to build them.
  - To have them not depend on themselves.
* How to minimize dependencies on external tools.
  - Like help2man, asciidoc, xsltproc, etc.
* How to take advantage of github / other standard processing of docs?

If it weren't for github showing asciidoc and markdown nicely, it makes sense
to have a custom format:
* --help text and doc comments are source of truth.
* So no issue with bootstrapping.
* No extra dependencies.
* Full control over generated code.
* A fun example to add to fble.

The downsides being:
* Github doesn't render things in a pretty fashion.
* Readers won't be able to google to understand the syntax of documentation.
* It could be a fair amount of work to define my own markup language.

Perhaps fble binaries are a bad place to start, because they don't really need
clear text source of truth. But library doc comments do need a clear text
source of truth, because they are comments in code.

// # FbleNewStructValue
//
// Create a new struct value with given arguments.
//
// @ Inputs
//   @ heap
//     The heap to allocate the value on.
//   @ argc
//     The number of fields in the struct value.
//   @ args
//     'argc' `FbleValue` arguments to the struct value. Args are borrowed,
//     and may be `NULL`.
//
// @ Results
//   A newly allocated struct value with given args.
//
// @ Side effects
//   * The returned struct value must be freed using FbleReleaseValue when no
//     longer in use.

That's a little less compact than I want though. I would prefer:

// FbleNewStructValue --
//
// Create a new struct value with given arguments.
//
// Inputs:
//   heap - The heap to allocate the value on.
//   argc - The number of fields in the struct value.
//   args - 'argc' `FbleValue` arguments to the struct value. Args are borrowed,
//          and may be `NULL`.
//
// Results:
//   A newly allocated struct value with given args.
//
// Side effects:
// * The returned struct value must be freed using FbleReleaseValue when no
//   longer in use.

That is, the '@ ' of a definition list shifts things two characters to the
right, and the newline shifts things down an extra line.

Compare to doxygen:

/**
 * \brief Create a new struct value with given arguments.
 *
 * \param heap  The heap to allocate the value on.
 * \param argc  The number of fields in the struct value.
 * \param args  'argc' `FbleValue` arguments to the struct value.
 *              Args are borrowed, and may be `NULL`.
 *
 * \return A newly allocated struct value with given args.
 *
 * @ Side effects
 *   * The returned struct value must be freed using FbleReleaseValue when no
 *     longer in use.
 */

Which is slightly more compact, because it doesn't use extra lines for
'Inputs', 'Results', and 'Side effects' sections or the title of the function.

Maybe I come up with my own doc comment format?

Why not use doxygen:
* It doesn't generate output the way I want.
* No tag for side effects.
* Doesn't have title of function at top of comment.
* \brief seems not useful to me.
* I don't like /** ... */ to denote doc comment? Though I guess I don't care
  that much. This could be a decent way to denote what is a doc comment versus
  general code comment.

I might prefer something like:

/**
 * FbleNewStructValue
 * 
 * Create a new struct value with given arguments.
 *
 * \param heap  The heap to allocate the value on.
 * \param argc  The number of fields in the struct value.
 * \param args  'argc' `FbleValue` arguments to the struct value.
 *              Args are borrowed, and may be `NULL`.
 *
 * \return A newly allocated struct value with given args.
 *
 * \effect The returned struct value must be freed using FbleReleaseValue when
 *         no longer in use.
 * \effect Some other effect, just for example purposes.
 */

Asciidoc would give us:

// FbleNewStructValue
// ------------------
// Create a new struct value with given arguments.
//
// Inputs::
//   heap:: The heap to allocate the value on.
//   argc:: The number of fields in the struct value.
//   args:: 'argc' `FbleValue` arguments to the struct value.
//     Args are borrowed and may be `NULL`.
//
// Results::
//   A newly allocated struct value with given args.
//
// Side effects::
//   * The returned struct value must be freed using FbleReleaseValue when no
//     longer in use.

That's pretty compact.

---

Let me take a break from this to start working on what needs to be done
regardless: extract the doc comments from the header files. I'm thinking in
tcl.

Can we get everything with some regex? My goal would be: given a header file,
extract all the doc comments into a list.

---

I'm going to take a detour and try the doxygen route. I'll get back to you on
how well that works out.

---

Here's where we are currently at with documentation:

* binaries:
 - help usage as plain text in program.
 - man pages via help2text or asciidoc. Need to make a decision.
* library functions:
 - doxygen in source code.
 - man pages via doxygen. Need to set up install.
* tutorials, readme, spec, etc.
 - asciidoc.

And general thoughts:
* asciidoc takes a long time to convert spec to html, and syntax highlighting
  in vim doesn't work at all. Yet another case of asciidoc "ugh".
* It would be great to have easy programmatic access to the structure of these
  docs, because then I could generate whatever I want from them.
* If I'm doing my own doc format, maybe don't rely on indentation for meaning?
  Because vim syntax highlighting sounds hard in that case. And if it's hard
  for vim, it's hard for anyone.

What if I take a break by implementing a markdown library in fble? It's been
too long since I've written fble code. Anything I write I could later adapt to
support a custom format if I want, or asciidoc, or some subset of
markdown/asciidoc, and get more control over generated manpages, etc. Not
necessarily for practical purposes, but for example purposes?

Start with commonmark, which is best standardized. But what do you do with it?
Parse it? Convert it to something? Convert it to a man page?

---

Let the spiral continue.

Imagine I wanted to invent my own doc format. What are the goals and use
cases?

* vim syntax highlighting that works.
  - e.g. metadata colored differently, section titles highlighted, definition
    terms. Just a little bit to add color here and there.
* Be able to write code to generate whatever outputs I want based on document
  structure.
* Be able to clearly specify structure document.
* Be able to capture all the structure I care about it my own documents.
  - e.g. definition lists, links, etc.
* Support for document-specific custom structure
  - e.g. sideeffects, synopsis, concrete/abstract/example.
* Support for generating man pages, latex, html.
  - man pages for distribution. latex and html as option to share more
    formally.
* Content can be understood easily from reading document source.
* Focus on structure only, not on presentation.
* Easy to parse structure by computer or by human.
* Would be nice if we could have a linter/error checker to detect errors in
  syntax.
* Would be nice if things like github could auto-display the formatted
  version, but I assume that won't happen for anything custom I do.
* Nice concrete syntax to write (whatever that means).

As we've said before, we can separate into two parts: abstract syntax and
concrete syntax. The abstract syntax will be whatever is important to me. I
can look at my existing docs to get an idea.

What's wrong with existing formats?
* Markdown
  - Lacks structure I care about, like definition lists (though I could pick
    one of the extended formats that does have definition lists).
  - I don't have my own parser for it (though I could write one).
  - Structure not entirely obvious from reading. Just look at how complicated
    the specs are.
* asciidoc
  - vim syntax highlighting doesn't work.
  - I don't have a parser for it.
  - Structure is not clear from text, in my opinion.
* xml
  - I don't have a parser for it. But would be easy to write.
  - I would have to come up with a schema definition.
  - Having <p> around all paragraphs too annoying to write?
    This suggests a new requirement?
* plain text
  - No syntax highlighting.
  - I don't have a parser for it. Structure is not clear from the text.
* tcl
  - Braces and substitution within braces is awkward.

Markdown and asciidoc specify the abstract and concrete syntax. xml/tcl don't
specify an abstract syntax, which means I could make them work just fine with
whatever abstract syntax I choose. That suggests I really do care about the
concrete syntax. It might be nice if I can separate abstract syntax and
concrete syntax, so that you could reuse the concrete syntax for other
kinds of structures. But then, why not just use xml?

It's way too verbose. Just compare:

<dl>
 <dt>bin</dt>
 <dd>Source code for fble compiler binaries.</dd>
 <dt>book</dt>
 <dd>Drafts for a book about the design of the fble language.</dd>
 <dt>include</dt>
 <dd>Public header files for the fble library.</dd>
 <dt>lib</dt>
 <dd>Source code for an fble interpreter and compiler implemented in C.</dd>
</dl>

versus:

bin/:: Source code for fble compiler binaries.
book/:: Drafts for a book about the design of the fble language.
include/:: Public header files for the fble library.
lib/:: Source code for an fble interpreter and compiler implemented in C.

Particularly with syntax highlighting on the later. It's too much tags. It
really gets in the way of reading the document and seeing the content of the
text.

I'm thinking instead something like:

[def] bin/:     Source code for fble compiler binaries.
[def] book/:    Drafts for a book about the design of the fble language.
[def] include/: Public header files for the fble library.
[def] lib/:     Source code for an fble interpreter and compiler implemented in C.

So, we still give an initial tag. But there is some built in structure to say
a list definition item is the item followed by the content. And maybe,
somehow, it knows to use ':' as the separator?

That's the biggest challenge here. How to clearly separate arguments to a
structure without becoming overly cumbersome? Specify the terminator as part
of the command?

[def /] bin/     Source code for fble compiler binaries.
[def /] book/    Drafts for a book about the design of the fble language.
[def /] include/ Public header files for the fble library.
[def /] lib/     Source code for an fble interpreter and compiler implemented in C.

[def :] bin/:     Source code for fble compiler binaries.
[def :] book/:    Drafts for a book about the design of the fble language.
[def :] include/: Public header files for the fble library.
[def :] lib/:     Source code for an fble interpreter and compiler implemented in C.

[def  ] bin/      Source code for fble compiler binaries.
[def  ] book/     Drafts for a book about the design of the fble language.
[def  ] include/  Public header files for the fble library.
[def  ] lib/      Source code for an fble interpreter and compiler implemented in C.

[def \n] bin/
  Source code for fble compiler binaries.
[def \n] book/
  Drafts for a book about the design of the fble language.
[def \n] include/
  Public header files for the fble library.
[def \n] lib/
  Source code for an fble interpreter and compiler implemented in C.

The last one is stretching it. That's a bit hard to read.

[def] bin/     ' Source code for fble compiler binaries.
[def] book/    ' Drafts for a book about the design of the fble language.
[def] include/ ' Public header files for the fble library.
[def] lib/     ' Source code for an fble interpreter and compiler implemented in C.

[def]{bin/}     Source code for fble compiler binaries.
[def]{book/}    Drafts for a book about the design of the fble language.
[def]{include/} Public header files for the fble library.
[def]{lib/}     Source code for an fble interpreter and compiler implemented in C.

@def' bin/'     Source code for fble compiler binaries.
@def' book/'    Drafts for a book about the design of the fble language.
@def' include/' Public header files for the fble library.
@def' lib/'     Source code for an fble interpreter and compiler implemented in C.

@def "bin/"     Source code for fble compiler binaries.
@def "book/"    Drafts for a book about the design of the fble language.
@def "include/" Public header files for the fble library.
@def "lib/"     Source code for an fble interpreter and compiler implemented in C.

@def 'bin/'     Source code for fble compiler binaries.
@def 'book/'    Drafts for a book about the design of the fble language.
@def 'include/' Public header files for the fble library.
@def 'lib/'     Source code for an fble interpreter and compiler implemented in C.

Some thoughts when playing around with things:
* Blank lines, new lines, spaces are all natural boundaries for things.
* @foo[text] is decent for inline items. Unclear if we can naturally nest
  things like that.

@def bin/     @= Source code for fble compiler binaries.
@def book/    @= Drafts for a book about the design of the fble language.
@def include/ @= Public header files for the fble library.
@def lib/     @= Source code for an fble interpreter and compiler implemented in C.

@def[bin]     Source code for fble compiler binaries.
@def[book]    Drafts for a book about the design of the fble language.
@def[include] Public header files for the fble library.
@def[lib]     Source code for an fble interpreter and compiler implemented in C.

Think about it more.

---

Random idea: what if I use tcl for fble binary usage help? Specify the
structure explicitly via tcl, and generate text to use for the help usage and
for the man page directly from that? That way I can directly encode exactly
the structure I'm interested in, right?

* Paragraphs split across lines are annoying.

---

Okay, here's my proposal for a structure-agnostic syntax for marking up text,
that's hopefully reasonable to read.

A document is a sequence of commands.

A command has syntax:
  @tag[arg1][arg2]... lastarg

Where lastarg is treated specially as follows:
* If the @tag is not at column 0, there is no last arg. The command ends at
  the first non-'[' character. This is used for inline tags. For example:
  @emph[this text is emphasized] and the following is not.
* If the @tag is at column 0 and the first non-'[' character is on the same
  line as the last ']', the last arg goes until the end of the same line.
* If the @tag is at column 0 and the first non-'[' character is on the line
  after the last ']', the last arg goes until the next blank line.

With escape characters:
 @@ for '@'
 @[ for '['
 @] for ']'

And the syntax for a tag is [a-zA-Z0-9_]+ 

That's it. The entire concrete syntax. You add all your own structure on top
of that.

In terms of evaluation: commands are called with the raw values of their
arguments, whitespace included. The commands have the option to parse those
arguments as further arguments, where tags have local meaning.

Let me write up some examples to see how good or bad it looks. And probably
worth drafting a vim syntax file while I'm at it.

Some thoughts:
* Would be nice to have a way to explicitly disable long arg for inline tags
  that happen to line up on the left column. For now, put a space in front?
  Otherwise... brainstorm something. Maybe @tag[][]@ to end the long arg? That
  is, an '@' character on the same line? I don't know. Maybe use "@" at the
  end of the previous line to prevent it from triggering.
* Note, tags that take no arguments need to be followed by a blank line. Once
  again, it feels like it would be nice to have an explicit terminator command
  for tags. In case you want something more compact.

Okay, let's pick a decent syntax to terminate a command early. This takes
effect when a long argument is expected. If you see '@', it means there is no
long argument.

Another thought: it's unclear when something should be an argument or a
separate command. For example, I assume 'section' is a command to start a
section. Subsequent commands add to whatever the most recent section is. Same
for a list? If so, then maybe we want an @endlist command to say end the
current list? Or should the list take the list elements as arguments?

@list
@li First item.
@li Second item.
@li Third item.

@list[
@li
First item.

@li
Second item.

@li
Third item.
]

@list@
@li
First item.

@li
Second item.

@li
Third item.
@endlist@

In the case of a list, I prefer the list items be passed as the single
argument to the list. What about the case of a section?

Honestly, I think I would prefer section to take its contents as a single
argument. Can we come up with a nicer syntax for this? The square bracket
feels a little clunky.

@section My Favorite Section.
@{

@}

The idea is, @{ ... @} is a compound long argument.

But we can already use [ ... ] for that. Why do I prefer @{ ... @}? Maybe
allow them to be used interchangeably?

The idea is @{ would happen on the start of the next line.

So, could we do something like: @foo @{ first arg. @}, equivalent to
@foo[first arg.]@? Sure. Let's say yes. [ and @{ are both options. They need
to be equally matched, so [ is matched with ], and @{ is matched with @}.

But then, @[ as an escape is a little unintuitive. Maybe \@, \[, \] \\ are
better escape characters. Yeah, I think so.

That begs the question:

@foo
[ argument ]
[ argument ]

That should be allowed right? You can put a bracket on the next line. The
syntax is kind of nice too, so let's say yes. A bracket argument is allowed to
start on the next line where a long argument would start.

Summary of syntax:
  '@' tag [arg...]['@']
* \\, \@, \[, \] are escapes.
* Long argument parsing as discussed above.

Style guidelines: use args as much as possible, rather than, for example
@startsection, @endsection like commands.

Note, something like:

@foo
@bar
@sludge a.
@sludge b.

How is that parsed?

@bar is the start of the long argument for @foo.
@sludge is the start of the long argument for @bar.
Next @sludge continues the long argument for @bar.
Then we hit the newline. That ends the long argument for @bar. Does it also
end the long argument for @foo? I think it should.

I tried this out on fble-compile help text. I'm pretty happy with how the doc
looks. It's pretty readable, and has very clear structure to it. The only
thing unintuitive is the definition of the tags, partly by design. Custom tags
are allowed.

---

Some adjustments:
* Use @@tag for block level tags, @tag for inline level tags. The difference
  being whether they take a long argument or not. Then we don't need '@' as a
  terminator.
* in between text goes to a default special tag. So it can be treated as a
  command too.
* There's some open question about when whitespace is significant. Don't need
  to work out the details yet. Start with whatever makes sense to me and
  refine if needed.

Hmm.. '@@' looks a little excessive when stacked together. And now I wonder if
@{ should be changed to @@{ instead.

For example:

@@exitstatus
@@definitions
@@def[0] Success.
@@def[1] Failure.
@@def[2] Usage error.

Any other ideas I have. Maybe @ for has long arg, and $ for doesn't? Yeah.
That's much better. Let's go with that.

@tag[...][...]... ...
$tag[...][...]
\\, \@, \$, \[, \]

Umm... should @{ only be used for long form arguments? Use square bracket
otherwise?

No. Let's ditch @{. Just use square bracket instead. That's fine.

Next question: What would be the commands used for:

This is some $emph[emphasized] text. That's part of a 
paragraph. And some more $emph[strong] text.

Followed by another paragraph.

The question is, do we treat the paragraph as a special entity? I feel like we
ought to. Yeah. It's the tail part of a long arg to an implicit @_, right? So,
that's the same as:

@_
This is some $emph[emphasized] text. That's part of a 
paragraph. And some more $emph[strong] text.

@_
Followed by another paragraph.

Which is two '_' commands, each taking a single argument. The argument to the
first is:

"This is some $emph[empahsized] text. That's part of a
paragraph. And some more $emph[string] text."

The argument to the second is: "Followed by another paragraph."

The argument to the first paragraph can then be parsed as:

$_[This is some ]$emph[emphaiszed]$_[ text. That's part of a
paragraph. And some more ]$emph[strong]$_[ text.]

Notice:
* We preserve space in the spans. That space is important.
* The space can wrap around lines.

Okay? How can we precisely specify the syntax?

S0:
  Start state. Just finished a block command, or at start of doc.
  '@' -> Start parsing @ command (Go to S3).
  * -> Set @_ as current command. Start parsing long arg for @_ command as if it
    was on a new line (Go to S1).

S1:
  Parse long arg starting on next line.
  '[' -> Read up to next matching ']',
         add everything read as arg to command on top of the stack. Include
         leading and trailing whitespace in arg.
         Go to S2.
  * -> Read up to next blank line (which may be the current line).
         add everything read as arg to current command.
         Include leading and trailing whitespace in arg.
         Issue current command.
         Go to S0

S2:
  Parse long arg, not yet on next line.
  '\n' -> Go to S1.
  '[' -> Read up to next matching ']',
         add everything read as arg to current command. Include
         leading and trailing whitespace in arg.
         Go to S2.
  * -> Read up to end of line.
         add everything read to current command on top of the stack.
         Include leading and trailing whitespace in arg.
         Issue current command.
         Go to S0.

S3:
  Just read '@'.
  Read [a-zA-Z0-9_]+ as tag. Set as current command.
  Go to S2.
  

Questions:
* When to switch default text from @_ form to $_ form? When to start parsing
  '$' form?

---

Next revision:

We have two separate passes: block and inline.

The block pass interprets text as a sequence of block commands and executes
those. Parsing is pretty straight forward as described above:
1. Skip blank lines. While not at end of input:
2. If next character is not '@', read all characters until the next blank
   line. Issue the 'default block' command with the string read as the single
   argument. Then go to (1).
2. If next character is '@', read '@' and the tag.
3. If next character is not newline or '[', read all characters until end of
   line. Add that as the last argument to the current command. Issue the
   current command, and go to (1).
4. If next character is '[', read all characters until matching ']'. Add that
   as next argument to current command. Go to (3).
5. If next character is newline, skip passed that and go to 6.
6. If next character is '[', read all characters until matching ']'. Add that
   as next argument to current command. Go to (3).
7. If next character is newline, issue the current command. Go to (1).
8. Read all characters up until next blank line. Add those as an arg to
   current command issue the current command, and go to (1).

The inline pass interprets text as a sequence of inline commands and executes
those.
1. While not at end of input:
2. If next character is not '@', read all characters until the next '@'. Issue
   the 'default inline' command with the string read as the single argument.
   Then go to (1).
3. If next characters is '@', read '@' and the tag.
4. If next characters is '[', read all characters until matching ']'. Add that
   as next argument to current command. Go to (4).
5. If next character is not '[', issue the current command and go to (1).

Note:
* We reuse '@' for both block and inline elements. The parsing above should be
  a able to sort them out, except for the case where you want an inline
  command at the beginning of a default block. In that case, use an explicit
  block command instead.
* Also, mention that we escape \@, \[, \], and \\. 
* It's up to the command to decide whether it's argument should be interpreted
  as blocks or inline commands. At the end of the day, the default block
  command will likely want to interpret it's argument as inline commands. And
  the default inline command will only ever receive unmarked-up text.
* Still some open question about whitespace? I think, include all whitespace
  in [ ... ]. And for a long argument starting on the next line. The places we
  skip whitespace are blank lines between commands, space between '[]'
  arguments, and space before same line last arg.

Awesome. What are the next steps here?
* Write a vim syntax file, to see how things will look.
* Write some tcl code to implement this. Two procs: exec_blocks, exec_inlines.
* Write a tcl script to generate a man page from my bin/fble-compile.fbld
  file.

That will prove that it still looks nice with syntax highlighting, we can
implement the parser for it, and we can do something useful with the result.

How to highlight?
* @<tag> should be purple I think. Easy to see.
* [ and ] should be ... red maybe?
* \[ \\ \] \@ should be like a character literal.
That's it. Just those three things. I don't want to highlight any argument
text. We could add structure specific highlighting if we want later on. For
example, if I have a doc where @section is defined, and the first arg to
@section is the title, we can recognize that and highlight the title? Maybe
easier said than done. Don't worry about it for now.

Cool. Syntax highlighting looks great. I ended up with identifier for tag,
special for brackets, and character for escapes.

I started pulling together thoughts in specs/fbld.txt. That needs a lot of
work, but better than nothing right now.

Let's see if we can implement it next in tcl. Call it 'fbld.tcl'.

---

I implemented the parser for inline structured text. It was annoying, but not
bad. Note: I prefer to pass a generic 'invoke' function as an argument to the
tcl function that can reroute commands given command name and args. That's
nicer for my test case, for example, where I want all commands treated the
same way.

Next (and final?) step in the fbld implementation: implement support for
parsing block structured text. How to do that? Just plow ahead and see how it
goes I guess. Maybe shouldn't be too hard?

Can I do parsing of block level structure entirely on a line-by line basis? I
should be able to, right? Let's give it a try.

Well, except matching [] can span across multiple lines, which would be
awkward. Maybe don't short cut for now.

---

Okay, my draft of parsing block structure is done. Again, a bit tedious, but
otherwise pretty simple and straight forward.

Cool! Next step is to try generating some help text or man pages for my usage
doc.

Maybe we write something called usage.tcl that defines three modes:
1. Check that commands are valid with expected number of arguments and proper
subparsing.
2. Convert to usage text (as a C header file like xxd -i produces?)
3. Convert to man page.

That will be the real test.

---

Let's start with man page generation. What markup do I need?
* name, brief
* synopsys:  
  - distinguish between bold for 'as-is', italics for args.
* options
* exit status
* examples
* filenames italics

What do I want to for inline commands?
* @arg.  Call it @a for short?
* @file. Call it @f for short?
* @lit.  Call it @l for short?

Let's try that.

The only thing I'm not sure how to do right is referencing an element of a
list. Can I avoid having to do that to start? Yeah. I think I can manage.

Let's start by cleaning up bin/fble-compile.fbld.

Top level commands:
* default: @par[inline]
* @usage[inline]
* @defs[block]
* @options[block]
* @subsection[text][block]
* @exitstatus[block]
* @examples

Within @options
* @opt[inline][inline]

Within @examples
* @ex[text][inline]

Within @defs:
* @def[inline][block]


Inline Commands:
* @l[text]
* @a[text]

---

Observations when trying to implement man page generator:
* I'm ignoring outer structure like @defs, just passing through to @def. So
  should I not need @defs tag? Or should I somehow make use of the overall
  @defs structure?
* My implementation is not right, in that it really depends what indent level
  you are at for things. Somehow we need to keep that context, for example if
  you are printing a paragraph inside a list? Not sure.

---

Issues with my man page generation:
* Extra space between fble-compile and -m in usage, and in front of
  fble-compile.
 - Let me skip this .SY thing. That helps with the first space, but not the
   second. Maybe need a non-breaking space \& somewhere?
* definition lists have no space between tag and content.
 - Because the label doesn't include a newline. We should manually add a
   newline. DONE.
* Default nest for definition list 8 chars. Change to 4?
 - Change ".TP" to ".TP 4" fixes this.
* Need to strip whitespace from main function function paragraph?
* Option shows .P as part of the option.
 - Same issue as defs.
* Defs shows .TP for exit status.
 - Because there's no newline after the definition in this case.
 - So, strip whatever newline is there, and add my own?
* opts not nearly so compact as I would like.
 - Because it's using .P for block text. Should I treat it as inline instead
   of block?
* Newline needed after example so .EE tag works as expected.
* Main Function has a blank line before it, but Exported Module and Compiled
  Module do not.
  - Are we parsing definition value as inline instead of block? Yes. We were.
    If we go back to block, we get stuck in an infinite loop somehow.
  - It's parsing "Success." as a default, then seems to get stuck trying to
    parse the next one?

Definition lists are tricky. Assume the definitions are block level structure,
which is needed in some cases, such as my definition for "Main Function". That
means they will output a .P tag to start, but that doesn't fit with the .TP we
use.

---

Okay, so I think I got it down to three issues:
1. How to do definition lists supporting block definitions and compact lists.
2. That extra space in the usage before -m.
 - It's not just an extra space. It was an entire missing [...], because we
   didn't remember to unescape the final text. I can fix that.
 - Cool. This is fixed now.
3. The extra whitespace in the main function example.
 - It's almost like, for a paragraph, we want to split it into lines, trim
   each of the lines, concatenate those all together with a single space into
   one big long line, and then parse the inline structure?

Let me think on the paragraphs and definition lists things.

---

The most obvious thing to do about definition lists is have two kinds of
definitions: a short definition that takes inline structured text, and a long
definition that takes blocked structured text. The expectation is the short
definition goes on the same line as the label if it fits, and the long
definition always starts on the next line.

For paragraphs, this is admittedly a weird case. In general, it's just a
matter of defining how paragraphs should behave with respect to whitespace
and implementing it.

