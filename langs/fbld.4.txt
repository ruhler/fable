The Fable of Damocrates 
=======================
Richard Uhler <ruhler@degralder.com>

Introduction
------------
Damocrates is a computer programming language from the Fable collection. It
builds on top of the Calvisus language, providing compile-time developer
features for modularity and abstraction geared at reducing the cost of
producing large fblc programs.

A core philosophy of fbld is that it can be statically compiled to fblc.
The abstractions introduced by fbld are zero-cost in the sense that they have
no overhead at runtime after compiling the program down to fblc. The developer
need not have to make a tradeoff between modularity/abstraction and runtime
performance.

Damocrates facilitates development of large scale programs by introducing two
broad features on top of the existing fblc language: modules and polymorphism.
Modules allow the same peice of code to be reused in many different programs,
and polymorphism allows the same peice of code to be reused in many different
contexts within a single program. These features allow a developer to easily
leverage the existing work of others to assemble and reuse large scale
programs.

Modules
-------
A module is a collection of type, func, and proc entities that can be reused
in different programs. The entities defined in a module exist in their own
namespace to avoid name conflicts when combining modules together to form
programs. To make it simpler to use a module without having to understand its
implementation details, a module has a separate interface describing what
entities it makes publicly available for use. To allow the benefits of modules
to scale to much larger programs, modules and their interfaces can be defined
hierarchically; a module can define its own sub-interfaces and sub-modules in
addition to defining types, funcs, and procs.

Module Declaration
~~~~~~~~~~~~~~~~~~
The following shows an example of a module declaring a unary integer type and
operations:

  module IntegerM(IntegerI) {
    struct Unit();
    union Int(Unit 0, Int S);

    func Add(Int a, Int b; Int) {
      ?(a; b, Int:S(Add(a.S, b)));
    };
  };

The module declaration provides the name of the module, "IntegerM", the name
of the module's interface "IntegerI", and the collection of entities defined
by the module: types "Unit" and "Int" and function "Add" in this case.

Module Namespaces
~~~~~~~~~~~~~~~~~
The braces of a module declaration introduce a new name space. Entities
declared in a different namespace cannot be directly referred to. For example,
the following program is incorrect, because the Unit type is not available
in the namespace where Int is defined, and the Int type is not available in
the namespace where IntPair is defined:

  struct Unit();

  module IntegerM(IntegerI) {
    union Int(Unit 0, Int S);               # ERROR: 'Unit' not defined

    func Add(Int a, Int b; Int) {
      ?(a; b, Int:S(Add(a.S, b)));
    };
  };

  struct IntPair(Int first, Int second);    # ERROR: 'Int' not defined.

There are three ways to refer to entities declared in another name space.

Import from Parent
^^^^^^^^^^^^^^^^^^
A module can explicitly import entities into its own namespace from the
namespace in which the module itself is defined. For example, this can be used
to improt the Unit type in the previous example into the IntegerM namespace so
that it can be referred to when defining the Int type. To import an entity
from a parent module, an "import @" statement is used:

  struct Unit();

  module IntegerM(IntegerI) {
    import @ { Unit; };               # Unit imported from parent namespace.
    union Int(Unit 0, Int S);         # OK: 'Unit' is now in scope.

    func Add(Int a, Int b; Int) {
      ?(a; b, Int:S(Add(a.S, b)));
    };
  };

The basic form of the import @ statement is to list entities in the parent
namespace to import under the same name in the module namespace. Multiple
entities can be imported with a single import @ statement, separated by
semicolons. For example, to import entities Apple, Bannana, and Pair from a
parent namespace, you could write:

  import @ { Apple; Bannana; Pair; };

More generally, an entity can be imported from the parent namespace to the
module namespace under a different name. This allows a module to have full
control over its own namespace. For example, to import the Unit type under the
name MyParentsUnit:

  struct Unit();

  module IntegerM(IntegerI) {
    import @ { MyParentsUnit=Unit; };
    union Int(MyParentsUnit 0, Int S); # OK: 'MyParentsUnit' is now in scope.

    func Add(Int a, Int b; Int) {
      ?(a; b, Int:S(Add(a.S, b)));
    };
  };

The general syntax for the parent import statement is:

   'import' '@'  '{' [tname ['=' tname]; [tname ['=' tname]; [...]]] '}'

Only entities available in the module's immediate parent namespace may be
imported this way. An entity declared in the parent's parent namespace cannot
be imported unless it has first been imported into the parent namespace.

2.

* Namespaces
  - qualified references: foo@bar to access entity in module bar.
  - import bar { ... } shorthand
* Interfaces
  - interface declaration syntax.
  - kinds - type, struct, decl, func, proc, module, interf.
  - requirements for a module to implement an interface.
* Hierarchical modules and interfaces.
* Top level name space and programs.

Polymorphism
* Intro
  - Motivating example.
* Declaring polymorphic entities ("meta abstraction")
* Supplying static arguments to qrefs ("meta application")
* Partial application of static arguments.
  - Monad example.
* Entity aliases ("meta let")
  - kind = 'qref';

Syntax Reference
----------------
  type_kind ::= 'type' tname params ;
  struct_kind ::= 'struct' tname params '(' [qref fname [',' qref fname [...]]] ')' ;
  union_kind ::= 'union' tname params '(' qref fname [',' qref fname [...]] ')' ;
  func_kind ::= 'func' tname params '(' [qref vname [',' qref vname [...]]] ';' qref ')' ;
  proc_kind ::= 'proc' tname params '('
                     [qref polarity pname [',' qref polarity pname [...]]] ';'
                     [qref vname [',' qref vname [...]]] ';' qref ')' ;
  interf_kind ::= 'interf' tname params '{' [decl [decl [...]]] '}' ;
  module_kind ::= 'module' tname params '(' qref ')' ;

  kind ::= type_kind
         | struct_kind
         | union_kind
         | func_kind
         | proc_kind
         | interf_kind
         | module_kind
         ;

  import ::= 
      (* TODO: ['=' qref] instead of ['=' tname]? *)

     'import' '@'  '{' [tname ['=' tname]; [tname ['=' tname]; [...]]] '}'
   | 'import' qref '{' [tname ['=' tname]; [tname ['=' tname]; [...]]] '}'
   ;

  decl ::= kind ';'       (* TODO: allow kind '=' qref ';' too? *)
         | import ';'
         ;

  defn ::= struct_kind ';'
        |  union_kind ';'
        |  func_kind expr ';'
        |  proc_kind proc ';'
        |  interf_kind ';'
        |  module_kind '{' [defn [defn [...]]] '}' ';'
        |  kind '=' qref ';'
        |  import ';'
        ;
  
  prgm ::= (* collection of defn, organized into file by defn <name>.fbld *)
 
  params ::= ['<' [kind [',' kind [...]]] '>'] ;

  qref ::= tname ['<' [qref [',' qref [...]]] '>'] ['@' qref] ;

  expr ::= ... (* as in fblc, with qref in place of tname *)
  proc ::= ... (* as in fblc, with qref in place of tname *)

  polarity ::= ... (* as in fblc *)
  pname ::= ... (* as in fblc *)
  tname ::= ... (* as in fblc *)
  vname ::= ... (* as in fblc *)

Style Suggestions
-----------------
* Capitalize entities, including types, functions, procs, interfaces, and
  modules.
* Lowercase field names, including for structs, unions, function and proc
  arguments.
* Lowercase variable names.
* "true/something/cons" before "false/nothing/empty/error" when ordering
  fields of that kind of union declaration, so that ?(x; a, b) is
  consistent with (x ? a : b) behavior.

  But "0" before "1" for bit, decimal, byte, hex, etc?

Changes from Fbld 3
-------------------
* Instead of <[type...] ; [module...]> for params, we have <[kind...]>.
Which is surely an improvement in simplicity and generality.

* Kinds can themselves be parameterized.
Which avoids an artificial arbitrary limitation by allowing full generality.

* Partial application of qrefs.
Needed once kinds are parameterized.
Also generalizes import statements, which implicitly import parameterized
things, not fully applied things.

* kind = 'qref'
Which really is needed for full generality.

I approve these changes as improving the overall simplicity and generality of
the language. Parameterized kinds, partial application, and kind = 'qref' do
add complexity, but they do so in a simple way and provide important
capabilities.

