Damocrates is a meta-language built on top of Androcles, Bathylus, and Calvisus
designed to be programmed by human, with features for modularity and
development.

Damocrates should be statically compilable into Androcles/Bathylus/Calvisus.
Abstractions introduced by the Damocrates language should be zero-cost in the
sense that they will have no overhead at runtime after compiling the program
down to Androcles/Bathylus/Calvisus. The developer should not have to make a
tradeoff between modularity/abstraction and runtime performance.

Overview
--------
Damocrates adds support for modularity and polymorphism on top of the
Calvisus language. The purpose of these features is to facilitate reuse of
code across multiple programs, expanding the scale of programs that can be
developed.

Fbld shifts a focus on implementing programs that exists in fblc to a focus on
implementing reusable pieces of programs. These pieces of programs are called
modules and include type, function, and process definitions.

For example, many programs make use of some form of integer arithmetic. Rather
than re-implement and re-test integer arithmetic for each program, a single
integer arithmetic module can be developed and reused. The integer arithmetic
module will define an integer type and functions that operate on integer
values.

To effectively reuse a piece of code, it must be very easy to understand what
that code does at a high level and how it should be used; it should not be
import to understand implementation details of the code. Fbld has the notion
of a module interface, which provides an abstract view of the code provided by
a module to make it easy to understand what the code does at a high level and
how to use it without having to understand excess implementation details.

For example, the integer arithmetic module could be used knowing there is some
type Int with operations to add two Ints together, but the user need not know
whether the Int type is implemented using a unary, binary, 2s-complement or
other representation.

Interfaces allow modules to be developed independent of their use and reused
independent of their development. Modules can be understood and developed in
isolation then combined to form large programs that would otherwise be too
complex and costly to develop.

Interfaces make it possible to write code that is agnostic to the details of
how types, functions, and processes are defined and implemented. To take full
advantage of this, fbld supports polymorphic interfaces and modules, which
allows the code to be reused in multiple different contexts with different
definitions of the types, functions, and processes it interfaces with within
the same program. Polymorphism is supported by having interfaces be
parameterized by types and having modules parameters by types and other
modules.

For example, there are common data structures, such as lists, which can be
used with many different element types. Fbld's polymorphism allows an
interface to be defined that is a function of a given type parameter. For
example, a single List interface can be defined that is used for lists of
Ints, Lists of booleans, Lists of Lists, or any other type. This is a form of
parametric polymorphism.

As another example, some computation involving numbers can be defined that
works on any type of number satisfying a required set of operations. A module
involving polynomials, for example, could be reused with natural numbers,
integers, real numbers, or booleans. This is a form of ad-hoc polymorphism.

Concepts
--------
Fbld adds two new top level constructs to fblc: modules and interfaces. All
type, function, and process declarations occur within modules.

A module defines a collection of types, functions, and processes that are
parameterized by any number of types and any number of other modules. Each
implements some interface.

An interface is an abstraction of a module that includes only type, function,
and process declarations, without their implementations. For a module to
properly implement an interface, every type, function, and process declared in
the interface must have a corresponding implementation supplied by the module.

Interfaces
----------
mtype <interface_name> (<type_parameters>) {
  <interface_declarations>
};

Interfaces are named. They take zero or more type parameters, and contain zero
or more interface_declaration elements. Type parameters are specified using a
comma-separated list of simple names. These names can be used within the
interface_declarations to refer to the types passed to the interface when the
interface is instantiated.

There are 6 kinds of interface_declaration items: using, type, struct, union,
func, and proc. The struct, union, func, and proc declarations are exactly as
in fblc.

Abstract Type Declarations
^^^^^^^^^^^^^^^^^^^^^^^^^^
The 'type' declaration is used to declare an abstract type that is defined
internally by modules implementing the interface. For example:

   type Int;

Defines an abstract Int type. The 'Int' type can be used anywhere a type is
expected. Values of abstract types cannot be used as objects of member access
or arguments to conditional expressions or processes.

Using Declarations
^^^^^^^^^^^^^^^^^^
The 'using' declaration is used to refer to entities declared within another
module. Each 'using' declaration brings one or more entities into the local
interface's namespace from another module. By default entities are imported
using the same name they are declared with, but it is possible to specify an
alternate name when importing an entity in order to avoid name conflicts.

For example:
  using Bool() { Bool; true=True; false=False; };

The above statement imports three entities from the Bool module. In this case
the Bool module does not have any type parameters, so no type arguments are
provided. If the module has type parameters, then type arguments must be
specified for every type parameter. The entities that are imported are
specific to the type arguments provided.

Following the module is a list of entities to bring in, each entity terminated
with a semicolon. The entity can either be a single name, indicating that
entity from the module is being imported under its same name, and can be
referred to elsewhere by that simple name. Or the entity can have the form
'name' = 'name', where the first name is the name the entity is imported
under, and the second name is the name of the entity as declared in the module
it is being imported from.

As a more complex example, consider a polymorphic List implementation, which
is reused both as an integer list and a boolean list. This entities from the
List implementation would need to be imported using multiple 'using'
declarations, with different names chosen to avoid name conflict:
  using List(Int) { IntList=List; IntHead = head; IntTail = tail; };
  using List(Bool) { BoolList=List; BoolHead = head; BoolTail = tail; };

The result is as if two types IntList and BoolList have been defined and four
functions, IntHead, IntTail, BoolHead, and BooLTail have been defined and can
be referenced from elsewhere in the interface.

Modules
--------
mdefn <module_name> (<type_parameters> ; <module_parameters> ; <interface> ) {
  <module_declarations>
};

Module are named. Modules have type parameters and module parameters. The type
paramaters are as in interfaces, a comma separate list of simple names of
types that can be referred to from within the module.

Each module parameter is specified as an interface and a module parameter
name. The module parameter can be used by providing any concrete module that
implements the given interface. Module parameters may refer to the type
parameters of the module.

Each module has a single interface type.

Every module implements a specific interface. This means the module will
provide definitions for all components declared in the interface. The
concrete interface specification can refer to type parameters and module
parameter types.

Here are some examples of the initial parts of module definitions, called
module declarations:

A Bool module implementing a Bool interface with no parameters:
  mdefn Bool( ; ; Bool());

A Maybe module implementing the Maybe interface with type parameter T:
  mdefn Maybe(T ; ; Maybe(T));

HashMap and TreeMap modules, parameters by the key and value type, and with
module parameters to compute the hash value or compare key values as
appropriate. Both of these modules implement the same Map interface:
  mdefn HashMap(K, V; Hash(K) hash; Map(K, V));
  mdefn TreeMap(K, V; Ord(K) ord; Map(K, V));

A module that implements a specific kind of interface without being fully
polymorphic:
  mdefn BoolHashMap(V; ; Map(Bool@Bool(), V));

In this last case, the syntax <name> @ <module> is used to refer to a type
declared within a module. This is the only place in the fbld language where
this notation is needed. All other times a 'using' directive is used to refer
to an entity defined in another module.

Following the module declaration is a list of module declaration items. These
include 'using', 'struct', 'union', 'func', and 'proc' declarations. The
'using' declaration is as for module interfaces. The 'union', 'func', and
'proc' declarations are as for fblc.
