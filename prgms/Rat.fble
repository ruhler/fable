
@ Int@ = /Int/Int%.Int@;
% AddI = /Int/Int%.Add;
% SubI = /Int/Int%.Sub;
% MulI = /Int/Int%.Mul;
% DivI = /Int/Int/Div%.Div;

# Rat@ --
#   A rational number: n / d.
#
# Fields:
#   n - the numerator
#   d - the denominator.
@ Rat@ = *(Int@ n, Int@ d);

(Rat@, Rat@) { Rat@; } Add = (Rat@ a, Rat@ b) {
  Rat@(AddI(MulI(a.n, b.d), MulI(b.n, a.d)), MulI(a.d, b.d));
};

(Rat@, Rat@) { Rat@; } Sub = (Rat@ a, Rat@ b) {
  Rat@(SubI(MulI(a.n, b.d), MulI(b.n, a.d)), MulI(a.d, b.d));
};

(Rat@, Rat@) { Rat@; } Mul = (Rat@ a, Rat@ b) {
  Rat@(MulI(a.n, b.n), MulI(a.d, b.d));
};

(Rat@) { Rat@; } Neg = (Rat@ a) {
  Rat@(/Int/Int%.Neg(a.n), a.d);
};

(Rat@, Rat@) { Rat@; } Div = (Rat@ a, Rat@ b) {
  Rat@(MulI(a.n, b.d), MulI(a.d, b.n));
};

# Approx --
#   Approximate the rational number x to within e.
#
# This reduces the amount of memory required to store the rational number, at
# the expense of some precision.
#
# For example, Approx(x, 1/1000) will round x down to the nearest whole 1/1000
# units.
(Rat@, Rat@) { Rat@; } Approx = (Rat@ x, Rat@ e) {
  Int@ n = DivI(MulI(e.d, x.n), x.d).q;
  Rat@(SubI(n, DivI(n, e.n).r), e.d);
};

@(Rat@, Add, Sub, Neg, Mul, Div, Approx);
