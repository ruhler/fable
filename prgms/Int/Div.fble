
@ Int@ = /Int/Int%.Int@;
% Dec = /Int/Int%.Dec;
% Neg = /Int/Int%.Neg;
% Sub = /Int/Int%.Sub;
% 0 = /Int/Int%.0;

@ IntS@ = /Int/IntS%.IntS@;

% P = /Int/IntP/Div%;

(IntS@) { Int@; } IntS = (IntS@ s) {
  s.?(0: 0, p: Int@(p: s.p));
};

# QR@ --
#   Quotient and remainder from integer division.
@ QR@ = *(Int@ q, Int@ r);

% DivideByZero = /Undef%.Undef<QR@>;

# Div --
#   a = q*b + r, |r| < |b|, where q = floor(a/b)
(Int@, Int@) { QR@; } Div = (Int@ a, Int@ b) {
  b.?(
    n: {
      QR@ qr = Div(Neg(a), Neg(b));
      @(q: qr.q, r: Neg(qr.r));
    },
    0: DivideByZero.undefined,
    p: {
      a.?(
        n: {
          P.QR@ qr = P.Div(a.n, b.p);
          Int@ q = Neg(IntS(qr.q));
          qr.r.?(0: @(q: q, r: 0));
          @(q: Dec(q), r: Sub(b, IntS(qr.r)));
        },
        0: @(q: 0, r: 0),
        p: {
          P.QR@ qr = P.Div(a.p, b.p);
          @(q: IntS(qr.q), r: IntS(qr.r));
        });
      });
};

@(QR@, Div);
