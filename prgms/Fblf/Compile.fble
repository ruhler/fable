
@ Char@ = /Char%.Char@;
% Chars = /Char%.Chars;

@ Bit@ = /Digits%.Bit@;
% Bit = /Digits%.Bit;

@ Addr@ = /Fblf/Program%.Addr@;
@ Assign@ = /Fblf/Program%.Assign@;
@ Condition@ = /Fblf/Program%.Condition@;
@ IfElse@ = /Fblf/Program%.IfElse@;
@ Sequence@ = /Fblf/Program%.Sequence@;
@ While@ = /Fblf/Program%.While@;
@ Value@ = /Fblf/Program%.Value@;
@ Program@ = /Fblf/Program%.Program@;
% Ref = /Fblf/Program%.Ref;

@ Int@ = /Int/Int%.Int@;
% Add = /Int/Int%.Add;
% Sub = /Int/Int%.Sub;
% Eq = /Int/Int/Eq%.Eq;
% Le = /Int/Int/Eq%.Le;
% Mod = /Int/Int/Div%.Mod;
% D = /Int/Int/Lit%.D;
% I = /Int/Int/Lit%.I;

<@>@ List@ = /List%.List@;
<@>% List = /List%.List;
<@,@>% Map = /List%.Map;
<@>% Nil = /List%.Nil;
<@>% Cons = /List%.Cons;
<@>% Append = /List%.Append;
<@>% Concat = /List%.Concat;

<@>% Drop = /List/Length%.Drop;
<@>% Length = /List/Length%.Length;
<@>% Take = /List/Length%.Take;

<@,@>@ Lit@ = /Literal%.Lit@;

@ String@ = /String%.String@;
% Str = /String%.Str;

@ Unit@ = /Unit%.Unit@;
% Unit = /Unit%.Unit;

Int@ BitsPerWord = I(D|64);

(Lit@<String@>) { String@; } Strs = (Lit@<String@> l) {
  Concat<Char@>(List<String@>(l));
};

# Lines@ -- 
#   Abstract data type for outputting a sequence of lines of text from
#   compilation.
@ Lines@ = String@;

# Line --
#   Output the given line of text.
(String@) { Lines@; } Line = (String@ line) {
  Append<Char@>(line, Str[Chars.nl]);
};

# Lines_ --
#   Output multiple lines of text in order.
(List@<Lines@>) { Lines@; } Lines_ = (List@<Lines@> lines) {
  Concat<Char@>(lines);
};

# Lines --
#   Output multiple lines of text in order.
(Lit@<Lines@>) { Lines@; } Lines = (Lit@<Lines@> lines) {
  Lines_(List<Lines@>(lines));
};

(Addr@) { String@; } CompileAddr = /Int/Int/Show%.Show;

# Compile a constant that is assumed to fit within BitsPerWord.
(List@<Bit@>) { String@; } 
CompileSmallConstant = {
  # Convert a list of bits to hex string, assuming the number of elements on
  # the list is a multiple of 4.
  (List@<Bit@>) { String@; } ToHex = (List@<Bit@> l) {
    l.?(
      cons: {
        Bit@ a = l.cons.head;
        Bit@ b = l.cons.tail.cons.head;
        Bit@ c = l.cons.tail.cons.tail.cons.head;
        Bit@ d = l.cons.tail.cons.tail.cons.tail.cons.head;
        String@ tail = ToHex(l.cons.tail.cons.tail.cons.tail.cons.tail);
        Char@ h = a.?(
          0: b.?(
            0: c.?(0: d.?(0: Chars.0, 1: Chars.1), 1: d.?(0: Chars.2, 1: Chars.3)),
            1: c.?(0: d.?(0: Chars.4, 1: Chars.5), 1: d.?(0: Chars.6, 1: Chars.7))),
          1: b.?(
            0: c.?(0: d.?(0: Chars.8, 1: Chars.9), 1: d.?(0: Chars.A, 1: Chars.B)),
            1: c.?(0: d.?(0: Chars.C, 1: Chars.D), 1: d.?(0: Chars.E, 1: Chars.F))));
        Cons<Char@>(h, tail);
      },
      nil: Nil<Char@>);
  };

  (List@<Bit@> c) {
    Int@ length = Length<Bit@>(c);
    Eq(Mod(length, I(D|4)), I(D|0)).?(
      true: Strs[Str(Chars|'0x'), ToHex(c)],
      false: {
        # TODO: We could improve performance by adding just the right number
        # of bits here, instead of having to recompute the length of the list
        # each time.
        CompileSmallConstant(Cons<Bit@>(Bit.0, c));
      });
  };
};

# Compile an equals condition into an atomic boolean expression in C, where
# the number of bits is assumed to fit within BitsPerWord.
(Value@, Value@, Int@) { String@; }
CompileSmallEquals = (Value@ a, Value@ b, Int@ n) {
  a.?(
    ref: b.?(
      ref: Strs[
        Str(Chars|'FblfHeapEqual(heap, '),
        CompileAddr(a.ref),
        Str(Chars|', '),
        CompileAddr(b.ref),
        Str(Chars|', '),
        /Int/Int/Show%.Show(n),
        Str(Chars|')')],
      const: Strs[
        Str(Chars|'FblfHeapEquals(heap, '),
        CompileAddr(a.ref),
        Str(Chars|', '),
        CompileSmallConstant(b.const),
        Str(Chars|', '),
        /Int/Int/Show%.Show(n),
        Str(Chars|')')]),
    const: b.?(
      ref: Strs[
        Str(Chars|'FblfHeapEquals(heap, '),
        CompileAddr(b.ref),
        Str(Chars|', '),
        CompileSmallConstant(a.const),
        Str(Chars|', '),
        /Int/Int/Show%.Show(n),
        Str(Chars|')')],
      const: Strs[
        Str(Chars|'('),
        CompileSmallConstant(a.const),
        Str(Chars|' == '),
        CompileSmallConstant(b.const),
        Str(Chars|')')]));
};

# Split the first n bits off of the given value, returning the n most
# significant bits of the value as 'hi', and the remaining least significant
# bits of the value in 'lo'.
(Value@, Int@) { *(Value@ hi, Value@ lo); } Split = (Value@ v, Int@ n) {
  v.?(
    ref: @(
      hi: v,
      lo: Ref(Add(v.ref, n))),
    const: @(
      hi: Value@(const: Take<Bit@>(n, v.const)),
      lo: Value@(const: Drop<Bit@>(n, v.const))));
};

# Compile an equals condition into an atomic boolean expression in C.
(Value@, Value@, Int@) { String@; }
CompileEquals = (Value@ a, Value@ b, Int@ n) {
  Le(n, BitsPerWord).?(
    true: CompileSmallEquals(a, b, n),
    false: {
      % as = Split(a, BitsPerWord);
      % bs = Split(b, BitsPerWord);
      String@ hi = CompileSmallEquals(as.hi, bs.hi, BitsPerWord);
      String@ lo = CompileEquals(as.lo, bs.lo, Sub(n, BitsPerWord));
      Strs[Str|'(', hi, Str|' && ', lo, Str|')'];
    });
};

# Compile a condition into an expression suitable for use in the condition of
# an if or while statement in C.
(Condition@) { String@; } CompileCondition = (Condition@ cond) {
  String@ equals = CompileEquals(cond.a, cond.b, cond.n);
  cond.op.?(
    eq: equals,
    ne: Cons<Char@>(Chars.'!', equals));
};

# Compile an assignment statement assuming the number of bits fits within
# BitsPerWord.
(String@, Assign@) { Lines@; }
CompileSmallAssign = (String@ indent, Assign@ assign) {
  assign.value.?(
    ref: Line(Strs[
      indent,
      Str|'FblfHeapCopy(heap, ',
      CompileAddr(assign.ref),
      Str|', ',
      CompileAddr(assign.value.ref),
      Str|', ',
      /Int/Int/Show%.Show(assign.n),
      Str|');']),
    const: Line(Strs[
      indent,
      Str|'FblfHeapWrite(heap, ',
      CompileAddr(assign.ref),
      Str|', ',
      CompileSmallConstant(assign.value.const),
      Str|', ',
      /Int/Int/Show%.Show(assign.n),
      Str|');']));
};

# Compile an assignment statement into a sequence of statements in C.
(String@, Assign@) { Lines@; } CompileAssign = (String@ indent, Assign@ assign) {
  Le(assign.n, BitsPerWord).?(
    true: CompileSmallAssign(indent, assign),
    false: {
      % vs = Split(assign.value, BitsPerWord);
      Lines(List<Lines@>[
        CompileSmallAssign(indent, Assign@(assign.ref, vs.hi, BitsPerWord)),
        CompileSmallAssign(indent, Assign@(Add(assign.ref, BitsPerWord), vs.lo, Sub(assign.n, BitsPerWord)))]);
    });
};

(String@, Sequence@) { Lines@; } CompileSequence = (String@ indent, Sequence@ seq) {
  Lines_(Map<Program@, Lines@>(seq, (Program@ p) { CompileProgram(indent, p); }));
},

(String@, IfElse@) { Lines@; } CompileIfElse = (String@ indent, IfElse@ ifelse) {
  String@ nested = Strs[indent, Str(Chars|'  ')];
  Lines(List<Lines@>[
    Line(Strs[
      indent,
      Str(Chars|'if ('),
      CompileCondition(ifelse.condition),
      Str(Chars|') {')]),
    CompileProgram(nested, ifelse.if_body),
    Line(Strs[
      indent, Str(Chars|'} else {')]),
    CompileProgram(nested, ifelse.else_body),
    Line(Strs[indent, Str(Chars|'}')])]);
},

(String@, While@) { Lines@; } CompileWhile = (String@ indent, While@ while) {
  String@ nested = Strs[indent, Str|'  '];
  Lines(List<Lines@>[
    Strs[
      indent,
      Str|'while (',
      CompileCondition(while.condition),
      Str|') {'],
    CompileProgram(nested, while.body),
    Strs[indent, Str(Chars|'}')]]);
},

(String@, Program@) { Lines@; } CompileProgram = (String@ indent, Program@ prgm) {
  prgm.?(
    assign: CompileAssign(indent, prgm.assign),
    sequence: CompileSequence(indent, prgm.sequence),
    ifelse: CompileIfElse(indent, prgm.ifelse),
    while: CompileWhile(indent, prgm.while));
};

# Compile_ --
#   Compile an fblf program to a C function with the given name.
#
# The signature of a function named 'Foo' will be:
#   void Foo(FblfHeap* heap);
(String@, Program@) { Lines@; }
Compile_ = (String@ name, Program@ program) {
  Lines(List<Lines@>[
    Line(Strs[
      Str|'void ',
      name,
      Str|'(FblfHeap* heap)']),
    Line(Str(Chars|'{')),
    CompileProgram(Str(Chars|'  '), program),
    Line(Str(Chars|'}'))]);
};

# Compile --
#   Compile an fblf program to a C function with the given name.
#
# The signature of a function named 'Foo' will be:
#   void Foo(FblfHeap* heap);
(String@, Program@) { String@; } Compile = Compile_;

@(Compile);
