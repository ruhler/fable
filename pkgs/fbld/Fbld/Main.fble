
% True = /Core/Bool%.True;
% False = /Core/Bool%.False;

<@>@ List@ = /Core/List%.List@;
<@>% Cons = /Core/List%.Cons;
<@>% Nil = /Core/List%.Nil;

<@>@ Maybe@ = /Core/Maybe%.Maybe@;
<@>% Just = /Core/Maybe%.Just;

<<@>@>@ Monad@ = /Core/Monad%.Monad@;
<<@>@>@ Stdio@ = /Core/Stdio%.Stdio@;
<<@>@>@ Main@ = /Core/Stdio%.Main@;

<<@>@>@ IStream@ = /Core/Stream%.IStream@;

@ String@ = /Core/String%.String@;
% Str = /Core/String%.Str;
% Strs = /Core/String%.Strs;

@ Unit@ = /Core/Unit%.Unit@;
% Unit = /Core/Unit%.Unit;

@ Env@ = /Fbld/Fbld%.Env@;

% Report = /Fbld/Loc%.Report;
% Start = /Fbld/Loc%.Start;
% Unknown = /Fbld/Loc%.Unknown;

@ Markup@ = /Fbld/Markup%.Markup@;
% Markups = /Fbld/Markup%.Markups;

<@>@ Result@ = /Fbld/Result%.Result@;
<@>% Ok = /Fbld/Result%.Ok;
<@>% Err = /Fbld/Result%.Err;

% Run = /Fbld/Run%;

@ Text@ = /Fbld/Text%.Text@;
% Text = /Fbld/Text%.Text;
% StringOf = /Fbld/Text%.StringOf;
% LocOf = /Fbld/Text%.LocOf;


# Main --
#   Main function for fbld program.
Main@ Main = <<@>@ M@>(Monad@<M@> m, Stdio@<M@> stdio) {
  % I = /Core/Stream/IStream%(m);
  % O = /Core/Stream/OStream%(m);

  @ Backend@ = +(Unit@ html, Unit@ man, Unit@ text, Unit@ raw);

  @ Args@ = *(
    Backend@ backend,
    List@<String@> rfiles
  );

  (List@<String@>) { Args@; } ParseArgs = (List@<String@> args) {
    (List@<String@>, Args@) { Args@; }
    parse = (List@<String@> args, Args@ result) {
      args.?(nil: result);
      String@ arg = args.cons.head;
      /Core/String/Eq%.Eq(Str|'--html', arg).?(true: {
        List@<String@> nargs = args.cons.tail;
        parse(nargs, result.@(backend: Backend@(html: Unit)));
      });
      /Core/String/Eq%.Eq(Str|'--man', arg).?(true: {
        List@<String@> nargs = args.cons.tail;
        parse(nargs, result.@(backend: Backend@(man: Unit)));
      });
      /Core/String/Eq%.Eq(Str|'--text', arg).?(true: {
        List@<String@> nargs = args.cons.tail;
        parse(nargs, result.@(backend: Backend@(text: Unit)));
      });
      parse(args.cons.tail, result.@(rfiles: Cons(arg, result.rfiles)));
    };
    parse(args, Args@(Backend@(raw: Unit), Nil<String@>));
  };

  (List@<String@> args) {
    Args@ parsed = ParseArgs(args);

    Markup@ backend = parsed.backend.?(
      html: /Fbld/Core%.Markup(/Fbld/Html%.Core),
      man: /Fbld/Core%.Markup(/Fbld/Man%.Core),
      text: /Fbld/Core%.Markup(/Fbld/TextBackend%.Core),
      raw: /Fbld/Markup%.Empty);

    Markup@ markup = Markups[/Fbld/Builtin%.Markup, backend];

    Env@ env = /Fbld/Markup%.Env(markup);

    Result@<List@<Text@>> texts <- m.do(/Core/List%.ForEach(parsed.rfiles,
        m.return(Ok(Nil<Text@>)),
        (String@ filename, M@<Result@<List@<Text@>>> ims) {
          Result@<List@<Text@>> rms <- m.do(ims);
          rms.?(err: ims);
          List@<Text@> head = rms.ok;

          Result@<Text@> text <- m.do({
            Maybe@<IStream@<M@>> fin <- m.do({
              /Core/String/Eq%.Eq(Str|'-', filename).?(true: m.return(Just(stdio.in)));
              stdio.read(filename);
            });

            fin.?(nothing: {
              String@ msg = Strs[Str|'unable to open ', filename];
              m.return(Err<Text@>(Text(msg, Unknown)));
            });

            String@ contents <- m.do(I.GetText(fin.just));
            m.return(Ok(Text(contents, Start(filename))));
          });
          text.?(err: m.return(Err<List@<Text@>>(text.err)));
          m.return(Ok(Cons(text.ok, head)));
        }));

    texts.?(err: {
      String@ msg = Report(LocOf(texts.err), StringOf(texts.err));
      Unit@ _ <- m.do(O.PutLine(stdio.err, msg));
      m.return(False);
    });

    Text@ text = /Fbld/Text%.Concat(Unknown, texts.ok);
    Result@<Text@> r = /Fbld/Fbld%.Run(Run.Block(text), env);
    r.?(err: {
      String@ msg = Report(LocOf(r.err), StringOf(r.err));
      Unit@ _ <- m.do(O.PutLine(stdio.err, msg));
      m.return(False);
    });

    Unit@ _ <- m.do(O.PutStr(stdio.out, StringOf(r.ok)));
    m.return(True);
  };
};

/Core/Stdio/IO%.Run(Main);
