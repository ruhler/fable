Fble Docs
=========
In the process of writing tutorials and trying to generate man pages, the
question has come up of whether we should use markdown or asciidoc. Let's
discuss.

Markdown is fairly standard and reasonable enough to use. But it doesn't
consistently support advanced features I would want for real documentation or
anything more basic than headings, links, and lists. I want things like
includes and definition lists.

I would love a tool that can check the syntax of my docs. And also be able to
convert to man pages in a fairly standard way.

I feel like asciidoc is more likely to have well defined syntax, advanced
features for more complicated docs, and conversion to man pages.

The potential downsides of asciidoc:
* Another dependency to add to the project. Though it could be set up as a
  dist dependency rather than a build or run dependency.
* Potentially less appealing syntax? Need to double check.
* Less standard, for example, integration with github readme.

Where I'm thinking about using docs:
* Project README - how does it show up on github?
* Tutorials - how easy to connect tutorials together?
* Book - booklike stuff wanted.
* Program help text to convert to man pages.
* Library function doc comments to convert to man pages.

I would like to check the syntax of asciidoc too:
* Support for '##' style headers instead of '~~~~~~~'?
  == Title ==, === Title === looks like is what we would use.
  Not consistent with markdown.
* Support for definition lists?
  Yes. For example:
   x:: ...

See /usr/share/doc/asciidoc/userguide.html for asciidoc docs.

In general, it's pretty clear that asciidoc will not be compatible with
markdown.

Apparently github does support asciidoc? Yes. I just need to use '.adoc',
'.ad', or .asciidoc extension.

I don't see an obvious syntax checker for asciidoc yet, but maybe we could
enable warnings and give an error if there is a warning generating some
format for asciidoc.

My vote: let's give asciidoc a shot. I know how I feel about markdown. It's
been a while since I tried asciidoc.

To start:
* Update README, tutorials
  - Add build commands to call asciidoc or asciidoctor as seems best for
    syntax checks.
* Consider generating man pages for --help via asciidoc fragments instead of
  using help2man.

Oh, I guess one question is how a doc comment would look as an asciidoc.

// Foo --
// Inputs::
// * ...
// Side effects::
// * ...
// Returns::

I think it works via definition list just fine. Cool. Is it worth changing the
header too?

// = Foo =
// Inputs::
// * ...
// Side effects::
// * ...
// Returns::

That's just as easy to parse as // Foo --. I think it looks fine.

---

Initial reactions after converting README.md to README.adoc:
* asciidoc does give an error in some cases.
* Reading the asciidoc.txt sample file, it's not quite as easy for me to read
  in ascii format as I would have liked.
* I don't like having 'XXXXXXXXXXXXXXXXXXXXXXXXXXXX' delimiters for things.
  Seems like arbitrary length lines are asked for. Just use 4 chars to start?
* It's nice having definition lists. I like that.

---

I wonder if I can write help usage for programs directly in asciidoc, and
import the rendered text to use in --help. Wouldn't that be nicer? Then we
could read it separately, include in a bigger manual, generate man pages, all
that from the raw source documentation?

Trouble is, manpage input format has special requirements different from help
text and generic asciidoc description.

Also, trying to generate text output from asciidoc is a pain. And I don't like
the generated output style at the moment (lots of horizontal rules for no
apparent reason?).

Ugh. I'm going to be honest. I feel like really all I want is:
* title, section headers, paragraphs, unordered lists, ordered lists,
  definition lists, code blocks, inline code blocks, comments, callouts (todo,
  warning, note, etc.), references to other docs, links.

Markdown and asciidoc are both so close, but not quite there?
* markdown is missing definition lists, callouts, references to other docs?
* asciidoc is missing... none of these? But it doesn't do nested indenting
  well. Like, definition lists can't be indented, right? No, it looks like you
  can indent them.

---

The real problem is, I don't have enough control over how things are
generated, because I don't have my own programmatic representation of a
document. Imagine I could parse a document and represent it abstractly. Then I
could easily generate whatever I want in terms of man pages and checking
proper document format.

But, guess what? I have a programming language that I could use for this. Why
not write a doc package in fble? Generating man pages is not going to be
difficult.

How things could work:
* fble program to parse header files and generate man pages.
* fble program to parse help text and generate man pages.
 - I don't think we want to generate help text from an fble program, because
   that gives us an annoying bootstrapping problem.

But that still leaves open the question: what syntax do we use? Do we keep
README as a markdown format? What syntax do we use for tutorials, markdown?
Asciidoc?

I'll tell you the syntax I like: markdown plus definition lists. I guess
technically we could use asciidoc for that, because I think asciidoc,
technically, supports the '## ...' style section titles (though vim doesn't
syntax highlight that).

My documentation needs are not complex. If I want to go for a standard
approach, asciidoc is better because it supports everything I could want in a
more standard way than markdown. For man pages, I really would prefer to
generate them myself.

So, here is what I propose: Use a strict, small, subset of asciidoc. Write an
fble program that can parse that subset of asciidoc. Use it for the following:
* To extract doc comments on header files and generate man pages.
* To extract help text on main program and generate man pages.
* To syntax check my README file and tutorials.

How about if I don't want to write my own program? If I don't want to be
restricted to a subset of asciidoc?
* README file and tutorials can be fullblown asciidoc.
* Write code to extract general description and convert to custom format man
  page for library code. As in, everything in the doc comment goes to the
  description section of the man page. Ignore RETURN VALUE section of man
  page. Write my own wrapper around the asciidoc.
* Continue to use help2man for commands? Or write them in such a way that I
  can extract asciidoc directly?
 - The hard part is separating synopsys and options? Honestly, I don't really
   want asciidoc syntax in the output of --help.

Perhaps another option is to write my own asciidoc backend to generate text
to use as input to --help and for man pages? That's an idea worth exploring I
think.

So, here's where we stand at the moment:
* Continue to push ahead with asciidoc approach, but explore more advanced
  options. Don't give up on asciidoc yet.

Proposal:
* README and tutorials in asciidoc.
* --help text for commands generated automatically from fble-foo.adoc file
  using a custom asciidoc backend.
* man page for commands generated automatically from fble-foo.adoc file using
  another custom asciidoc backend.
* Use tcl to extract header file doc info and generate man pages from them via
  asciidoc using another custom asciidoc backend.


Let's start by seeing if we can generate useful --help from an asciidoc file.

Features to look for:
* attribute to define brief format for man page.
* attribute to define synopsys/usage text.

Ug. It's just hard. Asciidoc is so complicated. I really am tempted to just
write my own. It can't possibly be that hard to parse basic formatting, can
it?

---

Before going down that route, let's just double check if there isn't some
other standard document format that meets my requirements.

creole - no definition lists
github flavored markdown - no definition lists
mediawiki - no definition lists
reStructuredText - no definition lists, overly verbose.

No, I don't see any that I like. Best bet, I feel like, is to use a subset of
asciidoc, call it asciidoc, but implement my own parser for the subset.
Hopefully that gets me the best of most worlds:
* Standard doc format that can be read by things like github and vim syntax
  highlighting.
* Full control over generated output.
* Can implement my own checker.
* No need to have asciidoc installed.

With the plus of having another fble program to try to write.

Let's be honest about what this really means:
* For doc comments and --help text, use a subset of asciidoc.
* For everything else, may as well use full asciidoc.

Because I only need to generate man pages from doc comments and --help
text.

---

Every time I try to do asciidoc, it feels like a slog. I'm playing around with
labelled lists using fairly commonly accepted syntax of:

label
: definition
label
: definition

It's actually not so bad.

Oh, and I should remember I probably want the language spec to be turned into
a doc with whatever format I choose.

I'm not sure if github supports definition lists in its markdown.

Options:
* markdown with definition lists
 - custom parser and man page generator for a subset?
 - or use pandoc or some such for generating man pages.
* asciidoc 
 - custom parser and man page generator for a subset?

---

Screw it. Let's me have some fun and do my own doc format from scratch. It can
be whatever I want: as similar or different from markdown or asciidoc. No
worry about standards or anything like that. How would I do it?

We have a lot of docs existing to work with. Let's start with adding minimal
features needed for those. Starting with README:

* Title (or section 0?)
* Sections (each with a title)
* Paragraphs
* Definition list.
* Verbatim blocks.
* Inline verbatim.

Start with those.

The syntax I'm thinking about:
* section syntax, paragraphs, verbatim blocks, inline verbatim from markdown.
  Ish.
* definition list is:  '@ <label>: <definition>'.

Let's see how that might look.

What extension should I use for my doc format? .txt perhaps? .fbld, short for
fbledoc? Let's stick with .txt for now. README.txt looks okay to me for now.
It would look even better with syntax highlighting.

Anyway, more important than the concrete syntax is the abstract syntax.

First question: is everything in a section, or can there be things not in a
section? Explicit sections have titles. If you had something in an implicit
section, would it be a section without a title?

Once you start a section, the only way out is to start a new section or end
the document. We don't have explicit section end markers. That, to me,
suggests a section has a title, optional (non subsection) content, followed by
a list of subsections.

Then it makes sense for a whole doc to be a top level section. The title of
the top level section is the title of the doc?

Question: what's the difference between the 'root' section, and a top level
section? For example, if we use:

# Foo
...

To give the title of the doc, what if you say:

# Foo
...

# Bar
...

Then we don't have a document title, but rather two level 1 subsections in the
document. Options:
* Don't allow level 1 section anywhere in doc except at the beginning.
* Use a separate syntax to describe the title of the doc.

I'm leaning towards using separate syntax for the document title.

Historically I've used:

Title
=====
Author

Anyway, that's back to a concrete syntax issue. Sounds like sections are clear
to me.

Section:
  (title :: String)
  (content :: Maybe Content)
  (subsections :: [Section])

Where a top level document is of type Section.

Question: Can we use inline formatting in titles? I don't think I personally
tend to do that in practice. Let's simplify and say no for now. We can add
that back later.

What is content?

Content is a list of (non-section) blocks.

Content: (blocks :: [Block])

Block: ParagraphBlock | CodeBlock | DefinitionListBlock
ParagraphBlock: (spans :: [Span])
CodeBlock: (text :: String)
DefinitionListBlock: [(label :: String, content :: Content)]

Span: TextSpan | CodeSpan
TextSpan: (text :: String)
CodeSpan: (text :: String)

Note, in particular, the body of a labelled list element is Content, which
could be multiple paragraphs. At minimum it is at least a single paragraph.
I'm not sure if that's right, but it's a good place to start. It's only wrong
if we have reason to distinguish between a paragraph and a list of spans. I
don't see a reason to.

Cool. We have a draft spec for documents. Shall I codify it? Then we can dig
into the nitty gritty of the concrete syntax.

Section:
* '#' in left column, number of consecutive '#' is section level. Whitespace 
  after last '#'. Everything following the whitespace to the end of the line
  is the name of the title.
* Let's say line before and after have to be blank lines. So blank lines form
  a kind of delimiter here.
* Content is everything that follows up until the next section that's not at a
  subsection level from this one.

Document title brainstorm:

Foo
===

# Foo

% Foo

Honestly, I like the first one from a human reader point of view. It gives
weight enough to make it look like a title, and leaves room for metadata
beneath it. I think better to be entirely separate from section syntax, even
though the whole doc is meant to be one big section.

Okay, so, ignore any initial blank lines in the document.
The first non-blank line should be followed by a line of '===...' of same
length as previous line? Let's say it's an error not to include a title? Or
should the title be optional? Can the title be empty?

Food Thought
====

Food
=========

I don't like having to match the number of '=' to the length of the title. I
don't like it being mismatched. Anything better we could do instead?

= Foo =
Richard Uhler <...>

Actually, I think a single '=' sign beneath looks okay.

Foo
=
Richard Uhler <...>


Okay, let's say title is first non-blank line, and it must be followed by a
line consisting of one or more consecutive '=' signs, of any number.

To have an empty tile? A section title could be empty by just not providing
one. How about same here: empty title by having the line of '=' be the first
thing.

What about no title at all? Like, no '=' at all? I don't like it. I want it to
be required.

Okay, so, start of document is:
  <blank lines>
  non-blank line followed by '==' line
  or '==' line

And content starts after a blank line, then beyond.

That's sections for you. Next is blocks, which could be at some indent level,
because we may want nested lists. We keep track of a current indent level and
read blocks relative to that.

Skip blank lines. Interesting question: can we always use blank lines for
delimiters? Is there ever a time we don't want to do that? I'm thinking of a
code block with blank lines in it. If we treat blank line as delimiter, that
would mean we have multiple code blocks back to back rather than a single code
block.

I certainly have code blocks in question with blank lines in them. Potentially
multiple blank lines. Imagine we want to highlight a code block a different
color. I think we need to consider code blocks with blank lines inside them
all as one code block. Don't get rid of the blank line. Especially if there
are multiple.

How about start and end of a code block? Strip blank lines? Then, is it not
possible to have an initial blank line?

How about this: code blocks are always indented. That's the concrete syntax
for them. So, if you want to continue the code block, continue the indent.

So, a single code block:

....@ Unit@ = *();
....@ Bit@ = +(Unit@ 0, Unit@ 1);
....@ Bit4@ = *(Bit@ 3, Bit@ 2, Bit@ 1, Bit@ 0);
....
....Unit@ Unit = Unit@();
....
....Bit@ 0 = Bit@(0: Unit);
....Bit@ 1 = Bit@(1: Unit);

And three adjacent code blocks:

....@ Unit@ = *();
....@ Bit@ = +(Unit@ 0, Unit@ 1);
....@ Bit4@ = *(Bit@ 3, Bit@ 2, Bit@ 1, Bit@ 0);

....Unit@ Unit = Unit@();

....Bit@ 0 = Bit@(0: Unit);
....Bit@ 1 = Bit@(1: Unit);

From a viewer's perspective, they look the same. No harm. The hardest part
will be writing them and remembering to indent if you want it to be a single
block.

This way you can do blank lines before and after the same way. I like that.

And this way, we can treat blank lines as delimiters of content.

In terms of blocks, taking into account the indent level to know how much of
the stack of current elements to close:
* '# ' starts a new section.
* '* ' is a list element.
* '@ ' denotes a labeled list element.
* '  ' or other indent is a code block.
* Anything else is a paragraph. Hopefully you don't want to start a paragraph
  with '#', '*', or '@'. If you do, uh... We should have a paragraph symbol
  you can use to escape those? Or, just escape with a '\' character? But what
  if we want, for example, bold to start the paragraph, versus '*' to start
  the paragraph? Maybe have '$ ' or '^ ' be an optional paragraph marker for
  those special cases? Or '*' versus \*? No, I like '$ ' or '^ ' for an
  explicit paragraph, as opposed to an implicit paragraph. Then *foo* could
  still be a bolded thing at the front a paragraph, and \* foo could be a
  literal '*' character at the start of a paragraph.

* this is a list item
$ *this* is a bolded first word of a paragraph.
$ \*\*\* is three asterisks at the start of a paragraph.
$ *\** is a bold asterisk at the start of a paragraph.

---

An important challenge is going to be allowing special characters to show up
as regular characters in paragraphs. Here is what I propose:
* A blank line is required after a paragraph before you consider anything a
  special character. Blank line between paragraph and section, list, etc.
* Option, or maybe always have it be, so the first line clearly denotes a
  paragraph.

For example, maybe paragraphs always have a single space to start? Is that
sufficient? So we don't have to worry about what may be a special character,
and we can add all sorts of new special characters later on like, 1, 2, 3, a,
b, c, A, B, C, i, I, etc.

I don't know. Single space to start each paragraph feels weird to me. Too
subtle perhaps. Awkward with single line paragraphs. Maybe for now stick with
the idea of '$' optional to start? Or, think about it more.

Maybe a better approach would be to make special characters more special. They
don't show up too often. Not as much as paragraphs. For example, maybe '@' is
in front of every special character, and we just need to escape @@?

@## Section
@* list item 1
@* list item 2
   @* nested list item
@. X: labeled.

Who puts '@' in a paragraph anyway?

No. I think go with what we had before. No special '@' character. Take our
changes with having to know what to escape. Allow '$' as an explicit paragraph
marker to support those escapes.

---

Next topic of discussion: whitespace and the vagaries thereof.

Is it okay to align, for example, definition lists? I'm pretty sure I would
want to. For example:

  -I DIR::                     add DIR to the module search path
  -m, --module MODULE_PATH::   the path of the module to compile

The definitions are left aligned. That means there is an arbitrary amount of
space between the label and the definition.

According to our abstract syntax, the definition is <Content>. Content can be
a code block, and a code block is denoted by using indent. If we support
arbitrary whitespace between label and definition, how could we possibly code
block content for that definition?

Options:
* Don't allow arbitrary whitespace. Always use a single space.
* Use '> ...' as an indicator for code block instead of indent.
* Have some sort of invisible hack, for example, where we put the verbatim
  text on the next line.

That also begs the question: for definition lists:
* What is the indent level set to for subsequent lines.
* How to put the definition on a separate line?

For example:
   @ foo: this is a really long example text in
          a short window
   @ bar: here is a another example that is
     slightly different
   @ sludge:
     here is a definition on a different line.
   @ also:             left aligned definition
     that wraps back to the beginning.
   @ and also:         left aligned definition
                       that wraps back to the 
                       alignment
  
More examples:
  @ -I DIR:                     add DIR to the module search path
  @ -m, --module MODULE_PATH:   the path of the module to compile

  @ -I DIR: add DIR to the module search path
  @ -m, --module MODULE_PATH: the path of the module to compile

  @ -I DIR:
    add DIR to the module search path
  @ -m, --module MODULE_PATH:
    the path of the module to compile

  @ bin/:
    Source code for fble compiler binaries.
  @ book/:
    Drafts for a book about the design of the fble language.
  @ include/:
    Public header files for the fble library.
  @ lib/:
    Source code for an fble interpreter and compiler implemented in C.
  @ pkgs/:
    Sample fble library and application packages.
  @ spec/:
    Specification of the fble language, including spec tests.
  @ test/:
    Source code for fble test binaries and other test utilities.
  @ thoughts/:
    A collection of running discussions about fble.
  @ tutorials/:
    Tutorials for getting started with fble.

Okay. That's actually growing on me. In this case, we require the label to be
on its own line. The content starts at 2 space indent on the next line. The
above examples are worst case examples where you might want compact definition
lists. They aren't so bad. They are all aligned. And now, in theory, we could
have a code block:

  @ foo:
        code block is here

Question: do we need the colon at all now?

  @ -I DIR
    add DIR to the module search path
  @ -m, --module MODULE_PATH
    the path of the module to compile


  @ test/
    Source code for fble test binaries and other test utilities.
  @ thoughts/
    A collection of running discussions about fble.
  @ tutorials/
    Tutorials for getting started with fble.

I feel like no, we don't.

---

Next topic: how many spaces to indent?
* always 2 spaces?
* let the user decide?

It's related to the above discussion. If it's not a fixed number of spaces,
then code blocks aren't obvious to start when entering a new indent level.

I personally would always decide 2 spaces. This is for me. Let's just require
2 space indent everywhere.

---

Idea: let's call this format fbld. Recycle the name. Where 'd' stands for doc.
You could imagine having 'fblt' for my 'test' format.

---

Question: how do you have two back-to-back lists? For example:

* l1.1
* l1.2

* l2.1
* l2.2

Is that one list or two? Now, consider instead:

* l1.1

* l1.2

* l2.1

* l2.2

That's clearly one list. How about:

* l1.1

* l1.2


* l2.1

* l2.2

How about:

* l1.1

* l1.2 

  which in this case is a multi-line list item.

  Which makes it much harder to keep track of the end.

* l2.1

* l2.2

Actually, it's not too hard. If we want to support multiple lists back to
back, put two blank lines before the list element instead of a single blank
line. This suggests we can't coalesce blank lines together into generic
delimiters, because we want to allow blank lines between list items, but also,
in this case, between lists.

Whitespace means so much in this language. I guess that's not surprising,
given the goal is to have something structured and uncluttered. So we use
whitespace for the structure without having it clutter things up.

---

Anyway, I think we have enough worked out to get going. I think it could be
easier to write the spec after first writing an implementation. This spec
sounds hard to me to write, given the effect of whitespace, indent, and
context on the meaning of the syntax.

Things to do:
* Draft fbld.txt spec.
* Start pkgs/fbld with definition of Doc@ types.
* Implement printer for Doc@.
  - Do it right, so we can use this to see if there are any kinds of documents
    you can't express in the concrete syntax.
* Implement parser for Doc@.
* Write a vim syntax file.

Summary of decisions so I don't forget:
* title\n=== for title, where any number of '=' characters allowed.
* '#' for section
* '*' for unordered list
* '@ <label>\n  <content>' for definition list.
* '$' optionally for paragraph
* paragraph requires blank line to end.
* 2 space indent for code block
* 2 space indent for continuation.
* 2 blank lines splits lists in two.
* `...` for code inline

Future work:
* *...* for bold inline? italic inline? mixed bold/italic?
* Numbered lists.
* link to other file.
* 'include' other file (with some handling of section levels).

---

Interesting side note: github renders markdown files nicely, and asciidoc
files. It would be nice if links between files worked for that. Presumably
using my own markup language will not work with github.

Looks like links in theory would be: [display](tutorials/Tutorials.md). So
that would be, uh, [tutorials/Tutorials.md](tutorials/Tutorials.md)? Could I
just do (tutorials/Tutorials.md) instead? In asciidoc, you can do
link:tutorial/Tutorials.md[]. Maybe markdown can do
[](tutorials/Tutorials.md)? Apparently not.

In that case, maybe I want to use asciidoc primarily while in the progress of
switching to my own format? Now because it has definition lists and more
convenient local reference links.

---

Let me give asciidoc another chance. It seems to be okay for tutorials,
readme. Can we use it reasonably for man pages is the question. I think it's
worth having the same discussion again that we had before, in case anything
different comes out of it.

First commands:
* Writing the man page in asciidoc creates a reasonable description to read. I
  have no complaints with, for example, bin/fble-compile.adoc.
* The generated man page is not great, but it's serviceable.
  - Examples don't render very well.
  - No bold/italics in synopsis.
  - But aside from minor things like that, it's fine.
  - I guess this is because I haven't manually done the markup. I can add
    that.
* Any way to get --help text from this?
  - The default generated text is not nearly concise enough. Table of
    contents, lots of blank lines, lots of -------------- lines.

The question, then, is how can I change the style of the output? Maybe now's a
good time to read the documentation for asciidoc in detail, with an eye for
how to do my own output formatting.

Notes from reading asciidoc docs:
* Learn about DocBook.
* In theory I can change the input language by changing config files.
* DocBook is XML. XSLT is a style sheet. Looks like we could provide custom
  XSLT and CSS stylesheets.
* See manpage.xsl for the manpage style sheet.
* There is something called themes, which changes .css and .js for generated
  html?
* It's possible to annotate a section with a template name, which appears to
  get processed in a template-specific way in the backend. For example:
  'bibliography' section.
* We can automatically set the template for a section based on its title using
  [specialsections] part of an asciidoc .conf file. But this use is not
  recommended. They say it is deprecated.
* Looks like the .conf file contains templates for generating documents.

Okay, so how does the text backend work when invoking a2x? Does asciidoc
generate docbook via docbook backend, and then use xslt to turn that into
text? Or does it go straight asciidoc to text?

It goes:
foo.adoc =(asciidoc)=> foo.xml =(xsltproc)=> foo.text.html =(w3m)=> foo.text

In this case, a lot of the junk is brought in by xsltproc.

So, we have options. We could try to add special config file to go straight to
text from foo.adoc. Or we could try to improve xsltproc.

How do man pages work right now? It generates a different foo.xml file that is
a refentry format instead of article format. Then uses xsltproc with a manpage
xslt sytlesheet to generate the man page.

Let's first understand the asciidoc conf files and how the .xml file is
generated. For man pages:

/etc/asciidoc/asciidoc.conf
- defines input language format.

/etc/asciidoc/docbook45.conf
- generates the xml tags using templates.

Then a bunch of mostly irrelevant filters:
  /etc/asciidoc/filters/graphviz/graphviz-filter.conf
  /etc/asciidoc/filters/source/source-highlight-filter.conf
  /etc/asciidoc/filters/music/music-filter.conf
  /etc/asciidoc/filters/latex/latex-filter.conf
  /etc/asciidoc/filters/code/code-filter.conf

/etc/asciidoc/lang-en.conf
  English language stuff.

Can I try doing my own configuration files to start? Or, are there any other
configuration files available I could use instead? No. But I bet I could write
my own.

How about we start here then? How would I turn my man-page structured
fble-compile.adoc file into help-text suitable output?

* <NAME> section
* Add 'Usage:' in front of synopsys section text, same line.
* Render description in as-is formatted text, limited to 80 cols.
  Maybe go through roff or something to do the formatting for me?
* Change sect2 titles to '<Title>'
* Change sect3 titles to '<Title>:'

It's all the same info. I think it's reasonable to try and generate help text
from the man page asciidoc input.

Shall I try?

Looks like I could use:
  asciidoc -v -e -f /etc/asciidoc/asciidoc.conf -f ruhler.conf fble-compile.adoc

To try and pass my own custom .conf file. I'm not sure how to use my own
backend otherwise.

---

Working through how to make a config file that would translate
fble-compile.adoc to a reasonable usage help text:
* How to add Usage: as special case for SYNOPSIS section?
* How to get rid of &#8230; for '...' in synopsis?
* How to add blank lines between paragraphs in the description?
* How to get list item numbers?
  - {listindex} is the attribute (found by reading /usr/bin/asciidoc).
* How to put first list line on the same line as list index?
  - I don't think I can.
* Indent options. How to put definition on same line?
* How to show 'EXIT STATUS', 'EXAMPLE' titles as special case for those
  sections?
  - Or maybe remove NAME, SYNOPSYS, DESCRIPTION, OPTIONs as special cases?
* Remove footer text. DONE.
  
The generated output from asciidoc includes raw text from the input file. That
means I can't do direct processing on that text, like stripping newlines,
reflowing to fit column width, etc. Things like aligning list definitions will
be hard. This suggests I'll want to pass the output through some post
processor that can do wrapping and alignment for me.

Two post-processors come to mind:
1. Whatever is used for man pages. roff?
2. xsltproc.

Perhaps it's worth learning about xsltproc first.

Okay, I guess let's read about xslt:
* Ugh. It's a template language in xml syntax. I'm not convinced it will be
  sufficient to address the problem I'm having. That is, I don't think it will
  provide layout functionality. If it doesn't, then there is no value using it
  instead of using asciidoc for that part.

Why is this so hard? Why can't we just have a data structure that I can write
python code to generate output from, for example? I could probably write a raw
xml backend to asciidoc, and then use xml libraries in python to generate
output.

Maybe now is a good time to step back and ask what I'm trying to accomplish in
this case anyway. I want to have a single source of truth for the
documentation of an fble binary program that can be reused in the man page and
--help text. I've said asciidoc is nice to use to describe the single source
of truth, because it has the structure elements for lists, sections, etc. In
that case, however, we would require asciidoc to generate the executable. Is
that really what I want? Like, is this worth the complexity and overhead? Just
duplicate the usage info. It's not that much.

I could, of course, go the other direction, like I have now. Custom structured
usage text that I generate asciidoc and/or man pages from. It's limited
because I want to use the compact text form as the source of truth, which
makes it hard to extract structure.

There are a few cruxes here:
* How to capture structure in compact text?
  - For if I want --help to be source of truth.
  - For library function doc comments.
* How to avoid bootstrap problem for fble binaries
  - To minimize dependencies needed to build them.
  - To have them not depend on themselves.
* How to minimize dependencies on external tools.
  - Like help2man, asciidoc, xsltproc, etc.
* How to take advantage of github / other standard processing of docs?

If it weren't for github showing asciidoc and markdown nicely, it makes sense
to have a custom format:
* --help text and doc comments are source of truth.
* So no issue with bootstrapping.
* No extra dependencies.
* Full control over generated code.
* A fun example to add to fble.

The downsides being:
* Github doesn't render things in a pretty fashion.
* Readers won't be able to google to understand the syntax of documentation.
* It could be a fair amount of work to define my own markup language.

Perhaps fble binaries are a bad place to start, because they don't really need
clear text source of truth. But library doc comments do need a clear text
source of truth, because they are comments in code.

// # FbleNewStructValue
//
// Create a new struct value with given arguments.
//
// @ Inputs
//   @ heap
//     The heap to allocate the value on.
//   @ argc
//     The number of fields in the struct value.
//   @ args
//     'argc' `FbleValue` arguments to the struct value. Args are borrowed,
//     and may be `NULL`.
//
// @ Results
//   A newly allocated struct value with given args.
//
// @ Side effects
//   * The returned struct value must be freed using FbleReleaseValue when no
//     longer in use.

That's a little less compact than I want though. I would prefer:

// FbleNewStructValue --
//
// Create a new struct value with given arguments.
//
// Inputs:
//   heap - The heap to allocate the value on.
//   argc - The number of fields in the struct value.
//   args - 'argc' `FbleValue` arguments to the struct value. Args are borrowed,
//          and may be `NULL`.
//
// Results:
//   A newly allocated struct value with given args.
//
// Side effects:
// * The returned struct value must be freed using FbleReleaseValue when no
//   longer in use.

That is, the '@ ' of a definition list shifts things two characters to the
right, and the newline shifts things down an extra line.

Compare to doxygen:

/**
 * \brief Create a new struct value with given arguments.
 *
 * \param heap  The heap to allocate the value on.
 * \param argc  The number of fields in the struct value.
 * \param args  'argc' `FbleValue` arguments to the struct value.
 *              Args are borrowed, and may be `NULL`.
 *
 * \return A newly allocated struct value with given args.
 *
 * @ Side effects
 *   * The returned struct value must be freed using FbleReleaseValue when no
 *     longer in use.
 */

Which is slightly more compact, because it doesn't use extra lines for
'Inputs', 'Results', and 'Side effects' sections or the title of the function.

Maybe I come up with my own doc comment format?

Why not use doxygen:
* It doesn't generate output the way I want.
* No tag for side effects.
* Doesn't have title of function at top of comment.
* \brief seems not useful to me.
* I don't like /** ... */ to denote doc comment? Though I guess I don't care
  that much. This could be a decent way to denote what is a doc comment versus
  general code comment.

I might prefer something like:

/**
 * FbleNewStructValue
 * 
 * Create a new struct value with given arguments.
 *
 * \param heap  The heap to allocate the value on.
 * \param argc  The number of fields in the struct value.
 * \param args  'argc' `FbleValue` arguments to the struct value.
 *              Args are borrowed, and may be `NULL`.
 *
 * \return A newly allocated struct value with given args.
 *
 * \effect The returned struct value must be freed using FbleReleaseValue when
 *         no longer in use.
 * \effect Some other effect, just for example purposes.
 */

Asciidoc would give us:

// FbleNewStructValue
// ------------------
// Create a new struct value with given arguments.
//
// Inputs::
//   heap:: The heap to allocate the value on.
//   argc:: The number of fields in the struct value.
//   args:: 'argc' `FbleValue` arguments to the struct value.
//     Args are borrowed and may be `NULL`.
//
// Results::
//   A newly allocated struct value with given args.
//
// Side effects::
//   * The returned struct value must be freed using FbleReleaseValue when no
//     longer in use.

That's pretty compact.
