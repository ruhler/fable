* [eval] Thread management cleanup
 - Clarify for FORK instruction whether the main thread continues to run until
   join, or if the main thread waits until all children are done. If the
   former, implement it correctly. If the later, fix the bug in reference
   counting that triggers a memory leak in some cases if we fail to execute
   the release following the fork in a timely manner.
 - Switch i/o ports to use links.
 - Track suspended threads on links.
   Use this to determine i/o blocking instead of progress.
 - Use fair thread traversal by starting over from root when yield occurs.

* [invaders] Implement space invaders game.
 - Add lives indicators to display.
 - Figure out how they know when to move forward as a group.

* [compile] Figure out why Normal is called so often
 - See if we can fix that to reduce the now annoyingly long compile times.
 - Profiling said its all in TypeEquals. Maybe something pathological?

* [lang] Set up cindent properly for fble.vim
 - For example, so you can do newline in a comment block and have it auto add
   the comment character.

* [compile] Optimization: Avoid REF_INSTR if we aren't going to ever use it.
 - Maybe have a way to list free vars in an expression and use that to compute
   'recursive' ahead of time? Not sure.
 - gcov suggests we'll save on the order of 4 million instructions and 4
   million allocations in fble bench. Surely that's good for something.

* [bench] Optimize
 - game of life:
    40s step,
    14s transform draw, calling back into 'f'.
        x: 5s add, 3s mul, y: 3s add, 1s mul.
        Looks like add, mul the only opportunity for improvement?

* [profile] Optimize profiling.
 - 30 seconds spent in enter/exit processing
 - 17 seconds spent in FbleProfileSample
 - 24 seconds spent in FbleProfileTick (without sampling)
 I'm not sure how to make it better though, besides turning it off.

* [cc] Implement .fble -> .o compiler
 - Goal is to significantly increase performance by removing the instruction
   fetch decode logic.

* [gc] Optimize gc. 
 - Experiments suggest gc is 28% overhead for fble bench today.

* [test] Add fble-heap-test for splitting cycles
   Test that we don't retain a cycle a->b->c by referencing a separate object
   d that used to be in the cycle a->b->c->d.

* [snake] Switch to a target 60 FPS?
* [snake] Test and fix bug when snake eats its tail.
* [snake] Ignore moves that aren't orthogonal to current snake direction.
* [snake] Keep track of and report score.
* [snake] Figure out why the background box gets lost some times.
* [pingpong] Render a static 3D table tennis scene.
* [gameoflife] Switch to a target 60 FPS?
* [invaders] Optimize space invaders game.
 - Figure out how I'm going to get to 60 FPS.
   Maybe try getting 60 FPS on the C implementation to see if it's reasonable?
 - Implement and test Alien simulation

* [lib] Add test coverage for the Int routines.
 - In particular, test Div and Mod.
* [lib] Separate Map from DataMap and EqMap.
* [lib] Add unit tests for /Map%.Equals.
* [lib] Separate List@ from S@ and P@ module wise.

* [api] Can fble-stdio check that the function has the right type?

* [compile] Consider tracking memory for proper cleanup?
  I wonder how much of what we allocate ends up unused. If we could track and
  clean up allocations when we are done with them, maybe we can save some
  memory.

* [compile] Is there a way to clean up compile.c, in terms of orders of setting fields
  of instructions vs scopes vs locals? It all seems very confused to me.

* [compile] Test and fix error message for type of anonymous type let values.
 - The type should be the computed type for the value, not the introduced
   abstract type?

* [profile] Come up with a way to deal with irregular ticks.
 - For example, what if we block on user data. Then the ticks stop. Then the
   first sample afterwards gets charged a huge amount unfairly.
 - I think this is solved fine for 'profile time', it's only wall time now
   that suffers from this problem. Maybe we just need to take an explicit
   sample whenever we come back after blocking on I/O? The only question is...
   who do we charge that time against? Have a separate category?

* [profile] I suspect there are still bugs around block id 0
 - test that calling into block 0 does the right thing. Though I'm not sure it
   makes much sense.

* [eval] Experiment with alternate garbage collection implementations.
 - For the purpose of improving memory and runtime performance.
* [eval] Make child thread execution fair.
  Children should be time multiplexed, where priority is assigned based on how
  far down the family tree the child belongs. The amount of time a family gets
  to spend evaluating should be independent of the number of children in the
  family.

* [lang] Can a module reference itself? Clarify in the spec and test this case.
* [lang] Add support for abstract types?
* [lang] Document the runtime memory model,
  - Including that tail recursive functions should not smash the stack.
* [lang] Document and test that put ports don't retain link values.

* [release] Better error messages on types that have the same name but different values?
* [release] Write man pages for fble and friends?
* [release] Better error message for importing something from a module that
  is not defined in the module?

* [heap] Change reference counting to be incrementally done on allocation.
  Maybe write a test that shows how something that should take no time gets
  charged for a big deallocation time today?

* [arena] Rethink arenas and documentation, because some cases appear to assume you
  have a bulk-free arena. Other cases its not well specified what is freed
  explicitly and what is expected to be freed implicitly.
  I claim a good model is: pass an arena to a function to say: the function
  allocates its result in this arena. The function creates and uses a separate
  arena for its intermediate allocations.

* [debugger] Implement an fble debugger. Features:
 - Set a breakpoint at a line in a file.
 - Step through code line by line.
 - Evaluate expressions in the context of the current scope and print the
   results.
 - Auto breakpoint at undefined behavior?
 
 Use cases:
 - Debug why sudoku solver isn't working properly by stepping through a line
   at a time and printing intermediate values.

   Turns out it wasn't too hard to figure out the problem in this case without
   a debugger.

 - Debug why snake AI wasn't working.

   It turns out we were using the wrong direction. A debugger to step through
   code and print variable values would have found this more quickly than my
   guess and check approach, which was pretty tedious.

