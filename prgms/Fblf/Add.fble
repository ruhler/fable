
@ Addr@ = /Fblf/Program%.Addr@;
@ Bit@ = /Fblf/Program%.Bit@;
@ Program@ = /Fblf/Program%.Program@;
@ Value@ = /Fblf/Program%.Value@;
% Assign = /Fblf/Program%.Assign;
% Eq = /Fblf/Program%.Eq;
% If = /Fblf/Program%.If;
% Seq = /Fblf/Program%.Seq;
% Const = /Fblf/Program%.Const;
% Ref = /Fblf/Program%.Ref;

@ Int@ = /Int/Int%.Int@;
% Add = /Int/Int%.Add;
% Sub = /Int/Int%.Sub;

% D = /Int/Int/Lit%.D;
% I = /Int/Int/Lit%.I;

<@>% Just = /Maybe%.Just;
<@>% Nothing = /Maybe%.Nothing;

@ IntP@ = /Int/IntP%.IntP@;

<@>% Cons = /List%.Cons;
<@>% Nil = /List%.Nil;

<@,@>% DoWhile = /Loop%.DoWhile;

% Unit = /Unit%.Unit;

# Add1 --
#   A 1-bit adder.
#
# Inputs:
#   a - The address of the first operand.
#   b - The address of the second operand.
#   c - The address of carry bit in.
#   x - The address of the carry bit out.
#   z - The address of where to store the result of the addition.
#
# Results:
#   A program that sets x and z based on the one bit addition a + b + c.
(Addr@, Addr@, Addr@, Addr@, Addr@) { Program@; }
Add1 = (Addr@ a, Addr@ b, Addr@ c, Addr@ x, Addr@ z) {
  Int@ n1 = I(D|1);
  Value@ b0 = Const(Cons<Bit@>(Bit@(0: Unit), Nil<Bit@>));
  Value@ b1 = Const(Cons<Bit@>(Bit@(0: Unit), Nil<Bit@>));
  Seq(
    If(Eq(Ref(a), b0, n1),
      Seq(
        If(Eq(Ref(b), b0, n1),
          Seq(
            Assign(z, Ref(c), n1),
            Assign(x, b0, n1))),
        If(Eq(Ref(b), b1, n1),
          Seq(
            If(Eq(Ref(c), b0, n1),
              Seq(
                Assign(z, b1, n1),
                Assign(x, b0, n1))),
            If(Eq(Ref(c), b1, n1),
              Seq(
                Assign(z, b0, n1),
                Assign(x, b1, n1))))))),
    If(Eq(Ref(a), b1, n1),
      Seq(
        If(Eq(Ref(b), b0, n1),
          Seq(
            If(Eq(Ref(c), b0, n1),
              Seq(
                Assign(z, b1, n1),
                Assign(x, b0, n1))),
            If(Eq(Ref(c), b1, n1),
              Seq(
                Assign(z, b0, n1),
                Assign(x, b1, n1))))),
        If(Eq(Ref(b), b1, n1),
          Seq(
            Assign(z, Ref(c), n1),
            Assign(x, b1, n1))))));
};

# Adder -- 
#   An n-bit adder, with most significant bit first.
#
# Inputs:
#   heap - The next available address on the heap.
#   n - The number of bits to add together.
#   a - The address of the first operand.
#   b - The address of the second operand.
#   z - The address of where to store the result of the addition.
#
# Results:
#   heap - An updated value for the next available address on the heap.
#   prgm - A program that, when executed, sets z = a + b.
(Addr@, IntP@, Addr@, Addr@, Addr@) { *(Addr@ heap, Program@ prgm); }
Adder = (Addr@ heap, IntP@ n, Addr@ a, Addr@ b, Addr@ z) {
  # We need a single bit of internal state to store the carry bit as we do
  # the addition.
  Addr@ carry = heap;
  Addr@ nheap = Add(heap, I(D|1));

  Value@ b0 = Const(Cons<Bit@>(Bit@(0: Unit), Nil<Bit@>));
  Program@ initialize_carry = Assign(carry, b0, I(D|1));

  Program@ p = DoWhile<Int@, Program@>(
    Sub(Int@(p: n), I(D|1)),
    (Int@ i) {
      /Int/Int/Eq%.Eq(i, I(D|0)).?(true: Nothing<Int@>, false: Just<Int@>(Sub(i, I(D|1))));
    },
    initialize_carry,
    (Int@ i, Program@ program_start) {
      Seq(program_start, Add1(Add(a, i), Add(b, i), carry, carry, Add(z, i))); 
    });

  @(heap: nheap, prgm: p);
};

@(Adder);
