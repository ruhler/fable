
@ Drawing@ = /Drawing%.Drawing@;
@ Color@ = /Drawing%.Color@;
@ Point@ = /Drawing%.Point@;
% Color = /Drawing%.Color;

@ Drawn@ = /Drawing/Test%.Drawn@;
@ Pixel@ = /Drawing/Test%.Pixel@;
% Drawn = /Drawing/Test%.Drawn;
% Draw = /Drawing/Test%.Draw;
% LtPoint = /Drawing/Test%.LtPoint;
% EqColor = /Drawing/Test%.EqColor;
% ShowColor = /Drawing/Test%.ShowColor;

@ Vec@ = /Graphics/3D%.Vec@;

@ Camera@ = /Graphics/Camera%.Camera@;
@ Rect@ = /Graphics/Camera%.Rect@;
% Camera = /Graphics/Camera%.Camera;
% RotateY = /Graphics/Camera%.RotateY;
% Translate = /Graphics/Camera%.Translate;
% Vertex = /Graphics/Camera%.Vertex;

% Triangle = /Graphics/Triangle%.Triangle;

% Neg = /Int/Int%.Neg;
% Int = /Int/Int/Lit%.Int;

<@>% List = /List%.List;

<@>@ Maybe@ = /Maybe%.Maybe@;
<@>% Just = /Maybe%.Just;

% Str = /String%.Str;

@ Test@ = /Test%.Test@;
% Test = /Test%.Test;
% TestSuite = /Test%.TestSuite;

Test@ Tests = TestSuite(Str|'Graphics.Triangle', List<Test@>[
  Test(Str|'Focus Triangle', !({
    # A triangle drawn at the focus plane should appear normal size.
    Camera@ camera = Camera(Int|10, Rect@(Neg(Int|1), Neg(Int|1), Int|6, Int|6));
    Vec@ a = Vertex(camera, Vec@(Int|0, Int|0, Int|10));
    Vec@ b = Vertex(camera, Vec@(Int|0, Int|4, Int|10));
    Vec@ c = Vertex(camera, Vec@(Int|4, Int|0, Int|10));

    Drawing@ drawing = Triangle(camera, a, b, c, Color.Green);

    Drawn@ wnt = Drawn[
      Pixel@(Int|0, Int|0, Color.Green),
      Pixel@(Int|0, Int|1, Color.Green),
      Pixel@(Int|0, Int|2, Color.Green),
      Pixel@(Int|0, Int|3, Color.Green),
      Pixel@(Int|1, Int|0, Color.Green),
      Pixel@(Int|1, Int|1, Color.Green),
      Pixel@(Int|1, Int|2, Color.Green),
      Pixel@(Int|2, Int|0, Color.Green),
      Pixel@(Int|2, Int|1, Color.Green),
      Pixel@(Int|3, Int|0, Color.Green)
    ];
    Drawn@ got = Draw(drawing);
      
    /Drawing/Test%.AssertEquals(wnt, got);
  })),

  Test(Str|'Far Triangle', !({
    # A triangle drawn at twice the distance from the focus plane should
    # appear half its actual size.
    Camera@ camera = Camera(Int|10, Rect@(Neg(Int|1), Neg(Int|1), Int|6, Int|6));
    Vec@ a = Vertex(camera, Vec@(Int|0, Int|0, Int|20));
    Vec@ b = Vertex(camera, Vec@(Int|0, Int|4, Int|20));
    Vec@ c = Vertex(camera, Vec@(Int|4, Int|0, Int|20));

    Drawing@ drawing = Triangle(camera, a, b, c, Color.Green);

    Drawn@ wnt = Drawn[
      Pixel@(Int|0, Int|0, Color.Green),
      Pixel@(Int|0, Int|1, Color.Green),
      Pixel@(Int|1, Int|0, Color.Green)
    ];
    Drawn@ got = Draw(drawing);
      
    /Drawing/Test%.AssertEquals(wnt, got);
  })),

  Test(Str|'Close Triangle', !({
    # A triangle drawn at half the distance to the focus plane should appear
    # twice its normal size.
    Camera@ camera = Camera(Int|10, Rect@(Neg(Int|1), Neg(Int|1), Int|6, Int|6));
    Vec@ a = Vertex(camera, Vec@(Int|0, Int|0, Int|5));
    Vec@ b = Vertex(camera, Vec@(Int|0, Int|2, Int|5));
    Vec@ c = Vertex(camera, Vec@(Int|2, Int|0, Int|5));

    Drawing@ drawing = Triangle(camera, a, b, c, Color.Green);

    Drawn@ wnt = Drawn[
      Pixel@(Int|0, Int|0, Color.Green),
      Pixel@(Int|0, Int|1, Color.Green),
      Pixel@(Int|0, Int|2, Color.Green),
      Pixel@(Int|0, Int|3, Color.Green),
      Pixel@(Int|1, Int|0, Color.Green),
      Pixel@(Int|1, Int|1, Color.Green),
      Pixel@(Int|1, Int|2, Color.Green),
      Pixel@(Int|2, Int|0, Color.Green),
      Pixel@(Int|2, Int|1, Color.Green),
      Pixel@(Int|3, Int|0, Color.Green)
    ];
    Drawn@ got = Draw(drawing);
      
    /Drawing/Test%.AssertEquals(wnt, got);
  })),

  Test(Str|'Translated Triangle', !({
    # Test that translation moves the camera in the direction specified.
    Camera@ camera = Translate(Int|0, Int|0, Int|10,
      Camera(Int|10, Rect@(Neg(Int|1), Neg(Int|1), Int|6, Int|6)));
    Vec@ a = Vertex(camera, Vec@(Int|0, Int|0, Int|20));
    Vec@ b = Vertex(camera, Vec@(Int|0, Int|4, Int|20));
    Vec@ c = Vertex(camera, Vec@(Int|4, Int|0, Int|20));

    Drawing@ drawing = Triangle(camera, a, b, c, Color.Green);

    Drawn@ wnt = Drawn[
      Pixel@(Int|0, Int|0, Color.Green),
      Pixel@(Int|0, Int|1, Color.Green),
      Pixel@(Int|0, Int|2, Color.Green),
      Pixel@(Int|0, Int|3, Color.Green),
      Pixel@(Int|1, Int|0, Color.Green),
      Pixel@(Int|1, Int|1, Color.Green),
      Pixel@(Int|1, Int|2, Color.Green),
      Pixel@(Int|2, Int|0, Color.Green),
      Pixel@(Int|2, Int|1, Color.Green),
      Pixel@(Int|3, Int|0, Color.Green)
    ];
    Drawn@ got = Draw(drawing);
      
    /Drawing/Test%.AssertEquals(wnt, got);
  })),

  Test(Str|'Rotated Triangle', !({
    # Test that rotation rotates the camera in the direction specified.
    # Here we rotate the camera 90 degrees around the Y axis, so that the
    # camera is now looking in the -x direction.
    Camera@ camera = RotateY(Int|64,
      Camera(Int|10, Rect@(Neg(Int|1), Neg(Int|1), Int|6, Int|6)));
    Vec@ a = Vertex(camera, Vec@(Neg(Int|10), Int|0, Int|0));
    Vec@ b = Vertex(camera, Vec@(Neg(Int|10), Int|4, Int|0));
    Vec@ c = Vertex(camera, Vec@(Neg(Int|10), Int|0, Int|4));

    Drawing@ drawing = Triangle(camera, a, b, c, Color.Green);

    Drawn@ wnt = Drawn[
      Pixel@(Int|0, Int|0, Color.Green),
      Pixel@(Int|0, Int|1, Color.Green),
      Pixel@(Int|0, Int|2, Color.Green),
      Pixel@(Int|0, Int|3, Color.Green),
      Pixel@(Int|1, Int|0, Color.Green),
      Pixel@(Int|1, Int|1, Color.Green),
      Pixel@(Int|1, Int|2, Color.Green),
      Pixel@(Int|2, Int|0, Color.Green),
      Pixel@(Int|2, Int|1, Color.Green),
      Pixel@(Int|3, Int|0, Color.Green)
    ];
    Drawn@ got = Draw(drawing);
      
    /Drawing/Test%.AssertEquals(wnt, got);
  })),

  Test(Str|'1 Vertex Clip Right', !({
    # One of the vertices of the triangle is clipped, so that the result of
    # drawing a triangle looks like a trapezoid.
    Camera@ camera = Camera(Int|10, Rect@(Int|0, Int|0, Int|2, Int|8));
    Vec@ a = Vertex(camera, Vec@(Int|0, Int|0, Int|10));
    Vec@ b = Vertex(camera, Vec@(Int|0, Int|4, Int|10));
    Vec@ c = Vertex(camera, Vec@(Int|4, Int|0, Int|10));

    Drawing@ drawing = Triangle(camera, a, b, c, Color.Green);

    Drawn@ wnt = Drawn[
      Pixel@(Int|0, Int|0, Color.Green),
      Pixel@(Int|0, Int|1, Color.Green),
      Pixel@(Int|0, Int|2, Color.Green),
      Pixel@(Int|0, Int|3, Color.Green),
      Pixel@(Int|1, Int|0, Color.Green),
      Pixel@(Int|1, Int|1, Color.Green),
      Pixel@(Int|1, Int|2, Color.Green)
    ];
    Drawn@ got = Draw(drawing);
      
    /Drawing/Test%.AssertEquals(wnt, got);
  })),

  Test(Str|'2 Vertex Clip Right', !({
    # Two of the verticies of the triangle are clipped, so that the result of
    # drawing a triangle looks like a smaller triangle.
    Camera@ camera = Camera(Int|10, Rect@(Int|0, Int|0, Int|2, Int|8));
    Vec@ a = Vertex(camera, Vec@(Int|0, Int|0, Int|10));
    Vec@ b = Vertex(camera, Vec@(Int|4, Int|4, Int|10));
    Vec@ c = Vertex(camera, Vec@(Int|4, Int|0, Int|10));

    Drawing@ drawing = Triangle(camera, a, b, c, Color.Green);

    Drawn@ wnt = Drawn[
      Pixel@(Int|0, Int|0, Color.Green),
      Pixel@(Int|1, Int|0, Color.Green),
      Pixel@(Int|1, Int|1, Color.Green)
    ];
    Drawn@ got = Draw(drawing);
      
    /Drawing/Test%.AssertEquals(wnt, got);
  })),

  Test(Str|'3 Vertex Clip Right', !({
    # The entire triangle is outside the clipping region, so nothing should be
    # drawn.
    Camera@ camera = Camera(Int|10, Rect@(Int|0, Int|0, Int|8, Int|8));
    Vec@ a = Vertex(camera, Vec@(Int|10, Int|10, Int|10));
    Vec@ b = Vertex(camera, Vec@(Int|10, Int|14, Int|10));
    Vec@ c = Vertex(camera, Vec@(Int|14, Int|10, Int|10));

    Drawing@ drawing = Triangle(camera, a, b, c, Color.Green);

    Drawn@ wnt = Drawn[];
    Drawn@ got = Draw(drawing);
      
    /Drawing/Test%.AssertEquals(wnt, got);
  })),

  Test(Str|'1 Vertex Clip Left', !({
    # One of the verticies of the triangle is clipped on the left.
    Camera@ camera = Camera(Int|10, Rect@(Int|0, Int|0, Int|2, Int|8));
    Vec@ a = Vertex(camera, Vec@(Neg(Int|2), Int|0, Int|10));
    Vec@ b = Vertex(camera, Vec@(Int|2, Int|4, Int|10));
    Vec@ c = Vertex(camera, Vec@(Int|2, Int|0, Int|10));

    Drawing@ drawing = Triangle(camera, a, b, c, Color.Green);

    Drawn@ wnt = Drawn[
      Pixel@(Int|0, Int|0, Color.Green),
      Pixel@(Int|0, Int|1, Color.Green),
      Pixel@(Int|0, Int|2, Color.Green),
      Pixel@(Int|1, Int|0, Color.Green),
      Pixel@(Int|1, Int|1, Color.Green),
      Pixel@(Int|1, Int|2, Color.Green),
      Pixel@(Int|1, Int|3, Color.Green)
    ];
    Drawn@ got = Draw(drawing);
      
    /Drawing/Test%.AssertEquals(wnt, got);
  })),

  Test(Str|'Full Screen Clipped Triangle', !({
    # The triangle takes up the entire available display, so you see a solid
    # color screen. Tests clipping on all sides.
    Camera@ camera = Camera(Int|10, Rect@(Int|0, Int|0, Int|2, Int|2));
    Vec@ a = Vertex(camera, Vec@(Neg(Int|3), Neg(Int|1), Int|10));
    Vec@ b = Vertex(camera, Vec@(    Int|3,      Int|5 , Int|10));
    Vec@ c = Vertex(camera, Vec@(    Int|3,  Neg(Int|1), Int|10));

    Drawing@ drawing = Triangle(camera, a, b, c, Color.Green);

    Drawn@ wnt = Drawn[
      Pixel@(Int|0, Int|0, Color.Green),
      Pixel@(Int|0, Int|1, Color.Green),
      Pixel@(Int|1, Int|0, Color.Green),
      Pixel@(Int|1, Int|1, Color.Green)
    ];
    Drawn@ got = Draw(drawing);
      
    /Drawing/Test%.AssertEquals(wnt, got);
  })),

  Test(Str|'Close Up Full Screen Clipped Triangle', !({
    # Test that clipping rounds to outside the clip region in cases.
    # The full screen is taken up by the triangle, but the projection causes
    # rounding to be required.
    Camera@ camera = Camera(Int|10, Rect@(Int|0, Int|0, Int|2, Int|2));
    Vec@ a = Vertex(camera, Vec@(Neg(Int|3), Neg(Int|1), Int|9));
    Vec@ b = Vertex(camera, Vec@(    Int|3,      Int|5 , Int|9));
    Vec@ c = Vertex(camera, Vec@(    Int|3,  Neg(Int|1), Int|9));

    Drawing@ drawing = Triangle(camera, a, b, c, Color.Green);

    Drawn@ wnt = Drawn[
      Pixel@(Int|0, Int|0, Color.Green),
      Pixel@(Int|0, Int|1, Color.Green),
      Pixel@(Int|1, Int|0, Color.Green),
      Pixel@(Int|1, Int|1, Color.Green)
    ];
    Drawn@ got = Draw(drawing);
      
    # TODO: Debug this test failure.
    /Test%.ExpectFails(/Drawing/Test%.AssertEquals(wnt, got), Str|'');
  })),

  Test(Str|'X/Y Clip Issue', !({
    # Regression test for a case where we clipped X, then clipped Y, but the
    # clipping of Y rounded the X clipped point inside of the X clipping
    # region, causing a hole to appear where there should not have been one.
    Camera@ camera = Translate(Int|1, Int|0, Int|0,
      Camera(Int|20, Rect@(Neg(Int|32), Neg(Int|24), Int|64, Int|48)));
    Vec@ a = Vertex(camera, Vec@(Neg(Int|20), Neg(Int|6), Neg(Int|30)));
    Vec@ b = Vertex(camera, Vec@(Neg(Int|20), Neg(Int|6), Int|30));
    Vec@ c = Vertex(camera, Vec@(Int|20, Neg(Int|6), Neg(Int|30)));
    Drawing@ drawing = Triangle(camera, a, b, c, Color.Green);
    Drawn@ drawn = Draw(drawing);

    # Verify we don't have a hole in the lower left corner.
    Maybe@<Color@> got = /Map%.Lookup<Point@>(LtPoint)<Color@>(
      drawn, Point@(Neg(Int|32), Neg(Int|24)));
    Maybe@<Color@> wnt = Just<Color@>(Color.Green);
      
    # TODO: debug this test passing.
    /Test%.ExpectFails(/Test%.ExpectFails(/Test%.AssertEquals<Maybe@<Color@>>(
      /Maybe/Eq%.Eq<Color@>(EqColor),
      /Maybe/Show%.Show<Color@>(ShowColor),
      wnt, got), Str|'Nothing'), Str|'');
  })),

  Test(Str|'Poked Eye Triangle', !({
    # A triangle at the origin, poking out the camera's eye.
    # In this case we expect the triangle to take up the entire display.
    Camera@ camera = Camera(Int|10, Rect@(Int|0, Int|0, Int|4, Int|4));
    Vec@ a = Vertex(camera, Vec@(Int|0, Int|0, Int|0));
    Vec@ b = Vertex(camera, Vec@(Int|0, Int|2, Int|0));
    Vec@ c = Vertex(camera, Vec@(Int|0, Int|0, Int|4));

    Drawing@ drawing = Triangle(camera, a, b, c, Color.Green);

    Drawn@ wnt = Drawn[
      Pixel@(Int|0, Int|0, Color.Green),
      Pixel@(Int|0, Int|1, Color.Green),
      Pixel@(Int|0, Int|2, Color.Green),
      Pixel@(Int|0, Int|3, Color.Green),
      Pixel@(Int|1, Int|0, Color.Green),
      Pixel@(Int|1, Int|1, Color.Green),
      Pixel@(Int|1, Int|2, Color.Green),
      Pixel@(Int|1, Int|3, Color.Green),
      Pixel@(Int|2, Int|0, Color.Green),
      Pixel@(Int|2, Int|1, Color.Green),
      Pixel@(Int|2, Int|2, Color.Green),
      Pixel@(Int|2, Int|3, Color.Green),
      Pixel@(Int|3, Int|0, Color.Green),
      Pixel@(Int|3, Int|1, Color.Green),
      Pixel@(Int|3, Int|2, Color.Green),
      Pixel@(Int|3, Int|3, Color.Green)
    ];
    Drawn@ got = Draw(drawing);
      
    /Drawing/Test%.AssertEquals(wnt, got);
  }))

  # TODO:
  # * Add test for clipping where two vertices are outside the clip region
  #   but the line between them has parts inside the clip region?
  # * Add tests for clipping due to point behind the camera.
]);

 @(Tests);
