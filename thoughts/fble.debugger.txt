Fble Debugger
=============
Features:
 - Set a breakpoint at a line in a file.
 - Step through code line by line.
 - Evaluate expressions in the context of the current scope and print the
   results.
 - Auto breakpoint at undefined behavior?
 - Any way we could do this just by using dwarf + gdb?

Times in the past I wished I have an fble debugger:
 - Debug why sudoku solver isn't working properly by stepping through a line
   at a time and printing intermediate values.

   Turns out it wasn't too hard to figure out the problem in this case without
   a debugger.

 - Debug why snake AI wasn't working.

   It turns out we were using the wrong direction. A debugger to step through
   code and print variable values would have found this more quickly than my
   guess and check approach, which was pretty tedious.

 - Debug why sat solver test is failing.
   Manual code inspection doesn't reveal the issue. I really want to trace the
   code to see which unexpected branch is being taken.

   Manually tracing through the code by profiling block led straight to the
   problem: bad implementation of boolean Eq.

 - Debug why List Eq test is failing. I want to step through again.
   Sigh. I definitely need a debugger.

   Turns out False was being defined as True instead of False. I figured that
   out by changing the body of ListEq to always return False and being
   surprised when the result was as if it returned True.

 - Debug why map equality is failing when show shows identical maps
   { (1,1) => 1; } vs. { (1,1) => 1; }

   Turns out it was a bug in map quality, not too hard to find by code
   inspection.

 - Debug where we're getting stuck in an infinite recursion in fble that
   exhibits as a fast memory leak followed by OOM kill.

   This turned out to be big memory use, not infinite recursion. I tracked it
   down by minimizing the test case enough to run it to completion, and using
   profiling to see how many times different functions were being called.

 - Debug wrong tag in fble tests, where the invariants for what the tag should
   be are a bit complicated.
   
   Ideally we can run until we hit the error, then get a stack trace in the
   debugger and have a way to look at local variables and the stack trace to
   figure out where things are going wrong.

   Turned out to be a flaw in the code. Identified by minimizing the test case
   and working out the issue on paper. It would have been much easier if I
   could have stepped through the code and printed values of local variables
   along the way.

 - Debug why drawing a line from (0, 0) to (-2, -2) actually draws a line from
   (-1, -1) to (-3, -3), ideally by stepping through the code and viewing
   local variables at each step.

   Walked through the code by hand on pen and paper to see that the code was
   doing exactly what I wanted it to, but what I wanted it to do was wrong.
   Being able to step through the code and view values of variables as we go
   would have been nicer than doing it on pen and paper.

 - Debug why triangle is not being clipped properly. Walking through the code
   by hand suggests it should work. I want debugger to step through the code
   and print variable values to confirm it lines up with what I expect based
   on walking through the code by hand.

   I ended up making a copy of the code, turning the Clip function into a
   process, making it a Stdio@ program, and adding print statements for printf
   style debugging. This revealed the problem was a bug in the integer Ge
   function.

 - Debug another issue why triangle is not being clipped properly. I can step
   through the code in gdb now, but without the ability to print variables,
   it's too hard to follow what's going on. I'm tempted to use my printf
   debugging approach again, which should find the problem pretty quickly. The
   printf approach is effective, but it's very tedious to thread IO through an
   otherwise pure function.

 - Debug why snake screen is just blank. In this case I wanted to step through
   a mix of fble code and fble-app.c code, but using the interpreter, because
   I don't happen to have a compiled version of the fble snake app. I ended up
   using gdb to step through fble-app.c after things were converted outside of
   the FbleValue domain.

 - Debug strange behavior of pinball hitting a corner where it gets a bunch of
   energy. I want to add a check to the code to detect when the situation
   occurs, then do printf to print values of variables at the time of
   collision to better understand.

 
---

It doesn't look like gdb can easily support languages that are far different
from C. Perhaps it's worth trying to develop a custom debugger for fble. I can
avoid any overhead/dependency on gdb that way. But it also means I have to
implement the entire thing myself.

There are guides online for how to add a new language to gdb, which requires
modifying the gdb source code. That includes ways to specify how to print
types and expressions and how to parse types and expressions.

Could we use dwarf to pretend we are executing C code, and encode structs and
unions in a way that gdb can understand? Then at least for structs we could
see all the fields, and for unions, perhaps we could see the names of tag?
That's about as good as we could do anyway, right?

Dealing with the stack will be challenging, given tail calls and the fact that
the stack is managed. Perhaps it would be simpler if I finish implementing my
plan to use native stacks. Or perhaps not.

I'm thinking it is at least worth a try to emit dwarf information. In that
process I'll see what we can encode in dwarf and how, and how useful gdb is in
that case.

Let's go a ways down this route and see where we get. Initial goals:
* Be able to set break points and step through .fble files.
* Be able to print data type values as structs/unions based on variables on
  the stack.

Don't worry about stack traces yet. And let's focus on debugging compiled
code, which I suspect would be easier.

What happens today if we try to run a compiled program and set a breakpoint
based on an fble source file and line number? It says no such source file.

The first step, then, should be to see how we can get my .fble files included
in the list from 'info sources'. Let's download the dwarf spec and see how
to start with that.

---

My sample assembly program passes the file using a '.file' assembly directive
at the top of the generated assembly:

.arch armv8-a
.file "foo.c"

Within the assembly, I also see directives of the form:

.file 1 "foo.c"

And:

.loc 1 9 3
.loc 1 13 12 discriminator 3
.loc 1 13 12 is_stmt 0
.loc 1 13 12 is_stmt 1

My guess is what we need is:
* .file 1 "foo.c" somewhere near the top of the generated assembly file.
* .loc 1 <line> <col> for each line, and after the last line.

What does the gnu assembly docs say about these?
* The plain .file "foo.c" directive is deprecated
* https://www.sourceware.org/binutils/docs/as/index.html seems to have decent
  documentation of the directives.

The .loc options are all related to the .debug_line state machine, which I can
probably read about in the dwarf spec, page 151:

* lines and cols start at '1'
* is_stmt is a recommended breakpoint location
* discriminator is used in case multiple blocks have the same line, column,
  and file.

My guess is I don't have to worry about any of the line number options.

So, plan is simple:
* At the top of the generated assembly, emit a .file 1 "foo.c" directive.
* At the start of each emitted instruction, ...

We have to decide and track somehow which code instructions should have line
numbers associated with them. Or at least, which are starts of statements. We
also need to start tracking line number information more generally in
FbleInstr.

I would say a statement is:
* let bindings, branch of case expression, expression in a block or 'stmt'
  form, union_select statement, function bind, proc_link, and proc_exec.

Other things are not statements.

Can we use our profiling block locations as statements? We already have that
information available in the code block, and it has the location information.

Let's try this: profile enter and profile replace emit locations which will
correspond to statements. Try that.

It works! I can now set breakpoints on .fble files. Stepping through doesn't
work too well at this point, but it's a good start.

Question also: the profile blocks are basic blocks, not statements. This means
we'll skip over let expressions and things like that. It would be good if we
could add statements there. Maybe we could add a fake kind of profile op to
mark the beginning of a statement?

---

Note: Turn off -O3 when debugging to get better info, hopefully.

How can I print the values of variables?

Maybe to start, can we list the available variables somehow in gdb? Perhaps
'info locals'?

And also, typing 'next' in gdb doesn't work at all. Would be nice if I could
fix that somehow. Perhaps because we don't have more statements in the same
block, and so it doesn't know where the statement ends?

Other things my sample assembly has:
.cfi_startproc
.cfi_def_cfa_offset 16
.cfi_endproc

And a .debug_info section.

---

I finally read through the dwarf5 spec in sufficient detail. My summary of
dwarf is:

Debugging information is represented as a tree of nodes. Nodes describe things
like programs, functions, call sites, declarations, etc. Each node has a tag
describing the type of the node and a collection of key,value pairs which are
attributes. The tree is flattened into a sequence of nodes stored in the
.debug_info section.

Along with the tree of nodes, there is a section for storing a mapping from
line numbers to machine addresses, stored in .debug_lines. There is also a
section for call frame information, stored in .debug_frame, that describes how
to unwind the stack and restore registers appropriately.

My guess is that the gnu assembler generates the .debug_lines section for me
based on my .loc directives, and it would generate the .debug_frames section
for me too if I add relevant cfi directives. I'll have to write the
.debug_info tree myself.

The dwarf spec has an appendix showing what all attributes you could expect
for various node types in the tree. I don't know what information gdb needs
for specific features, such as going to the next statement. But presumably if
I try to fill out the debug information tree with as much information as I
reasonably can that seems related, eventually I'll get to a place where gdb
can do good things.

Note that dwarf5 does support tagged unions. I think they call them variants.

What approach should I take for adding dwarf support? I would like to do it
well and complete. Not just hacky like I have so far. For example, statements
should include all the statements, not just the beginnings of blocks. Then it
should be fairly straight forward I think: start with a minimal compilation
unit debug tree, then slowly and recursively add more attributes until we get
to a place we are happy with.

A big challenge will be figuring out how to write tests for the generated
debug info.

Maybe libdwarf will be useful? Looks like it can do some sanity checks, and
dump to human readable format. So I could at least craft a particular .fble
file, dump the dwarf for it, and verify it has all the statements and
variables and types and such? Or perhaps objdump has some support?

dwarf.h and libdwarf.h exist on my computer, defining a bunch of the dwarf
contents. That will be useful.

For example, try objdump with --dwarf and see what it outputs. And it has
a --dwarf-check option too.

It looks like the assembler is generating a compilation unit entry for me. It
also says it is emitting dwarf2. Maybe I should start by generating dwarf2,
which is perhaps more widely supported than dwarf5 and simpler?

I think first step is to pick some attribute I want to add to the compilation
unit node. Figure out how to add that in the assembler. Next step is to figure
out how to add a broken attribute value and use objdump or dwarfdump to catch
the error. Then set up a dwarf test case that runs as part of build.

Once I have the infrastructure up and running to test dwarf, I guess I can
slowly start adding dwarf. For now we can just check for consistency in the
generated dwarf code.

---

Let me start with dwarf2, look at an example c file compiled by gcc. Dump the
debug info entries, and see where the functions/statements show up in the
tree. If statements are completely separate from functions, then let's start
by generating all the statement nodes. If, as I suspect, the statements are
parts of functions, then let's generate function nodes to start, and worry
about adding statement nodes after.

My sample foo.o file has:

DW_TAG_compile_unit
  DW_TAG_subprogram main, with low_pc and high_pc
  DW_TAG_subprogram sludge
  DW_TAG_subprogram foo
  

I see no nodes for statements. Presumably those are captured using low_pc and
high_pc along with line location info? Except .debug_abbrev might augment
that?

And from assembly, how is that encoded?
Maybe add
  .type foo, %function before a function label?
  .size foo, .-foo at the end of each function?

I don't know. This is hard. I should probably actually read and understand the
spec.

Let's try setting .type and .size and see if the assembler generates anything
for us for free from that.

No, it doesn't. I think what happens is GNU AS generates a .debug_info section
if there isn't one in the file, but in the case of gcc, it adds one explicitly
to the file. So I'll need to add my own to the file, with all the node info,
and presumably GNU AS will see it and avoid creating its own.

Any reason to keep the .type and .size info for symbols? How about no, until I
figure out what it's good for.

Note: my gcc appears to emit dwarf version 4 for the .debug_info section
(unlike dwarf version 2 for other sections). So maybe that's a good target to
start with? Or maybe stick with dwarf version 2 as long as it has what we
need, and upgrade to later version only as needed.

I suppose a decent place to start, then, is to emit my own compile_unit tag:

producer: FBLE
name: foo.fble
comp_dir: getcwd
low_pc: 0
high_pc: ??? get this with some asm magic? Yes. I can use a label to the end
of the text.

So probably we'll want to emit the debug_info all at the end, referencing
labels within things?

It looks like we need a .debug_abbrev section too. .debug_info stores the
attribute values, .debug_abbrev stores the attribute names.

Cool. This should be straight forward to start, if a little tedious in the
details. Let's emit a single compile_unit node.

---

The compile_unit should contain subroutine entries for each of the functions.

DW_TAG_subprogram
  DW_AT_name string "/foo/bar%.blah"
  DW_AT_external flag for externally visible functions. Just the top level?
  DW_AT_calling_convention - can be omitted for standard c calling convention.
  DW_AT_type - for the return type, but I don't have support for describing
               types yet.
  DW_AT_low_pc, DW_AT_high_pc - for the address range of the function.
  DW_AT_return_addr, DW_AT_frame_base 

So, to start, just name, external, low_pc, and high_pc I guess. Or even just
name, low_pc, and high_pc.

---

I could write tests for the debugging stuff using gdb scripts, right? Debug a
known program, verify I can place breakpoints and view things and step through
things.

It would be great if I knew what information gdb needed for certain tasks, so
I could do this based on what gdb needs instead of randomly adding information
and hoping for the best.

If the first debugging goal was to be able to set breakpoints on .fble files,
the next debugging goal would be to be able 'step' and 'next' through the code
reliably. I suppose we don't really have the first goal done yet, because you
can't set breakpoints at the start of a let body?

How about:
* figure out how to write a gdb based test of the debugging stuff.
* write a test that you can set a breakpoint at the start of a basic block.
* write a failing test that you can set a breakpoint at a let body.
* add debug info necessary to set a breakpoint at a let body.
* research what approach/info gdb needs to implement step and next.
* add a test for step/next.
* implement whatever is needed for step/next.

Apparently I can no longer set breakpoints at lines in .fble files, presumably
because I added my own debug_info section? No, looks like it's because I
specify the statement list as 0 instead of some relocatable value, and it
isn't being relocated properly.

Yeah, that was the problem.

I'm also getting some dwarf warnings about bogus end of sibling markers that I
don't understand. Maybe I need to check out the source code for dwarfdump to
see why it produces that warning.

dwarfdump -ka produces a lot more info, and I have source code so it's
possible to figure out what's up.

Here's one issue reported:
* DW_AT_stmt_list is apparently expected to use data4, not data8.

The trouble is, gcc generates a lot of errors according to dwarfdump too, and
given that some of the errors are generated by the assembler, it's hard to
know how I could use dwarfdump meaningfully as a test. Maybe just run it
occasionally in case of gdb issues?

Examples of current errors reported by dwarfdump associated with FBLE:
* .debug_line: Address 0x004220b4 DW_LNE_end_sequence address does not exactly match high function addr:  0x0041928c ***
* .debug_line: standard DWARF3 operands matched, but is DWARF2 linetable: count 12 at offset 0x000139b3  ( 80307 ) ***

The second one I see from GCC, so let's ignore that.
The first is specific to FBLE, so maybe worth tracking down.

This happens, for example, in /Fble/DebugTest% function.

I have no idea what's going on here.

---

Next steps with gdb: 'step' and 'next'.
* step apparently goes to whatever the next source line encountered is. I
  should be able to verify that works today.
* next: "Execution stops when control reaches a
   different line of code at the original stack level that was executing when
   you gave the next command. This command is abbreviated n."

Presumably 'next' is not going to work in the case where the frame pointer
gets mess up, or the backtrace gets messed up?

Step appears to work as specified, except it's a little annoying it steps into
C code. It would be nice if we could make it go to the next 'fble' source
file.

Next gets stuck at the address of the 'exit' trampoline. Somehow that stack
appears to be corrupted when we get there. Perhaps it would help to give each
function its own exit routine. More traditional and straight forward. I'm not
sure why the stack is messed up there though. Maybe gdb is just confused that
a part of the function isn't where it thought it would be?

Yeah, moving exit into the particular function it is for fixes gdb's
unhappiness about next. But next doesn't work the way you want because it
triggers when we do any call into a function, which causes us to move the
native stack to the managed stack for the current running function, so gdb
thinks we have exited the function and it's time to stop.

---

How will multithreading work?

gdb has support for pthreads. Otherwise I bet it will get confused.

But, can we use pthreads for light weight multithreading? For example, if I'm
going to allocate a separate stack per thread anyway, is there significant
overhead associated with pthreads?

I would be happy to use pthreads if:
* The overhead of creating threads isn't too high, because we do it with every
  proc/exec. Creating and joining threads should be light weight. Like, on the
  order of a function call, or maybe up to 4x a function call.
* We can set the scheduler to only allow one thread to run at once.
  I suppose we can have a big lock if we want to, to control this.

I fear it's just going to be way too much overhead though.

And the fble thoughts archive shows last time I considered pthreads, there's a
not very high limit on the total number of threads you can have.

Maybe multithreading won't be so big a problem in practice, because we tend to
execute a thread to completion whenever possible, so the only time we do a
context switch that could confuse gdb is when the thread gets blocked.
Straight line code should work just fine.

---

Another question: any way we can avoid calling into the .c files? How about we
avoid generating debugging symbols for .c files, so the only debug symbols we
have are for fble files. Step should then step through only the .fble files,
right?

Yes! That works great. As long as we can make it obvious to gdb what the stack
is, if we only have fble debug info produced, then 'step' goes to the next
fble line. In practice this would work by having a user link with a release
build of libfble that does not have debugging symbols. It looks like there's
also an option in gdb to skip files, so the user could say skip all .c files.

---

With subprogram entries in place, we can now set breakpoints on function
names, assuming you can figure out what the right name to use is with regards
to '!' extensions.

---

Now that we do function calls in place instead of falling back to RunThread to
do function calls, next and backtrace work decently well. That's cool. I bet
we can step through the code in a useful way now. Aside from there not being
enough statement locations.

---

Next step is to have some way to print variable values. I think to start,
given a variable name, it would be nice to print the raw pointer value as an
FbleValue*, or worst case to start, as an intptr_t.

Looks like I'll want:
   DW_TAG_variable
     DW_AT_name string name
   DW_AT_location location at runtime
   DW_AT_type (for when I start supporting that)
   DW_AT_start_scope (offset from low_pc)
     For variables that are declared in the middle of a block.

If I want I can put these directly in the subprogram tag it looks like, or
introduce DW_TAG_lexical_block with low_pc and high_pc for grouping.

How to specify a location?
I want something like: a register specifies an address, we compute an offset.
So: memory[reg + X].

Looks like we can do it with one op:

  DW_OP_breg* <reg> <X>

Where we'll have to look up how aarch64 registers are numbered for dwarf. I
don't think that's in the dwarf spec.

One question is how I'll propagate this information from the fble compiler to
the aarch64 code generator.

Could we define an explicit dwarf like data structure that we pass around
along side an fble code description that refers to offsets in terms of fble pc
and variable offsets? Then the aarch64 code generator could convert that to
dwarf. It would be nice if we accurately tracked statements and braces and all
that fun stuff. Instead of overloading profiling info? Or could the profiler
reuse this same info for describing locations of blocks?

---

Let's start with statements. What info do I want for statements?

From dwarf:
 DW_TAG_compile_unit - clear
   DW_TAG_subprogram - clear
     DW_TAG_lexical_block - Any use of { } braces for stmts?
       Start of basic block
         Start of statement

 prologue_end? epilogue_begin?
      
We can associate each of these things with fble code pcs.

What I see gcc generates:

* .loc at the '{' after a function, emitted at the first instruction of the
  function.
* .loc at the start of a new statement in the function.
* .loc with discriminator ?? inside the for loop?
* .loc with is_stmt 0 ?? inside the for loop?
* .loc with is_stmt 1 following one with is_stmt 0.
* .loc at the close bracket at the end of a function, emitted just before the
  instructions to restore the stack. So, after the last statement's
  instructions.
* .cfi_* info in functions. I'm not sure if this influences debug_lines.

dwarf2 spec says nothing about discriminator or prologue/epilogue. I don't
understand the use of is_stmt 0, but it looks like I should just not emit
location information if it's not the start of a statement? Or, emit location
information for every fble instruction, but set is_stmt to 0 for those that
are not on a statement boundary to get more fine grained mapping from assembly
address to the source code. In other words, we can choose how much granularity
we want for locations, somewhere in the range of 1 location for each statement
to 1 location for each fble instruction.

Question: what if we have a nested statement block {}? Do we put a loc for
open and close brace, or just for the statements inside of it? Or maybe it
doesn't matter, because we would end up with two .loc right after each other
in the assembly code so the first would be ignored. gcc does not emit an
extra loc for '{' or '}' in this case. So that must be special to a function.

So, each function ideally keeps a location for it's open and close brace
around with it so we can emit that in dwarf. Otherwise we just need locations
for the starts of every statement, and optionally the starts of every pc
instruction. My vote is to focus on just whole statements to start. I don't
see us gaining much by going into subexpressions.

Here's my proposal:
* Add a field to every fble instruction with the location of the instruction
  and a boolean flag indicating if it was the start of an instruction or not.
* Use that info to generate .loc statements instead of the profile statements.
* To start we can just emit .loc for instructions that are the starts of
  statements. Later on, if we want, we can emit .loc for non statement
  instructions too. If there's any value to be had from that.
* Emit a .loc instruction for a function. So maybe track open and close brace
  as part of a function too.

On second thought, looking through the compiler implementation makes it look
like not a lot of instructions are statement instructions, and those that
aren't we don't necessarily have easy access to locations for. How about make
something analogous to profile_ops but for debug info, where we have optional
debug_ops we can add. We can "emit" a debug op just before compiling an
expression that should be counted as a new statement, which is usually obvious
from the caller rather than the expression being compiled itself.

---

Note, it's a little weird, but if you have something like:
  Unit@ u = Unit;
  g(u);

Then you can't set a breakpoint on the first line, because there is no code
generated for that. Variable assignment like this is free. There are no
instructions emitted for it.

---

How to print variables?

1. First step is telling gdb about the mapping from variable name to FbleValue*.
I propose:
* Add a DebugInfo type called VarInfo that stores the first fble pc, last fble
  pc, name, and frame index for each variable.
* Compute the VarInfo in the compiler, store it at the first pc, associate the
  VarInfo with a Local, and have the Local automatically set last fble pc when
  we do ReleaseLocal.
* Emit dwarf info for VarInfos by iterating again over the instructions when
  emitting dwarf info.

Hopefully at this point we can say 'print x' in gdb, and it will print out a
raw address. We could cast that to a corresponding FbleValue* type, or try to
interpret it manually (because it could be packed bits).

2. The next level of usefulness, for data type values, would be to print the raw
structure form, using tags and offsets. For example, an integer 5 might be
printed as:
  @(2: @(2: @(1: @(0: @()))))

That's not terribly useful, but at least you don't have to unpack it manually.
We could implement this by providing a C function users can invoke from gdb to
dump the data type value.

3. The next level of usefulness for data type values would be to have field
names available. So an integer 5 would be printed as:

  Int@(p: IntP@(2p1: IntP@(2p0: IntP@(1: Unit@()))))

I would argue that's still not terribly useful, but that's about the best we
can expect from gdb, even if we give gdb full type information and somehow
manage to teach it about how to unpack values.

I almost wonder if the easiest way to implement this will be by providing a C
function users can invoke from gdb, passing the value and somehow being able
to get from gdb a pointer to the type info.

4. The real level of usefulness for data type values would be to allow users
to call an fble function on the data type value that returns an fble string,
and printing that string out to the user. So an integer 5 would be printed as:
  
  "5"

From gdb's point of view, however, I don't think we have access to top level
functions.

To summarize, I think the type system gdb is designed for is not nearly as
well suited to fble, where integers are not primitives. It's going to be
tedious for a user to type out what they want to print, and I'm not sure how
I'll be able to implement in a reasonable way.

All of which starts to make a printf debugging approach much more appealing.

I suppose fundamentally what we want to make a debugger useful here is:
1. Ability to print strings, where strings use a user defined type.
2. Ability to invoke fble functions naturally passing fble arguments.
3. Ability to access fble functions by full module path from anywhere.

Or, more generally:

* Ability to print strings, where strings use a user defined type.
* Ability to evaluate arbitrary fble expressions, in the context of a current
  environment.
* Ability to refer to values by module path.
* Ability to set breakpoint at function or line.
* Ability to run, continue, break, step, next in a program.
* Ability to print backtrace and go to the context of any particular frame.
* Ability to list threads and switch between them.
* Ability to see current location in source code, preferably by showing the
  actual lines of source around the current location.
* Ideally an ability to easily switch out whatever UI you want on top of the
  debugger.

---

Going through the gdb manual, looks like gdb may have some support for
customized pretty printing of expressions. May be useful for printing strings
or particular types? Looks like there is elf section .debug_gdb_scripts we
could potentially emit to the object code to do pretty printing? Seems like
gdb supports python and scheme as the main scripting languages. I would
probably choose to use python.

I suppose the question is, is it worth adding debugging support that's so
specific to gdb, or would it be nicer to have an fble specific debugger that's
flexible enough that other people could make it work with gdb or whatever
debugger they prefer?

Put another way, everything I've done so far for debugging is in the dwarf
standard. We don't actually do anything gdb specific yet. If I start to be gdb
specific... is that overly specific?

---

Success story with the debugger: I was getting a divide by zero. I put a
breakpoint at fprintf, saw the stack trace, and it immediately saw what fble
code was leading to the divide by zero.

Then I had a long running loop. I ran gdb, did ctrl-c, saw where in the code
it was looping, and that helped me find another bug. Yay!

---

For the sake of making some progress towards support for printing variables,
next step is to try and generate debug info for variables. One question in
terms of the info I need to generate is how we track variable scopes. Or,
maybe it isn't an issue as long as we use the function scope as the end,
because if another variable of the same name is declared, it shadows the
scope?

Or, just don't worry about scopes for now. Get something useful, and we can
add a TODO and improve scope management later. That sounds like a plan to me.

First step: have the compiler generate VarInfo debug entries for each
variable.
 
* I need to pass variable name info via tc. Specifically for:
  - let_tc bindings ==> done.
  - func_value_tc args ==> done.
  - func_value_tc statics (not via PushVar?).
  - link_tc get and put ==> done.
  - fork_tc bindings ==> done.
  - Compile for top level module args ==> done.

Figuring out the location info:

   DW_OP_bregx <offset> <regnum>
Or DW_OP_breg<regnum> <offset>

What are the registers for R_STATICS, R_LOCALS?

R_LOCALS = x20 = ??
R_STATICS = x21 = ??

Encoding:
  OP (1 byte): 0x7? or 0x92 depending.
  (ULEB128 reg)
  SLEB128 offset

Let's figure out the register numbers. The internet says x0-x30 are dwarf
register numbers 0-30. So we can use:

R_LOCALS: OP 0x84
R_STATICS: OP 0x85

Followed by a SLEB 128 offset.
So, what kind of constant do we use for this?
It's got to be a block. We'll have to know the length
of the block. DW_FORM_block1 should be just fine.

The format of a block1 block is: 1-byte length followed by bytes of
information.

gcc uses 0x18 for the form of a location, which I don't see in the dwarf2
spec.

---

It totally works. I can print variables now. That's pretty awesome. Great
progress.

You know, I could use FbleStructValueAccess, FbleUnionValueAccess, ReadInt,
etc. functions to view the contents of fble values. That might be better than
dumping them as a tree of tag numbers.

But first, let's see if we can get the type to print a little more nicely.
Ideally we can specify the type as FbleValue*, but I don't know how we have
access to that definition.

Maybe:
  DW_TAG_base_type
    DW_AT_name FbleValue
    DW_AT_encoding DW_ATE_address

Or:
  DW_TAG_pointer_type
    DW_AT_type?

If only I could find a way to reference whatever debug entry gcc outputs for
FbleValue*? Could I duplicate it? It's not that complicated. Except it
references ValueTag as well. Is it worth it? All just to have it show as hex
instead of decimal? I'm thinking maybe not.

In practice the most valuable next step for debugging would be to have names
for tag values instead of numbers. But that sounds hard.

---

Another round of debugging I want to do. I want to print local variables that
are Num@ to start. How? I suppose...  Num@ is an Int@. It would be nice to be
able to convert an Int@ to a C int. We have a function for that, in
fble-app.c. But I don't have access to that in fble-tests. Can I load that
somehow? Apparently not.

My suggestion is to move the ReadInt function to a library: prgms/Int.o, or
some such. And link that into fble-tests.o solely for debug ability?

Or maybe, to get started, copy that function into fble-test.c? Ideally it's a
library function that is shared though. We can reference it from fble-test.c
solely for the purpose of debug ability?

Note: fble-stdio.c has an Output function that takes a stream and a fble
String@. If I'm willing to do some printf style string declarations in the
source code, I could use that to print them out.

Let me try a mix. I'll add ReadInt to fble-stdio.c and maybe try adding a
string to the source code to print the information I want, and see what works.

First though, can I call the Output function if it's static? No. Some how
about I add DumpString and DumpInt functions to fble-stdio for use with
debugging.

* DebugInt works.
  Except it got stuck in an infinite loop in one case? Not sure.
* It's a little annoying to have to call FbleStructValueAccess and know the
  tag numbers by heart instead of using names, or better yet, 's.x'. But it
  works.
* It's tedious enough to add a String@ variable for printf that I was hesitant
  and didn't do it. Just having to import Strs, Str, define Show functions,
  etc. That would be a cost to a printf style approach too.

Debugging with DebugInt helped me to find a bug though, so that's good. And
debugging in general feels pretty good to me now in terms of setting
breakpoints and stepping through code.

For some reason print DebugInt(FbleStructValueAccess(x, 1)) is hanging in
some (but not all?) cases. I wonder if there is some conversion issue, because
I see 'x' is being treated as a negative number in gdb. Yeah, looks like that
could be the case. It would be great to mark the type of FbleValue* as
FbleValue*, a pointer, or unsigned at least.

* I eventually got around to trying DebugString, it works pretty well. No need
  to thread through process everywhere.

---

The trouble with adding things like DebugInt and DebugString to fble-tests is
they don't work for fble-pinball. It would really be nice to have them in
general.

I compile those programs manually. I should just have some .o files that I
build as a library. Maybe a library, libfblelib.a? Or separate .o files
included specifically for debugging? FbleReadInt, FbleDebugInt,
FbleReadString, FbleDebugString, etc? If I have FbleReadInt and
FbleReadString, there's no need for the Debug variants because gdb can print
int and string already?

---

How gdb represents FbleValue* type:

<1><5b2>: Abbrev Number: 2 (DW_TAG_typedef)
    <5b3>   DW_AT_name        : (indirect string, offset: 0x3bd): FbleValue
    <5b7>   DW_AT_decl_file   : 14
    <5b8>   DW_AT_decl_line   : 15
    <5b9>   DW_AT_decl_column : 26
    <5ba>   DW_AT_type        : <0x5be>
<1><5be>: Abbrev Number: 11 (DW_TAG_structure_type)
    <5bf>   DW_AT_name        : (indirect string, offset: 0x3bd): FbleValue
    <5c3>   DW_AT_declaration : 1
 <1><5c4>: Abbrev Number: 6 (DW_TAG_pointer_type)
    <5c5>   DW_AT_byte_size   : 8
    <5c6>   DW_AT_type        : <0x5b2>

It appears to duplicate that information for every object file. What's
interesting is it is only defined as a structure once. Perhaps this is all we
need to output to the dwarf information, set DW_AT_declaration to 1 to say we
aren't defining the value here, you'll have to find it elsewhere. That's very
reasonable for me to output in generated code I feel like. Cool. Let's try
that.

Maybe leave out the file, line and column where FbleValue typedef is declared.
Maybe I can leave out the typedef as well? Just something like:
    
<1><5be>: Abbrev Number: 11 (DW_TAG_structure_type)
    <5bf>   DW_AT_name        : (indirect string, offset: 0x3bd): FbleValue
    <5c3>   DW_AT_declaration : 1
 <1><5c4>: Abbrev Number: 6 (DW_TAG_pointer_type)
    <5c5>   DW_AT_byte_size   : 8
    <5c6>   DW_AT_type        : <0x5b2>

We reference the type using an offset from the first byte of the compilation
unit, or a raw address.

This works. It shows it as (struct FbleValue*) instead of (FbleValue*), which
is not surprising, but it is also able to dereference the tag, which is cool.

---

Is it at all feasible to imagine a world where we can have an fble-level type
description for gdb, so it can do member access and all that stuff? Let's look
at struct to start. First question: how to access an unpacked type.

To access field i from object x:
  *(x + 16 + i*8)

That should be easy. Because we pass a location as a function from base offset
'x' to target offset.

Second question: how to access a packed type? That's harder, because I'm not
sure there is any way to tell gdb how many bits the field takes up when the
number of bits depends on the runtime value. Or maybe we say all the bits? It
might just be possible if we can say all the bits not here.

So, a few different ideas:
* Have a function we can call to unpack the value, the debugger could then
  print the unpacked value.
* Have a runtime flag we can set (via debugger perhaps) to disable packing on
  all values, then debugging works fine on the unpacked values.
* Double check dwarf spec to see how it handles bitfields and whether we could
  support packed and unpacked values in a single type entry. I'm... skeptical.
  If it's doable, it sounds like it would be pretty gnarly.

