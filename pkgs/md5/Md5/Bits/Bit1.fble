
@ Bool@ = /Core/Bool%.Bool@;
% True = /Core/Bool%.True;
% False = /Core/Bool%.False;

@ Bit@ = /Core/Digits%.Bit@;
<@>@ Bits@ = /Md5/Bits/Bits%.Bits@;
<@>@ Overflow@ = /Md5/Bits/Bits%.Overflow@;

Bit@ 0 = /Core/Digits%.Bit.0;
Bit@ 1 = /Core/Digits%.Bit.1;

@ Bit1@ = Bit@;

(Bit1@) { Bit1@; } not = (Bit1@ a) {
  a.?(0: 1, 1: 0);
};

(Bit1@, Bit1@) { Bit1@; } and = (Bit1@ a, Bit1@ b) {
  a.?(0: a, 1: b);
};

(Bit1@, Bit1@) { Bit1@; } or = (Bit1@ a, Bit1@ b) {
  a.?(0: b, 1: a);
};

(Bit1@, Bit1@) { Bit1@; } xor = (Bit1@ a, Bit1@ b) {
  a.?(0: b, 1: not(b));
};

(Bit1@, Bit1@, Bit1@) { Overflow@<Bit1@>; }
add_overflow = (Bit1@ a, Bit1@ b, Bit1@ c) {
  Bit1@ x = xor(a, b);
  Overflow@<Bit1@>(xor(x, c), x.?(0: a, 1: c));
};

(Bit1@, Bit1@) { Bit1@; } add = (Bit1@ a, Bit1@ b) {
  add_overflow(a, b, 0).x;
};

(Bit1@) { Overflow@<Bit1@>; } inc_overflow = (Bit1@ a) {
  Overflow@<Bit1@>(not(a), a);
};

(Bit1@) { Bit1@; } inc = (Bit1@ a) {
  inc_overflow(a).x;
};

(Bit1@) { Bool@; } iszero = (Bit1@ a) {
  a.?(0: True, 1: False);
};

(Bit1@, Bit1@) { Bool@; } eq = (Bit1@ a, Bit1@ b) {
  a.?(0: b.?(0: True,  1: False),
      1: b.?(0: False, 1: True));
};

(Bit1@) { Bit1@; } msb = (Bit1@ a) {
  a;
};

(Bit1@, Bit1@) { Overflow@<Bit1@>; } lshift_overflow = (Bit1@ a, Bit@ cin) {
  Overflow@<Bit1@>(cin, a);
};

Bits@<Bit1@> Bits = @(
  not, and, or, xor,
  add, inc,
  0, iszero, eq,
  msb,
  add_overflow, inc_overflow, lshift_overflow
);

@(Bit1@, Bits);
