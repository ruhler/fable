

@ Bool@ = /Core/Bool%.Bool@;
% True = /Core/Bool%.True;

<@>% List = /Core/List%.List;
<@>% Nil = /Core/List%.Nil;

<<@>@>@ Main@ = /Core/Stdio%.Main@;

<@>@ Pure@ = /Core/Stdio/Pure%.Pure@;
<@>@ PureResult@ = /Core/Stdio/Pure%.PureResult@;
@ PureState@ = /Core/Stdio/Pure%.PureState@;
% Monad = /Core/Stdio/Pure%.Monad;
% Stdio = /Core/Stdio/Pure%.Stdio;
<@>% Run = /Core/Stdio/Pure%.Run;
<@>% PureResultEq = /Core/Stdio/Pure/Eq%.PureResultEq;
<@>% PureResultShow = /Core/Stdio/Pure/Show%.PureResultShow;

@ String@ = /Core/String%.String@;
% Strs = /Core/String%.Strs;

@ Test@ = /Core/Test%.Test@;
<@>% AssertEquals = /Core/Test%.AssertEquals;

@ Unit@ = /Core/Unit%.Unit@;

(String@, Main@, String@, String@) { Test@; }
Test = (String@ name, Main@ game, String@ n, String@ expected) {
  /Core/Test%.Test(name, (Unit@ _) {
    PureResult@<Bool@> want = PureResult@<Bool@>(
      PureState@(Nil<String@>, List<String@>[expected], Nil<String@>), True);

    PureResult@<Bool@> got = Run(
      game<Pure@>(Monad, Stdio, List<String@>[n]),
      Nil<String@>);

    # Flatten the output, because we only care about the final results, not
    # how it's split into different calls to Stdio.out.
    PureResult@<Bool@> merged = PureResult@<Bool@>(
      PureState@(got.state.in, List<String@>[Strs(got.state.out)], got.state.err),
      got.result);

    AssertEquals(
      PureResultEq(/Core/Bool/Eq%.Eq),
      PureResultShow(/Core/Bool/Show%.Show),
      want, merged);
  });
};

@(Test);
