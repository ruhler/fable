Fble Release 0.1
================
It seems like we have made enough progress on fble to consider trying to make
a release of it.

Goals:
* Put fble in releasable form.
* Gain experience trying to use fble in a released form, in particular around
  version control of various components of fble.
* Clean up separation of things that are better separated.
* Revisit APIs between components, clean up, and document.

When I say release, I'm thinking some tarballs that someone could download
from a website and install on their own computer in traditional fashion.

Implications:
* There is not one fixed environment that we can assume. We need to be more
  flexible.
* Things that don't belong together should be split up. For example, fble
  language spec doesn't belong together with a draft pinball game.
* Separate pieces will want separate build systems.
* Separate pieces will want separate test suites.

Brainstorm of components to release:
* Language specification, spec tests, tutorials, style guide, syntax file.
* fble reference implementation: libfble.
* fble packages, each separate.
  - Libraries: Core, Stdio, App, Map, 
  - Apps: GameOfLife, Invaders, Md5, Primes, Sat, Snake, Sudoku, TicTacToe

I think the biggest challenges are going to be around the interfaces between
these components:
* How to decouple native interface from reference implementation?
* How to build an app against a set of 'installed' fble packages?
 - Given that a package could include native code as well as fble code.

---

If we assume the libfble interface is fixed, it's not too hard to think about
packages. We can do interpreted or compiled code, mixed together, by
generating an elf file with the executable code to run using the standard
calling convention for an fble module.

A package is a collection of modules that we can compile all together into a
single elf file. The package dependency graph is an abstraction of the module
dependency graph. The module dependency graph is still useful, primary for
limiting what module code gets run at runtime. The package dependency graph is
useful for limiting what packages need to be available at compile time.

Conceptually we want to be able to compile a module in the presence of other
packages, listed explicitly. Then from the compiler point of view a package
needs to list for each module path in the package, the type of the module.
That should be enough info for the compiler. We can think about embedding the
type of a module in the elf file for the package so all you have to do is pass
around the library file.

There is a question of user documentation versus module interface. The
compiler wants to know the raw type of a module. The user wants to have
abstractions for types, like a module hierarchy, and comments in code. Which
is slightly different from the full source code, where ideally the user
doesn't get to see the implementation, just the type. That's an open question
that perhaps doesn't matter too much conceptually. Bottom line is, the
compiler needs a way to know what the modules and their types are in a
package.
 
If we allow different incompatible implementations of libfble, then that's
going to be harder. Unless a package is compiled for a particular
implementation of fble and you combine things that way. I'm not sure if it's
worth trying to standardize the native interface for all implementations,
focus on just libfble for the time being, try to make an alternative
implementation to see what the issues are in practice, or something else.

I suppose either the different implementations of libfble can be intermixed,
in which case there is a standard interface we can use for linking, or they
can't be intermixed, in which case we have to generate separate elf files per
implementation anyway, so we can use the specific implementation interface for
linking.

In short, I'm suggesting we package fble packages as elf files containing the
code for all the modules in the package and supplementary information
describing the types of modules in the package, assuming that's a convenient
format for the compile to consume.

Then the fble compile command should take a list of include packages when
compiling a module, and we should organize modules into packages using a
separate directory for each package. One question: should the package
directory be part of the module path or not? Why not? Otherwise we risk having
multiple packages defining the same module name, which is no good. It will be
slightly inconvenient in the sense of having longer module paths. There's also
the question of whether package versions should be in the module path. I feel
like users should be able to set up their own redirects: any time you use
package "/foo/...", rename it to, for example, "/foo-3.4.1/...". That's at
compile time.

---

Another big consideration for release is that different people have different
goals in how they interact with building, testing, and installing:
* developers probably want/ought to build and test as much as they can.
* users may only want to build and install the bits they care about,
  especially if it means they can avoid installing dependencies they otherwise
  don't want to.

How can we organize it so that users can easily specify what dependencies they
have where? Some kind of configure script, right?

I see 4 classes of things that a user may want to build:
1. Everything, including things not necessarily buildable on a single computer.
   This would be for developers testing their changes to break anything.
   Including compilation to other architectures.
2. Everything that can be done on a single computer. This would also be for
   developers testing their changes don't break things, but with the more
   realistic restriction that you can, in theory, do everything on one
   computer.
3. Some subset of things. For those who don't want to install dependencies for
   bits they don't care about. This would be configure time options. Assume
   you still want to run all possible tests.
4. Install. For those who don't want to run all the tests, for example. Or
   don't want to build everything even if all the dependencies are satisfied.

The difference between (1) and (2) is perhaps academic at this point. The
difference between (3) and (4) doesn't seem worth worrying about: just build
and test everything you can, it doesn't take that long.

That suggests the first focus should be on a mechanism to support (3), aka a
configure script.

How I can test in an automated fashion that the configure script works is
beyond me.

Another approach for optional dependencies is to pull them out into different
packages. In other words, we say no individual package has any optional
dependencies. It's up to the user to decide which packages they want to
download and install. This seems a bit inflexible to me.

Let's start down the configure route. Follow up in
thoughts/fble.configure.txt.

---

Now we have support for compiling to C code as well as aarch64, I want to
revisit the idea of a release again. There are lots of things to work out in a
release. Here's a brainstorm of things to think about.

* Configuration: what are we installing where.
 - Currently the only dependency I think we want to make optional is libsdl.
 - We may want to make it optional to install or not install certain fble
   library packages.
* Version numbering systems.
 - Release implies compatibility guarantees. What should those be?
 - Do we version all the components separately, or all under one number?
 - Components are: language spec (and spec tests), libfble, each separate fble
   library package.
* Post-install build/search path
 - After installing, how will users build fble programs?
 - Is there a standard search path we use, or it's up to users to specify
   that?
 - Do we do something with pkg-config to find installed fble packages?
 - Do we share any of the build.tcl infrastructure to help build fble
   packages?
* libfble interface cleanup
 - Clean up odds and ends in the libfble API.
 - In particular, create a cleaner interface between libfble and compiled fble
   code.
 - Think about potentially upcoming changes for packing values based on known
   types.
* Modular/compiled fble package release
 - Do we have to release fble programs as source?
 - Should we add support for releasing an fble package entirely as a .so file?
 - Should we add support for .fble.@ header files?
* Documentation
 - Clean up existing documentation. Make sure it's up to date.
 - Add getting started / tutorial guides.
 - Add man pages.
* TODOs
 - How much of the existing TODOs do I want to tackle before making the
   release? It's not feasible to do them all.
* Fble libraries
 - I suggest not worrying about having clean APIs for .fble libraries for the
   first release. That's too big a scope. Focus on language specification and
   reference implementation (interpreter/compiler) for the first release.
 - But do I want to change Stdio@ to use a File@ interface? Perhaps to avoid
   need for gnu getline?
 
That's a pretty good summary list of things to tackle. Shall we go one by one?

---

Version numbering systems

The goal of version numbering is to communicate compatibility. The language
itself is independent of reference implementation and libraries. In theory it
could be versioned separately. I think three components: A.B.C
C - No change to language spec, but could be improvements in spec tests or
    description of the language.
B - Backwards compatible changes to the language spec. Existing programs
    should continue to work, but adds some new features that won't work on
    older implementations
A - Incompatible changes to the language spec. Old programs will no longer
    work.

Next is the reference implementation. In theory there could be multiple
implementations for a given language version. Any A or B change to the
language spec will require a new libfble to support that change. Other changes
you could make without a change to the language spec, let's call them: D.E.F
F - No change to interface. Maybe cleanup, bug fixes, performance
    improvements.
E - Backwards compatible change to API. Old programs should still work. New
    ones may take advantage of features not supported on older releases.
D - Incompatible change to API.

There is the question whether we are talking about source level compatibility
or binary compatibility at this point.

If we include language spec version in libfble version, we get a version
string like: A.B.D.E.F. That's a bit ridiculous.

Next is per fble package version numbers. Again we have a triple for bug
fixes, backwards compatible changes, or incompatible changes. These will
depend on language version certain, and also possibly libfble version for any
use of those APIs. A.B.D.E.G.H.I?

Is there a single versioning scheme that makes sense to bundle together all
these components under a single version number? Maybe an: A.B.C.D, for
A: incompatible language change.
B: incompatible libfble change.
C: incompatible library package change.
D: internal/compatible change.

We could consider a backwards compatible language change as an incompatible
libfble change? And consider a backwards compatible libfble change as a
library incompatible change?

Honestly, my expectation to begin is that we change the language hopefully
fairly rarely. We change the libfble API a little less rarely. In practice we
are pretty likely to change the fble library. The goal of having a versioning
number, besides uniquely identifying a release, is to say something like, if
my code works on X.Y, then it also works on X.Z for all Z > Y. I suspect
pretty much all code would be written against the fble library to start, in
which case, in practice, nothing will be compatible release to release early
on. In that case, why bother? How about let's just have 0.1, 0.2, ... where
'0' means too early in the project lifecycle to have any compatibility
guarantees, and 1, 2, ... identify unique releases ordered in time. We can
target a major release bump to 1.* when things are stable enough that we can
have a useful breakdown after that where releases are less likely to break
things.

Another point to make:

Ideally libfble works with any of the previous language versions. For example,
you could put it in language 1.* mode, language 2.* mode, etc. and it would,
restrict the language settings to match that given mode. That way, in a sense,
libfble is independent of language version. Version X of libfble supports all
language versions Y that were released up until the date when libfble X is
released. The main goal, I think, would be to be able to write older language
compatible programs where libfble enforces that you aren't relying on any
newer language features.

I don't want to start versioning fble libraries yet. I don't want to have to
worry about compatible changes. They are too early for that. Long term,
ideally each different library package has its own version and release
cadence. They each target their preferred language version. They work with any
libfble with required libfble API and supported language version.

So, in summary, for now just stick with version 0.1, 0.2, ... Later on, plan
to have more flexibility in versioning support. The first release is like a
preview release. The goal is to let people try it easily. Not to promise there
won't be breaking changes.

---

What do we install where? And how to we build against that?

$bindir
  fble-test
  fble-compile
  fble-md5
  fble-stdio
  fble-invaders
  ...

$includedir:
  fble-alloc.h
  fble-arg-parse.h
  ...

$libdir:
  libfble.a
  libfble-md5.a
  ...

man pages, etc. All of this is straight forward.

The real question is: where do we install the .fble files? Maybe datarootdir,
which is /usr/local/share, for example? So:
 /usr/local/share/fble/core/Core/...
 /usr/local/share/fble/md5/Md5/...

It would be a pain to have to manually add -I options for each of these
directories, on the one hand. On the other hand, maybe that's the whole point:
to specify explicitly everything you depend on. It's kind of like how I need
to add a -I option to compile against libsdl. In that case, I think that's
fine. -I /usr/share/fble/md5 is reasonable.
  
That's all fairly straight forward. The more interesting question is about
configure. I think I should have a configure script. I think it should give
options for standard include directory settings. I think it should work as in
thoughts/fble.configure.txt. I think we should have an option to enable or
disable any of the fble library packages.

---

Post-install build/search path

As above, I think no need to specify a default search path. We don't really
have a standard library yet.

Should we use pkg-config? That gave me trouble in the past I feel like,
because it doesn't support a separate language very easily. I think fine to
use it for c parts of the packages, but not the include paths for the fble
parts of the packages.

Should we expose parts of build.tcl? I don't want to enforce any sort of build
system on users, much less a funny one like build.tcl. My vote is not to
supply any build scripts for the initial release. Just make it clear to users
how they can do things their own way.

---

Review of steps to release:
* Generate man pages for library functions via fbld.
* Remove doxygen.
* Burn down TODOs.
* Make SDL dependency optional.
* Figure out how to make a release tarball.

Things not to worry about this release:
* Fbld cleanup.
* libfble API cleanup or tutorials.
* Packed data types.
* Module header file support.
* Or really any big thing.

---

Let's jump right to the heart of what we need for release. Everything else is
just cleanup/polish:

How to generate a release tarball.

First place to look: standard make targets for this?
* distclean - clean up everything include stuff generated by configure.
* maintainer-clean
 Deletes more than distclean. Including source files produced by Bison, info
 files, and so on. That suggests we should include the bison-generated source
 as part of the release tarball?
* Info files should be present in the source directory, make should update
  them in the source directory.
* dist - Create a distribution tar file for the program.

   The easiest way to do this is to create a subdirectory appropriately
   named, use ln or cp to install the proper files in it, and then tar that
   subdirectory.

   Compress the tar file with gzip. For example, the actual distribution file
   for GCC version 1.40 is called gcc-1.40.tar.gz. It is ok to support other
   free compression formats as well.

   The dist target should explicitly depend on all non-source files that are
   in the distribution, to make sure they are up to date in the distribution.
   See [15]Making Releases in GNU Coding Standards.

Making Releases Documentation:
* Need a major and minor version number. Let's say "0" and "1" for example.
* fable-0.1.tar.gz should unpack to fable-0.1
* Can include source and non-source files.
  - non-source files must be up to date with the source and machine
  independent. Including outputs of Bison to reduce dependencies.
  - Don't include non-source files that would be modified by building and
    installing the program.
* All files world readable (755), directories world writeable (777).

Anything ninja supports?
* Not that I see.

So, conceptually, it's clear. We want a build target that knows how to package
everything up. 

The question is what non-source files we want to include in the distribution
and where/how that all works out.

Let's go by dependency:
  expect - can be skipped without running check target.
  binutils - needed at build time (architecture specific).
  bison - can generate the parser c file at distribution time.
  gcc - needed at build time.
  gdb - only for tests.
  diffutils, grep - for tests.
  groff-base - can be done at distribution time.
  source-highlight - could be done at distribution time.
  ninja-build - needed at runtime.
  libgl-dev, libsdl2-dev - needed at runtime, can be skipped.
  tcl8.6 - needed for configure.

So, let's review the non-source files we may want to include in the dist:
* Docs, including man pages and www.
* parse.tab.c
* *.usage.h files.

That's pretty straight forward.

What mechanism to use for this, given that source directory is different from
build directory?

The suggestion from the gnu docs is to generate and use those from the source
directory. Add a 'maintainer-clean' option to remove those files.

Note: we don't want to include .git/ metadata in the release tarball.

I suggest the following:
* Update those 'dist-non-source' files to be built in $::s instead of $::b.
* Add 'clean', 'dist-clean', and 'maintainer-clean' targets.
  clean: cleans up non-config generated files.
  distclean: clean + remove config.tcl and build.ninja.
  maintainer-clean: distclean + remove dist-non-source files.
* Add a dist target that copies all source and dist-non-source files into a
  build subdirectory and packages up a tarball for it.
* Clearly document in README which dependencies are needed for which things.
* Add a TAGS file to dist-non-source.
* Add .gitignore for dist-non-source files.

That all sounds straight forward, but I fear the build.tcl files aren't
organized in a way currently to make this easily modular and correct. Some
better cleanup and structure to those will help.

Hey, this means we can add a TAGS file as part of dist-non-source. That would
be convenient. 

---

How to organize build files:
* source files: files checked into git.
* install: files installed into the install directory.
* dist-non-source: generated files included in release tarball.
   - Anything generated, not installed, that doesn't depend on the
     architecture.
* build-non-source: generated files not included in release tarball.
   - Anything generated that does depend on the architecture.

Categories of non-source files:
* dist: things for the dist tarball
* www: things for the generated www
* test: things needed for test

Build targets:
* all: all non-source files needed for install.
  This is the default.
* install: all install files.
* dist: makes the release tarball
* www: makes the website.
* test: makes the tests.
* cov: generated code coverage output.
* check: everything except install, includes all, test, dist, www, cov.
* clean/distclean/maintainer-clean, depending on what ninja supports.
  To clean appropriate pieces.

Each build.tcl file should identify it's:
* source files: need to be copied to dist.
* dist-non-source
* install targets
* install sources: what gets made by all.
* tests.
* www.

Build files to have:
build.tcl - top level, includes sub-build files.
  include
  lib
  bin
  fbld
  test
  spec
  tutorials
  www
  pkgs/*

Some questions around:
* Should we have a separate www directory? Who generates the www?
  For example, tutorials go to www. Who should be responsible for saying that?
  I think treat www similar to install. Separate build.tcl files mark things
  as www. Either the www/build.tcl file defines the top level and tcl procs to
  help with that, or just move that to the top level build.tcl file.
* spec tests rules separate from test directory?
  I think, don't worry too much about it. Whatever is easiest. Fine to keep
  things organized as is, but we will want to add a spec/build.tcl file.

I would like to separate the top level build.tcl build target parts from the
build infrastructure/library. But that's not too important. We can always do
it later however feels right. I think do try to move helper functions into sub
build.tcl files where it makes sense, such as fbleobj.

In terms of implementing targets, let's have procs to identify things as
follows:
* dist - anything to include in the release tarball, including source and
  dist-non-source.
* install - marks the source of the thing to install.
* www - anything for generated www.
* test - tests.

That should be enough for the targets:
* all: any install source
* install: any install target
* dist: any dist
* test: tests.
* www: www.
* check: all, dist, test, www

To implement 'clean', I guess we could have:
  clean: clean all
  distclean: clean -g all 
  maintainer-clean: clean -g

Assuming I figure out how to mark the generator rule so config doesn't have to
be re-run.

In general, I think it's fine to have higher level abstractions responsible
for calling test, install, dist, etc. As long as its clear you would always
want to do that. To reduce clutter.

That's the high level vision. Let's see if we can get there little by little.

I feel like having a separate build/ directory with the build library, and
maybe a readme file would help with clarity and cleanliness. Not sure. Maybe
we just need to document build.tcl very clearly. Yeah. Let's document
build.tcl very clearly, from the top. And then work at a single build.tcl file
at a time with cleanup until we end up with the above proposed structure.

For out directory, have:
* Something corresponding to each build.tcl directory.
* dist/fble-0.1/...
  dist/fble-0.1.tar.gz
* www/...

And add a $::d directory for dist-non-source files. Which will be set to the
same as $::s, but gives us more flexibility/documentation over what is what.

---

Top level build directory:
bin/ book/ fbld/ include/ lib/ pkgs/ spec/ test/ thoughts/ tutorials/ vim/ www/
build.tcl configure deps.tcl README.fbld TODO.txt

Listing all the files explicitly, like thoughts/*, is going to be tedious I
fear. And error prone. Hmm...

---

How to clean up organization of test target?

::tests
proc tests
proc testsuite
phony test
directory test/

Tests depend on the contents of the test/ directory. So we could define it
there. But I want all phony targets in build.tcl, which suggests we define it
there.

Or maybe we have tests/detail.tr and tests/summary.tr, all described in the
test/ directory, and put the phony in the top level build?

Again, the reason to do this is to hopefully simplify the top level build.tcl
file. I guess it's a question about our assumptions of what's defined where.
Before it was:

* Shared things go into build.tcl
 - Except things like app, stdio, etc.

This is suggesting:
* Shared things go where their dependencies are built.

It's a question about who assumes what is built where.

It would at least be nice for all the phony targets to be defined in the top
level build.tcl, so it's clear what the different targets are. How about... I
don't know.

Maybe let's skip that and clean up www first.

1. Add helper functions for building fbld files.
2. Move stuff out of www/build.tcl 
  - Each subdirectory is responsible for its own part of www
  - top level build.tcl is responsible for putting it all together.

---

For www, do I want to generate directly into 'www', or do I want to generate
into the current directory and copy to www?

Seems like a waste to make copies. So I guess we go straight to www. And have
a proc www to mark something as www? If we want, we could define a $www var to
say where www is.

Or... make www part of ::html_*?

---

Clean up of globs?

Uses:
* [glob $::s/bin/*.c]
* [glob $::s/include/fble/*.h]
* [glob $::s/tutorials/*.fbld]
* [glob $::s/test/fble-*.c]
* [glob -tails -directory $::s/pkgs/$name -nocomplain -type f $dir/*.fble]
* [glob -tails -directory $root -nocomplain -type d $dir*]
* [glob -tails -directory $::s/lib *.c]
* [glob -tails -directory $::s/spec -nocomplain -type f $dir/*.fble]

So, two use cases. Maybe I can shift them into one. I want to be able to
extract the directory. Something like:

build_glob { dir args } {
}

Cool. That sounds good.

---

Okay. I think the initial cleanup of build.tcl is done. Next step is to
prepare for the 'dist' target.

We want to include two things in dist. source and non-source dist. So...

Either two separate procs:
  dist_src
  dist_non_src

Or one:
  dist

Why distinguish between them?

I remember. We need to figure out what directory they belong to. If we have
dist_src, we can imply relative to the source directory.

So, how about: dist_s, dist_d, and use $::d for generated source directory.

For example, to mark $::s/README.fbld as source, use:

dist_s README.fbld

The behavior will be to copy $::s/$target to $::b/fble-0.1/$target for the
'dist' command.

How do I feel about building dist_d in the source directory? It has to be that
way. It's the only way it can work when using a dist. But can ninja deal with
it properly? Something about timestamps matters? It should be okay I think, as
long as we preserve timestamps in the tar file. If we the tar file gets
extracted out of order, then it could be more troublesome.

---

Adding dist_s to dirs. Still need:
* spec, test, tutorials, pkgs

Should I move spec tests to the spec/ directory?

Also, I'm concerned that using build_glob to identify dist_s could accidentally
capture untracked files and non-source dist files. And it's annoying to strip
the $::s/ prefix off of things when passing to dist_s. It really feels like
there's some improvements I could make to the api for specifying these things.

---

How to have a single source of truth for the version?

Let's put it into configure.

We use version for:
* release tarball file name. e.g. fble-0.1-dev.tar.gz
* fble-version.h

Any desire to:
* Separate into MAJOR, MINOR, and OTHER fields?
* Add a git sha? Or `git describe --always --dirty`?

Separating into major/minor might be useful in the future for supporting
certain kinds of backwards compatibility things or working around bugs?

I think it would be good to have

FBLE_VERSION_MAJOR 0
FBLE_VERSION_MINOR 1
FBLE_VERSION

Kind of thing.

But let's explore some other projects to see how they deal with version
numbers. Particularly for intermediate git checkins, and possibly even local
dirty modifications to the git repo.

If we put the version in configure, then we should have a rule to generate
fble-version.h?

---

Some thoughts:
* Instead of having 0.1-dev mean we haven't reached 0.1 yet, we should have
  0.1-dev mean we have just passed 0.1.
 - If we use git commit, we wouldn't know next number. So that would let us be
   consistent with whatever approach we use with git commits.
 - Read it as: 0.1-dev has whatever 0.1 has and then some.
* There's no way to ensure someone hasn't modified the release number.
* Hard code major/minor/dev status in fble-version.h.
* For git hash, make that part of the build id rather than version.
 - We could have user, git sha, dirty status, date, hostname, etc.
* We can add git tags to map release number to git commit.
 - And have a commit where we change release number/status that we can link
   to.
* To have an up-to-date build id, see if we can generate it when you link an
  executable. That way it should always be up to date without forcing
  unnecessary rebuilds.

Proposal:
* fble-version.h defines FBLE_VERSION_MAJOR, FBLE_VERSION_MINOR, and
  FBLE_VERSION.
* We have a build category that's part of the version. Say:
  r for release, rc for release candidate (if needed), d for dev.
* Add a build info string somewhere, ideally generated whenever we link an
  executable. That string includes git describe output and maybe other things.

Let's do a survey of some other approaches.

I'm not seeing anything terribly exciting. We have:
* major/minor version numbers as part of release.
* some have a 'patch' number.
* some have pre-release identifiers, like alpha, beta, rc
  for example 0.1-rc means the release candidate for 0.1. The final release
  has 0.1. So in general, 0.1-* comes before 0.1 in time.
* We can include whatever build metadata we want. For example:
  0.1+f17f983e, where the last part is the git sha.

Let's think about what version info is meaningful for what purposes.
* major/minor version corresponds to what's released to, e.g. github.
Incremented manually on release.
* If we don't post alpha, beta, release candidate packages, then no need to
  make that distinction.
* If we have continuous integration that generates releases, we could have a
  number associated with that. Number nicer than sha because then you can see
  right away which build is older. You can only have an incrementing number if
  you have something like a CI job to coordinate the version.
* Having a git sha is useless unless you have access somehow to the commit. If
  someone builds something locally and shares the resulting build without
  sharing their local commits, that information is useless.
  Also, we may not have git metadata if building from a release, unless we
  explicitly put the git tag in the release.

Let's imagine there is a wall between development and releases. What comes out
on the release side is exactly major/minor version.

What we have on the development side is:
* major/minor version, reflecting what's seen on the outside.
* rc candidacy. So the only thing we have to do is drop the rc candidacy part
  once the release is in good shape, and not, for example, increment the
  version number. Optional in my case I think.

Separate from that is a build stamp:
* user, host, date, git sha?

Interesting. How about we consider three scenarios:

1. Making an official release. specify major/minor once everything looks
ready. This is easy.

2. A user making a build from an official release.
No git info is available. Maybe the user changed something, who knows.
The major/minor version number corresponds to the official release
major/minor.

3. A developer doing incremental builds.
It would be nice to have build stamp with user, host, date, git sha, etc.
The major/minor version number corresponds to the previously released
major/minor version number (?). But we note that it is a 'dev' build.

Wait. I like thinking of a dev build as a pre-release build.

0.1-dev means a development build working on development of release 0.1.

When you generate a release tarball, you may not know if it's going to work or
not. That's when it makes sense to switch to rc0, rc1, etc.

Strawman proposal:
* major/minor version.
* lifecycle status:
  dev - general development that will go into the major/minor release.
  rc<N> - actively trying to get a release out for major/minor version.
  rel - the final release candidate officially released.
* build metadata:
  user, hostname, date, git describe (only if available)

How/when we set these things:
* major/minor version is specified in the source code.
  The first commit after a release does nothing but bump the version number.
  If it turns out the change is bigger than expected, we can bump a major
  version number sometime during development.
* lifecycle is always 'dev' in the git branch.
  You manually specify rc<N> or rel when launching an official release build.
  The official release build copies the lifecycle into the release tarball.
* build metadata is computed and injected at link time for individual
  binaries, using an approach that supports incremental build.
  
Question: do we need rc<N>, or can we just use dev?
I guess rc<N> is to avoid having multiple fble-0.1d.tar.gz files that mean
different things.

What's the tarball naming strategy? Let's try a few:

fble-0.1.tar.gz (official release?)
fble-0.1r.tar.gz
fble-0.1-rc0.tar.gz (release candidate)

Yeah, let's go with that:
* official release: fble-<major>.<minor>.tar.gz
* release candidate: fble-<major>.<minor>-rc<N>.tar.gz

What's the version string look like?
 0.1
 0.1-rc0
 0.1-dev

What can we access from C code?
 MAJOR
 MINOR

What does the build metadata look like?

 0.1+user=richard,host=losaltos,date=2023-02-17T20:18:09-08:00,git=f17f983e-dirty

Use:
* for date: date -Is
* for user: whoami, or $USER
* for hostname: hostname or $HOSTNAME
* for git: git describe --always --dirty

Other's to try:
 0.1+user=richard,host=losaltos,date=2023-02-17T20:18:09-08:00,git=f17f983e-dirty
 0.1-rc0+ruhler@losaltos,2023-02-17T20:18:09-08:00,f17f983e-dirty
 0.1-rc0+ruhler,2023-02-17T20:18:09-08:00,f17f983e-dirty
 0.1-rc0+ruhler@2023-02-17T20:18:09-08:00,f17f983e-dirty
 0.1-rc0+2023-02-17T20:18:09-08:00,ruhler,f17f983e-dirty
 0.1-rc0+2023-02-17,ruhler,f17f983e-dirty
 0.1-rc0+ruhler-2023-02-17-f17f983e-dirty

Maybe we can arrange for builds done on github to have the username 'github'.

Yeah. I like that.

 major.minor-prerelease-user-date-git

No real need for hostname given it's unlikely you'll be copying around built
libraries between hosts. The username is mostly to know if you built it or
not. Well... I guess in this case you will always have built it. So should we
get rid of the username in the build?

 0.1-rc0+2023-02-17-f17f983e-dirty

Once we start building binaries to be distributed, we can include names in the
buildstamp with more details. Yeah. I like that.

Next question: can I sneak this string in somehow using the linker? Like, is
there an option to overwrite a string value using linker command line
arguments, or specify a region of memory?

--build-id can be used to inject a hex string in .note.gnu.build-id?
--insert-timestamp suggests there's already a timestamp in there by default?

Those are the only two I see. How could we fetch those from code?

Maybe --defsym to define a symbol that points to .note.gnu.build-id?

Could we do it by writing a .o file that refers to the .note.gnu.build-id? For
example:

.note.gnu.build-id:
  
Or, how about, in the same build step as linking, compile an object file and
link that?

Or, define a rule to build the build metadata .o file. The dependencies are
the same as the dependencies for ld, but we also have ld depend on the .o
file?

Like:
  link objs
    metadata.o: objs
      cmd = <generate metadata.o>
    ld objs metadata.o
      
That doesn't sound too bad. Don't need any crazy linker magic. Just some build
helper functions. We can use this for bin files.

Where ever we define a main program, we can refer to some extern const char*

Or, make use of preprocessor?

gcc -DMETADATA=... $objs metadata.c

where metadata.c is defined as:
  const char* metadata = METADATA;

That sounds like the most straight-forward approach to me. Maybe we could
avoid the .c file and write it directly?

echo const char* metadata = ... | gcc ... -

It totally works. Just need to add '-x c' before -, to tell it the right file
type. I can totally add this today.

Maybe best would be to write a script to generate metadata. Then we can do:

./metadata | gcc ... -x c -

What should I call this metadata program, string name, and where should the
script live?

BUILDSTAMP 
buildinfo
BUILDINFO
BuildInfo

_buildinfo.
_buildstamp
buildstamp_

BUILDINFO
BUILD_INFO.
main_build_info.

I prefer 'stamp' to 'info', because it's not that structured.

I guess we could define a structure if we wanted to though, with build-info.h.

This would be great to put in a build/ directory.

Let's keep things simple.

extern const char* BUILDSTAMP;

./buildstamp | gcc ... -x c -

Easy.

Or, perhaps:

tclsh8.6 buildstamp.tcl | gcc ... -x c -

No. I prefer ./buildstamp | gcc ... -x c -

And we can just put it at the top level and implement using shell or tcl
script internally as we see fit.

Yeah. This is going to work great for build stamps.

---

Next: how to specify lifecycle and make use of that officially? And how to
specify major/minor with a single source of truth?

FBLE_VERSION_MAJOR = 0
FBLE_VERSION_MINOR = 1
FBLE_VERSION_PRERELEASE = "" or "dev" or "rc<N>"
FBLE_VERSION = "MAJOR.MINOR-PRERELEASE"

I want to define these in configure. With a command line option to override
the value for prerelease. Let's pass them to fble-version.h. Maybe let's have
fble-version.h be auto-generated by configure?

Or, perhaps we have fble-version.h define extern instead of defines. And have
fble-version.c automatically generated?

Probably best to have fble-version.h automatically defined. That would make it
dist-non-source.

---

After some thought:
* Skip the concept of prelease. We can tell from the buildstamp if something
  was built from git, in which case it is a 'dev' build, or if built from
  a source tarball, in which case it is a release build. Optionally add 'dev-'
  to the git tag.
* We can define major/minor either in fble-version.h, or in build.tcl, or
  where-ever. It doesn't have to be in a fixed place. Start with it in
  fble-version.h. Move it if needed. We could also read it in build.tcl from
  fble-version.h if we wanted to.
* Places where version could be useful in build eventually:
  - generated readme files.
  - generated documentation.
  - .tar.gz filename.
* We don't have to include the version number in fble.tar.gz. That's an nice
  way to make clear what's official or not. Unofficial: 'fble.tar.gz'.
  Official requires manually renaming.
* In fble-version.h, use #define for version number so that users can do
  compile-time switches if they want or need to.

So, here's the new proposal:
* For now, MAJOR, MINOR defined in fble-version.h
* Generate fble.tar.gz always.

Oh, wait. We need the version number in dist so it extracts the right way.
Hmm...

So, here's the new proposal:
* fble-version.h defines FBLE_VERSION_MAJOR, FBLE_VERSION_MINOR, and
  FBLE_VERSION. Where FBLE_VERSION is a string of the form "fble-0.1".
* build.tcl reads FBLE_VERSION from fble-version.h.
* Generate tarball based on read fble version.
* Remove 'dev' from the version name.
* Add 'dev' somewhere to buildstamp when git is present.

Release process will be:
* fble-version.h defines the version we are about to release.
* generate an official tarball via github (or whatever).
* if there are problems with the generated tarball, either github should see
  that and fail when requesting it to build, or we submit some fixes and try
  again until it succeeds.
* Manually upload the tarball to github.
* Add a tag for the actual git commit used for the final release.
* Update the minor version number as the first commit after the final release
  CL.
* If at any point in time it feels like we should bump the major version
  number, do so and reset the minor version number.

Easy. No?

---

Next step: revisit the dist api. Get everything included in that that ought to
be included in it.

Here's a way to work around my unhappiness with generating files into the
source directory:
* Have a configure option to specify the $::d directory we use. It should
  default to the $::s directory.
* Dist copies things from $::d into the dist source directory.
* When I build myself, I'll set $::d to the build directory.
* When someone builds from a release package, they can use the default $::s
  directory to avoid rebuilding things, or, if they want, rebuild things from
  scratch to their own $::d directory.

Nice, eh?

Now, do we want general support for putting these things anywhere, or just the
choice to get it from source or build? What should the configure command line
option be called?

nonsourcedistbuildir?
--nsddir?
--no-dist-src
--builddir-for-dist
Honestly, I feel like nsddir is a reasonable name to use.
--nonsourcedistdir

Okay, I mostly like --nonsourcedistdir for a directory option.

How about for a flag? The flag should have the effect of using the build
directory for non-source dist files.

--no-non-source-dist

Means don't assume you have non-source dist files in your source directory.
Or, don't put non-source-dist files in your source directory.

--build-dir-all

--build-non-source-dist

That's good. It says use the build directory for non-source dist. I like that.
Let's use that.

Add a config setting nonsourcedistdir which defaults to srcdir., and a flag --build-non-source-dist.

--build-non-src-dist
nonsrcdistdir 

Yeah.

What other cleanup do I want to do for dist?

Idea:
* have dist_s take target with source dir in prefix. Assert and strip that
  from the prefix.
* have dist_d take target with dist dir in prefix. Assert and strip that from
  the prefix.
* avoid use of build_glob? Hard to say. I'm not sold on this one.

---

Directories to add dist support to:
* pkgs, spec, test, tutorials

Note: the reason build_glob is bad is because it can't distinguish between
source and non-source when using the source directory for non-source dist. So
we should not use build_glob for generating dist_s if there's any dist_d in
that same directory.

It makes me wonder. Do we need to include everything in git in the
distribution? For example, book and thoughts? They aren't needed to build or
run fble, or any of the targets that you can build. They are useful for
development. But if you are doing development, git is the place to do it,
right?

Interesting. I'm really tempted to leave thoughts and book out of the
distribution right now. And things like TODO and deps.tcl? Hmm... TODO might
be valuable as documentation of known issues with a release.

---

Now, in theory I have everything copied over to the distribution. Shall we
test it? Maybe fix the 'cp' timestamp thing first.

Now, in theory I have everything copied over to the distribution. Shall we
test it?

The test is: 
* build from scratch (to make sure it doesn't have things it shouldn't have).
* extract the tarball somewhere.
* configure, build, install in place.
* Need to also check it didn't try to rebuild any of the dist_d files.

It looks like it mostly works. Anything broken is an invisible kind of broken.
For example, maybe it's building too much. Oh well.

Note: I can build in place. We don't need a separate build directory.
Also note: configure should enforce absolute paths for prefix, otherwise it
seems like ninja isn't happy about creating the required directory? Not sure.

---

Cool. Now we have a solid draft of a dist target. What's left? What's critical
to fix before making the first release?

Brainstorm:
* Verify we can build with minimal dependencies from distribution tarball,
  without having to touch original non-source-dist files.
* Fix usage/version for compiled apps.
  - Particularly with respect to need for BUILDSTAMP.
  - But for name stuff too.
* Documentation for C API
  - man pages
  - tutorials
* Figure out if we should be installing libfble-*.a files.
* Miscellaneous Documentation improvements
  - how to build with minimal dependencies.
  - instructions build from source dir instead of separate build dir?
  - how to enable/disable SDL/OpenGL dependencies.
  - improve tutorials in general.
* Other easy miscellaneous TODO burndown.
* Add 'clean' targets?

I think we should start to make and document decisions as to what goes into
the 0.1 release and what not. As soon as I decide something shouldn't go into
the release, punt it and don't ask the question again.

Slowly burn down the TODOs for the 0.1 release. Once that list is empty, it's
ready to release.

That suggests we have two separate TODO lists. One for 0.1 or
to-be-categories. Another for future work. I suppose future work can be called
0.2, right? Because the work consists of either doing it, or punting it to a
future release.

So, how about...

todo-0.1.txt.
todo-0.2.txt.

You could imagine eventually having a todo-1.0 and todo-0.2 simultaneously.

The idea is, you can release once there is nothing left in todo-0.1.txt. At
which point, you remove the todo-0.1.txt file.

---

Issues related to sharing code for main functions:
* BUIDLSTAMP not available at build time for user defined main functions.
  - FbleFooMain should not reference some BUILDSTAMP symbol.
* name, example for executable printed in usage
  - fble-md5 should say "fble-md5", not "fble-stdio"
* name for executable printed in version info
  - Ideally something like "fble-stdio /Md5%" 
* buildstamp for executable
  - Based on buildstamp of libfble.a? fble-compile?
* Avoiding code/doc duplication
  - For example, search path package path arguments.

There's a lot of duplicated code for usage, version in all the binaries. It
would be great to factor that commonality out somehow. Maybe as part of the
arg-parse API?

List of main functions I currently have implemented:
* FbleTestMain
  search path, module-path, help, error, version, profile
* FbleMemTestMain
  search path, module-path, help, error
  growth, debug
* FbleProfilesTestMain
  search path, module path, help, error
* fble-disassemble
  search path, module path, version, help, error, fbldUsageHelpText
* fble-deps
  search path, module path, version, help, error, fbldUsageHelpText
  target
* fble-compile
  search path, module path, help, error, version, fbldUsageHelpText
  compile, export, main_, target
* FbleStdioMain (fble-stdio, fble-md5, ...)
  search path, module path, profile, help, error, version
  end_of_options
* FbleAppMain (fble-app, fble-invaders, ...)
  search path, module path, profile, help, error, version
* fble-perf-profile
  help
* fble-profile-test
  (none)

Categories:
* Generic Program Information: help, version
  Wanted for all.
* Module Input Options: -I, --package, -p, -m
  Includes search path and module path.
  Wanted for anything that takes an module as input.
* Profile Options: --profile
  Wanted for anything that runs a program.
* Misc
  Lots of things have custom options.

For each group of options, we want:
* Code to parse the options.
  Could be implemented as a library function.
* Code to check the options.
  Could be implemented as a library function.
* Usage text for the options.
  Could be a library function to print the documentation, or a fragment
  of .fbld.

So, the ideas are forming. Factor out common per-option code.

---

How should we enforce absolute paths to configure?
* Give an error message if the path doesn't start with '/'?
* Automatically turn it into an absolute path?
  Using [file normalize ...] for example.

Let me double check I understand why ~ doesn't work in the path.

It looks like a relative path looks okay, it's specifically the ~.
~ ends up as a literal in the build.ninja file, and ninja doesn't create that
as a directory.

But how does configure even see '~'? Why doesn't it go through shell
expansion?

It turns out this is a bashism. --foo=~/bar doesn't expand the tilde.

But tcl does have it's own support for tilde expansion. For example, it will
do expansion in file normalize.

Autotools will give an error like:
 configure: error: expected an absolute directory name for --prefix: ~/foo

I don't see why the complaint. I suppose it's out of fear that the tilde ends
up somehow in whatever is installed? And it would be bad for that to depend on
what directory you are or which user you are?

One reason I worry about using file normalize is because ~ might be a long
path that shows up a lot in the build.ninja file. But that could be fixed
other ways.

So, options are:
* Do like we do now. It's up to users not to do --prefix=~/foo
  But some of the code does the expansion, so it's confusing that not all of
  it does the expansion. I don't like this approach.
* Automatically file normalize.
  Any downside aside from build.ninja size?
* Reject anything that isn't already file normalized.

Let's make it easy for people and just auto-normalize.

---

Problem: ninja doesn't avoid making targets that are already up to date if it
hasn't run them before. How can we make non-source dist files work in that
case?

Realistically, I don't think it makes sense to hack around ninja and try to
trick it into thinking it has already built something. Better to be more
explicit. Fundamentally ninja has know way of knowing how a target was
generated if it didn't generate it itself. It doesn't know if the command line
was changed or not.

We could switch to auto-generate makefile and use that instead of ninja, but
that has the key problem that ninja solves and that is getting in the way
here: make won't recognize when the command to build something has changed.

That means we want to be explicit. Let's have two different modes of building.
Not sure what to call them yet. Let's say 'maintainer' mode and 'user' mode.
Or... 'dev' mode and 'release' mode.

In dev mode, we build the non-source-dist into the build directory and read
them from the build directory. In release mode, we read the non-source-dist
from the source directory without ever building them.

It has to be two different build.ninja files. We can't just have different
build targets. You have to run configure again to switch between them.

Now let's consider all the cases:

* dev mode from git:
  Works great. Requires you to build everything.
* release mode from git:
  Fails to find required files.
* dev mode from release:
  Works great. Requires you to build everything.
* release mode from release:
  Works great. Reduced dependencies.

In the case where source directory is the same as the build directory, you can
mix dev mode and release mode. Like, do dev mode from a release and it will
update your files, then you can go back to release mode if you want. Or do dev
mode from git, now you can use release mode.

In the case where source directory is different from the build directory, then
mixing dev mode and release mode from a release will result in multiple copies
of the non-source files in different locations. May be slightly confusing.

Maybe it's worth putting a note on top of all these generated files saying
it's auto-generated. Yeah. Probably is.
  
If we go this route:
* What is the name of the flag we should use to switch between dev mode and
  release mode?
* What should the default value of the flag be?

Options for default value:
* always release: builds minimal by default, but leads to confusing error
  message when building from git.
* always dev: always builds, but requires more dependencies. May as well not
  have any non-source dist files.
* dev for dev, release for release, with option to override.
  Sounds good. How do we detect dev versus release? Detect for the presence of
  a file?

What are we gaining by having non-source dist files? Honestly, in practice,
today?
* Bison dependency dropped for 'release'.
* source-highlight dependency dropped for 'release'.
* groff dependency could be dropped for 'release'.
* pre-generated documentation available. For example, README.txt, TAGs.

The final minimal dependency for fble looks nice without these:
  gcc, binutils, ninja, tcl

We have to be careful with auto-detecting, because it can be messed up if you
modify things yourself or do in-place builds. It shouldn't be based on
presence of absence of non-source dist files.

How about this: default to release, but, in the case of release, add a check
when generating the build.ninja file that all the required files exist. If any
of them don't, print an error that tells people to add the 'dev' flag to
generate the missing file. Yeah. I like that.

Which brings us back to the question of what to call the flag. I'm tempted to
have '--dev'. Maybe '--maintainer'? --enable-maintainer-mode?

I like '--dev'. I think that's fair. If you are doing development, you ought
to regenerate all those files, because they will be out of date otherwise.

This starts to get scary. What if you do a --dev, then the next time around
you forget. And you build locally. Then you change parse.y? Ugh. It's not
safe. If you change parse.y, we really want the guarantee that parse.tab.c
will be generated.

Other ideas:
* Can we use the restat tool for some ninja magic? No. Looks like not.
* Can I just implement my own build system? It can't be that hard, right?
* hack the ninja log?

Let's assume the ninja log format is standard and doesn't change between ninja
versions. Could we write our own ninja log? It makes sense, right? We are
recording how the dist_d files got built in the first place.

Looks like the ninja log has a version number at the top. Maybe it's backwards
compatible? Or we can pick a known version to generate and require you have at
least that version of ninja?

The internet says:
   Each line has five fields separated by a \t:

    1. Start time in milliseconds since the start of the run (integer)
    2. End time in milliseconds since the start of the run (integer)
    3. Restat mtime (integer) (0 if there was none)
    4. Output path (string)
    5. In v5: The hash of the command in hexadecimal. In v4: The full command
       as string.

And these appear to be relative paths? Relative to the build directory.

Here's the proposal: filter out all lines from .ninja_log that are dist_d
files. Include those in the release tarball. Have configure copy the
.ninja_log over the first time you build.

Nope. Doesn't work. I guess it thinks the command lines changed, perhaps due
to the change in build directory.

What if I provide a 'userspace' solution?

Take parse.tab.c for example, which is generated from parse.y.

No. It's the fundamental problem. If you use timestamp to tell what's
up-to-date, you can't change the command line.

I think, for release 0.1, we should drop the idea of dist_d. If the set of
dist_d files is empty, no need to worry about all this. The complexity is not
worth the very small benefit of not requiring bison to build, having a
reformatted README file, and not requiring source-highlight to build the html
code.
 
