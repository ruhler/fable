
import @ { StdLib; };
import StdLib { Unit; BoolM=Bool; };
import BoolM { Bool; True; False; Eq; };

abst union Nat(
  Unit 0,
  Unit 1,
  Nat 2p0,  # 2 * x + 0, where x != 0
  Nat 2p1   # 2 * x + 1, where x != 0
);

# Compute 2 * x.
# This is like Nat:2p0(x), but properly handles the case when x is 0.
priv func 2p0(Nat x; Nat) {
  Nat z = Nat:2p0(x);
  ?(x; 0: 0(), 1: z, 2p0: z, 2p1: z);
};

# Compute 2 * x + 1.
# This is like Nat:2p1(x), but properly handles the case when x is 0.
priv func 2p1(Nat x; Nat) {
  Nat z = Nat:2p1(x);
  ?(x; 0: 1(), 1: z, 2p0: z, 2p1: z);
};

# Compute 4 * x.
priv func 4p0(Nat x; Nat) {
  Nat z = Nat:2p0(Nat:2p0(x));
  ?(x; 0: 0(), 1: z, 2p0: z, 2p1: z);
};

func 0( ; Nat) Nat:0(Unit());
func 1( ; Nat) Nat:1(Unit());
func 2( ; Nat) Nat:2p0(1());
func 3( ; Nat) Nat:2p1(1());
func 4( ; Nat) Nat:2p0(2());
func 5( ; Nat) Nat:2p1(2());
func 6( ; Nat) Nat:2p0(3());
func 7( ; Nat) Nat:2p1(3());
func 8( ; Nat) Nat:2p0(4());
func 9( ; Nat) Nat:2p1(4());
func 10( ; Nat) Nat:2p0(5());
priv func 100( ; Nat) Mul(10(), 10());

func Lit2(Nat a, Nat b; Nat) Add(Mul(10(), a), b);
func Lit3(Nat a, Nat b, Nat c; Nat) Add(Mul(100(), a), Lit2(b, c));

func Inc(Nat a; Nat) {
  ?(a; 0: 1(), 1: 2(), 2p0: Nat:2p1(a.2p0), 2p1: Nat:2p0(Inc(a.2p1))); 
};

func Dec(Nat a; Nat) {
  ?(a; 0: 0(),                  # 0 - 1 ==> 0
       1: 0(),                  # 1 - 1 = 0
       2p0: 2p1(Dec(a.2p0)),    # 2a - 1 = 2(a-1)+1
       2p1: Nat:2p0(a.2p1));    # 2a+1 - 1 = 2a
};

func Add(Nat a, Nat b; Nat) {
  ?(a; 0: b,
       1: Inc(b),
       2p0:
       ?(b; 0: a,
            1: Nat:2p1(a.2p0),
            2p0: Nat:2p0(Add(a.2p0, b.2p0)),        # 2a + 2b = 2(a+b)
            2p1: Nat:2p1(Add(a.2p0, b.2p1))),       # 2a + 2b+1 = 2(a+b)+1
       2p1:
       ?(b; 0: a, 
            1: Nat:2p0(Inc(a.2p1)),               # 2a+1 + 1 = 2(a+1)
            2p0: Nat:2p1(Add(a.2p1, b.2p0)),        # 2a+1 + 2b = 2(a+b)+1
            2p1: Nat:2p0(Inc(Add(a.2p1, b.2p1))))); # 2a+1 + 2b+1 = 2(a+b+1)
};

func Sub(Nat a, Nat b; Nat) {             
  ?(b; 0: a,                                   # a - 0 = a
       1: Dec(a),                              # a - 1 = a - 1
       2p0:
       ?(a; 0: 0(),                            # 0 - 2b ==> 0
            1: 0(),                            # 1 - 2b ==> 0
            2p0: 2p0(Sub(a.2p0, b.2p0)),         # 2a - 2b = 2(a-b)
            2p1: 2p1(Sub(a.2p1, b.2p0))),        # 2a+1 - 2b = 2(a-b) + 1
       2p1:
       ?(a; 0: 0(),                            # 0 - (2b+1) ==> 0
            1: 0(),                            # 1 - (2b+1) ==> 0
            2p0: Dec(2p0(Sub(a.2p0, b.2p1))),    # 2a - (2b+1) = 2(a-b) - 1
            2p1: 2p0(Sub(a.2p1, b.2p1))));       # 2a+1 - (2b+1) = 2(a-b)
};

func Mul(Nat a, Nat b; Nat) {              
  ?(a; 0: 0(),                                   # 0 * b = 0
       1: b,                                     # 1 * b = b
       2p0:
       ?(b; 0: 0(),                              # 2a * 0 = 0
            1: a,                                # 2a * 1 = 2a
            2p0: 4p0(Mul(a.2p0, b.2p0)),           # 2a * 2b = 4ab
            2p1: Add(4p0(Mul(a.2p0, b.2p1)), a)),  # 2a * (2b+1) = 4ab + 2a
       2p1:
       ?(b; 0: 0(),                              # (2a+1) * 0 = 0
            1: a,                                # (2a+1) * 1 = 2a+1
            2p0: Add(4p0(Mul(a.2p1, b.2p0)), b),   # (2a+1) * 2b = 4ab + 2b
                                              # (2a+1) * (2b+1) = 2(2ab + a + b) + 1
            2p1: Nat:2p1(Add(Nat:2p0(Mul(a.2p1, b.2p1)), Add(a.2p1, b.2p1)))));
                
};

struct DivModResult(Nat quotient, Nat remainder);
func Div(Nat a, Nat b; Nat) DivMod(a, b).quotient;
func Mod(Nat a, Nat b; Nat) DivMod(a, b).remainder;

func DivMod(Nat a, Nat b; DivModResult) {
  ?(b; 0: DivModResult(0(), 0()),    
       1: DivModResult(a, 0()),
       2p0: DivModAux(a, b),
       2p1: DivModAux(a, b));
};

# DivMod assuming b > 1
priv func DivModAux(Nat a, Nat b; DivModResult) {
  ?(a; 0: DivModResult(0(), 0()),
       1: DivModResult(0(), 1()),
       2p0: { 
          DivModResult qr = DivModAux(a.2p0, b);
          Nat 2r = 2p0(qr.remainder);
          ?(Lt(2r, b);
              true: DivModResult(2p0(qr.quotient), 2r),
              false: DivModResult(2p1(qr.quotient), Sub(2r, b)));
       },
       2p1: {
          DivModResult qr = DivModAux(a.2p1, b);
          Nat 2rp1 = Inc(2p0(qr.remainder));
          ?(Lt(2rp1, b);
              true: DivModResult(2p0(qr.quotient), 2rp1),
              false: DivModResult(2p1(qr.quotient), Sub(2rp1, b)));
       });
};

func IsZero(Nat a; Bool) {
  ?(a; 0: True(), 1: False(), 2p0: False(), 2p1: False());
};

module EqNat(Eq<Nat>) {
  import @ { Nat; Bool; True; False; };

  func Eq(Nat a, Nat b; Bool) {
    ?(a;
       0:   ?(b; 0: True(),  1: False(), 2p0: False(), 2p1: False()),
       1:   ?(b; 0: False(), 1: True(),  2p0: False(), 2p1: False()),
       2p0: ?(b; 0: False(), 1: False(), 2p0: Eq(a.2p0, b.2p0), 2p1: False()),
       2p1: ?(b; 0: False(), 1: False(), 2p0: False(), 2p1: Eq(a.2p1, b.2p1)));
  };

  func Ne(Nat a, Nat b; Bool) {
    ?(a;
       0:   ?(b; 0: False(), 1: True(), 2p0: True(), 2p1: True()),
       1:   ?(b; 0: True(),  1: False(), 2p0: True(), 2p1: True()),
       2p0: ?(b; 0: True(),  1: True(), 2p0: Ne(a.2p0, b.2p0), 2p1: True()),
       2p1: ?(b; 0: True(),  1: True(), 2p0: True(), 2p1: Ne(a.2p1, b.2p1)));
  };
};

func Lt(Nat a, Nat b; Bool) {
  ?(a;
     0:   ?(b; 0: False(), 1: True(), 2p0: True(), 2p1: True()),
     1:   ?(b; 0: False(), 1: False(), 2p0: True(), 2p1: True()),
     2p0: ?(b; 0: False(), 1: False(), 2p0: Lt(a.2p0, b.2p0), 2p1: Le(a.2p0, b.2p1)),
     2p1: ?(b; 0: False(), 1: False(), 2p0: Lt(a.2p1, b.2p0), 2p1: Lt(a.2p1, b.2p1)));
};

func Le(Nat a, Nat b; Bool) {
  ?(a;
     0: ?(b; 0: True(), 1: True(), 2p0: True(), 2p1: True()),
     1: ?(b; 0: False(), 1: True(), 2p0: True(), 2p1: True()),
     2p0: ?(b; 0: False(), 1: False(), 2p0: Le(a.2p0, b.2p0), 2p1: Le(a.2p0, b.2p1)),
     2p1: ?(b; 0: False(), 1: False(), 2p0: Lt(a.2p1, b.2p0), 2p1: Le(a.2p1, b.2p1)));
};

func Gt(Nat a, Nat b; Bool) {
  ?(a; 0: False(),
     1: ?(b; 0: True(), 1: False(), 2p0: False(), 2p1: False()),
     2p0: ?(b; 0: True(), 1: True(), 2p0: Gt(a.2p0, b.2p0), 2p1: Gt(a.2p0, b.2p1)),
     2p1: ?(b; 0: True(), 1: True(), 2p0: Ge(a.2p1, b.2p0), 2p1: Gt(a.2p1, b.2p1)));
};

func Ge(Nat a, Nat b; Bool) {
  ?(a;
     0: ?(b; 0: True(), 1: False(), 2p0: False(), 2p1: False()),
     1: ?(b; 0: True(), 1: True(), 2p0: False(), 2p1: False()),
     2p0: ?(b; 0: True(), 1: True(), 2p0: Ge(a.2p0, b.2p0), 2p1: Gt(a.2p0, b.2p1)),
     2p1: ?(b; 0: True(), 1: True(), 2p0: Ge(a.2p1, b.2p0), 2p1: Ge(a.2p1, b.2p1)));
};
