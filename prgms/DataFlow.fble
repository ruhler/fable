
# DataFlow describes computation as a graph of modules. A module has some
# number of input ports and some number of output ports. The behavior of a
# module is to consume values on its input ports and produce corresponding
# values on its output ports.

# A DataFlow module is described in fble as a process that takes output ports
# as arguments and returns input ports to the module. It has the effect of
# instantiating a computation that runs asynchronously. In particular, putting
# a value onto an input port is a non-blocking operation.

<@,@>@ List@ = /List%.List@;

<@>@ Get@ = /Process%.Get@;
<@>@ Put@ = /Process%.Put@;

@ Unit@ = /Unit%.Unit@;
% Unit = /Unit%.Unit;

# DataFlow@ --
#   A data flow computation.
@ DataFlow@ = Unit@!;

# End@ --
#   Data to send to a data flow computation that can indicate end of
#   computation.
#
# Often we want to either send data to a data flow computation, or tell it to
# finish running. The End@ type should be used for that.
<@>@ End@ = <@ T@> { +(T@ data, Unit@ end); };

<@ T@> { End@<T@>; } End = <@ T@> { End@<T@>(end: Unit); };
<@ T@>(T@) { End@<T@>; } Data = <@ T@>(T@ x) { End@<T@>(data: x); };

# Input and output wires, from the perspective of the DataFlow computation.
<@>@ In@ = <@ T@> { Get@<End@<T@>>; };
<@>@ Out@ = <@ T@> { Put@<End@<T@>>; };

# Compose --
#   Compose together a bunch of data flow computations.
#
# The resulting data flow computation behaves as if all argument data flow
# computations were run in parallel. It completes when all argument data flow
# computations have completed.
(List@<DataFlow@>) { DataFlow@; } Compose = (List@<DataFlow@> args) {
  args<DataFlow@>(
    (DataFlow@ x, DataFlow@ y) {
      Unit@ _ := x;
      Unit@ _ := y;
      $(Unit);
    },
    $(Unit));
};

# Run --
#   Execute a data flow computation.
(DataFlow@) { Unit@!; } Run = (DataFlow@ x) {
  x;
};

# Input --
#   Inject input into a data flow computation.
<@ T@>(Get@<End@<T@>>, Out@<T@>) { DataFlow@; }
Input = <@ T@>(Get@<End@<T@>> in, Out@<T@> out) {
  End@<T@> x := in;
  x.?(
    data: {
      Unit@ _ := out(x);
      Input<T@>(in, out);
    },
    end: out(x));
};

# Output --
#   Get output from a data flow computation.
<@ T@>(Put@<End@<T@>>, In@<T@>) { DataFlow@; }
Output = <@ T@>(Put@<End@<T@>> out, In@<T@> in) {
  Input<T@>(in, out);
};

# Const --
#   Output a constant value for every input.
<@ T@>(T@, In@<Unit@>, Out@<T@>) { DataFlow@; }
Const = <@ T@>(T@ x, In@<Unit@> in, Out@<T@> out) {
  End@<Unit@> i := in;
  i.?(
    data: {
      Unit@ _ := out(Data<T@>(x));
      Const<T@>(x, in, out);
    },
    end: out(End<T@>));
};

# Copy --
#   Copy an input to multiple outputs.
<@ T@>(In@<T@>, List@<Out@<T@>>) { DataFlow@; }
Copy = <@ T@>(In@<T@> in, List@<Out@<T@>> outs) {
  End@<T@> i := in;
  Unit@! broadcast = outs<Unit@!>((Out@<T@> o, Unit@! _) { o(i); }, $(Unit));
  i.?(
    data: {
      Unit@ _ := broadcast;
      Copy<T@>(in, outs);
    }, 
    end: broadcast);
};

@(DataFlow@, In@, Out@, Input, Output, Copy, Const, Compose, Run);
