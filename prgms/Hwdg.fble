
@ Bool@ = /Bool%.Bool@;
% True = /Bool%.True;
% False = /Bool%.False;
% Or = /Bool%.Or;

@ Int@ = /Int/Int%.Int@; 
% Inc = /Int/Int%.Inc;

<@>@ Maybe@ = /Maybe%.Maybe@;
<@>% Just = /Maybe%.Just;
<@>% Nothing = /Maybe%.Nothing;

% PairS = /Structure%.PairS;
<@>@ Structured@ = /Structured%.Structured@;

@ Unit@ = /Unit%.Unit@;
% Unit = /Unit%.Unit;

@ Coord@ = *(Int@ x, Int@ y);

Structured@<Coord@> CoordS = {
  % IntS = /Int/Int/Structured%.Structured;
  (Coord@ c) {
    PairS(IntS(c.x), IntS(c.y));
  };
};

@ Data@ = +(Unit@ 0, Unit@ 1);
Data@ 0 = Data@(0: Unit);
Data@ 1 = Data@(1: Unit);

@ PortSpec@ = +(Unit@ input, Unit@ output, Unit@ unused);
PortSpec@ InputPort = PortSpec@(input: Unit);
PortSpec@ OutputPort = PortSpec@(output: Unit);
PortSpec@ UnusedPort = PortSpec@(unused: Unit);

<@>@ Ports@ = <@ T@> { *(T@ ul, T@ ur, T@ ll, T@ lr); };

# GateFunction@ --
#   Describes the behavior of a gate when it is triggered. The input is the
#   data value for each port, where 0 is passed for any non-input port. The
#   output is a new data value for each port, where values for non-output
#   ports are ignored. This allows us to have a uniform gate function
#   specification regardless of how the gate's ports are configured as
#   input/output/unused ports.
@ GateFunction@ = (Ports@<Data@>) { Ports@<Data@>; };

@ Gate@ = *(Ports@<PortSpec@> ports, GateFunction@ function);

@ Cells@ = /Map%.Map@<Coord@, Data@>;
@ GateEntry@ = *(Coord@ coord, Gate@ gate);
@ Gates@ = /List%.List@<GateEntry@>;

# EmptyCells -- 
#  An empty array of data cells.
Cells@ EmptyCells = /Map%.Empty<Coord@, Data@>;

# EmptyGates --
#  An empty array of gates.
Gates@ EmptyGates = /List%.Nil<GateEntry@>;

# GetData --
#   Get the data of a particular cell.
(Cells@, Coord@) { Maybe@<Data@>; } GetData = {
  /Map%.Lookup<Coord@>(CoordS)<Data@>;
};

# SetData --
#   Set the data value of the given cell.
(Cells@, Coord@, Data@) { Cells@; } SetData = {
  /Map%.Insert<Coord@>(CoordS)<Data@>;
};

# ClearData --
#   Clear the data value of the given cell, leaving the cell empty.
(Cells@, Coord@) { Cells@; } ClearData = {
  /Map%.Delete<Coord@>(CoordS)<Data@>;
};

# SetGate --
#   Configure the gate whose upper left corner is at the given coordinates of
#   the layout.
(Gates@, Coord@, Gate@) { Gates@; }
SetGate = (Gates@ gates, Coord@ coord, Gate@ gate) {
  /List%.Cons<GateEntry@>(@(coord, gate), gates);
};

# ForEachGate --
#   Iterate over a set of gates.
#
# Conceptually:
#   B@ b = base
#   foreach (coord, gate) in gates:
#     b = body(coord, gates, b)
#   return b
<@ B@>(Gates@, B@, (Coord@, Gate@, B@) { B@; }) { B@; }
ForEachGate = <@ B@>(Gates@ gates, B@ base, (Coord@, Gate@, B@) { B@; } body) {
  /List%.ForEach<GateEntry@, B@>(gates, base, (GateEntry@ ge, B@ b) {
    body(ge.coord, ge.gate, b);
  });
};

# Step --
#   Run a single step of the hardware.
#
# Returns the update data cells, or Nothing if no gates are enabled. The exact
# meaning of a single step is not currently well specified.
#
# TODO: Test and fix the case when conflicting gates are simultaneously
# enabled.
(Gates@, Cells@) { Maybe@<Cells@>; } Step = {
  (PortSpec@, Maybe@<Data@>) { Bool@; } Blocked = (PortSpec@ ps, Maybe@<Data@> d) {
    ps.?(
      input: d.?(just: False, nothing: True),
      output: d.?(just: True, nothing: False),
      unused: False);
  };

  (PortSpec@, Maybe@<Data@>) { Data@; } InputData = (PortSpec@ ps, Maybe@<Data@> d) {
    ps.?(
      input: d.?(just: d.just, nothing: 0),
      output: 0,
      unused: 0);
  };

  @ B@ = *(Cells@ cells, Bool@ updated);
  (B@, Coord@, PortSpec@, Data@) { B@; } UpdateResult = (B@ b, Coord@ c, PortSpec@ ps, Data@ d) {
    ps.?(
      input: @(cells: ClearData(b.cells, c), updated: True),
      output: @(cells: SetData(b.cells, c, d), updated: True),
      unused: b);
  };

  (Gates@ gates, Cells@ cells) {
    B@ b = ForEachGate<B@>(gates, B@(cells, False),
      (Coord@ c, Gate@ g, B@ b) {
        Ports@<Coord@> coords = Ports@<Coord@>(
          Coord@(c.x, c.y),
          Coord@(Inc(c.x), c.y),
          Coord@(c.x, Inc(c.y)),
          Coord@(Inc(c.x), Inc(c.y)));

        Ports@<Maybe@<Data@>> data = Ports@<Maybe@<Data@>>(
          GetData(cells, coords.ul), GetData(cells, coords.ur),
          GetData(cells, coords.ll), GetData(cells, coords.lr));

        Bool@ blocked_ul = Blocked(g.ports.ul, data.ul);
        Bool@ blocked_ur = Or(blocked_ul, Blocked(g.ports.ur, data.ur));
        Bool@ blocked_ll = Or(blocked_ur, Blocked(g.ports.ll, data.ll));
        Bool@ blocked_lr = Or(blocked_ll, Blocked(g.ports.lr, data.lr));

        blocked_lr.?(
          true: b,
          false: {
            Ports@<Data@> inputs = Ports@<Data@>(
              InputData(g.ports.ul, data.ul),
              InputData(g.ports.ur, data.ur),
              InputData(g.ports.ll, data.ll),
              InputData(g.ports.lr, data.lr));

            Ports@<Data@> outputs = g.function(inputs);
            B@ b_ul = UpdateResult(b, coords.ul, g.ports.ul, outputs.ul);
            B@ b_ur = UpdateResult(b_ul, coords.ur, g.ports.ur, outputs.ur);
            B@ b_ll = UpdateResult(b_ur, coords.ll, g.ports.ll, outputs.ll);
            B@ b_lr = UpdateResult(b_ll, coords.lr, g.ports.lr, outputs.lr);
            b_lr;
          });
      });
    b.updated.?(true: Just<Cells@>(b.cells), false: Nothing<Cells@>);
  };
};

# Run --
#   Run the given hardware layout as long as any gates are enabled.
(Gates@, Cells@) { Cells@; } Run = (Gates@ gates, Cells@ cells) {
  Maybe@<Cells@> mc = Step(gates, cells);
  mc.?(just: Run(gates, mc.just), nothing: cells);
};

@(Cells@, Gates@, Coord@, Data@, Gate@, Ports@, PortSpec@,
  0, 1, InputPort, OutputPort, UnusedPort,
  EmptyCells, GetData, SetData, ClearData, EmptyGates, SetGate, ForEachGate,
  Step, Run);
