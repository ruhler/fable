
@ Char@ = /Char%.Char@;
% Chars = /Char%.Chars;

@ Bit@ = /Digits%.Bit@;
% Bit = /Digits%.Bit;

@ Addr@ = /Fblf/Program%.Addr@;
@ ProgramId@ = /Fblf/Program%.ProgramId@;
@ Env@ = /Fblf/Program%.Env@;
@ Assign@ = /Fblf/Program%.Assign@;
@ Condition@ = /Fblf/Program%.Condition@;
@ IfElse@ = /Fblf/Program%.IfElse@;
@ Sequence@ = /Fblf/Program%.Sequence@;
@ While@ = /Fblf/Program%.While@;
@ Shared@ = /Fblf/Program%.Shared@;
@ Value@ = /Fblf/Program%.Value@;
@ Program@ = /Fblf/Program%.Program@;
% Ref = /Fblf/Program%.Ref;
<@>% ForEachProgram = /Fblf/Program%.ForEachProgram;

@ Int@ = /Int/Int%.Int@;
% Add = /Int/Int%.Add;
% Sub = /Int/Int%.Sub;
% Eq = /Int/Int/Eq%.Eq;
% Le = /Int/Int/Eq%.Le;
% Mod = /Int/Int/Div%.Mod;
% Int = /Int/Int/Lit%.Int;

<@>@ List@ = /List%.List@;
<@>% List = /List%.List;
<@,@>% Map = /List%.Map;
<@>% Nil = /List%.Nil;
<@>% Cons = /List%.Cons;
<@>% Append = /List%.Append;
<@>% Concat = /List%.Concat;

<@>% Drop = /List/Length%.Drop;
<@>% Length = /List/Length%.Length;
<@>% Take = /List/Length%.Take;

@ String@ = /String%.String@;
% Str = /String%.Str;

Int@ BitsPerWord = Int|64;

(List@<String@>) { String@; } Strs = Concat<Char@>;

# Lines@ -- 
#   Abstract data type for outputting a sequence of lines of text from
#   compilation.
@ Lines@ = String@;

# Line --
#   Output the given line of text.
(String@) { Lines@; } Line = (String@ line) {
  Append<Char@>(line, Str[Chars.nl]);
};

# Lines --
#   Output multiple lines of text in order.
(List@<Lines@>) { Lines@; } Lines = (List@<Lines@> lines) {
  Concat<Char@>(lines);
};

(Addr@) { String@; } CompileAddr = /Int/Int/Show%.Show;

# Compile a constant that is assumed to fit within BitsPerWord.
(List@<Bit@>) { String@; } 
CompileSmallConstant = {
  # Convert a list of bits to hex string, assuming the number of elements on
  # the list is a multiple of 4.
  (List@<Bit@>) { String@; } ToHex = (List@<Bit@> l) {
    l.?(
      cons: {
        Bit@ a = l.cons.head;
        Bit@ b = l.cons.tail.cons.head;
        Bit@ c = l.cons.tail.cons.tail.cons.head;
        Bit@ d = l.cons.tail.cons.tail.cons.tail.cons.head;
        String@ tail = ToHex(l.cons.tail.cons.tail.cons.tail.cons.tail);
        Char@ h = a.?(
          0: b.?(
            0: c.?(0: d.?(0: Chars.0, 1: Chars.1), 1: d.?(0: Chars.2, 1: Chars.3)),
            1: c.?(0: d.?(0: Chars.4, 1: Chars.5), 1: d.?(0: Chars.6, 1: Chars.7))),
          1: b.?(
            0: c.?(0: d.?(0: Chars.8, 1: Chars.9), 1: d.?(0: Chars.A, 1: Chars.B)),
            1: c.?(0: d.?(0: Chars.C, 1: Chars.D), 1: d.?(0: Chars.E, 1: Chars.F))));
        Cons<Char@>(h, tail);
      },
      nil: Nil<Char@>);
  };

  (List@<Bit@> c) {
    Int@ length = Length<Bit@>(c);
    Eq(Mod(length, Int|4), Int|0).?(
      true: Strs[Str|'0x', ToHex(c)],
      false: {
        # TODO: We could improve performance by adding just the right number
        # of bits here, instead of having to recompute the length of the list
        # each time.
        CompileSmallConstant(Cons<Bit@>(Bit.0, c));
      });
  };
};

# Compile an equals condition into an atomic boolean expression in C, where
# the number of bits is assumed to fit within BitsPerWord.
(Value@, Value@, Int@) { String@; }
CompileSmallEquals = (Value@ a, Value@ b, Int@ n) {
  a.?(
    ref: b.?(
      ref: Strs[
        Str|'FblfHeapEqual(heap, ',
        CompileAddr(a.ref), Str|', ',
        CompileAddr(b.ref), Str|', ',
        /Int/Int/Show%.Show(n), Str|')'],
      const: Strs[
        Str|'FblfHeapEquals(heap, ',
        CompileAddr(a.ref), Str|', ',
        CompileSmallConstant(b.const), Str|', ',
        /Int/Int/Show%.Show(n), Str|')']),
    const: b.?(
      ref: Strs[
        Str|'FblfHeapEquals(heap, ',
        CompileAddr(b.ref), Str|', ',
        CompileSmallConstant(a.const), Str|', ',
        /Int/Int/Show%.Show(n), Str|')'],
      const: Strs[
        Str|'(',
        CompileSmallConstant(a.const),
        Str|' == ',
        CompileSmallConstant(b.const),
        Str|')']));
};

# Split the first n bits off of the given value, returning the n most
# significant bits of the value as 'hi', and the remaining least significant
# bits of the value in 'lo'.
(Value@, Int@) { *(Value@ hi, Value@ lo); } Split = (Value@ v, Int@ n) {
  v.?(
    ref: @(
      hi: v,
      lo: Ref(Add(v.ref, n))),
    const: @(
      hi: Value@(const: Take<Bit@>(n, v.const)),
      lo: Value@(const: Drop<Bit@>(n, v.const))));
};

# Compile an equals condition into an atomic boolean expression in C.
(Value@, Value@, Int@) { String@; }
CompileEquals = (Value@ a, Value@ b, Int@ n) {
  Le(n, BitsPerWord).?(
    true: CompileSmallEquals(a, b, n),
    false: {
      % as = Split(a, BitsPerWord);
      % bs = Split(b, BitsPerWord);
      String@ hi = CompileSmallEquals(as.hi, bs.hi, BitsPerWord);
      String@ lo = CompileEquals(as.lo, bs.lo, Sub(n, BitsPerWord));
      Strs[Str|'(', hi, Str|' && ', lo, Str|')'];
    });
};

# Compile a condition into an expression suitable for use in the condition of
# an if or while statement in C.
(Condition@) { String@; } CompileCondition = (Condition@ cond) {
  String@ equals = CompileEquals(cond.a, cond.b, cond.n);
  cond.op.?(
    eq: equals,
    ne: Cons<Char@>(Chars.'!', equals));
};

# Compile an assignment statement assuming the number of bits fits within
# BitsPerWord.
(String@, Assign@) { Lines@; }
CompileSmallAssign = (String@ indent, Assign@ assign) {
  assign.value.?(
    ref: Line(Strs[
      indent,
      Str|'FblfHeapCopy(heap, ',
      CompileAddr(assign.ref),
      Str|', ',
      CompileAddr(assign.value.ref),
      Str|', ',
      /Int/Int/Show%.Show(assign.n),
      Str|');']),
    const: Line(Strs[
      indent,
      Str|'FblfHeapWrite(heap, ',
      CompileAddr(assign.ref),
      Str|', ',
      CompileSmallConstant(assign.value.const),
      Str|', ',
      /Int/Int/Show%.Show(assign.n),
      Str|');']));
};

# SharedFuncName --
#   The C function name used for the implementation of the program with given
#   id.
(ProgramId@) { String@; } SharedFuncName = (ProgramId@ id) {
  Strs[Str|'__prog_', /Int/Int/Show%.Show(id)];
};

(String@, Shared@) { Lines@; } CompileShared = (String@ indent, Shared@ id) {
  Line(Strs[indent, SharedFuncName(id), Str|'(heap);']);
};

# Compile an assignment statement into a sequence of statements in C.
(String@, Assign@) { Lines@; } CompileAssign = (String@ indent, Assign@ assign) {
  Le(assign.n, BitsPerWord).?(
    true: CompileSmallAssign(indent, assign),
    false: {
      % vs = Split(assign.value, BitsPerWord);
      Lines(List<Lines@>[
        CompileSmallAssign(indent, Assign@(assign.ref, vs.hi, BitsPerWord)),
        CompileSmallAssign(indent, Assign@(Add(assign.ref, BitsPerWord), vs.lo, Sub(assign.n, BitsPerWord)))]);
    });
};

(String@, Sequence@) { Lines@; } CompileSequence = (String@ indent, Sequence@ seq) {
  Lines(Map<Program@, Lines@>(seq, (Program@ p) { CompileProgram(indent, p); }));
},

(String@, IfElse@) { Lines@; } CompileIfElse = (String@ indent, IfElse@ ifelse) {
  String@ nested = Strs[indent, Str|'  '];
  Lines(List<Lines@>[
    Line(Strs[
      indent,
      Str|'if (',
      CompileCondition(ifelse.condition),
      Str|') {']),
    CompileProgram(nested, ifelse.if_body),
    Line(Strs[
      indent, Str|'} else {']),
    CompileProgram(nested, ifelse.else_body),
    Line(Strs[indent, Str|'}'])]);
},

(String@, While@) { Lines@; } CompileWhile = (String@ indent, While@ while) {
  String@ nested = Strs[indent, Str|'  '];
  Lines(List<Lines@>[
    Strs[
      indent,
      Str|'while (',
      CompileCondition(while.condition),
      Str|') {'],
    CompileProgram(nested, while.body),
    Strs[indent, Str|'}']]);
},

(String@, Program@) { Lines@; } CompileProgram = (String@ indent, Program@ prgm) {
  prgm.?(
    assign: CompileAssign(indent, prgm.assign),
    sequence: CompileSequence(indent, prgm.sequence),
    ifelse: CompileIfElse(indent, prgm.ifelse),
    while: CompileWhile(indent, prgm.while),
    shared: CompileShared(indent, prgm.shared));
};

# Compile_ --
#   Compile an fblf program to a C function with the given name.
#
# The signature of a function named 'Foo' will be:
#   void Foo(FblfHeap* heap);
(String@, Program@) { Lines@; }
Compile_ = (String@ name, Program@ program) {
  Lines(List<Lines@>[
    Line(Strs[
      Str|'void ',
      name,
      Str|'(FblfHeap* heap)']),
    Line(Str|'{'),
    CompileProgram(Str|'  ', program),
    Line(Str|'}')]);
};

# CompileEnv_ --
#   Compile an fblf program environment to static C function that can be
#   referenced from programs compiled with Compile.
(Env@) { Lines@; } CompileEnv_ = (Env@ env) {
  ForEachProgram<Lines@>(env, Str|'', (ProgramId@ id, Program@ p, Lines@ l) {
    Lines[l, Compile_(SharedFuncName(id), p)];
  });
};

# Compile --
#   Compile an fblf program to a C function with the given name.
#
# TODO: Clarify in documentation the dependence on CompileEnv.
#
# The signature of a function named 'Foo' will be:
#   void Foo(FblfHeap* heap);
(String@, Program@) { String@; } Compile = Compile_;

# CompileEnv --
#   Compile an fblf program environment to static C function that can be
#   referenced from programs compiled with Compile.
(Env@) { String@; } CompileEnv = CompileEnv_;

@(CompileEnv, Compile);
