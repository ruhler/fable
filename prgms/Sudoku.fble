{ Bool%; @(Bool@, True, False); };
{ Char%; @(Char@, newline); };
{ List%; @(S@, S0, S, ConsS, Append, Concat); };
{ Maybe%; @(Maybe@, Just, Nothing, For); };
{ String%; @(Str@, Str); };
{ Unit%; @(Unit@, Unit); };

# The 9 symbols used in sudoku: 1 through 9.
@ Symbol@ = +(
  Unit@ 1, Unit@ 2, Unit@ 3,
  Unit@ 4, Unit@ 5, Unit@ 6,
  Unit@ 7, Unit@ 8, Unit@ 9);

Symbol@ 1 = Symbol@(1: Unit);
Symbol@ 2 = Symbol@(2: Unit);
Symbol@ 3 = Symbol@(3: Unit);
Symbol@ 4 = Symbol@(4: Unit);
Symbol@ 5 = Symbol@(5: Unit);
Symbol@ 6 = Symbol@(6: Unit);
Symbol@ 7 = Symbol@(7: Unit);
Symbol@ 8 = Symbol@(8: Unit);
Symbol@ 9 = Symbol@(9: Unit);

# Iterate over the symbols in order.
(Symbol@){ Maybe@<Symbol@>; } IterateSymbol = (Symbol@ s) {
  (Symbol@){ Maybe@<Symbol@>; } J = Just<Symbol@>;
  ?(s;
    1: J(2), 2: J(3), 3: J(4),
    4: J(5), 5: J(6), 6: J(7),
    7: J(8), 8: J(9), 9: Nothing<Symbol@>);
};

# An index specifying a row or column of a box group.
@ BoxIndex@ = +(Unit@ 1, Unit@ 2, Unit@ 3);

BoxIndex@ B1 = BoxIndex@(1: Unit);
BoxIndex@ B2 = BoxIndex@(2: Unit);
BoxIndex@ B3 = BoxIndex@(3: Unit);

# s / 3
(Symbol@) { BoxIndex@; } Div3 = (Symbol@ s) {
  ?(s; 1: B1, 2: B1, 3: B1,
       4: B2, 5: B2, 6: B2,
       7: B3, 8: B3, 9: B3);
};

# s % 3
(Symbol@) { BoxIndex@; } Mod3 = (Symbol@ s) {
  ?(s; 1: B1, 2: B2, 3: B3,
       4: B1, 5: B2, 6: B3,
       7: B1, 8: B2, 9: B3);
};

# 3a + b
(BoxIndex@, BoxIndex@) { Symbol@; } Lit3 = (BoxIndex@ a, BoxIndex@ b) {
  ?(a; 1: ?(b; 1: 1, 2: 2, 3: 3),
       2: ?(b; 1: 4, 2: 5, 3: 6),
       3: ?(b; 1: 7, 2: 8, 3: 9));
};

# An array of elements of type T@, indexed by symbol.
<@>@ Array@ = <@ T@>(Symbol@){ T@; };

# Set the value of a single element of an array.
#   a[s] = x
<@ T@>(Symbol@, T@, Array@<T@>){ Array@<T@>; }
Set = <@ T@>(Symbol@ s, T@ x, Array@<T@> a) {
  T@ a1 = ?(s; 1: x, : a(1));
  T@ a2 = ?(s; 2: x, : a(2));
  T@ a3 = ?(s; 3: x, : a(3));
  T@ a4 = ?(s; 4: x, : a(4));
  T@ a5 = ?(s; 5: x, : a(5));
  T@ a6 = ?(s; 6: x, : a(6));
  T@ a7 = ?(s; 7: x, : a(7));
  T@ a8 = ?(s; 8: x, : a(8));
  T@ a9 = ?(s; 9: x, : a(9));
  (Symbol@ k) {
    ?(k;
      1: a1, 2: a2, 3: a3,
      4: a4, 5: a5, 6: a6,
      7: a7, 8: a8, 9: a9);
  };
};

<@ T@>(Symbol@, Symbol@, T@, Array@<Array@<T@>>){ Array@<Array@<T@>>; }
Set2D = <@ T@>(Symbol@ a, Symbol@ b, T@ x, Array@<Array@<T@>> array) {
  Set<Array@<T@>>(a, Set<T@>(b, x, array(a)), array);
};

# A cell is identified by its row and column.
@ CellId@ = *(Symbol@ row, Symbol@ col);

# Return the id of the box group that this cell belongs to.
(CellId@) { Symbol@; } BoxGroupOf = (CellId@ cell) {
  BoxIndex@ row = Div3(cell.row);
  BoxIndex@ col = Div3(cell.col);
  Lit3(row, col);
};

# Return the position of this cell within its box group.
(CellId@) { Symbol@; } BoxPosOf = (CellId@ cell) {
  BoxIndex@ row = Mod3(cell.row);
  BoxIndex@ col = Mod3(cell.col);
  Lit3(row, col);
};

# Return the id of the cell in the given position of the given box.
(Symbol@, Symbol@) { CellId@; } CellOfPos = (Symbol@ box, Symbol@ pos) {
  Symbol@ row = Lit3(Div3(box), Div3(pos));
  Symbol@ col = Lit3(Mod3(box), Mod3(pos));
  CellId@(row, col);
};

# A set of symbols.
@ Set@ = Array@<Bool@>;

# The set of all possible symbols.
Set@ FullSet = (Symbol@ s) { True; };

# Remove all elements of the given set except for the given symbol.
# If the given symbol was in the set, the set becomes a singleton set.
# Otherwise the set becomes an empty set.
(Symbol@, Set@) { Set@; } RemoveAllBut = (Symbol@ s, Set@ a) {
  Set<Bool@>(s, a(s), (Symbol@ k) { False; });
};

# Return the singleton value of a set, if it is a singleton set. Return
# Nothing if it is not a singleton set.
(Set@){ Maybe@<Symbol@>; } Singleton = (Set@ set) {
  @ State@ = +(Unit@ empty, Symbol@ single, Unit@ multi);

  State@ state = For<Symbol@, State@>(1, State@(empty: Unit), IterateSymbol,
    (Symbol@ symbol, State@ state) {
       ?(set(symbol);
          true: ?(state;
            empty: State@(single: symbol),
            single: State@(multi: Unit),
            multi: state),
          false: state);
  });
  ?(state; empty: Nothing<Symbol@>,
           single: Just<Symbol@>(state.single),
           multi: Nothing<Symbol@>);
};

# For each Cell, we keep track of the set of possible symbols the cell may
# take on.
@ Cell@ = Set@;
Cell@ InitialCell = FullSet;

# 2D array of cells. The first index is the row, the second index is the
# column.
@ Board@ = Array@<Array@<Cell@>>;
Board@ InitialBoard = (Symbol@ r, Symbol@ c) { InitialCell; };

# An assignment of a symbol value to a particular cell.
@ Assign@ = *(CellId@ cell, Symbol@ symbol);

# A value of some type T along with a list of generated assignments.
<@>@ A@ = <@ T@>{ *(T@ _, S@<Assign@> assigns); };

# Apply a function, accumulating assignment constraints.
<@ S@, @ T@>(A@<S@>, (S@){ A@<T@>; }){ A@<T@>; }
A = <@ S@, @ T@>(A@<S@> a, (S@){ A@<T@>; } f) {
  A@<T@> x = f(a._);
  A@<T@>(x._, Append<Assign@>(x.assigns, a.assigns));
};

<@ T@>(T@){ A@<T@>; } ReturnA = <@ T@>(T@ x) {
  A@<T@>(x, S0<Assign@>);
};

# UpdateCell --
#   Update the set of possibilities in a cell 'id' given we are setting some
#   cell 'c' in the same group to a known symbol value.
#
# Inputs:
#   this - True if we are setting this cell to the known symbol value
#          ('c' == 'id'). False if we are setting some other cell in the same
#          group to the known symbol value ('c' != 'id').
#   id - The id of the cell to update.
#   symbol - The symbol that the cell 'c' is being assigned.
#   board - The board to update.
#
# Results:
#   An updated board along with new constraints generated based on the cell
#   update.
(Bool@, CellId@, Symbol@, Board@) { A@<Board@>; }
UpdateCell = (Bool@ this, CellId@ id, Symbol@ symbol, Board@ board) {
  ?(this;
    true: {
      # We are setting this cell to the given symbol.
      # Eliminate all other potential symbols for this cell.
      Board@ nboard = Set2D<Cell@>(id.row, id.col,
          RemoveAllBut(symbol, board(id.row, id.col)), board);
      ReturnA<Board@>(nboard);
    },
    false: {
      # We are setting some other cell in the same group to the given symbol
      # value. Eliminate the symbol as a potential symbol for this cell.
      # But only do that if the symbol is a potential symbol for this cell.
      Cell@ cell = board(id.row, id.col);
      ?(cell(symbol);
         true: {
           Cell@ ncell = Set<Bool@>(symbol, False, cell);
           Board@ nboard = Set2D<Cell@>(id.row, id.col, ncell, board);

           # If there is now only one possible symbol value for this cell, we
           # know this cell must take on that single possible symbol value.
           Maybe@<Symbol@> single = Singleton(ncell);
           S@<Assign@> nassigns = ?(single;
             just: {
               S<Assign@>([Assign@(id, single.just)]);
             },
             nothing: S0<Assign@>);
           A@<Board@>(nboard, nassigns);
         },
         false: ReturnA<Board@>(board));
    });
};

# Set the value of a cell on the board.
# Results in an updated board and a set of new assignments to make.
(Board@, Assign@) { A@<Board@>; } Assign = (Board@ board, Assign@ x) {
   A@<Board@> b0 = ReturnA<Board@>(board);

   # Columns
   Set@ isThisCol = Set<Bool@>(x.cell.col, True, (Symbol@ _) { False; });
   A@<Board@> b1 = For<Symbol@, A@<Board@>>(1, b0, IterateSymbol,
     (Symbol@ col, A@<Board@> aboard) {
       Board@ board <- A<Board@, Board@>(aboard);
       UpdateCell(isThisCol(col), CellId@(x.cell.row, col), x.symbol, board);
   });

   # Rows
   Set@ isThisRow = Set<Bool@>(x.cell.row, True, (Symbol@ _) { False; });
   A@<Board@> b2 = For<Symbol@, A@<Board@>>(1, b1, IterateSymbol,
     (Symbol@ row, A@<Board@> aboard) {
       Board@ board <- A<Board@, Board@>(aboard);
       UpdateCell(isThisRow(row), CellId@(row, x.cell.col), x.symbol, board);
   });

   # Boxes
   Symbol@ box = BoxGroupOf(x.cell);
   Set@ isThisPos = Set<Bool@>(BoxPosOf(x.cell), True, (Symbol@ _) { False; });
   A@<Board@> b3 = For<Symbol@, A@<Board@>>(1, b2, IterateSymbol,
     (Symbol@ pos, A@<Board@> aboard) {
       Board@ board <- A<Board@, Board@>(aboard);
       UpdateCell(isThisPos(pos), CellOfPos(box, pos), x.symbol, board);
   });

   b3;
};

# Make all the given assignments to the board, and all resulting assignments,
# until there is nothing left to do.
(Board@, S@<Assign@>) { Board@; } AssignAll = (Board@ b, S@<Assign@> l) {
  ?(l;
    cons: {
      A@<Board@> ar = Assign(b, l.cons.head);
      AssignAll(ar._, Append<Assign@>(l.cons.tail, ar.assigns));
    },
    nil: b);
};

# Print a board.
# If spaced is true, insert whitespace to make it more legible.
# Otherwise, don't include any whitespace in the output.
(Bool@, Board@) { Str@; } ShowBoard = (Bool@ spaced) {
  (Symbol@) { Str@; } ShowSymbol = (Symbol@ s) {
    ?(s; 1: Str(Char@|1), 2: Str(Char@|2), 3: Str(Char@|3),
         4: Str(Char@|4), 5: Str(Char@|5), 6: Str(Char@|6),
         7: Str(Char@|7), 8: Str(Char@|8), 9: Str(Char@|9));
  };

  (Maybe@<Symbol@>) { Str@; } ShowMaybeSymbol = (Maybe@<Symbol@> m) {
    ?(m; just: ShowSymbol(m.just), nothing: Str(Char@|'.'));
  };

  (Cell@) { Str@; } ShowCell = (Cell@ cell) {
    ShowMaybeSymbol(Singleton(cell));
  };

  Str@ space = ?(spaced; true: Str(Char@|' '), false: S0<Char@>);
  Str@ nl = ?(spaced; true: S<Char@>([newline]), false: S0<Char@>);

  (Array@<Cell@>) { Str@; } ShowRow = (Array@<Cell@> row) {
    Concat<Char@>(S<Str@>([
      ShowCell(row(1)), ShowCell(row(2)), ShowCell(row(3)), space,
      ShowCell(row(4)), ShowCell(row(5)), ShowCell(row(6)), space,
      ShowCell(row(7)), ShowCell(row(8)), ShowCell(row(9)), nl
    ]));
  };

  (Board@ board) {
    Concat<Char@>(S<Str@>([
      ShowRow(board(1)), ShowRow(board(2)), ShowRow(board(3)), nl,
      ShowRow(board(4)), ShowRow(board(5)), ShowRow(board(6)), nl,
      ShowRow(board(7)), ShowRow(board(8)), ShowRow(board(9))
    ]));
  };
};

# Parse a set of assignments specified as a string of 89 characters specifying
# cell values. digits '1' through '9' are considered cell assignments. Any
# other character is interpreted as no assignment to that cell.
#
# For example, the initial board:
#
#   8.. .9. ..2
#   72. ... .49
#   ... 3.6 ...
#              
#   .5. .8. .16
#   ..9 ... 3..
#   67. .5. .9.
#              
#   ... 9.1 ...
#   96. ... .54
#   1.. .4. ..7
# 
# Is described using the string:
#
# 8...9...272.....49...3.6....5..8..16..9...3..67..5..9....9.1...96.....541...4...7
(Str@) { S@<Assign@>; } ParseAssigns = {
  (Symbol@){ Maybe@<Symbol@>; } J = Just<Symbol@>;

  (Str@, CellId@) { S@<Assign@>; } f = (Str@ str, CellId@ cell) {
    ?(str;
      cons: {
        Maybe@<Symbol@> mncol = IterateSymbol(cell.col);
        Symbol@ ncol = ?(mncol; just: mncol.just, nothing: 1);

        Maybe@<Symbol@> mnrow = ?(mncol;
          just: Just<Symbol@>(cell.row),
          nothing: IterateSymbol(cell.row));
        Symbol@ nrow = ?(mnrow; just: mnrow.just, nothing: 1);

        S@<Assign@> tail = f(str.cons.tail, CellId@(nrow, ncol));
        Maybe@<Symbol@> this = ?(str.cons.head;
          '1': J(1), '2': J(2), '3': J(3),
          '4': J(4), '5': J(5), '6': J(6),
          '7': J(7), '8': J(8), '9': J(9),
             : Nothing<Symbol@>);
        ?(this; just: ConsS<Assign@>(Assign@(cell, this.just), tail),
                nothing: tail);
      },
      nil: S0<Assign@>);
  };

  (Str@ str) { f(str, CellId@(1, 1)); };
};

# Solve a board as much as possible.
(Str@) { Str@; } Solve = (Str@ board) {
  ShowBoard(True, AssignAll(InitialBoard, ParseAssigns(board)));
};

# 8.. .9. ..2     816 497 532 
# 72. ... .49     723 518 649 
# ... 3.6 ...     495 326 781 
#                             
# .5. .8. .16     354 789 216 
# ..9 ... 3..     289 164 375 
# 67. .5. .9.     671 253 498 
#                             
# ... 9.1 ...     542 971 863 
# 96. ... .54     967 832 154 
# 1.. .4. ..7     138 645 927 

@(Solve);
