Cleanup Arc:
* Clean up all current fblc code.
  - all non-static functions should have a proper prefix.
  - document comments should be present and up to date.
  - code should be clean.

Space Invaders Arc:
* Rewrite testfblc as fblc-test in top of fblc library.
* Implement version of Checker that works on FblcProgram without symbols.
* Modify fblc-test to exercise {Read,Write}{Program,Value} functions
  - even though they aren't otherwise necessary to run.
* Remove expect_result_b tests.
* Replace expect_result and expect_proc_result with fblc-test
* Port tictactoe.c to use fblc interface
* Implement fbld front end to fblcbi.
* Port calc Integer to an fbld module.
* Implement space invaders game in fbld.

Miscellanous:
* Rename test/expect-malformed to test/fblc-check-error?
* Use consistent naming in spec tests to distinguish between:
  - Something with the wrong syntax, such as ???. "malformed"
  - Something that cannot be typed, such as x, when x is not defined.  "maltyped"
  - Something with the wrong type, such as Donut(), when Unit() is expected. "mistyped"

* Test that tail recursive functions and procedures don't smash the stack.
* Test that a link's type is valid.
* Test that a link action's ports can't shadow ports already in scope.
* Test that a link can't use the same name for the get and put ports.
* Test that a proc can't have multiple ports of the same name, with or without
  the same polarity.
* Test what happens when we try to access the wrong field of a union.

* Better document that for binary encodings of values, the top level value is
  guarenteed to take at least one bytes, regardless of whether or not it is
  part of a stream.

* Change fblc-check-error and friends to take the program last, and switch to
  a style where an anonymous program is passed rather than setting a $prg
  variable?

* Test writing a stream of Units
 - which requires some alignment be done.

* Test that error messages don't contain garbled characters.

* Write man pages for fblc and friends?

* Rethink arenas and documentation, because some cases appear to assume you
  have a bulk-free arena. Other cases its not well specified what is freed
  explicitly and what is expected to be freed implicitly.

* Reorder count and vector in FblcVector macros.

* In Parser have the caller parse the trailing semicolon for expressions
  intstead of the callee? That way we can return the expression right away in
  every branch.

Future:
* Implement compiler to C. Idea is translate a function body into a sequence
  of commands like we have in the current interpreter. Split the command
  sequence into blocks any place there is a function call. Gather up all the
  blocks of all the command sequences in the program, give each a unique name
  starting from zero, then generate a loop containing one large switch
  statement with a case for each block. Global state is a list of thread
  contexts. Thread context is a frame, which has variables, ports, the id of
  the block that currently needs to be executed, and a pointer to the frame to
  execute after executing this block.

* Implement compiler to hardware. Same idea as compiler to C: break up into
  blocks. Now each block can be its own hardware block. Frames are queued up
  at their block, all blocks can execute in parallel as inputs are available,
  and we can pipeline or duplicate the blocks to allow for even more
  parallelism.
