
@ Bool@ = /Bool%.Bool@;
% And = /Bool%.And;

@ Drawing@ = /Drawing%.Drawing@;
@ Point@ = /Drawing%.Point@;
@ Color@ = /Drawing%.Color@;
% Blank = /Drawing%.Blank;

@ Int@ = /Int/Int%.Int@;
% Add = /Int/Int%.Add;
% Sub = /Int/Int%.Sub;
% Mul = /Int/Int%.Mul;
% Neg = /Int/Int%.Neg;
% Le = /Int/Int/Eq%.Le;
% Gt = /Int/Int/Eq%.Gt;
% Div = /Int/Int/Div%.Div;
% Int = /Int/Int/Lit%.Int;

@ Mat@ = /Graphics/3D%.Mat@;
@ Vec@ = /Graphics/3D%.Vec@;
% AddV = /Graphics/3D%.AddV;
% SubV = /Graphics/3D%.SubV;
% MulMV = /Graphics/3D%.MulMV;
% MulMM = /Graphics/3D%.MulMM;
% DivMS = /Graphics/3D%.DivMS;
% DivVS = /Graphics/3D%.DivVS;
% Transpose = /Graphics/3D%.Transpose;

# Camera@ --
#   Describes the position and direction of the camera.
#
# Fields:
#   pos - The position of the camera, scaled by the factor RotF.
#   rot - Describes the rotation of the camera, as a matrix that rotates a
#         point into the basis of the camera. The basis of the camera is:
#           +x is to the right of the screen
#           +y is to the top of the screen
#           +z is into the screen
#         rot is an orthnormal matrix scaled by the factor RotF.
#   focus - The distance from the camera to the focus plane.
@ Camera@ = *(Vec@ pos, Mat@ rot, Int@ focus);

# RotF --
#   The scale factor used for the camera rotation matrix.
Int@ RotF = Int|256;

# Camera --
#   A camera at the origin with +x to the right of the screen, +y to the top
#   of the screen, and +z into the screen, with the given distance between
#   camera and focus plane.
(Int@) { Camera@; } Camera = (Int@ focus) {
  Camera@(
    Vec@(Int|0, Int|0, Int|0),
    Mat@(
      Vec@(RotF, Int|0, Int|0),
      Vec@(Int|0, RotF, Int|0),
      Vec@(Int|0, Int|0, RotF)),
    focus);
};

# Translate --
#   Move the camera by the given x, y, and z coordinates, relative to the
#   camera's current orientation.
(Int@, Int@, Int@, Camera@) { Camera@; }
Translate = (Int@ x, Int@ y, Int@ z, Camera@ camera) {
  Vec@ v_cam = Vec@(x, y, z);
  Vec@ v_abs = MulMV(Transpose(camera.rot), v_cam);
  Camera@(AddV(camera.pos, v_abs), camera.rot, camera.focus);
};

# RotateY --
#   Rotate the camera some small fixed amount about its own Y axis.
(Bool@, Camera@) { Camera@; } RotateY = (Bool@ clockwise, Camera@ camera) {
  # We pick a small angle θ to rotate where cos(θ) is approximately 255/256,
  # then sin(θ) is 23/256, and it takes about 71 rotations to make a full
  # circle.
  Int@ c = Int|255;
  Int@ s = clockwise.?(true: Int|23, false: Neg(Int|23));
  Mat@ m = Mat@(
    Vec@(c, Int|0, s),
    Vec@(Int|0, RotF, Int|0),
    Vec@(Neg(s), Int|0, c));
  Mat@ rot = DivMS(MulMM(m, camera.rot), RotF);
  Camera@(camera.pos, rot, camera.focus);
};

# Focus --
#   Change the distance to the focus plane by the given amount.
(Int@, Camera@) { Camera@; } Focus = (Int@ focus, Camera@ camera) {
  Camera@(camera.pos, camera.rot, Add(camera.focus, focus));
};

# Vertex --
#   Create a vertex out of a 3D point given the current camera.
#
# Maps from world coordinates to camera coordinates before projection to the
# screen.
(Camera@, Vec@) { Vec@; }
Vertex = (Camera@ camera, Vec@ p) {
  # Put the camera at the origin.
  Vec@ p_ = SubV(p, DivVS(camera.pos, RotF)); Vec@ p = p_;

  # Rotate the point around the origin/camera.
  DivVS(MulMV(camera.rot, p), RotF);
};

# ClippedTriangle --
#   Draw a triangle from the point of view of a camera, where the triangle has
#   already been clipped to be in front of the camera.
#
# The input points should all be from calling Vertex with the same camera.
# That is, the input points are relative to the position and orientation of
# the camera.
(Camera@, Vec@, Vec@, Vec@, Color@) { Drawing@; }
ClippedTriangle = (Camera@ camera, Vec@ a, Vec@ b, Vec@ c, Color@ color) {
  # Project the points onto the plane z = focus.
  Point@ a_ = Point@(
    Div(Mul(camera.focus, a.x), a.z),
    Div(Mul(camera.focus, a.y), a.z));
  Point@ b_ = Point@(
    Div(Mul(camera.focus, b.x), b.z),
    Div(Mul(camera.focus, b.y), b.z));
  Point@ c_ = Point@(
    Div(Mul(camera.focus, c.x), c.z),
    Div(Mul(camera.focus, c.y), c.z));
  /Graphics/2D%.Triangle(a_, b_, c_, color);
};

# Triangle --
#   Draw a triangle from the point of view of a camera.
#
# The input points should all be from calling Vertex with the same camera.
# That is, the input points are relative to the position and orientation of
# the camera.
(Camera@, Vec@, Vec@, Vec@, Color@) { Drawing@; }
Triangle = (Camera@ camera, Vec@ a, Vec@ b, Vec@ c, Color@ color) {
  # Rotate the points [a, b, c] such that any points behind the camera are at
  # the end of the list [a, b, c].
  % l = {
    And(Le(a.z, Int|0), Gt(b.z, Int|0)).?(true: @(a: b, b: c, c: a));
    And(Le(b.z, Int|0), Gt(c.z, Int|0)).?(true: @(a: c, b: a, c: b));
    @(a, b, c);
  };
  Vec@ a = l.a; Vec@ b = l.b; Vec@ c = l.c;

  Gt(c.z, Int|0).?(true: {
    # All points are in front of the camera.
    ClippedTriangle(camera, a, b, c, color);
  });

  Gt(b.z, Int|0).?(true: {
    # The point 'c' is behind the camera. Need to clip.
    # TODO: Proper clipping in this case.
    Blank;
  });

  Gt(a.z, Int|0).?(true: {
    # The points b and c are behind the camera. Need to clip.
    Vec@ b_ = @(
      x: Div(Add(Mul(a.x, Sub(Int|1, b.x)), Mul(b.x, Sub(a.x, Int|1))), Sub(a.z, b.z)),
      y: Div(Add(Mul(a.y, Sub(Int|1, b.y)), Mul(b.y, Sub(a.y, Int|1))), Sub(a.z, b.z)),
      z: Int|1);
    Vec@ c_ = @(
      x: Div(Add(Mul(a.x, Sub(Int|1, c.x)), Mul(c.x, Sub(a.x, Int|1))), Sub(a.z, c.z)),
      y: Div(Add(Mul(a.y, Sub(Int|1, c.y)), Mul(c.y, Sub(a.y, Int|1))), Sub(a.z, c.z)),
      z: Int|1);
    ClippedTriangle(camera, a, b_, c_, color);
  });

  # All points are outside of the camera. Skip drawing the triangle.
  Blank;
};

@(Camera@, Camera, Translate, RotateY, Focus, Vertex, Triangle);

