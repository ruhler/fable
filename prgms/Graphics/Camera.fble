
@ Bool@ = /Bool%.Bool@;

@ Drawing@ = /Drawing%.Drawing@;
@ Point@ = /Drawing%.Point@;
@ Color@ = /Drawing%.Color@;
% Blank = /Drawing%.Blank;

@ Int@ = /Int/Int%.Int@;
% Add = /Int/Int%.Add;
% Mul = /Int/Int%.Mul;
% Neg = /Int/Int%.Neg;
% Le = /Int/Int/Eq%.Le;
% Div = /Int/Int/Div%.Div;
% Int = /Int/Int/Lit%.Int;

@ Mat@ = /Graphics/3D%.Mat@;
@ Vec@ = /Graphics/3D%.Vec@;
% AddV = /Graphics/3D%.AddV;
% SubV = /Graphics/3D%.SubV;
% MulMV = /Graphics/3D%.MulMV;
% MulMM = /Graphics/3D%.MulMM;
% DivMS = /Graphics/3D%.DivMS;
% DivVS = /Graphics/3D%.DivVS;
% Transpose = /Graphics/3D%.Transpose;

# Camera@ --
#   Describes the position and direction of the camera.
#
# Fields:
#   pos - The position of the camera, scaled by the factor RotF.
#   rot - Describes the rotation of the camera, as a matrix that rotates a
#         point into the basis of the camera. The basis of the camera is:
#           +x is to the right of the screen
#           +y is to the top of the screen
#           +z is into the screen
#         rot is an orthnormal matrix scaled by the factor RotF.
#   focus - The distance from the camera to the focus plane.
@ Camera@ = *(Vec@ pos, Mat@ rot, Int@ focus);

# RotF --
#   The scale factor used for the camera rotation matrix.
Int@ RotF = Int|256;

# Camera --
#   A camera at the origin with +x to the right of the screen, +y to the top
#   of the screen, and +z into the screen, with the given distance between
#   camera and focus plane.
(Int@) { Camera@; } Camera = (Int@ focus) {
  Camera@(
    Vec@(Int|0, Int|0, Int|0),
    Mat@(
      Vec@(RotF, Int|0, Int|0),
      Vec@(Int|0, RotF, Int|0),
      Vec@(Int|0, Int|0, RotF)),
    focus);
};

# Translate --
#   Move the camera by the given x, y, and z coordinates, relative to the
#   camera's current orientation.
(Int@, Int@, Int@, Camera@) { Camera@; }
Translate = (Int@ x, Int@ y, Int@ z, Camera@ camera) {
  Vec@ v_cam = Vec@(x, y, z);
  Vec@ v_abs = MulMV(Transpose(camera.rot), v_cam);
  Camera@(AddV(camera.pos, v_abs), camera.rot, camera.focus);
};

# RotateY --
#   Rotate the camera some small fixed amount about its own Y axis.
(Bool@, Camera@) { Camera@; } RotateY = (Bool@ clockwise, Camera@ camera) {
  # We pick a small angle θ to rotate where cos(θ) is approximately 255/256,
  # then sin(θ) is 23/256, and it takes about 71 rotations to make a full
  # circle.
  Int@ c = Int|255;
  Int@ s = clockwise.?(true: Int|23, false: Neg(Int|23));
  Mat@ m = Mat@(
    Vec@(c, Int|0, s),
    Vec@(Int|0, RotF, Int|0),
    Vec@(Neg(s), Int|0, c));
  Mat@ rot = DivMS(MulMM(m, camera.rot), RotF);
  Camera@(camera.pos, rot, camera.focus);
};

# Focus --
#   Change the distance to the focus plane by the given amount.
(Int@, Camera@) { Camera@; } Focus = (Int@ focus, Camera@ camera) {
  Camera@(camera.pos, camera.rot, Add(camera.focus, focus));
};

# Vertex --
#   Create a vertex out of a 3D point given the current camera.
#
# Maps from world coordinates to camera coordinates before projection to the
# screen.
(Camera@, Vec@) { Vec@; }
Vertex = (Camera@ camera, Vec@ p) {
  # Put the camera at the origin.
  Vec@ p_ = SubV(p, DivVS(camera.pos, RotF)); Vec@ p = p_;

  # Rotate the point around the origin/camera.
  DivVS(MulMV(camera.rot, p), RotF);
};

# Triangle --
#   Draw a triangle from the point of view of a camera.
#
# The input points should all be from calling Vertex with the same camera.
# That is, the input points are relative to the position and orientation of
# the camera.
(Camera@, Vec@, Vec@, Vec@, Color@) { Drawing@; }
Triangle = (Camera@ camera, Vec@ a, Vec@ b, Vec@ c, Color@ color) {
  # TODO: Clip properly if any of the points are behind the camera.
  Le(a.z, Int|0).?(true: Blank);
  Le(b.z, Int|0).?(true: Blank);
  Le(c.z, Int|0).?(true: Blank);

  # Project the points onto the plane z = focus.
  Point@ a_ = Point@(
    Div(Mul(camera.focus, a.x), a.z),
    Div(Mul(camera.focus, a.y), a.z));
  Point@ b_ = Point@(
    Div(Mul(camera.focus, b.x), b.z),
    Div(Mul(camera.focus, b.y), b.z));
  Point@ c_ = Point@(
    Div(Mul(camera.focus, c.x), c.z),
    Div(Mul(camera.focus, c.y), c.z));
  /Graphics/2D%.Triangle(a_, b_, c_, color);
};

@(Camera@, Camera, Translate, RotateY, Focus, Vertex, Triangle);

