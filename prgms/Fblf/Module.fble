
<@>@ Export@ = /Fblf/Export%.Export@;

@ Program@ = /Fblf/Program%.Program@;
@ Proc@ = /Fblf/Program%.Proc@;
@ Var@ = /Fblf/Program%.Var@;
@ Stmt@ = /Fblf/Program%.Stmt@;
% Call = /Fblf/Program%.Call;
% Offset = /Fblf/Program%.Offset;

@ Int@ = /Int/Int%.Int@;
% Add = /Int/Int%.Add;
% Int = /Int/Int/Lit%.Int;
% Eq = /Int/Int/Eq%.Eq;
% Le = /Int/Int/Eq%.Le;

<@>@ List@ = /List%.List@;
<@>% Cons = /List%.Cons;
<@>% Nil = /List%.Nil;
<@,@>% Map = /List%.Map;
<@,@>% ForEach = /List%.ForEach;
<@>% Append = /List%.Append;
<@>% Contains = /List/Eq%.Contains;

@ String@ = /String%.String@;
% Str = /String%.Str;
% Strs = /String%.Strs;

@ Unit@ = /Unit%.Unit@;

# ModuleS@ --
#   The definition of a module.
#
# Fields: 
#   name - the name of the module.
#   heap - the number of bits required by the module on the heap.
#   procs - the processes defined directly in this module.
#   deps - the module's used directly in this module.
@ ModuleS@ = *(String@ name, Int@ heap, List@<Proc@> procs, List@<ModuleS@> deps);

# Module@ -- 
#   Monadic API used to define a collection of fblf procedures that share the
#   same internal state and module arguments.
#
# Fields:
#   name - the globally unique name of the current module.
#   this - pointer to 'this' internal state variable.
#   args - the list of arguments, not including 'this', passed to the module
#          when it was instantiated.
@ Read@ = *(Var@ this, List@<Var@> args);
<@>@ ModuleR@ = <@ T@> { *(ModuleS@ s, T@ x); };
<@>@ Module@ = <@ T@>(Read@, ModuleS@) { ModuleR@<T@>; };

# Helper function to make a variable that's relative to the intrernal state of
# a module.
(Int@) { Var@; } Local = (Int@ offset) {
  # The retured variable is relative to arg '0', which corresponds to 'this'.
  Var@(Int|0, offset);
};

# LocalArgs --
#  [s, s+1, ..., n]
(Int@, Int@) { List@<Var@>; } LocalArgs = (Int@ s, Int@ n) {
  Le(s, n).?(
    true: Cons<Var@>(Var@(s, Int|0), LocalArgs(Add(s, Int|1), n)),
    false: Nil<Var@>);
};

(List@<Var@>)(Var@) { Var@; } ExportVarImpl = (List@<Var@> args)(Var@ v) {
  Offset(/List/Length%.Drop<Var@>(v.id, args).cons.head, v.offset);
};

<@ T@>(Export@<T@>, String@, Int@, (List@<Var@>) { Module@<T@>; })(List@<Var@>) { Module@<T@>; }
Module = <@ T@>(Export@<T@> export, String@ name, Int@ argc, (List@<Var@>) { Module@<T@>; } body) {
  # Run the module in isolation to get it's definition.
  List@<Var@> local_args = LocalArgs(Int|1, argc);
  ModuleR@<T@> module = body(local_args)(
    Read@(Local(Int|0), local_args),
    ModuleS@(name, Int|0, Nil<Proc@>, Nil<ModuleS@>));

  # Return a function to the body of the module to get its returned value
  # relative to whatever module is instantiating it.
  (List@<Var@> args)(Read@ r, ModuleS@ s) {
    # TODO: Avoid adding duplicate modules to deps?
    T@ x = export(ExportVarImpl(Cons<Var@>(Local(s.heap), args)), module.x);
    ModuleR@<T@>(ModuleS@(s.name, Add(s.heap, module.s.heap), s.procs, Cons<ModuleS@>(module.s, s.deps)), x);
  };
};

# Module0 --
#   Define a module that takes no arguments.
<@ T@>(Export@<T@>, String@, Module@<T@>) { Module@<T@>; }
Module0 = <@ T@>(Export@<T@> export, String@ name, Module@<T@> body) {
  (List@<Var@>) { Module@<T@>; } f = Module<T@>(export, name, Int|0, (List@<Var@> _) { body; });
  f[];
};

# Module1 --
#   Define a module that takes 1 argument.
<@ T@>(Export@<T@>, String@, (Var@) { Module@<T@>; }) { (Var@) { Module@<T@>; }; }
Module1 = <@ T@>(Export@<T@> export, String@ name, (Var@) { Module@<T@>; } m) {
  (List@<Var@>) { Module@<T@>; } f = Module<T@>(export, name, Int|1, (List@<Var@> l) { m(l.cons.head); });
  (Var@ arg) { f[arg]; };
};

# Module2 --
#   Define a module that takes 2 arguments.
<@ T@>(Export@<T@>, String@, (Var@, Var@) { Module@<T@>; }) { (Var@, Var@) { Module@<T@>; }; }
Module2 = <@ T@>(Export@<T@> export, String@ name, (Var@, Var@) { Module@<T@>; } m) {
  (List@<Var@>) { Module@<T@>; } f = Module<T@>(export, name, Int|2, (List@<Var@> l) {
    m(l.cons.head,
      l.cons.tail.cons.head);
    });
  (Var@ arg1, Var@ arg2) { f[arg1, arg2]; };
};

# Module3 --
#   Define a module that takes 3 arguments.
<@ T@>(Export@<T@>, String@, (Var@, Var@, Var@) { Module@<T@>; }) { (Var@, Var@, Var@) { Module@<T@>; }; }
Module3 = <@ T@>(Export@<T@> export, String@ name, (Var@, Var@, Var@) { Module@<T@>; } m) {
  (List@<Var@>) { Module@<T@>; } f = Module<T@>(export, name, Int|3, (List@<Var@> l) {
    m(l.cons.head,
      l.cons.tail.cons.head,
      l.cons.tail.cons.tail.cons.head);
    });

  (Var@ arg1, Var@ arg2, Var@ arg3) { f[arg1, arg2, arg3]; };
};

# Module4 --
#   Define a module that takes 4 arguments.
<@ T@>(Export@<T@>, String@, (Var@, Var@, Var@, Var@) { Module@<T@>; }) { (Var@, Var@, Var@, Var@) { Module@<T@>; }; }
Module4 = <@ T@>(Export@<T@> export, String@ name, (Var@, Var@, Var@, Var@) { Module@<T@>; } m) {
  (List@<Var@>) { Module@<T@>; } f = Module<T@>(export, name, Int|4, (List@<Var@> l) {
    m(l.cons.head,
      l.cons.tail.cons.head,
      l.cons.tail.cons.tail.cons.head,
      l.cons.tail.cons.tail.cons.tail.cons.head);
    });
  (Var@ arg1, Var@ arg2, Var@ arg3, Var@ arg4) { f[arg1, arg2, arg3, arg4]; };
};

# Module5 --
#   Define a module that takes 5 arguments.
<@ T@>(Export@<T@>, String@, (Var@, Var@, Var@, Var@, Var@) { Module@<T@>; }) { (Var@, Var@, Var@, Var@, Var@) { Module@<T@>; }; }
Module5 = <@ T@>(Export@<T@> export, String@ name, (Var@, Var@, Var@, Var@, Var@) { Module@<T@>; } m) {
  (List@<Var@>) { Module@<T@>; } f = Module<T@>(export, name, Int|5, (List@<Var@> l) {
    m(l.cons.head,
      l.cons.tail.cons.head,
      l.cons.tail.cons.tail.cons.head,
      l.cons.tail.cons.tail.cons.tail.cons.head,
      l.cons.tail.cons.tail.cons.tail.cons.tail.cons.head);
    });

  (Var@ arg1, Var@ arg2, Var@ arg3, Var@ arg4, Var@ arg5) { f[arg1, arg2, arg3, arg4, arg5]; };
};

# Do --
#   Monadic bind for Module@ monad.
<@ A@, @ B@>(Module@<A@>)((A@) { Module@<B@>; }) { Module@<B@>; }
Do = <@ A@, @ B@>(Module@<A@> m)((A@) { Module@<B@>; } f)(Read@ r, ModuleS@ s) {
  ModuleR@<A@> a = m(r, s);
  f(a.x)(r, a.s);
};

# Return --
#   Monadic return for Module@ monad.
<@ T@>(T@) { Module@<T@>; }
Return = <@ T@>(T@ x)(Read@ r, ModuleS@ s) {
  ModuleR@<T@>(s, x);
};

# Alloc --
#   Allocate n bits on the heap for use in an instance of this module.
(Int@) { Module@<Var@>; } Alloc = (Int@ n)(Read@ r, ModuleS@ s) {
  ModuleR@<Var@>(ModuleS@(s.name, Add(s.heap, n), s.procs, s.deps), Local(s.heap));
};

<@ T@>(Int@)((Var@) { Module@<T@>; }) { Module@<T@>; }
DoAlloc = <@ T@>(Int@ n) { Do<Var@, T@>(Alloc(n)); };

# Method@ --
#   Method@ is used to represent a Call Stmt@.
#
# This is user documentation only. It is not enforced by the type system.
@ Method@ = Stmt@;

# Method --
#   Define a method of a module.
#
# Inputs:
#   name - the name of the method.
#   stmt - the body of the method.
(String@, Stmt@) { Module@<Method@>; }
Method = (String@ name, Stmt@ stmt)(Read@ r, ModuleS@ s) {
  String@ proc_id = Strs[s.name, Str|'.', name];
  Int@ argc = Add(/List/Length%.Length<Var@>(r.args), Int|1);
  Proc@ proc = Proc@(proc_id, argc, stmt);
  Stmt@ call = Call(proc_id)(Cons<Var@>(r.this, r.args));
  ModuleR@<Method@>(ModuleS@(s.name, s.heap, Cons<Proc@>(proc, s.procs), s.deps), call);
};

<@ T@>(String@, Stmt@)((Method@) { Module@<T@>; }) { Module@<T@>; }
DoMethod = <@ T@>(String@ name, Stmt@ body) { Do<Stmt@, T@>(Method(name, body)); };

# MethodArgs --
#   Extract the concrete arguments to supply to a method call for a method
#   returned from running the top level module.
#
# If a method is returned from the top level module, its args should all be
# relative to the 'this' var with id 0, which refers to bit 0 of the heap of a
# top level module.
#
# Behavior is undefined if the given method is not from a top level module.
(Method@) { List@<Int@>; } MethodArgs = (Method@ method) {
  Map<Var@, Int@>(method.call.args, (Var@ v) {
    Unit@ _ = Eq(Int|0, v.id).true;  # Assert
    v.offset;
  });
};

# Collect --
#   Collect all the procs needed for the given module.
#
# Args:
#   module - the module to collect from.
#   collected - includes the list of procs and modules collected so far.
#
# Returns:
#   The final set of collected procs.
@ Collected@ = *(List@<String@> modules, Program@ program);
(ModuleS@, Collected@) { Collected@; }
Collect = (ModuleS@ module, Collected@ collected) {
  Contains<String@>(/String/Eq%.Eq)(collected.modules, module.name).?(
   true: collected,
   false: {
     Collected@ nc = Collected@(
       Cons<String@>(module.name, collected.modules),
       Append<Proc@>(module.procs, collected.program));
     ForEach<ModuleS@, Collected@>(module.deps, nc, Collect);
   });
};

# Run --
#   Runs a module, returning the generated program, the size of the heap
#   required by the module, and whatever the module returns.
<@>@ Ran@ = <@ T@> { *(Program@ program, Int@ heap, T@ x); };
<@ T@>(Module@<T@>) { Ran@<T@>; } Run = <@ T@>(Module@<T@> m) {
  ModuleR@<T@> mr = m(
    Read@(Local(Int|0), Nil<Var@>),
    ModuleS@(Str|'', Int|0, Nil<Proc@>, Nil<ModuleS@>));
  Ran@<T@>(Collect(mr.s, Collected@(Nil<String@>, Nil<Proc@>)).program, mr.s.heap, mr.x);
};

@(Module@, Method@, Ran@,
  Module0, Module1, Module2, Module3, Module4, Module5,
  Do, Return, Alloc, DoAlloc, Method, DoMethod, MethodArgs,
  Run);
