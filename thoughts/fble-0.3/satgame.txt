Sat Game
========
Making sure we have enough experience programming in fble this release, let's
implement a sat game.

First step: have a nicer Random@ interface. Because I'd like to reuse code for
things like random integers and shuffling lists.

The current interface for Random is LFSR@. You can shift out a Bit@. I'd like
something monadic. Like:

<<@>@>@ Random@ = <<@>@ M@> { *(
  M@<Bit@> bit
);

Something like that. Build on top of that:

<<@>@ M@> {
  (Random@<M@>) { M@<Bool@>; } Bool;
  (Random@<M@>) { M@<Int@>; } Int;
  (Random@<M@>)<@ A@>(List@<A@>) { M@<List@<A@>>; } Shuffle;
  ...
};

---

The key to start is I don't want to have to reference LFSR@ or Shifted@.

Maybe start by defining Random@ as part of SatGame package. We can move it to
core if it turns out to be useful.

---

Draft of puzzle generation is done. It compiles, but crashes in a bad way at
runtime.

Three issues to investigate:
1. How it's getting tag 2 for a List@ value. This should be impossible. It's
not a bug in the satgame implementation. It must be a bug in the fble
implementation somewhere.

2. Why the stack trace for (1) says undefined function in multiple places.

3. Why number of clauses is 3 when asked for 6 using params 6 6 3 0.

Let's deal with the easy one first.

Clauses added should be:

num_free_vars = num_vars - num_vars_per_clause = 6 - 3 = 3.
clauses_per_variable = (3 + 3 - 1) / 3 = 1.

That's clearly wrong. We didn't even ask how many clauses we wanted here. It
should be: num_clauses / num_free_vars rounded up.

Let's add a test suite and then fix this.

---

(3) is fixed.

Here's the stack trace:

@[SatGame.Generate.Length]: ../pkgs/satgame/SatGame/Random/List.fble:28:7:
error: union field access undefined: wrong tag
../pkgs/satgame/SatGame/Random/List.fble:30:25: error: callee aborted
../pkgs/satgame/SatGame/Random/List.fble:19:22: error: callee aborted
../pkgs/satgame/SatGame/Random/List.fble:29:22: error: callee aborted
../pkgs/satgame/SatGame/Random/List.fble:30:25: error: callee aborted
../lib/value.c:1400:5: error: called undefined function
../pkgs/core/Core/Monad/State.fble:17:19: error: callee aborted
../pkgs/core/Core/Monad/State.fble:17:19: error: callee aborted
../pkgs/core/Core/Monad/State.fble:17:19: error: callee aborted
../pkgs/core/Core/Monad/State.fble:17:19: error: callee aborted
../pkgs/core/Core/Monad/State.fble:17:19: error: callee aborted
../pkgs/core/Core/Monad/State.fble:17:19: error: callee aborted
../pkgs/core/Core/Monad/State.fble:17:19: error: callee aborted
../pkgs/satgame/SatGame/Random/PureLFSR.fble:35:3: error: callee aborted
../pkgs/satgame/SatGame/Tests.fble:31:22: error: callee aborted
../pkgs/core/Core/Test/Run.fble:36:28: error: callee aborted
../lib/value.c:1400:5: error: called undefined function

Does that make any sense at all?

Maybe. We are returning a function, we return NULL when we abort, that creates
an 'undefined' function value. But why would I call that function?

Okay. I bet the case is: we do an overapplication or something to a function
that returns NULL. We should do something smarter there.

Also: why '../' for all the paths. Isn't that strange?

---

Here's the code in question:

  (List@<T@>) { M@<List@<T@>>; } S = (List@<T@> l) {
    l.?(nil: m.return(l));
    l.cons.tail.?(nil: m.return(l));
    Split@ s <- m.do(Split(l));
    List@<T@> a <- m.do(Shuffle(m, r, s.a));
    List@<T@> b <- m.do(Shuffle(m, r, s.b));
    m.return(Append(a, b));
  };

The first time we call Split, it returns
  s.a = 0x3117766445bb3 - same as the initial l.cons.tail
  s.b = 0x318bb33 - must be equivalent to List[l.cons.head],
     where l.cons.head is 0x62ed

Now we call Split again on s.a. It returns:
  0x188bbb33
  That's clearly wrong, because that's a union, and Split@ should be a struct.

So, next step for debug is to trace through the implementation of
Split(0x31177664445bb3) and figure out how it can be returning the wrong type
of object.

---

Based on the symptoms, my guess for what could be happening is a stack
allocated value is being returned and referenced after the stack is popped, we
allocate a new value on top of it, then we access a field. The field contains
the wrong packed value.

Let's debug to see what's really going on.

---

We do a tail call to Split, but instead of it passing the list argument
to split, it passes that list argument to the anonymous function 'S!.:.:!'.

Specifically, the function being called is
  0x533c48 GC allocated RefValue pointing to
  0x7ff7d58ad9 stack allocated FuncValue for 'S!.:.:!'.

In theory the arg should be statics[1] of the Split function, which is
definitely supposed to be 'Split'.

Somehow we get a Gc Value pointing to a stack allocated value. That's not
allowed, right? Because if it is, GcRealloc will not work correctly.

I see. Bug: when we assign a value to a ref value, we need to GcRealloc that
value. Otherwise things go bad.

Can I write a regression test for this? Should be able to.

1. Create a ref value. It's value should be an object allocated on the stack.
2. Return the ref value sufficiently far to pop the from of the stack
allocated value.
3. Do a nested call to clobber the stack with garbage.
4. Try to access the original ref value's value in a meaningful way.

Ugh. I tried reproducing it in a small test case. It's not reproducing.
