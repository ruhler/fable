
@ Char@ = /Char%.Char@;

@ Bit@ = /Digits%.Bit@;

% Int = /Int/Int/Lit%.Int;

<@>@ List@ = /List%.List@;
<@>% Cons = /List%.Cons;
<@>% Nil = /List%.Nil;
<@>% Append = /List%.Append;
<@,@>% ForEach = /List%.ForEach;

<@>% Length = /List/Length%.Length;

@ Output@ = /Fblf/Compile/Output%.Output@;
% Line = /Fblf/Compile/Output%.Line;
% Do = /Fblf/Compile/Output%.Do;
% Return = /Fblf/Compile/Output%.Return;

<@>@ Module@ = /Fblf/Module%.Module@;
<@>@ ModuleM@ = /Fblf/Module%.ModuleM@;
<@>@ Ran@ = /Fblf/Module%.Ran@;
@ Method@ = /Fblf/Module%.Method@;
% Method = /Fblf/Module%.Method;
% MethodArgs = /Fblf/Module%.MethodArgs;
<@>% Module0 = /Fblf/Module%.Module0;
<@>% Module1 = /Fblf/Module%.Module1;
<@>% Run = /Fblf/Module%.Run;
<@,@>% DoInst = /Fblf/Module%.DoInst;
<@>% DoAlloc = /Fblf/Module%.DoAlloc;

@ Var@ = /Fblf/Program%.Var@;
% Assign = /Fblf/Program%.Assign;
% Binary = /Fblf/Program%.Binary;
% Var = /Fblf/Program%.Var;
% Seq = /Fblf/Program%.Seq;
% IfElse = /Fblf/Program%.IfElse;
% Eq = /Fblf/Program%.Eq;

@ Test@ = /Fblf/Test%.Test@;
@ TestInstance@ = /Fblf/Test%.TestInstance@;

@ String@ = /String%.String@;
% Str = /String%.Str;
% Strs = /String%.Strs;

@ Unit@ = /Unit%.Unit@;

# Test Module: given single bit variable 'pass', sets it to true if the test
# succeeds, false otherwise.
@ TM@ = List@<Method@>;

# Collect all the individual test cases from a test suite into a single module.
(Var@, String@, Test@, List@<Method@>) { ModuleM@<TM@>; } Collect = (Var@ pass, String@ prefix, Test@ test, List@<Method@> tail) {
  test.?(
    case: {
      String@ name = Append<Char@>(prefix, test.case.name);
      (Var@) { Module@<Method@>; } tm = Module1<Method@>(name, (Var@ pass) {
        TestInstance@ ti <- DoInst<TestInstance@, Method@>(test.case.test);

        Method(Seq[
          Assign(pass, Binary|0, Int|1),
          ti.method,
          IfElse(Eq(Var(ti.result), Binary(ti.expected), Length<Bit@>(ti.expected)),
            Assign(pass, Binary|1, Int|1),
            Assign(pass, Binary|0, Int|1))
        ]);
      });

      Method@ method <- DoInst<Method@, TM@>(tm(pass));
      /Fblf/Module%.Return<TM@>(Cons<Method@>(method, tail));
    },
    suite: {
      String@ nprefix = Strs[prefix, test.suite.name, Str|'.'];
      ModuleM@<TM@> base = /Fblf/Module%.Return<TM@>(tail);
      ForEach<Test@, ModuleM@<TM@>>(test.suite.tests, base, (Test@ t, ModuleM@<TM@> m) {
        List@<Method@> as <- /Fblf/Module%.Do<List@<Method@>, TM@>(m);
        Collect(pass, nprefix, t, as);
      });
    });
};

# Compile --
#   Compiles an fblf test suite into a C file that runs all the tests.
(Test@) { Output@; } Compile = (Test@ t) {
  Unit@ _ <- Do(Line|'#include <assert.h>');
  Unit@ _ <- Do(Line|'');
  Unit@ _ <- Do(Line|'#include "heap.h"');
  Unit@ _ <- Do(Line|'');

  Module@<List@<Method@>> test_module = Module0<List@<Method@>>(Str|'TestsModule', {
    Var@ pass <- DoAlloc<TM@>(Int|1);
    Collect(pass, Str|'', t, Nil<Method@>);
  });

  Ran@<List@<Method@>> ran = Run<List@<Method@>>(test_module);

  Unit@ _ <- Do(/Fblf/Compile%.Compile(Str|'_prog', ran.program));

  Unit@ _ <- Do(Line|'int main()');
  Unit@ _ <- Do(Line|'{');
  Unit@ _ <- Do(Line(Strs[
    Str|'  FblfHeapWord heap[FBLF_HEAP_WORDS_FOR_BITS(',
    /Int/Int/Show%.Show(ran.heap),
    Str|')];'
  ]));
    
  Unit@ _ <- Do(ForEach<Method@, Output@>(ran.x, Return, (Method@ method, Output@ o) {
    Unit@ _ <- Do(o);
    Unit@ _ <- Do(/Fblf/Compile%.CompileUserCall(Str|'_prog', Str|'  ', Str|'heap', method.call.proc, MethodArgs(method)));
    Unit@ _ <- Do(Line|'  assert(FblfHeapRead(heap, 0, 1) == 1);');
    Return;
  }));

  Unit@ _ <- Do(Line|'  return 0;');
  Unit@ _ <- Do(Line|'}');
  Return;
};

@(Compile);
