Revisiting Fble Profiling
=========================
For two reasons:
1. We've hit the bug where we say AUTO_EXIT, but fail to do an ENTER right
after that, which messes up the stack and is producing bad profile data.

In this case because we do a tail call of a PUT value, and the PUT function
doesn't do a profile ENTER.

More generally, I've known that AUTO_EXIT is dangerous for a while and that we
should switch to REPLACE. Maybe now's the time to figure that out.

2. We ought to support profiling with compiled code. So that we can get rid of
the interpreter entirely if we want, and because we just ought to.

Let's start with (1).

To be clear about the bug, we have the following call structure:

R calls A
  A calls B
    B tail calls C
  A calls D

So the profile should say:
  R called A
  A called B, D
  B called C

Normally this is done as:

(init)              R
ENTER_A             R->A
ENTER B             R->A->B
AUTO_EXIT (B)       R->A->B
ENTER C             R->A->B->C
EXIT (C)            R->A
ENTER D             R->A->D
EXIT (D)            R->A
EXIT (A)            R

But in this case we don't have the ENTER C or EXIT (C). So instead we get:

(init)              R
ENTER_A             R->A
ENTER B             R->A->B
AUTO_EXIT (B)       R->A->B
ENTER D             R->A->B->D
EXIT (D)            R->A
EXIT (A)            R

And now it looks like B called D, when it did not.

The proposed fix is to replace AUTO_EXIT with REPLACE:

(init)              R
ENTER_A             R->A
ENTER B             R->A->B
REPLACE C           R->A(->B)->C
EXIT (C)            R->A
ENTER D             R->A->D
EXIT (D)            R->A
EXIT (A)            R

But that requires more coordination between B and C than we currently have
infrastructure for in the fble ISA. IN particular, B has to say if it's a tail
call or not, and C has to say what block is being called into.

---

I bet we've been running into this profiling issue unnoticed for a while now.

There are two places we use AUTO_EXIT in practice:
1. For exiting select expressions, where we know (by assumption between
compile.c and typecheck.c) that we will do an ENTER/EXIT around each branch.

2. For tail calls, where we don't know what function will be called, but we
assume (incorrectly) that the function will start with an ENTER call.

Regardless of whether we use AUTO_EXIT or REPLACE, it seems like we have to
require every function to have a profiling block associated with it. The
function we call has to mark when it exits, otherwise we can't properly track
instructions executed by the function. Unless we assume there will be no
samples in the body of the function?

The tricky part about this is how do we know what profiling block ID to use
for PUT and GET values, given those function's were not generated by the
compiler? More generally, how to handle any user constructed functions, where,
once again, the compiler didn't generate the function, so we don't know what
block ID to use for it?

Note that blocks are uniquely determined by name and location (because the
user couldn't tell the difference otherwise). Name alone is not enough. I see
in practice we have some blocks with the same names. May or may not be a bug,
but it doesn't seem unreasonable to have two blocks with the same name in
general.

I feel like we ought to just have every FbleExecutable* have a profile block
id associated with it. When you call it, that enters the profile block. When
you return from it, that exits the profile block. The executable can do it's
own enter/exit inside that if it wants to, the caller need not care.

For PUT and GET functions, it would be great for the profile block to be named
and located based on the link where they are declared. How about we require
the user to pass a block ID as input to FbleNewGetValue and
FbleNewPutValue?

For profiling with compilation, how about we say block ids in generated code
are relative to the FbleExecutable block, and we reserve the FbleExecutable
block id when we allocate the (top level) FbleExecutable. Perhaps an
FbleExecutable keeps track of how many profile block ids it wants.

Maybe we shouldn't be reallocating FbleExecutable for every new function in
the generated code...

That all sounds reasonable and doable to me. Add Profile as an argument to the
compiler generated linking function so we can add profiling block info then.

Is there any way we could turn off profiling for a function? Like have a
special profile ID that means: don't take stats on this transition, just keep
proper track of the stack. Then you could always use the special profile ID if
you don't want to support profiling. That would allow you to mix profiling
code with non-profiling code. And then we could make GET and PUT functions
non-profiling code to start. Which probably makes the most sense for them
anyway.

The last bit needed for profiling compiled code is a reasonably efficient way
to sample. In the interpreter we randomly sample about 0.1% of the time on
every instruction. Could we group instructions together somehow so we only
have to sample when we come into an instruction? But what if there are
multiple ENTER/EXITs in a block?

I suppose we could just emit a call to a Sample function before each
instruction, and worry about optimizing later. Yeah. That sounds good.

I wonder if this notion of a phantom block ID could be an easy fix for the
AUTO_EXIT issue? No. We would need a phantom EXIT call that corresponds to a
phantom REPLACE call, and that's what we are missing today.

