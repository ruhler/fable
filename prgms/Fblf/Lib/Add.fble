
% B = /Digits%.Bit;

@ Addr@ = /Fblf/Program%.Addr@;
@ Value@ = /Fblf/Program%.Value@;
@ ProgramM@ = /Fblf/Program%.ProgramM@;
@ Module@ = /Fblf/Program%.Module@;
% Assign = /Fblf/Program%.Assign;
% Eq = /Fblf/Program%.Eq;
% If = /Fblf/Program%.If;
% Seq = /Fblf/Program%.Seq;
% Noop = /Fblf/Program%.Noop;
% Const = /Fblf/Program%.Const;
% Ref = /Fblf/Program%.Ref;

@ Int@ = /Int/Int%.Int@;
% Add = /Int/Int%.Add;
% Sub = /Int/Int%.Sub;
% Le = /Int/Int/Eq%.Le;

% D = /Int/Int/Lit%.D;
% I = /Int/Int/Lit%.I;

<@>@ Maybe@ = /Maybe%.Maybe@;
<@>% Just = /Maybe%.Just;
<@>% Nothing = /Maybe%.Nothing;

<@,@>% For = /Loop%.For;

# Add1F --
#   A 1-bit adder.
#
# Inputs:
#   a - The address of the first operand.
#   b - The address of the second operand.
#   c - The address of carry bit in.
#   x - The address of the carry bit out.
#   z - The address of where to store the result of the addition.
#
# Results:
#   A program that sets x and z based on the one bit addition a + b + c.
(Addr@, Addr@, Addr@, Addr@, Addr@) { Module@; }
Add1F = (Addr@ a, Addr@ b, Addr@ c, Addr@ x, Addr@ z)(Addr@ free) {
  Int@ n1 = I(D|1);
  Value@ b0 = Const(B|0);
  Value@ b1 = Const(B|1);
  @(free: free,
    program: Seq([
      If(Eq(Ref(a), b0, n1),
        Seq([
          If(Eq(Ref(b), b0, n1),
            Seq([Assign(z, Ref(c), n1), Assign(x, b0, n1)])),
          If(Eq(Ref(b), b1, n1),
            Seq([
              If(Eq(Ref(c), b0, n1),
                Seq([Assign(z, b1, n1), Assign(x, b0, n1)])),
              If(Eq(Ref(c), b1, n1),
                Seq([Assign(z, b0, n1), Assign(x, b1, n1)]))]))])),
      If(Eq(Ref(a), b1, n1),
        Seq([
          If(Eq(Ref(b), b0, n1),
            Seq([
              If(Eq(Ref(c), b0, n1),
                Seq([Assign(z, b1, n1), Assign(x, b0, n1)])),
              If(Eq(Ref(c), b1, n1),
                Seq([Assign(z, b0, n1), Assign(x, b1, n1)]))])),
          If(Eq(Ref(b), b1, n1),
            Seq([Assign(z, Ref(c), n1), Assign(x, b1, n1)]))]))]));
};

# AddF -- 
#   An n-bit adder, with most significant bit first.
#
# Inputs:
#   n - The number of bits to add together.
#   a - The address of the first operand.
#   b - The address of the second operand.
#   z - The address of where to store the result of the addition.
(Int@, Addr@, Addr@, Addr@) { Module@; }
AddF = (Int@ n, Addr@ a, Addr@ b, Addr@ z)(Addr@ free) {
  # We need a single bit of internal state to store the carry bit as we do
  # the addition.
  Addr@ carry = free;

  (Int@) { Maybe@<Int@>; } next = (Int@ i) {
    /Int/Int/Eq%.Le(i, I(D|0)).?(true: Nothing<Int@>, false: Just<Int@>(Sub(i, I(D|1))));
  };

  Value@ b0 = Const(B|0);
  For<Int@, ProgramM@>(next(n), next,
    ProgramM@(Add(free, I(D|1)), Assign(carry, b0, I(D|1))),
    (Int@ i, ProgramM@ s) {
      ProgramM@ add1 = Add1F(Add(a, i), Add(b, i), carry, carry, Add(z, i))(s.free);
      ProgramM@(add1.free, Seq([s.program, add1.program])); 
    });
};

# IncF --
#   Increment an n-bit number by 1.
#
# Inputs:
#   n - The number of bits of the number to increment.
#   a - The address of the value to increment. The value is most significant
#       bit first.
(Int@, Addr@) { Module@; }
IncF = (Int@ n, Addr@ a)(Addr@ free) {
  Le(n, I(D|0)).?(
    true: ProgramM@(free, Noop),
    false: {
      Int@ nm1 = Sub(n, I(D|1));
      Addr@ lsb = Add(a, nm1);
      Addr@ tmp = free;
      ProgramM@ s = IncF(nm1, a)(Add(free, I(D|1)));
      ProgramM@(s.free, Seq([
          Assign(tmp, Ref(lsb), I(D|1)),
          If(Eq(Ref(tmp), Const(B|0), I(D|1)),
            Assign(lsb, Const(B|1), I(D|1))),
          If(Eq(Ref(tmp), Const(B|1), I(D|1)),
            Seq([Assign(lsb, Const(B|0), I(D|1)), s.program]))]));
    });
};

@(AddF, IncF);
