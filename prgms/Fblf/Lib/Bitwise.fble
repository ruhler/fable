% BitStr = /Digits/String%.BitStr;

@ Addr@ = /Fblf/Program%.Addr@;
@ Program@ = /Fblf/Program%.Program@;
% Assign = /Fblf/Program%.Assign;
% Eq = /Fblf/Program%.Eq;
% IfElse = /Fblf/Program%.IfElse;
% Seq = /Fblf/Program%.Seq;
% Noop = /Fblf/Program%.Noop;
% Const = /Fblf/Program%.Const;
% Ref = /Fblf/Program%.Ref;

<@>@ Module@ = /Fblf/Module%.Module@;
<@>% PureM = /Fblf/Module%.PureM;

@ Int@ = /Int/Int%.Int@;
% Add = /Int/Int%.Add;
% Sub = /Int/Int%.Sub;
% Lt = /Int/Int/Eq%.Lt;

% Int = /Int/Int/Lit%.Int;

% CountUpTo = /Int/Int/Iter%.CountUpTo;
<@,@>% For = /Iter%.For;


# Bitwise --
#   Helper function for describing modules that implement bitwise computation.
#
# Inputs:
#   n - the number of bits.
#   f - the program to execute to compute the ith bit.
#
# Results:
#   A module that computes each bit in sequence.
(Int@, (Int@) { Program@; }) { Module@<Program@>; }
Bitwise = (Int@ n, (Int@) { Program@; } f) {
  PureM<Program@>(For<Int@, Program@>(CountUpTo(n), Noop, (Int@ i, Program@ s) {
    Seq[s, f(i)];
  }));
};

# AndM --
#   n-bit bitwise AND.
#
# Inputs:
#   n - The number of bits in each operand.
#   a - The address of the first operand.
#   b - The address of the second operand.
#   z - The address of the result.
(Int@, Addr@, Addr@, Addr@) { Module@<Program@>; }
AndM = (Int@ n, Addr@ a, Addr@ b, Addr@ z) {
  Bitwise(n, (Int@ i) {
    Addr@ ai = Add(a, i);
    Addr@ bi = Add(b, i);
    Addr@ zi = Add(z, i);

    IfElse(Eq(Ref(ai), Const(BitStr|0), Int|1),
      Assign(zi, Const(BitStr|0), Int|1),
      Assign(zi, Ref(bi), Int|1));
  });
};

# OrM --
#   n-bit bitwise OR.
#
# Inputs:
#   n - The number of bits in each operand.
#   a - The address of the first operand.
#   b - The address of the second operand.
#   z - The address of the result.
(Int@, Addr@, Addr@, Addr@) { Module@<Program@>; }
OrM = (Int@ n, Addr@ a, Addr@ b, Addr@ z) {
  Bitwise(n, (Int@ i) {
    Addr@ ai = Add(a, i);
    Addr@ bi = Add(b, i);
    Addr@ zi = Add(z, i);

    IfElse(Eq(Ref(ai), Const(BitStr|1), Int|1),
      Assign(zi, Const(BitStr|1), Int|1),
      Assign(zi, Ref(bi), Int|1));
  });
};

# XorM --
#   n-bit bitwise XOR.
#
# Inputs:
#   n - The number of bits in each operand.
#   a - The address of the first operand.
#   b - The address of the second operand.
#   z - The address of the result.
(Int@, Addr@, Addr@, Addr@) { Module@<Program@>; }
XorM = (Int@ n, Addr@ a, Addr@ b, Addr@ z) {
  Bitwise(n, (Int@ i) {
    Addr@ ai = Add(a, i);
    Addr@ bi = Add(b, i);
    Addr@ zi = Add(z, i);

    IfElse(Eq(Ref(ai), Const(BitStr|0), Int|1),
      Assign(zi, Ref(bi), Int|1),
      IfElse(Eq(Ref(bi), Const(BitStr|0), Int|1),
        Assign(zi, Const(BitStr|1), Int|1),
        Assign(zi, Const(BitStr|0), Int|1)));
  });
};

# NotM --
#   n-bit bitwise NOT.
#
# Inputs:
#   n - The number of bits in the operand.
#   a - The address of the operand.
#   z - The address of the result.
(Int@, Addr@, Addr@) { Module@<Program@>; }
NotM = (Int@ n, Addr@ a, Addr@ z) {
  Bitwise(n, (Int@ i) {
    Addr@ ai = Add(a, i);
    Addr@ zi = Add(z, i);

    IfElse(Eq(Ref(ai), Const(BitStr|1), Int|1),
      Assign(zi, Const(BitStr|0), Int|1),
      Assign(zi, Const(BitStr|1), Int|1));
  });
};

# ClsM --
#   n-bit circular left shift.
#
# Inputs:
#   n - The number of bits in the operand.
#   s - The number of bits to shift left.
#   a - The address of the operand.
#   z - The address of the result.
(Int@, Int@, Addr@, Addr@) { Module@<Program@>; }
ClsM = (Int@ n, Int@ s, Addr@ a, Addr@ z) {
  Bitwise(n, (Int@ i) {
    Addr@ ai = Add(a, i);
    Int@ offset = Lt(i, s).?(
      true: Sub(Add(n, i), s),
      false: Sub(i, s));
    Addr@ zi = Add(z, offset);

    Assign(zi, Ref(ai), Int|1);
  });
};

@(AndM, OrM, XorM, NotM, ClsM);
