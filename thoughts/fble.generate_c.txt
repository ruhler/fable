Fble Generate C
===============
It's been a while since we tried generating c code for fble compilation. Now
that we're considering cross platform support, seems like it's worth trying
again.

The problem we had with generating C before was that it took too much memory
(>1GB) to compile the generated C code. A lot of things have changed in fble
since then. Perhaps most importantly, we pass list and literals all the way
through the compiler instead of desugaring them first. Also, we are single
threaded now and have a standard way of supporting tail recursion at the C
level.

The benefits of generating C code are:
* Support all platforms we can build fble for without any extra dependencies.

The potential disadvantages of C code, compared to custom assembly:
* Compile time memory and performance costs.
* Runtime performance costs.

My vote is to give it a try, again. See if we can get past the compile time
memory costs and how close we can get to runtime performance. This will help a
lot for cross platform support.

How about I do it from scratch, ish. Based of generate_aarch64.

Initial thoughts looking over generate_aarch64:
* I think there's a lot of code we can reuse from aarch64. My vote is reuse by
  copy-paste, under the assumption we keep either one or the other in the end,
  but likely not both.
* Function args: heap, thread, locals, statics, profile
* Don't worry about debug info to start.

There will be some tricky parts, but for the most part, I think it should be
straight forward.

First step: wire up some stub code and make it so I can run it.

---

How can we do debug info? Like, what does bison do in its generated code?

We have pragmas like:

#line 3 "fble/lib/parse.y"

Let's start with that then.

---

I'm getting close. Some observations:
* The #line pragmas are making debug the code generation logic annoying. Can I
  get rid of them for now? I don't think they work the way I think either. I
  think we need a separate way to get dwarf.
* I'm getting real mixed up on what GenerateCMain and GenerateCExport should
  do.

GenerateCMain:
int main(int argc, const char** argv) {
  return <main>(argc, argv, <compiled module>);
}

Type of <compiled module> is FbleCompiledModuleFunction.

That looks fine.

Next, GenerateCExport: it should take a heap as input. What does it do? I
guess it should call the module function, passing the heap argument?

Maybe my comment in the documentation is wrong? The assembly code is literally
branching to the module function and returning the result. It must be passing
all the arguments directly.

Uh... I'm lost.

FbleCompiledModuleFunction is a function that, given a program, adds the
module to that program. That's what we define. What's what we call to ensure
dependencies are loaded, right? That's what we pass to a main function to be
able to instantiate a program. Export 'main' invokes main function on that,
and that's what we generate code for. That all makes sense.

What I don't understand is the CExport function. What type is that supposed to
have? I assume it's supposed to be a wrapper something or other?

According to docs, the exported function should return a zero argument fble
function that can be executed to compute the value of the given module. How
does it work? I don't understand what generate_aarch64 is doing. That can't be
correct, can it?

Step back. How would I generate the FbleValue in the first place?

I think the documentation is wrong. That must be out of date. It should just
give a nice name to the FbleCompiledModuleFunction with the internal name,
that is: void X(FbleExecutableProgram* program), right? Yeah. That makes
sense.

Next issue: Need to generate prototypes for all Run and Abort functions up
front.

Notes:
* Double check if spec tests are using the c target or aarch64. I think it may
  be different.
* Will want to clean up includes of execute.h, value.h at some point.
* Memory use for compiling the generated c code is looking not too bad so far?
* Runtime for compiling the generated code isn't great.

Actually, we're starting to hit issues with gcc memory use to compile the
generated code. Let's see if I can find out which one it is.

  out/pkgs/md5/Md5/Rounds.fble.c

It's 100K lines of C code. Ugh.

Well, something to dig into next:
* Why is Rounds.fble.c so big. Anything we can do to cut that down by an order
  of magnitude?
* Try running just the spec tests with -c target, see if everything passes.

