
@ Bool@ = /Bool%.Bool@;
% True = /Bool%.True;
% False = /Bool%.False;
% Not = /Bool%.Not;
% Or = /Bool%.Or;

@ Coord@ = /Hwdg/Coord%.Coord@;
@ Data@ = /Hwdg/Data%.Data@;
@ Memory@ = /Hwdg/Memory%.Memory@;

% Inc = /Int/Int%.Inc;
% 0 = /Int/Int%.0;

<@>@ List@ = /List%.List@;

<@>@ Maybe@ = /Maybe%.Maybe@;
<@>% Just = /Maybe%.Just;
<@>% Nothing = /Maybe%.Nothing;

<@>@ Set@ = /Set%.Set@;

# Ports@ --
#   Convenience type for capturing information about each of the 4 adjacent
#   ports in a gate: upper left, upper right, lower left, lower right.
<@>@ Ports@ = <@ T@> { *(T@ ul, T@ ur, T@ ll, T@ lr); };

# PortSpec@ --
#   Describes how a given port is used in a gate.
#
# Input Port:
#   A gate cannot operate unless there is data available on all of its input ports.
#   The data on an input port is consumed as a result of operating the gate.
#
# Output Port:
#   A gate cannot operate unless there is space on all of its output ports
#   (after consuming any data on input ports). Data is written to an output
#   port as a result of operating the gate.
#
# A single port can be both an input and an output port. In this case there
# must be data available for the gate to operate. Conceptually that data will
# be consumed and new data written in its place as a result of operating the
# gate.
# 
# A single port may be neither an input or an output port for a particular
# gate. This means the port is unused.
@ PortSpec@ = *(Bool@ input, Bool@ output);
PortSpec@ In = PortSpec@(True, False);
PortSpec@ Out = PortSpec@(False, True);
PortSpec@ InOut = PortSpec@(True, True);
PortSpec@ Unused = PortSpec@(False, False);

(PortSpec@) { Bool@; } IsUsed = (PortSpec@ ps) { Or(ps.input, ps.output); };
(PortSpec@) { Bool@; } IsUnused = (PortSpec@ ps) { Not(IsUsed(ps)); };

# GateFunction@ --
#   Describes the behavior of a gate when it is triggered.
#
# Input:
#   The data value for each port, with 0 passed for any non-input port.
#
# Result:
#   The new data value for each port, where values for non-output ports are
#   ignored.
@ GateFunction@ = (Ports@<Data@>) { Ports@<Data@>; };

# Gate@ --
#   The primitive atomic computation block in a design.
#
# A gate updates memory according to 'function' when its ports are in an
# appropriate state to execute.
@ Gate@ = *(Ports@<PortSpec@> ports, GateFunction@ function);

# Design@ --
#   Either a single gate, or a collection of designs placed at various
#   locations relative to the overall design.
#
# Designs are Placed@ relative to the origin at the upper left most point in
# the design.
@ Design@ = +(Gate@ gate, List@<Placed@> designs),
@ Placed@ = *(Coord@ coord, Design@ design);

# ForEachGatePlaced --
#   Iterate over the set of gates in a Placed@ design.
#
# Conceptually:
#   B@ b = base
#   foreach (coord, gate) in gates:
#     b = body(coord, gates, b)
#   return b
<@ B@>(Placed@, B@, (Coord@, Gate@, B@) { B@; }) { B@; }
ForEachGatePlaced = <@ B@>(Placed@ placed, B@ base, (Coord@, Gate@, B@) { B@; } body) {
  placed.design.?(
    gate: body(placed.coord, placed.design.gate, base),
    designs: {
      /List%.ForEach<Placed@, B@>(placed.design.designs, base,
        (Placed@ p, B@ b) {
          Placed@ np = @(
            coord: /Hwdg/Coord%.Add(placed.coord, p.coord),
            design: p.design);
          ForEachGatePlaced<B@>(np, b, body);
          });
      });
};

# ForEachGate --
#   Iterate over the set of gates in a Design@.
#
# Conceptually:
#   B@ b = base
#   foreach (coord, gate) in gates:
#     b = body(coord, gates, b)
#   return b
<@ B@>(Design@, B@, (Coord@, Gate@, B@) { B@; }) { B@; }
ForEachGate = <@ B@> (Design@ design, B@ base, (Coord@, Gate@, B@) { B@; } body) {
  ForEachGatePlaced<B@>(Placed@(Coord@(0, 0), design), base, body);
};

# StepInternal --
#   Run a single step of the given design.
#
# This means executing all currently enabled gates in the design, except those
# that are disabled due to conflicts with other gates executed in the same
# step.
#
# Inputs:
#   design - the design to execute.
#   memory - the memory to modify.
#   modified - the set of coordinates modified so far.
#
# Returns:
#   The updated memory. Nothing if no changes were made to memory.
(Design@, Memory@, Set@<Coord@>) { Maybe@<Memory@>; } StepInternal = {
  @ B@ = *(Memory@ memory, Set@<Coord@> updated);

  # Check if a port is blocked because its memory location has already been
  # updated.
  (B@, Coord@, PortSpec@) { Bool@; } Blocked = (B@ b, Coord@ c, PortSpec@ ps) {
    IsUnused(ps).?(true: False);
    /Set%.Contains<Coord@>(/Hwdg/Coord%.Lt)(b.updated, c);
  };

  # Get the input value to use for the given port, or Nothing if there is no
  # input available for the port.
  (B@, Coord@, PortSpec@) { Maybe@<Data@>; } Input = (B@ b, Coord@ c, PortSpec@ ps) {
    ps.input.?(false: Just<Data@>(/Hwdg/Data%.0));
    /Hwdg/Memory%.Get(b.memory, c);
  };

  # Return true if output to the given port is blocked because there's
  # something in the way.
  (B@, Coord@, PortSpec@) { Bool@; } OutputBlocked = (B@ b, Coord@ c, PortSpec@ ps) {
    ps.input.?(true: False);
    ps.output.?(false: False);
    /Hwdg/Memory%.Get(b.memory, c).?(just: True, nothing: False);
  };

  # Update the state based on a computed output value.
  (B@, Coord@, PortSpec@, Data@) { B@; } Update = (B@ b, Coord@ c, PortSpec@ ps, Data@ d) {
    ps.output.?(true: @(
      memory: /Hwdg/Memory%.Set(b.memory, c, d),
      updated: /Set%.Insert<Coord@>(/Hwdg/Coord%.Lt)(b.updated, c)));
    ps.input.?(true: @(
      memory: /Hwdg/Memory%.Clear(b.memory, c),
      updated: /Set%.Insert<Coord@>(/Hwdg/Coord%.Lt)(b.updated, c)));
    b;
  };

  (Design@ design, Memory@ memory, Set@<Coord@> updated) {
    B@ b = ForEachGate<B@>(design, B@(memory, updated), (Coord@ c, Gate@ g, B@ b) {
      # The coordinates of each port.
      Ports@<Coord@> cs = Ports@<Coord@>(
        Coord@(c.x, c.y),
        Coord@(Inc(c.x), c.y),
        Coord@(c.x, Inc(c.y)),
        Coord@(Inc(c.x), Inc(c.y)));

      # Don't do anything if the data needed for this port has been modified
      # since the start of the cycle.
      Blocked(b, cs.ul, g.ports.ul).?(true: b);
      Blocked(b, cs.ur, g.ports.ur).?(true: b);
      Blocked(b, cs.ll, g.ports.ll).?(true: b);
      Blocked(b, cs.lr, g.ports.lr).?(true: b);

      # Get the inputs, exiting immediately if a required input isn't
      # available.
      Maybe@<Data@> uli = Input(b, cs.ul, g.ports.ul); uli.?(nothing: b);
      Maybe@<Data@> uri = Input(b, cs.ur, g.ports.ur); uri.?(nothing: b);
      Maybe@<Data@> lli = Input(b, cs.ll, g.ports.ll); lli.?(nothing: b);
      Maybe@<Data@> lri = Input(b, cs.lr, g.ports.lr); lri.?(nothing: b);

      # Exit immediately if any of the required output ports are blocked.
      OutputBlocked(b, cs.ul, g.ports.ul).?(true: b);
      OutputBlocked(b, cs.ur, g.ports.ur).?(true: b);
      OutputBlocked(b, cs.ll, g.ports.ll).?(true: b);
      OutputBlocked(b, cs.lr, g.ports.lr).?(true: b);

      # We are now good to execute the gate.
      Ports@<Data@> inputs = Ports@<Data@>(uli.just, uri.just, lli.just, lri.just);
      Ports@<Data@> outputs = g.function(inputs);

      # Update the state based on the result of executing the gate.
      B@ b_ul = Update(b, cs.ul, g.ports.ul, outputs.ul);
      B@ b_ur = Update(b_ul, cs.ur, g.ports.ur, outputs.ur);
      B@ b_ll = Update(b_ur, cs.ll, g.ports.ll, outputs.ll);
      B@ b_lr = Update(b_ll, cs.lr, g.ports.lr, outputs.lr);
      b_lr;
    });

    /Set%.IsEmpty<Coord@>(b.updated).?(true: Nothing<Memory@>);
    Just<Memory@>(b.memory);
  };
};

# Step --
#   Run a single step of the given design.
#
# This means executing all currently enabled gates in the design, except those
# that are disabled due to conflicts with other gates executed in the same
# step.
#
# Inputs:
#   design - the design to execute.
#   memory - the memory to modify.
#
# Returns:
#   The updated memory.
(Design@, Memory@) { Memory@; } Step = (Design@ design, Memory@ memory) {
  Maybe@<Memory@> m = StepInternal(design, memory, /Set%.Empty<Coord@>);
  m.?(just: m.just, nothing: memory);
};

# Run --
#   Run the design for as long as any gates are enabled.
#
# It is the responsibility of the caller to make sure the design terminates.
(Design@, Memory@) { Memory@; } Run = (Design@ design, Memory@ memory) {
  Maybe@<Memory@> m = StepInternal(design, memory, /Set%.Empty<Coord@>);
  m.?(just: Run(design, m.just), nothing: memory);
};

@(
  Ports@,
  PortSpec@, In, Out, InOut, Unused, IsUsed, IsUnused,
  GateFunction@, Gate@,
  Design@, Placed@,
  ForEachGate,
  Step, Run
);
