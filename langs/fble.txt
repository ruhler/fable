Fable E
=======
Richard Uhler <ruhler@degralder.com>

1. Introduction
---------------
Fble is a general purpose, Turing-complete functional programming language
with support for concurrent processes, polymorphism, and modularity.

1.1 Goals
---------
The primary design goals of fble are:

* Fble should be as simple a language as possible while still being useful.
  A simple language will hopefully be simple to specify, simple to learn,
  simple to understand, simple to program, powerful, and low cost to develop
  high quality tools for.

* Fble should support high performance, low overhead computing. This is
  achieved by using a static type system and having a very clear performance
  model that a developer can optimize for.

* Fble should be a joy to program in. It should be easy to describe the
  majority of programs we want to describe, not tediously difficult. To
  accomplish this, fble allows functions to be declared locally with access to
  variables in the context where they are declared, and fble supports
  polymorphic types and functions.

* Fble should support programming at scale. That is, namespace control and
  composition of modules developed by different individual developers or
  organizations.

1.2 Overview
------------
Fble is based around the primitive data types of structs, unions, functions,
and processes. It is a strongly and statically typed language supporting
polymorphic types and values. Recursive types and values are supported through
a recursive let construct. Types are treated as another kind of value in fble,
which allows us to reuse the constructs of variables, lets, polymorphism, and
structs for types in addition to normal values. Additional syntax is provided
to make structs suitable for describing and manipulating namespaces.

2. Types, Kinds, and Variables
------------------------------
2.1 Types
---------
Data values and the expressions that describe them are strongly typed. A
value's type describes the kinds of operations that can legally be performed
on that value. Types are used to check that an fble programs is well formed
statically. Types do not take meaningful part in the dynamic execution of an
fble program after it has been statically checked.

Types are themselves treated as data values in fble, which allows us to reuse
variables, lets, polymorphism, and structs for both types in addition to
normal values. This means an expression can be used to describe either a
normal value or a type, and that types themselves have types.

To ensure all type information is available at compile time, there is a
one-to-one mapping between a type and the type of that type. As a consequence,
you can determine the value of a type if you know the type of that type.

For example, the boolean value 'True' is a normal value. The type of 'True' is
the type 'Bool@', which is a union type. 'Bool@' is a type value. The type of
'Bool@' is known only as the type of Bool@, expressed using the syntax:
'@<Bool@>'. '@<Bool@>' is also a type value, and the type of that value is
'@<@<Bool@>>'. If you have an expression of type '@<Bool@>', you know
statically that the value of that expression must be 'Bool@', so the
expression need not be evaluated at runtime.

Type information is stripped away at runtime. The value of a type at runtime
is a special unit value. Without the type information, there is no way to
distinguish between the special unit value for different types. For this
reason we say types do not take meaningful part in the dynamic execution of an
fble program after it has been statically checked, though the special unit
value for types may exist at runtime when using an fble native interface.

2.2 Kinds
---------
To describe polymorphic expressions, we want a way to refer to an abstract
type. For this purpose we introduce the notion of a kind. Kinds are analogous
to types in that they describe what operations are supported by a particular
value, but they are much more restricted in the operations they allow.
Specifically, the kind of a value tells you if it is a normal value or a type
value. Type values can be used anywhere an abstract type is expected. Unlike
types, kinds do not act as values and cannot be described using expressions.

The kind of a value is uniquely determined by the type of the value.

To help distinguish between types and normal values syntactically, we
distinguish between type names and normal names for variable names and field
names. Type names must be used for any variables or fields that take on type
values, and normal names must be used for any variables or fields that take on
normal values. In the concrete syntax, names ending with the character '@' are
type names. So, for example, 'True' is a normal value, and 'Bool@' is a type
value.

A polymorphic expression that results in a normal value is considered an
normal value, and a polymorphic expression that results in a type value is
considered a type value. So, for example, the polymorphic type 'Maybe@' is a
type, and its constructor 'Just' is a normal value.

2.3 Typeof
----------
Abstract Syntax:
  Type ::= typeof (expr :: Expr)

Concrete Syntax:
  type ::= '@' '<' expr '>'

Example:
  @<x>

Evaluates to the type of the expression, without evaluating the expression
itself. This is primarily useful for explicitly describing the type of a
struct that has type fields.

2.4 Variables
-------------
Abstract Syntax:
  Expr ::= var (name :: Name)

Concrete Syntax:
  expr ::= name

Example:
  x

Variables allow data values to be reused multiple times within a program. In
conjunction with let expressions, variables allow data values to be used
recursively.

Expressions are evaluated in a context that maps variable names to values,
along with their types and kinds. The value, type, and kind of the variable
expression is the value, type, and kind associated with the variable name in
the context.

2.5 Let
-------
Abstract Syntax:
  MType ::= implicit_type (kind :: Kind)
  MType ::= explicit_type (type :: Type) ;
  Expr ::= let (bindings :: [(MType, Name, Expr)]) (body :: Expr)

Concrete Syntax:
  mtype ::= kind ;
  mtype ::= type ;
  stmt ::= mtype name '=' expr [',' mtype name = expr [...]] ';' stmt

Example:
  Int@ x = mul[3][3]; mul[x][x]
  <@>@ Maybe@ = <@ T@> { +(T@ just, Unit@ nothing); };

Let expressions can be used to define local variables that allow values to be
reused in multiple places in a program. Let expressions support recursive
definitions of variables, which makes it possible to define recursive values.

The let expression is used to define variables. For each binding, a new
variable is defined. The value of the variable is the result of evaluating the
expression for the variable's binding.

The defined variables are visible in the body of the let expression. To
support self and mutually recursive values, the defined variables
are also visible in all of the bindings expressions.

The value of the let expression is the value of its body.

When defining type variables, in place of the type of the type variable the
kind of the type variable can be used. The type of the type variable will be
inferred automatically in that case. This way you can define a type variable
without having to duplicate the definition in its own type. If a kind is
provided for a type variable, the type variable will behave as an abstract
type in the bindings, and a concrete type in the body of the let.

TODO: Are bindings allowed to defined variables with the same name as
variables already in scope, thus shadowing the variable already in scope?

3. Structs
----------
A struct value is a grouping of other values. The items of a struct are
organized into a finite number of fields. Each field has a name, used to
identify the field, and a type, specifying the type of value for that field.

Struct values are constructed by supplying values for all fields of the
struct. Individual components of a struct can be accessed by field name.

Struct values can be used for modularity and namespace control, by grouping
together a collection of types and normal values. Syntax is provided for
creating struct values with implicit types, evaluating expressions in the
context of the fields of a struct value, and importing fields of a struct into
the current context. When used this way, we sometimes refer to the struct
value as a namespace struct value.

3.1 Struct Type
---------------
Abstract Syntax:
  Expr ::= struct_type (fields :: [(Type, Name)])

Concrete Syntax:
  expr ::= '*(' [type name [',' type name [...]]] ')'

Examples:
  *()                 is the Unit type
  *(Int@ x, Int@ y)   is the type of a pair of ints x, y.

Struct types are considered equal if their fields are equal, including field
types, field names, and the order of the fields.

3.2 Struct Value Explicit Type
------------------------------
Abstract Syntax:
  Expr ::= struct_value_explicit_type (type :: Type) (args :: [Expr])

Concrete Syntax:
  expr ::= type '(' [expr [',' expr [...]]] ')'

Example:
  Coord@(3, 5)

The type of the struct value is the explicit type provided, which must be a
struct type. The number of arguments provided must match the number of fields
in the provided type, and the type of each argument must match the type of the
field of the struct type in the same position.

The expression is evaluated by evaluating all arguments and creating a struct
value with the results. The arguments may be evaluated in any order,
sequentially or in parallel.

3.3 Struct Value Implicit Type
------------------------------
Abstract Syntax:
  Expr ::= struct_value_implicit_type (args :: [(Name, Expr)])

Concrete Syntax:
  expr ::= '@' '(' [name [':' expr] [',' ...]] ')'         (* struct_value_implicit_type *)

Example:
  @(x: 3, y: 5)
  @(Bool@, True, False, Not: NotInternal)

Allows you to construct a struct value with an implicit type. When defining
structs used as namespaces, it is tedious to have to repeat the types of the
entities being defined and to worry about what order they are defined in. The
anoymous struct value makes it more convenient to define structs used as
namespaces.

As a syntactic sugar, if no value for a field is provided, its value is
assumed to be the variable with same name as the field. For example, the above
example is equivalent to:

  @(Bool@: Bool@, True: True, False: False, Not: NotInternal)

The type of the struct value is a struct type with fields defined in the same
order as the implicit value struct: the name of the field is the name provided
and the type of the field is the type of the argument provided.

The expression is evaluated by evaluating all arguments and creating a struct
value with the results. The arguments may be evaluated in any order,
sequentially or in parallel.


3.4 Struct Access
-----------------
Abstract Syntax:
  Expr ::= struct_access (object :: Expr) (field :: Name)

Concrete Syntax:
  expr '.' name

Example:
  x.first

Returns the value passed to the struct at the corresponding field position
when the struct was constructed.

The object must be a struct value. The field must refer to a field of that
struct value. The type of the expression is the type of the field being
accessed.

The expression is evaluated by evaluating the object, then accessing its field
value.

3.5 Struct Eval
---------------
Abstract Syntax:
  Expr ::= struct_eval (object :: Expr) (body :: Expr)

Concrete Syntax:
  expr ::= expr '{' stmt '}'

Example:
  @(True, False, And) { And(True, False); }

Struct eval evaluates an expression in a context where the only variables in
scope are those defined by the fields of a struct value. This allows you to
hide variables when evaluating an expression.

The object must be a struct value. The body of the struct_eval
is evaluated in a scope of variables which are the fields of the
struct value and no others. The type of the expression is the type of the body
of the expression.

The expression is evaluated by evaluating the object, then evaluating the body
under the new scope.

Struct eval is typically used when defining a module to hide all external
variables except those you need for the module. This allows the module to be
reused in many different contexts. For example, a module that only requires use
of the StdLib library would be written:

@(StdLib) {
  ...
};

That way, regardless of what other libraries are in scope, there will be no
name conflicts between what is already in scope and what is being defined by
the module itself.

3.6 Struct Import
-----------------
Abstract Syntax:
  Expr ::= struct_import (object :: Expr) (body :: Expr)

Concrete Syntax:
  stmt ::= expr ';' stmt

Example:
  @(And); And(True, False);

Struct import is a short hand form of let expression that allows you to
introduce new variables in scope. The object must be a struct
value. The body of import is evaluated in the current scope augmented with
variables formed from the fields of the struct value. The type of the
expression is the type of the body of the expression.

The expression is evaluated by evaluating the object, then evaluating the body
under the new scope.

The advantage of using struct import over using a regular let expression is
the convenience of not having to explicitly write the types of the variables
being defined and being able to define a group of variables concisely.

For example, assuming a struct of boolean operations:
  @ BoolOps@ = *(Bool@ True, Bool@ False, \(Bool@ x; Bool@) Not);
  BoolOps@ ops = ...

The following two are equivalent:
1. Bool@ True = ops.True;
   Bool@ False = ops.False;
   \(Bool@ x; Bool@) Not = ops.Not;
   ...

2. ops;
   ...
  
The typical use of struct import is to import values from an existing
namespace into the current namespace using a combination of struct
import, struct eval, and implict type struct value construction. For example:

  StdLib { @(Bool, Maybe, List); };
  ...

Has the effect of importing just Bool, Maybe, and List from StdLib.

Note that you can also make use of this construct with implicit type struct
values for defining a variable without having to explicitly specify its type.
This is useful for referring to a namespace without having to provide an
explicit type for the namespace. For example:

  @(StdLib: &StdLib); ...

Or, as another example, the following two are equivalent:

1. Bool@ True = Bool@(true: Unit@()); ...
2. @(True: Bool@(true: Unit@())); ...

4. Unions
---------
A union value is a particular value chosen amongst a group of possible values.
The possible choices are organized into a finite number of fields. Each field
has a name, used to identify the field, and a type, specifying the type of
value for that field.

Union values are constructed by supplying a value for a particular field of
the union. The particular value for the union can be accessed by field name,
and the union can be used to select among other values and expressions based
on the field present in the union value.

4.1 Union Type
--------------
Abstract Syntax:
  Type ::= union_type (fields :: [(Type, Name)])

Concrete Syntax:
  type ::= '+(' type name [',' type name [...]] ')'

Example:
  +(Unit@ true, Unit@ false)

Union types are considered equal if their fields are equal, including field
types, field names, and the order of the fields.

4.2 Union Value
---------------
Abstract Syntax:
  Expr ::= union_value (type :: Type) (field :: Name) (arg :: Expr)

Concrete Syntax:
  expr ::= type '(' name ':' expr ')'

Example:
  Maybe@(Just: 3)

The type of the union value is the type provided, which must be a union type.
The supplied argument name must be of a field in the union type, and the type
of the argument must match the type of that field.

The expression is evaluated by evaluating the argument and creating a union
value with the result.

4.3 Union Access
----------------
Abstract Syntax:
  Expr ::= union_access (object :: Expr) (field :: Name)

Concrete Syntax:
  expr ::= expr '.' name

Example:
  x.Just

Returns the value passed to the union at the corresponding field position when
the union was constructed. Behavior is undefined if the union tag does not
match the field being accessed.

The object must be a union value. The field must refer to a field of that
union value. The type of the expression is the type of the field being
accessed.

The expression is evaluated by evaluating the object, then accessing its field
value.

4.4 Union Select
----------------
Abstract Syntax:
  Expr ::= union_select (condition :: Expr) (choices :: [(Name, Expr)])

Concrete Syntax:
  expr ::= '?(' expr ';' name ':' expr [',' name ':' expr [...]] ')'

Example:
  ?(mfoo; Just: mfoo.Just, Nothing: 3)

The condition must be a union value. Returns the value of the choice selected
by the tag of the condition, without causing any other choices to be
evaluated. The type of all choices must be the same. A choice must be present
for each field of the condition's union type, in the same order the fields are
declared in the union type.

The expression is evaluated by evaluating the condition, then evaluating the
choice selected by the condition. No other choices are evaluated.

5. Functions
------------
A function is a mapping from argument value to result value. The argument has
a name, used to identify the argument in the body of the function, and a type,
specifying the type of value that can be supplied for that argument. A
function has a return type, specifying the type of value that will result when
applying the function.

Functions are described using the fble expression language. A function can be
applied to an argument of appropriate type to produce a value with the return
type of the function.

Functions can have more than one argument. For the most part function
expressions involving multiple arguments are desugared into function
expressions involving single arguments, in the sense that a multiple argument
function can be written as a single argument function that returns a function.
The exception is that in some cases there are performance implications
for use of multiple argument functions instead of single argument functions.

5.1 Function Type
-----------------
Abstract Syntax:
  Type ::= func_type (arg :: Type) (return :: Type)

Concrete Syntax:
  block ::= '(' type [',' type [...]] ')' block

Examples:
  (Int@, Int@){ Bool@; }

The function type describes the type of a function value by specifying the
function's argument and return types.

Function arguments can be any kind of value, including types, structs, unions,
functions, or processes.

Two function types are equal if they take the same argument and return types.

The concrete syntax allows you to specify multiple arguments in a function
type. This is syntactic sugar for nested single argument function types. For
example, the following three expressions describe the same type:
 
  (a, b, c){ d; }
  (a)(b)(c){ d; }
  (a){ (b){ (c){ d; }}}

5.2 Function Value
------------------
Abstract Syntax:
  Expr ::= func_value (args :: [(Type, Name)]) (body :: Expr)

Concrete Syntax:
  block ::= '(' type name [',' type name [...]] ')' block

Example:
  (Bool@ a, Bool@ b) { ?(a; true: b, false: False); }

The function value expression is used to describe a primitive function value
given the arguments and the body of the function. The return type of
the function is inferred to be the type of the body of the function. The
argument names chosen when defining a function has no effect on the type of
the function.

There is a slight performance difference between specifying a multi-argument
function value and nested single-argument function values. The body of the
function is not executed until all arguments have been supplied. A
multi-argument function can be partially applied, which creates a thunk that
retains the provided arguments without executing the function until sufficient
arguments are supplied for the function to be fully applied.

Multi-argument functions can be used to have O(N) application in the case of N
arguments, whereas nested single-argument functions would require O(N^2) time.

5.3 Function Application
------------------------
Abstract Syntax:
  Expr ::= apply (func :: Expr) (arg :: Expr)

Concrete Syntax:
  expr ::= expr '(' expr [',' expr [...]] ')'

Example:
  foo(x, y)

The application expression is used to apply a function to an argument. The
supplied argument must match the type of argument specified for the function.
The application expression evaluates to the value of the body of the function
in the context of the supplied argument.

The concrete syntax allows you to specify multiple arguments in a function
application. This is syntactic sugar for repeated single argument function
application. For example, the following three expressions describe the same
expression:
  foo(a, b, c)
  foo(a)(b)(c)

Function application creates a thunk if the function has not been supplied
with all required arguments. Otherwise the body of the function is evaluated
in the context of all arguments supplied to the function.

5.4 Function Bind
-----------------
Abstract Syntax:
  Expr ::= func_bind (args :: [(Type, Name)]) (func :: Expr) (body :: Expr)

Concrete Syntax:
  stmt ::= type name [',' type name [...]] '<-' expr ';' stmt

Example
  Int@ x <- map(l);
  f(x, y)

Bind is syntactic sugar for applying a function to a function value. It is
equivalent to:

  func_apply func (func_value args body)

6 Processes
-----------
A process is a computation with side effects that produces a value. Side
effects take the form of getting and putting values to and from links that can
be accessed by other running processes.

There are primitive processes for getting a value from a link, putting a value
to a link, and creating and using a new link. Processes can be combined by
executing them in parallel and serial.

We make a distinction between when a process is evaluated and when a process
is executed. Evaluating a process means evaluating the fble expression that
describes the process, producing a process value. Executing a process means
executing the process described by a process value, producing the result of
the process.

6.1 Process Type
----------------
Abstract Syntax:
  Type ::= proc_type (return :: Type)

Concrete Syntax:
  type ::= type '!'

Example:
  Int@!

6.2 Process Input Type
----------------------
Abstract Syntax:
  Type ::= proc_input_type (type :: Type)

Concrete Syntax:
  type ::= type '-'

Example:
  Int@-

An input port is a handle to a link that can be used to get values from
the link. An input port is typed, so that only values of the given type can be
taken from the port.

An input port is created for every link that is created. An input port can be
used as a process that takes a value off its link.

6.3 Process Output Type
-----------------------
Abstract Syntax:
  Type ::= proc_output_type (type :: Type)

Concrete Syntax:
  type ::= type '+'

Example:
  Int@+

An output port is a handle to a link that can be used to put values onto the
link. An output port is typed, so that only values of the given type can be
put onto the link.

An output port is created for every link that is created. An output port can
be used as a process that puts a value onto its link.

6.4 Process Get
---------------
Abstract Syntax:
  Expr ::= proc_get (port :: Expr)

Concrete Syntax:
  expr ::= expr '()'

Example:
  input()

The port must have type input_type. If the port has type T@-, evaluates to a
process value of type T@! that when executed gets the next value from the port.

6.5 Process Put
---------------
Abstract Syntax:
  Expr ::= proc_put (port :: Expr) (value :: Expr)

Concrete Syntax:
  expr ::= expr '(' expr ')'

Example:
  output(3)

The port must have type proc_output_type. If the port has type T@+, evaluates to a
process value of type T@! that when executed puts the given value onto the
port and returns that same value. The value put onto the port is evaluated
as part of evaluation of the process.

The rationale for having put return its argument value is to
avoid the complexity of introducing a builtin notion of a unit type or a
process that doesn't return anything. In most cases we expect the return value
of a put process to be ignored.

6.6 Process Eval
----------------
Abstract Syntax:
  Expr ::= proc_eval (expr :: Expr)

Concrete Syntax:
  expr ::= '$(' expr ')'

Example:
  $(3)

A process that returns the value of expr without performing any other
actions. The value to return is evaluated as part of evaluating the process.

6.7 Process Link
----------------
Abstract Syntax:
  Expr ::= proc_link (type :: Type) (get :: Name) (put :: Name) (body :: Expr)

Concrete Syntax:
  stmt ::= type '~' name ',' name ';' expr

Example:
  Int@ ~ input, output; f[input][output]

The body must have type process_type. When executed, creates a new link, then
evaluates and executes the body with get and put ports of type type- and type+
respectively added to the context.

6.8 Process Exec
----------------
Abstract Syntax:
  Expr ::= proc_exec (bindings :: [(Type, Name, Expr)]) (body :: Expr)

Concrete Syntax:
  stmt ::= type name ':=' expr [',' type name ':=' expr [...]] ';' stmt

Example:
  Int@ x := getx(), Int@ y := gety(); $(add(x, y))

Executes each process in parallel, then evaluates and executes the body with
the results of the processes assigned to variables in scope. The binding
processes are evaluated at the same time the overall exec process is
evaluated.

7. Polymorphism
---------------
Polymorphism allows expressions to be parameterized by abstract types.

7.1 Poly Kind
-------------
Abstract Syntax:
  Kind ::= type_kind
  Kind ::= poly_kind (arg :: Kind) (return :: Kind)

Concrete Syntax:
  kind ::= '@'
  kind ::= '<' kind [',' kind [...]] '>' kind

Examples:
  <@>@

A poly kind describes the kind of a polymorphic type, analogous to the way
function types describe the type of functions.

Two poly kinds are equal if they have the same argument and return kinds.

The is no syntax to describe the kind of a normal value, because there is no
need. You can use normal functions with polymorphic types in that case, rather
than use polymorphic expressions with normal kinds.

The concrete syntax allows you to specify multiple arguments in a poly kind.
This is syntactic sugar for nested single argument poly kinds. For
example, the following two expressions describe the same kind:
  <@, @, @>@
  <@><@><@>@

7.2 Poly Value
--------------
Abstract Syntax:
  Expr ::= poly_value (arg :: (Kind, Name)) (body :: Expr)

Concrete Syntax:
  block ::= '<' kind name [',' kind name [...] '>' block
 
Examples:
  <@ T@> { +(T@ just, Unit@ nothing); }
  <@ T@> { \(T@ x; Maybe@<T@>) { Maybe@<T@>(just: x); }; }

7.3 Poly Application
--------------------
Abstract Syntax:
  Expr ::= poly_apply (poly :: Expr) (arg :: Type)

Concrete Syntax:
  expr ::= expr '<' type [',' type [...]] '>'

Examples:
  Maybe@<Int@>
  fromJust<Int@>(3)

8. Literals
-----------
We introduce syntax for describing lists and literals to make it less tedious
to write code involving sequences of elements of the same type and raw
sequences of data without the overhead of punctuation between data elements.

8.1 List
--------
Abstract Syntax:
  Expr ::= list (args :: [Expr])
  
Concrete Syntax:
  expr ::= '['expr [',' expr [...]] ']'

Examples: 
  [x]
  [x, f(y), z]

A list describes a sequence of one or more values of the same type. The value
of a list is a polymorphic function that can be used to construct any type of
list of the given elements. Assuming the values have type T@, the type of this
function is:

  <@ L@>((T@, L@){L@;}, L@){L@;}

The type parameter L@ represents the type of the list that can be produced by
calling the function. The first argument to the function is a function that
prepends a single element to a list of type L@, and the second argument
represents the empty list.

For example, an expression such as
    
  [a, b, c, d]

would desugar to something like:

  <@ L@>((T@, L@){L@;} cons, L@ nil) {
     cons(a, cons(b, cons(c, cons(d, nil))));
  }

The expression is evaluated by evaluating all arguments and creating the
polymorphic function value with the results. The arguments may be evaluated in
any order, sequentially or in parallel.

8.2 Literal
-----------
Abstract Syntax:
  Expr ::= literal (type :: Type) (letters :: word)

Concrete Syntax:
  expr ::= type '|' word

Example:
  Octal@|177
  Char@|'hello there!'

A literal is syntax that allows you to express a raw sequence of data without
the overhead of punctuation between data elements.

The type used in a literal represents the type to use for each letter in the
literal. It must be a union type with fields of type *() that have single
letter field names. For example:

  @ Octal@ = +(*() 0, *() 1, *() 2, *() 3, *() 4, *() 5, *() 6, *() 7);

TODO: Can the letter type contain other fields too?

The value of a literal is a list of letters of the given type. For example, an
expression such as:

  Octal@|132

would desugar to:

  [Octal(1: *()()), Octal(3: *()()), Octal(2: *()())]
  
Because this is turned into a list, it will have a polymorphic function type
that accepts a prepend function and empty list:

  <@ L@>((Octal@, L@){L@;}, L@){L@;}

It is a type error if the word contains a letter for which there is no
corresponding field in the letter type or if the type of that field is not
*().

Unlike lists, literals can have zero letters. This is because we have the
necessary type information to determine the type of the list even if it is
empty.

9. Program
-----------
Abstract Syntax:
  Prgm ::= Expr

Concrete Syntax:
  prgm ::= stmt

A program is an fble expressions that creates a value that is used however is
deemed suitable by whoever is executing the program. Commonly this could be:

* struct: evaluate and output the value
* union: evaluate and output the value
* function: apply the function to arguments provided on the command line,
  evaluate and output the resulting value
* process: run the process, evaluate and output the resulting value.

9.1 Include
-----------
Abstract Syntax:
  Expr ::= include (name :: Name)

Concrete Syntax:
  expr ::= '&' name

Example:
  &StdLib

Syntactically includes the named module in place of the expression. The definition
of the module is located in a platform dependent way relative to the current
module. This allows an fble program to be split across multiple files that are
reused in multiple programs.

For example, assuming the current include search path is "lib", a program
Foo.fble can include module StdLib as follows:

  @(StdLib = &StdLib);
  ...

This would read StdLib from the file "lib/StdLib.fble". When reading
StdLib.fble, the include search path is adjusted to "lib/StdLib" for any child
modules included in StdLib.fble.

10. Abstract Syntax Reference
----------------------------
NormalName ::= (* A string of characters *)
TypeName ::= (* A string of characters *)

Name ::=
   normal_name (name :: NormalName)
 | type_name (name :: TypeName)
 ;

Kind ::=
   type_kind
 | poly_kind (arg :: Kind) (result :: Kind)
 ;

Type ::= (* synonym for Expr where a type is expected *)

MType ::=
   implicit_type (kind :: Kind)
 | explicit_type (type :: Type)
 ;
     
Expr ::=
   typeof (expr :: Expr)
 | var (name :: Name)
 | let (bindings :: [(MType, Name, Expr)]) (body :: Expr)

 | struct_type (fields :: [(Type, Name)])
 | struct_value_explicit_type (type :: Type) (args :: [Expr])
 | struct_value_implicit_type (args :: [(Name, Expr)])
 | struct_access (object :: Expr) (field :: Name)
 | struct_eval (namespace :: Expr) (body :: Expr)
 | struct_import (namespace :: Expr) (body :: Expr)

 | union_type (fields :: [(Type, Name)])
 | union_value (type :: Type) (field :: Name) (arg :: Expr)
 | union_access (object :: Expr) (field :: Name)
 | union_select (condition :: Expr) (choices :: [(Name, Expr)])

 | func_type (arg :: Type) (result :: Type)
 | func_value (args :: [(Type, Name)]) (body :: Expr)
 | func_apply (func :: Expr) (arg :: Expr)

 | proc_type (result :: Type)
 | proc_input_type (type :: Type)
 | proc_output_type (type :: Type)
 | proc_get (port :: Expr)
 | proc_put (port :: Expr) (value :: Expr)
 | proc_eval (expr :: Expr)
 | proc_link (type :: Type) (get :: Name) (put :: Name) (body :: Expr)
 | proc_exec (bindings :: [(Type, Name, Expr)]) (body :: Expr)

 | poly_value (arg :: (Kind, Name)) (body :: Expr)
 | poly_apply (poly :: Expr) (arg :: Expr)

 | list (args :: [Expr])
 | literal (type :: Type) (letters :: word)
 ;

Prgm ::= Expr

11. Concrete Syntax
-------------------
11.1 Lexical Syntax
-------------------
We have the following categories of characters:
1. whitespace: Any whitespace character, as traditionally classified.
2. The comment character '#'.
3. punctuation: Any of the following characters:
  (){};,:?=.<>+*-!$@~&'\[]
4. normal: any other character.

The lexical syntax is used to interpret a string of arbitrary characters as a
sequence of punctuation characters and words.

Whitespace is treated as a delimiter of words. The comment character and any
following characters on the same line are treated as a delimiter of words.
Whitespace and comments are otherwise ignored.

A sequence of continuous normal characters is grouped together into a word.

A sequence of characters surrounded by single quotes is treated as a sequence
of normal characters, regardless of what class the characters come from. This
makes it possible to specify words containing whitespace, comment, and
punctuation characters. For example, 'Foo,Bar' is treated as a single word
where the fourth character of the word is a comma.

Within a single quoted word, a single quote character can be expressed by
using two adjacent single quote characters. For example, 'Foo''Bar' is treated
as a single word where the fourth character of the word is a single quote.

Single quotes act as word delimiters. For example, Foo'.'Bar is treated as
three separate words: 'Foo', '.', and 'Bar', not as a single word 'Foo.Bar'.
The only exception is when consecutive single quote characters are used to
embed a single quote character in a word.

11.2 Reference
--------------
word ::= (* word as described in the section on lexical syntax *)
normal_name ::= word
type_name ::=   word '@'

name ::= 
   normal_name
 | type_name
 ;

kind ::=
   '@'                                (* type_kind *)
 | '<' kind [',' kind [...]] '>' kind (* poly_kind *)
 ;

type ::= expr ;

mtype ::= 
   kind   (* implicit_type *)
 | type   (* explicit_type *)
 ;

expr ::= 
   '@' '<' expr '>'                                (* typeof *)
 | name                                            (* var *)

 | '*(' [type name [',' type name [...]]] ')'      (* struct_type *)
 | type '(' [expr [',' expr [...]]] ')'            (* struct_value_explicit_type, get, put *)
 | '@(' [name [':' expr] [',' ...]] ')'            (* struct_value_implicit_type *)
 | expr '.' name                                   (* struct_access *)
 | expr '{' stmt '}'                               (* struct_eval *)
 | expr '|' word                                   (* string_literal *)

 | '+(' type name [',' type name [...]] ')'        (* union_type *)
 | type '(' name ':' expr ')'                      (* union_value *)
 | expr '.' name                                   (* union_access *)
 | '?(' expr ';' name ':' expr                     (* union_select *)
            [',' name ':' expr [...]] ')'   

 | expr '(' expr [',' expr [...]] ')'              (* func_apply *)

 | type '!'                                        (* proc_type *)
 | type '-'                                        (* proc_input_type *)
 | type '+'                                        (* proc_output_type *)
 | '$(' expr ')'                                   (* proc_eval *)

 | expr '<' type [',' type [...]] '>'              (* poly_apply *)

 | '['[expr [',' expr [...]] ']'                   (* list *)
 | type '|' word                                   (* literal *)

 | '&' name                                        (* include *)
 | block
 ;

block ::=
   '{' stmt '}'
 | '(' type [',' type [...]] ')' block             (* func_type *)
 | '(' type name [',' type name [...]] ')' block   (* func_value *)
 | '<' kind name [',' kind name [...]] '>' block   (* poly_value *)
 ;

stmt ::=
   expr ';'
 | mtype name '=' expr [',' mtype name '=' expr [...]] ';' stmt      (* let *)
 | expr ';' stmt                                                     (* struct_import *)
 | type name [',' type name [...]] '<-' expr ';' stmt                (* func_bind *)
 | type '~' name ',' name ';' stmt                                   (* proc_link *)
 | type name ':=' expr [',' type name ':=' expr [...]] ';' stmt      (* proc_exec *)
 ;

prgm ::= stmt                                                        (* program *)
 ;

Notes:
* struct and union access share the same form. The type of the object is used
  to distinguish between the two kinds of expressions.
* explicit type struct value, function apply, get, and put share the same
  form. The type of the expr is used to distinguish between the four kinds of
  expressions.

12. Thoughts
------------
* Vague concern: will fble support static evaluation / compilation to
  hardware? Is it bad to support structs and links that can hold functions and
  processes?

  I envision static evaluation as follows: you evaluate a program to, say, a
  function. That's the static evaluation pass. The result will be based on the
  interpreter you are using. If you have a hardware interpreter, for example,
  the resulting function will be a description of a hardware circuit.

* Concern: how to support raw literals
  Like string literals, integers, anything where you want to specify a dense
  amount of information for processing.
  
  See fble.sugar.txt.

* Is variable shadowing allowed?
  Consider also the following cases:
 - multi-arg functions with duplicate arg values.
 - variables whose value we explicitly want to ignore, such as the result of a
   bind or a put_proc.
 - Things like {Chars; S4<Char@>(0, 1, 2, 3)}, where it's not unlikely that we
   have a variable called 0, 1, 2, or 3 already in scope.

 I'm leaning towards yes. It doesn't make sense from a modularity perspective
 otherwise.

* Issues that came up when switching to the new unit test format
 - How should we organize tests? Do we need to import Test even if we just want to
   use a library? Should the code for all tests be completely separate from
   the code for all libraries? For example, instead of defining:
      StdLib(StdLib, Tests), UBNat (UBNat, Tests), ...
      (StdLib, UBNat, ...), (StdLibTests, UBNatTests, ...)?
   Because, for example, fble-Snake.fble shouldn't need to care about
   importing Test.

   See fble.modules.txt

 - It's annoying to have to remember to import all the S* functions, and to
   have to figure out what number to put after each of them.

   Can we have list literals, or varargs functions, or something so I can
   change the number of elements in a list in a single place rather than
   having to change multiple places in the code?

   See fble.sugar.txt for more discussion.
 
 - String literals are tough to read and write.
    For example, { Chars; S6<Char@>(G, t, underscore, 7, underscore, 5); }
    Is much easier to read as  "Gt_7_5", or some variation.
    Perhaps: {StrLit; "Gt_7_5"} is something we could realistically expect to
    support?

    See fble.sugar.txt for more discussion.

 - Should it be an error to import or define an unused variable?
    Otherwise it's easy to make a change to what's used without updating an
    import list.

 - For writing tests, it would be really useful if common data types all had
   function to convert them to strings.

   How should that be organized? Does that bring in false dependencies between
   modules? Like, I need to import String to import Unit, but I need to import
   Unit to import String?

   See fble.modules.txt

 - It's not at all obvious when writing tests what part of the test is
   executed when we define the test and what part of the test is executed when
   we run the test.

   For example, given something like:
     { a = ...; b = ...; $(TestResult@(a, b)) }

   I intend for nothing to be run until we execute the test, but I think in
   practice the test is essentially run when we define the test, and executing
   the test just returns the results.

   This seems like a subtle trap to get caught with.

   Should we add a ${...} syntax analogous to $(...)? Then it's more obvious
   you can write:
     ${ a:= ...; b := ...; TestResult@(a, b); }
   
