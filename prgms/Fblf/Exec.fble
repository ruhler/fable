
@ Bool@ = /Bool%.Bool@;
% Not = /Bool%.Not;

% I = /Int/Int/Lit%.I;
% D = /Int/Int/Lit%.D;

@ Heap@ = /Fblf/Heap%.Heap@;
@ Ptr@ = /Fblf/Heap%.Ptr@;
% HeapFromBits = /Fblf/Heap%.HeapFromBits;
% Assign = /Fblf/Heap%.Assign;
% Equals = /Fblf/Heap%.Equals;
% AssignBits = /Fblf/Heap%.AssignBits;
% EqualsBits = /Fblf/Heap%.EqualsBits;

<@,@>% ForEach = /List%.ForEach;

@ Program@ = /Fblf/Program%.Program@;
@ Value@ = /Fblf/Program%.Value@;
@ Condition@ = /Fblf/Program%.Condition@;

# Value --
#   Get the value of a value as a Ptr@.
(Value@, Heap@) { Ptr@; } Value = (Value@ value, Heap@ heap) {
  value.?(
    ref: Ptr@(heap, value.ref),
    const: Ptr@(HeapFromBits(value.const), I(D|0)));
};

# Eval --
#   Evaluate a condition.
(Condition@, Heap@) { Bool@; } Eval = (Condition@ cond, Heap@ heap) {
  Ptr@ a = Value(cond.a, heap);
  Bool@ equals = cond.b.?(
    ref: Equals(a, Ptr@(heap, cond.b.ref), cond.n),
    const: EqualsBits(a, cond.b.const, cond.n));
  cond.op.?(eq: equals, ne: Not(equals));
};

# Exec --
#   Execute a program on the given heap.
#
# Behavior is undefined if the heap is not big enough for the program.
(Program@, Heap@) { Heap@; } Exec = (Program@ prgm, Heap@ heap) {
  prgm.?(
    assign: {
      Ptr@ dest = Ptr@(heap, prgm.assign.ref);
      prgm.assign.value.?(
        ref: Assign(dest, Ptr@(heap, prgm.assign.value.ref), prgm.assign.n),
        const: AssignBits(dest, prgm.assign.value.const, prgm.assign.n));
    },

    sequence: {
      ForEach<Program@, Heap@>(prgm.sequence, heap, Exec);
    },

    ifelse: {
      Eval(prgm.ifelse.condition, heap).?(
        true: Exec(prgm.ifelse.if_body, heap),
        false: Exec(prgm.ifelse.else_body, heap));
    },

    while: {
      Eval(prgm.while.condition, heap).?(
        true: Exec(prgm, Exec(prgm.while.body, heap)),
        false: heap);
    });
};

@(Exec);
