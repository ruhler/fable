
struct Unit();

union Bool(Unit true, Unit false);

union Operator(
  Unit OPEN_PAREN,
  Unit CLOSE_PAREN,
  Unit AND,
  Unit OR,
  Unit NOT
);

union Token(Bool operand, Operator operator);

struct NonEmptyTokens(Token head, Tokens tail);
union Tokens(Unit nil, NonEmptyTokens cons);

struct NonEmptyOperands(Bool head, Operands tail);
union Operands(Unit nil, NonEmptyOperands cons);

struct NonEmptyOperators(Operator head, Operators tail);
union Operators(Unit nil, NonEmptyOperators cons);

struct MachineOk(Operands operands, Operators operators);
union Machine(Unit error, MachineOk ok);

func True( ; Bool) {
  Bool:true(Unit());
};

func False( ; Bool) {
  Bool:false(Unit());
};

func Not(Bool a ; Bool) {
  ?(a; Bool:false(Unit()), Bool:true(Unit()));
};

func Or(Bool a, Bool b ; Bool) {
  ?(a ; a, b);
};

func And(Bool a, Bool b ; Bool) {
  ?(a ; b, Bool:false(Unit()));
};

func MError( ; Machine) {
  Machine:error(Unit());
};

func MOk(Operands operands, Operators operators ; Machine) {
  Machine:ok(MachineOk(operands, operators));
};

# Perform the operation on the top of the stacks.
func Operate(Machine m ; Machine) {
  ?(m ; MError(),
    ?(m.ok.operators ; MError(),
      ?(m.ok.operators.cons.head;
        # OPEN PAREN
        MError(),

        # CLOSE PAREN - should match an open paren. Pop them both.
        ?(m.ok.operators.cons.tail; MError(),
           ?(m.ok.operators.cons.tail.cons.head;
              MOk(m.ok.operands, m.ok.operators.cons.tail.cons.tail),
              MError(), MError(), MError(), MError())),
        
        # AND
        ?(m.ok.operands ; MError(),
          ?(m.ok.operands.cons.tail ; MError(),
            MOk(
              Operands:cons(
                NonEmptyOperands(
                  And(m.ok.operands.cons.head,
                      m.ok.operands.cons.tail.cons.head),
                  m.ok.operands.cons.tail.cons.tail)),
              m.ok.operators.cons.tail))),

        # OR
        ?(m.ok.operands ; MError(),
          ?(m.ok.operands.cons.tail ; MError(),
            MOk(
              Operands:cons(
                NonEmptyOperands(
                  Or(m.ok.operands.cons.head,
                     m.ok.operands.cons.tail.cons.head),
                  m.ok.operands.cons.tail.cons.tail)),
              m.ok.operators.cons.tail))),

        # NOT
        ?(m.ok.operands ; MError(),
          MOk(
            Operands:cons(
              NonEmptyOperands(
                Not(m.ok.operands.cons.head),
                m.ok.operands.cons.tail)),
            m.ok.operators.cons.tail))
      )
    )
  );
};

# Return true if the given operator should be pushed on the operator stack.
func ShouldPush(MachineOk m, Operator op ; Bool) {
  ?(m.operators ;
    # nil: Always push if we don't have any operators yet.
    True(),

    # cons: Push depending on the operator.
    ?(op ;
      # OPEN_PAREN:
      ?(m.operators.cons.head ;
        True(), True(), True(), True(), True()),

      # CLOSE_PAREN:
      ?(m.operators.cons.head ;
        True(), False(), False(), False(), False()),

      # AND:
      ?(m.operators.cons.head ;
        True(), False(), False(), True(), False()),

      # OR:
      ?(m.operators.cons.head ;
        True(), False(), False(), False(), False()),

      # NOT:
      ?(m.operators.cons.head ;
        True(), False(), True(), True(), False())
    )
  );
};

# Feed the machine a single token.
func Input(Machine m, Token tok ; Machine) {
  ?(m ; MError(),
     ?(tok ; 
       # Operand: Push the operand onto the operand stack.
       MOk(
         Operands:cons(NonEmptyOperands(tok.operand, m.ok.operands)),
         m.ok.operators),

       # Operator: Push the operator or operate as appropriate.
       ?(ShouldPush(m.ok, tok.operator) ;
         MOk(
           m.ok.operands,
           Operators:cons(NonEmptyOperators(tok.operator, m.ok.operators))),
         Input(Operate(m), tok))
      )
   );
};

# Feed all tokens into the given machine.
func InputAll(Machine m, Tokens toks ; Machine) {
  ?(toks; m, InputAll(Input(m, toks.cons.head), toks.cons.tail));
};

union Result(Unit error, Bool value);

# Perform all remaining operations for the given machine and return the final
# machine.
func FinishMachine(Machine m ; Machine) {
  ?(m ; MError(), ?(m.ok.operators ; m, FinishMachine(Operate(m))));
};

# Perform all remaining operations for the given machine and return the final
# result.
func Finish(Machine m ; Result) {
  Machine finished = FinishMachine(m);
  ?(finished ; Result:error(Unit()),
      ?(finished.ok.operands; Result:error(Unit()),
        ?(finished.ok.operands.cons.tail ;
          Result:value(finished.ok.operands.cons.head),
          Result:error(Unit()))));
};

# Evaluate the boolean formula described by the given sequence of tokens.
func Eval(Tokens toks ; Result) {
  Finish(InputAll(MOk(Operands:nil(Unit()), Operators:nil(Unit())), toks));
};


union TestName(
  Unit 0,
  Unit 1,
  Unit 0o1,
  Unit n0,
  Unit 0o1an1on0
);

struct TestFail(TestName name, Result expected, Result actual, Machine machine);
struct NonEmptyTestFailures(TestFail head, TestFailures tail);
union TestFailures(Unit nil, NonEmptyTestFailures cons);

func T(TestName name, Result expected, Tokens toks, TestFailures rest ; TestFailures) {
  Machine final = FinishMachine(InputAll(MOk(Operands:nil(Unit()), Operators:nil(Unit())), toks));
  Result actual = Eval(toks);
  TestFailures pass = rest;
  TestFailures fail = TestFailures:cons(NonEmptyTestFailures(TestFail(name, expected, actual, final), rest));
  ?(expected ;
      ?(actual ; pass, fail),
      ?(actual ; fail,
          ?(expected.value;
              ?(actual.value; pass, fail),
              ?(actual.value; fail, pass))));
};

func Test( ; TestFailures) {
  T(TestName:0(Unit()),     #0
    Result:value(False()),
    {
      Tokens:cons(NonEmptyTokens(
      Token:operand(False()), Tokens:nil(Unit())));
    },
  T(TestName:1(Unit()),     #1
    Result:value(True()),
    {
      Tokens:cons(NonEmptyTokens(
      Token:operand(True()), Tokens:nil(Unit())));
    },
  T(TestName:0o1(Unit()),   # 0 + 1
    Result:value(True()),
    {
      Tokens:cons(NonEmptyTokens(
      Token:operand(Bool:false(Unit())), Tokens:cons(NonEmptyTokens(
      Token:operator(Operator:OR(Unit())), Tokens:cons(NonEmptyTokens(
      Token:operand(Bool:true(Unit())), Tokens:nil(Unit())))))));
    },
  T(TestName:n0(Unit()),    # !0
    Result:value(True()),
    {
      Tokens:cons(NonEmptyTokens(
      Token:operator(Operator:NOT(Unit())), Tokens:cons(NonEmptyTokens(
      Token:operand(Bool:false(Unit())), Tokens:nil(Unit())))));
    },
  T(TestName:0o1an1on0(Unit()),    # 0 + 1 * !1 + !0
    Result:value(True()),
    {
      Tokens:cons(NonEmptyTokens(
      Token:operand(Bool:false(Unit())), Tokens:cons(NonEmptyTokens(
      Token:operator(Operator:OR(Unit())), Tokens:cons(NonEmptyTokens(
      Token:operand(Bool:true(Unit())), Tokens:cons(NonEmptyTokens(
      Token:operator(Operator:AND(Unit())), Tokens:cons(NonEmptyTokens(
      Token:operator(Operator:NOT(Unit())), Tokens:cons(NonEmptyTokens(
      Token:operand(Bool:true(Unit())), Tokens:cons(NonEmptyTokens(
      Token:operator(Operator:OR(Unit())), Tokens:cons(NonEmptyTokens(
      Token:operator(Operator:NOT(Unit())), Tokens:cons(NonEmptyTokens(
      Token:operand(Bool:false(Unit())), Tokens:nil(Unit())))))))))))))))))));
    },
    TestFailures:nil(Unit()))))));
};

