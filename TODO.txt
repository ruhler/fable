* See if I can't do a round of cleanup for what belongs in which header files.

* Generate FbleExecutable instead of FbleCode for FbleNewGetValue,
  FbleNewPutValue
 - Then we no longer need get and put instructions, right?

* Add 'abort' function to FbleExecutable for cleaning up the stack.
 - And use it to unwind frame by frame instead of whatever we do now.
* Change ReleaseInstr to always return from a local.
* Add explicit Release instructions to free values during normal flow
 - Set to NULL on release so we can properly cleanup based on NULLs in abort.
* Track info necessary to know what to release on abort without checking if
  something is NULL or not.
* Remove setting of NULL on release to test that we don't rely on it. 
  And maybe get a tiny speed boost?

* [compilation] Switch over entirely to compilation use case?
 - We'll want to add profiling support to the compilation use case.
 - Remove interpreter entirely? Any significant downside?

* [compilation] Cleanup API between execute/value/interpret/generated code.
 - Can I cleanup/break the dependency cycle between execute.h and value.h?
 - Should definition of FbleThread* be private to execute.c?
* [compilation] Make public headers available for compiled code to use so we don't have to
  give direct access to internal header files.
* [compilation] Figure out what to do about profiling for the compilation code path.
* [compilation] Add support for .fble.@ files and module compilation.

* [cleanup] Avoid duplicating code between fble-stdio and fble-compiled-stdio.
* [cleanup] For things like FbleValueAddRef, is it okay if dst is NULL?
 - It would be convenient for constructing things in case of error.
 - I'm not sure if there's any performance implications.
 - It would be nice to specify explicitly and be consistent with this kind of
   thing.
* [cleanup] Consistently document ownership of args to C functions?
 Borrowed: no transfer of ownership.
 Consumed: ownership transferred from caller to callee.
 Outlives: caller responsible for keeping alive as long as returned result is.

* [build] Decide whether individual test failures should fail to build or not.
  If they should fail to build, then tools/tests.tcl could be simplified?

* [tests] Any way to improve memory growth tests?
 It feels wrong to me to have to do a full gc for the tests to pass. It feels
 too specific to the implementation of garbage collection. Anything we can do?
* [tests] Add coverage for tagged_type and tagged_expr parse destructors
 - if only I could figure out how to exercise them.

* [/*%] Follow style guide in fble.txt
  In particular, union field names should be lowercase: just, true, false, not
  Just, True, False.
* [/*%] Clean up fble library
 - Separate modules as appropriate to reduce false dependencies.
 - Document all functions.
 - Add tests for full code coverage of all functions.
 - Rename Str to String? Or to S?
 - Only support Int@ officially, not IntP@ and IntS@ too?
 - Consider pulling ForEach and Map out into their own class?
* [/App%] Change App% back to drawing over the previous screen?
 - It can figure out how to double buffer appropriately on the implementation
   side, for example by drawing the last two updates to the buffer.
 - Because presumably, if not much has changed, that can be much more
   efficient? And if a lot has changed, we can optimize 'Over' to throw away
   the previous frame entirely if you start with a blank screen?

   Maybe more accurate is, if your point of view isn't changing, delta is
   better. If your point of view is changing, you probably have to redraw
   everything regardless and it would be nice to avoid drawing a bunch of
   stuff and then covering it up right away.
* [/Int%] Add test coverage for the Int routines.
 - In particular, test Div and Mod.
* [/Fble/Test%] Clean up fble test framework
 - Use AssertEquals for more of the tests.
 - Properly test the test infra.
 - Add way to write 'skip' test and/or 'expect_fail' test?
   For example, so we can have the fblf md5 tests, compile them, skip them
   because they are too slow, and report on how many were skipped and why.
* [/Fblf%] Figure out how to avoid duplication of module definitions.
  For the case like Add, and Bitwise modules that take a non-var argument as a
  function to the module.
  - I'm pretty sure the solution is to separate the definition of the module
    procs from the definition of the module interface. It's just annoying.
* [/Fblf%] Add nicer summary and error messages in compiled fblf test runner.
* [/Fblf%] Rewrite tests for /Fblf/Heap%.
* [/Fblf%] Figure out how to replace fblf integer arithmetic with a native c
  implementation at compile time.
  - See how much faster it is now.
* [/Fblf%] Implement space invaders in fblf.
  - Do whatever is necessary to make it easier to write the program as I go
    along with regards to types and syntax.
* [/Fblf%] Add test cases for aliasing for things in general?
* [/Fblf%] Replace /Loop%.For and /Loop%.DoWhile with /Iter%.For?
 - Because the /Iter%.For is a nicer API I think.
* [/Fblf%] Add test for /Fblf/Program/Show%, which I don't think is currently even
  compiled when tests are run.
* [/GameOfLife%] Switch to a target 60 FPS?
* [/Hwdg%] Improve the API for describing a bunch of gates with modules.
* [/Hwdg%] Have an easier way to set a bunch of cells at once?
* [/Hwdg%] Add test case for nondeterministic/conflicting gates case.
* [/Invaders%] It's way way way too slow. Figure out how to make it go much faster.
 - Profile the benchmark to see what's up.
 - Figure out if this is a problem with the code written in fble or if it's a
   problem with the fble implementation.
* [/Invaders%] The aliens look like they are too far down the screen to start. Double check
  their initial coordinates.
* [/Invaders%] Once it is fast enough to be reasonable to develop, finish writing the game.
* [/Sat%] Optimize the solver.
* [/Sat%] Implement dimacs cnf parser.
* [/Snake%] Switch to a target 60 FPS?
* [/Snake%] Test and fix bug when snake eats its tail.
* [/Snake%] Ignore moves that aren't orthogonal to current snake direction.
* [/Snake%] Keep track of and report score.
* [/Snake%] Figure out why the background box gets lost some times.

* [libfble] Can fble-stdio check that the function has the right type?

* [lang] Clarify in spec: is it okay to retain a local variable until a function
  exits, even if that means retaining it longer than its lexical scope?
* [lang] Clarify spec on when (compile vs runtime) vacuous value error should be
  reported.
* [lang] Add support for abstract types?
* [lang] Document the runtime memory model,
  - Including that tail recursive functions should not smash the stack.
* [lang] Document and test that put ports don't retain link values.

* [typecheck] Change FbleFuncValueTc scope to be FbleTcV? Isn't that more natural?
* [typecheck] Be more consistent in FbleTc about use of vector versus FbleTc*[].
* [typecheck] We don't get a warning about an unused self recursive function.
  More generally, we don't get warnings about variables that are referenced
  only by unused variables.
* [typecheck] Better error messages on types that have the same name but different values?
* [typecheck] Quote funny names in types. For example, the field ',' should have
  quotes in type error messages.
* [typecheck] Better error message for importing something from a module that
  is not defined in the module?
* [typecheck] Test and fix error message for type of anonymous type let values.
 - The type should be the computed type for the value, not the introduced
   abstract type?
* [typecheck] Figure out why Normal is called so often
 - See if we can fix that to reduce the now annoyingly long compile times.
 - Profiling said its all in TypeEquals. Maybe something pathological?
* [typecheck] Improve type error in case of this?
  <@ T@>{ Maybe@<T@>; } Nothing = <@ T@> { Maybe@<T@>(nothing: Unit@()); };
  True.?(true: Nothing<Bool@>, false: True);

  We get: expected type <@ T@> { Maybe@<T@>; }<Bool@>
  Should we instead get: expected type Maybe@<Bool@>? 

* [eval] Clean up how we track io activity?
* [eval] Thread execution should be at least somewhat fair.
  In the current implementation, in theory, a long running non-IO computation
  could cause IO threads to get blocked. That's certainly against the spirit
  of the spec, but I don't have a clear definition for how things ought to
  behave or a decent way to test that. Figure out something better here.
* [eval] Make child thread execution fair.
  Children should be time multiplexed, where priority is assigned based on how
  far down the family tree the child belongs. The amount of time a family gets
  to spend evaluating should be independent of the number of children in the
  family.

* [profile] Cleanup
 - either way, document that clearly.
 - Switch to convention that caller is responsible for enter block?
 - Replace AutoExitBlock with ReplaceBlock?
* [profile] Check if it's okay to add new blocks to a profile in progress.

* [debugger] Implement an fble debugger?
  see thoughts/fble.debugger.txt

* [release] Write man pages for fble and friends?
 
