
% True = /Core/Bool%.True;
% False = /Core/Bool%.False;

% Chars = /Core/Char%.Chars;

@ Int@ = /Core/Int%.Int@;

<@>@ List@ = /Core/List%.List@;
<@>% Cons = /Core/List%.Cons;
<@>% Nil = /Core/List%.Nil;

<@>@ Maybe@ = /Core/Maybe%.Maybe@;
<@>% Nothing = /Core/Maybe%.Nothing;

<<@>@>@ Monad@ = /Core/Monad%.Monad@;

<<@>@>@ Stdio@ = /Core/Stdio%.Stdio@;
<<@>@>@ Main@ = /Core/Stdio%.Main@;

@ String@ = /Core/String%.String@;
% Str = /Core/String%.Str;

@ Unit@ = /Core/Unit%.Unit@;

@ Formula@ = /Sat/Sat%.Formula@;
@ Result@ = /Sat/Sat%.Result@;
% Solve = /Sat/Sat%.Solve;

<@>@ Parse@ = /Sat/Dimacs%.Parse@;
% ParseLines = /Sat/Dimacs%.ParseLines;
% ShowResult = /Sat/Show%.ShowResult;

Main@ Main = <<@>@ M@>(Monad@<M@> m, Stdio@<M@> stdio) {
  % s = /Core/Stdio/Stdio%(m, stdio); 

  M@<List@<String@>> GetLines = {
    Maybe@<String@> next <- m.do(s.In);
    next.?(nothing: m.return(Nil<String@>));

    List@<String@> tail <- m.do(GetLines);
    m.return(Cons<String@>(next.just, tail));
  };

  (List@<String@> args) {
    List@<String@> lines <- m.do(GetLines);
    Parse@<Formula@> parsed = ParseLines(lines);
    parsed.?(error: {
      Unit@ _ <- m.do(s.Err(parsed.error));
      m.return(False);
      });

    Result@ result = Solve(parsed.parsed, Nothing<Int@>);
    Unit@ _ <- m.do(s.Out(ShowResult(result)));
    Unit@ _ <- m.do(s.Out(Str[Chars.nl]));
    m.return(True);
  };
};

/Core/Stdio/IO%.Run(Main);
