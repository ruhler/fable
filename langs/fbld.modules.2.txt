Fbld Modules

See fbld.modules.txt for background and context.

Question: Can we naturally get polymorphic code using modules?

Example: Implement MaxFlow without knowing how Graph is defined, so long as
Graph satisfies certain properties such as having comparable nodes. Then a
different type can be used to test Graph than use Graph in practice.

Other use cases:
* Maybe<T>
* List<T>
* Multiple different implementations of some Map data structure with different
  performance characteristics.
* Ad-Hoc polymorphism: Example: Primes implementation that works for any kind
  of 'Nat' number with appropriate operations on it.

Proposal:

Goal is to build up, define and share modules.
A module is a collection of type, func, and proc definitions.

Modules can take other modules as parameters. For example, MaxFlow could be
used with TestGraph or with PingPongWinsGraph. Primes could be used with
UBNatUnary or UBNatBinary. Any module that satisfies the required interface
may be used.

Interfaces define a set of types, functions, and processes that a module
implements. An interface can be thought of as a type of module.

We say each module implements a specific interface. It's not hard to have a
module effectively implementing multiple interfaces  by defining wrapper
modules for each different interface.

Multiple modules may implement the same interface. This is required for
an interface to be useful as 'a type of module'.

To support polymorphism, interfaces may be parameterized by type. Note there
is no need to parameterize interfaces by func, proc, or module more generally,
because types is the only thing an interface depends on from the outside
world. Modules may also be parameterized by type.

A concrete interface is one without any type parameters. An abstract interface
can be made concrete by supplying all its type parameters. A type parameter is
supplied by giving a type (concrete or abstract) declared as part of some
other concrete interface, so that interfaces depend only on other interfaces.

Given interface I with type parameters a and b, any occurence of I(A, B)
refers to the same interface as I(A, B), so long as I, A, and B are all the
same.

Concern: Is there any problem with the fact that you could have two modules
with the same interface that have different implementations of concrete types?
For example, given some Map interface, where underneath it could be a ListMap
or a SetMap or a HashMap? That just means that distinct module variables with
the same interface should not be considered to have the same types. I think it
should be fine.

Similarly given mnodule M with type or module parameters a and b, any
occurence of M(A, B) refers to the same as M(A, B), such that some type M(A,
B).T is considered equal to some other M(A,B).T. But note that isn't true in
general unless the modules can be shown to be the same (it is not enough to
show the interfaces are the same).

In other words, I(A, B).T != I(A, B).T in general, but M(A, B).T = M(A, B).T.

Proposed syntax:

interface Map(K, V) {
  type Map;
  func empty( ; Map);
  func single(K key, V value; Map);
  func union(Map a, Map b; Map);
  func contains(Map m, K key; Bool@Bool);
  ...
}

Notes: 
 - No explicit dependency list. Dependencies should be clear enough from the
   interface description I hope. If need be, we can add extra syntax to
   document required dependencies.
 - The interface is parameterized, not the types within it.

module ListMap(K, V ; List(Pair(K, V)) list; Map(K, V)) {
  ...
}

Notes:
 - Defined like a function: name, type args, module args, resulting module
   type. Where module args and resulting module type are functions of the type
   args.
 - Types referred to from within a module must be associated with a specific
   module - either a module passed as a parameter, or a named module. We can
   still test the module is correct without knowing the implementation of a
   named module it depends on by assuming each differently named module
   defines different opaque types.

