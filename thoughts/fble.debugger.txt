Fble Debugger
=============
Features:
 - Set a breakpoint at a line in a file.
 - Step through code line by line.
 - Evaluate expressions in the context of the current scope and print the
   results.
 - Auto breakpoint at undefined behavior?
 - Any way we could do this just by using dwarf + gdb?

Times in the past I wished I have an fble debugger:
 - Debug why sudoku solver isn't working properly by stepping through a line
   at a time and printing intermediate values.

   Turns out it wasn't too hard to figure out the problem in this case without
   a debugger.

 - Debug why snake AI wasn't working.

   It turns out we were using the wrong direction. A debugger to step through
   code and print variable values would have found this more quickly than my
   guess and check approach, which was pretty tedious.

 - Debug why sat solver test is failing.
   Manual code inspection doesn't reveal the issue. I really want to trace the
   code to see which unexpected branch is being taken.

   Manually tracing through the code by profiling block led straight to the
   problem: bad implementation of boolean Eq.

 - Debug why List Eq test is failing. I want to step through again.
   Sigh. I definitely need a debugger.

   Turns out False was being defined as True instead of False. I figured that
   out by changing the body of ListEq to always return False and being
   surprised when the result was as if it returned True.

 - Debug why map equality is failing when show shows identical maps
   { (1,1) => 1; } vs. { (1,1) => 1; }

   Turns out it was a bug in map quality, not too hard to find by code
   inspection.

 - Debug where we're getting stuck in an infinite recursion in fble that
   exhibits as a fast memory leak followed by OOM kill.

   This turned out to be big memory use, not infinite recursion. I tracked it
   down by minimizing the test case enough to run it to completion, and using
   profiling to see how many times different functions were being called.

 - Debug wrong tag in fble tests, where the invariants for what the tag should
   be are a bit complicated.
   
   Ideally we can run until we hit the error, then get a stack trace in the
   debugger and have a way to look at local variables and the stack trace to
   figure out where things are going wrong.

   Turned out to be a flaw in the code. Identified by minimizing the test case
   and working out the issue on paper. It would have been much easier if I
   could have stepped through the code and printed values of local variables
   along the way.

 - Debug why drawing a line from (0, 0) to (-2, -2) actually draws a line from
   (-1, -1) to (-3, -3), ideally by stepping through the code and viewing
   local variables at each step.

   Walked through the code by hand on pen and paper to see that the code was
   doing exactly what I wanted it to, but what I wanted it to do was wrong.
   Being able to step through the code and view values of variables as we go
   would have been nicer than doing it on pen and paper.

 - Debug why triangle is not being clipped properly. Walking through the code
   by hand suggests it should work. I want debugger to step through the code
   and print variable values to confirm it lines up with what I expect based
   on walking through the code by hand.

   I ended up making a copy of the code, turning the Clip function into a
   process, making it a Stdio@ program, and adding print statements for printf
   style debugging. This revealed the problem was a bug in the integer Ge
   function.

 - Debug another issue why triangle is not being clipped properly. I can step
   through the code in gdb now, but without the ability to print variables,
   it's too hard to follow what's going on. I'm tempted to use my printf
   debugging approach again, which should find the problem pretty quickly. The
   printf approach is effective, but it's very tedious to thread IO through an
   otherwise pure function.
 
---

It doesn't look like gdb can easily support languages that are far different
from C. Perhaps it's worth trying to develop a custom debugger for fble. I can
avoid any overhead/dependency on gdb that way. But it also means I have to
implement the entire thing myself.

There are guides online for how to add a new language to gdb, which requires
modifying the gdb source code. That includes ways to specify how to print
types and expressions and how to parse types and expressions.

Could we use dwarf to pretend we are executing C code, and encode structs and
unions in a way that gdb can understand? Then at least for structs we could
see all the fields, and for unions, perhaps we could see the names of tag?
That's about as good as we could do anyway, right?

Dealing with the stack will be challenging, given tail calls and the fact that
the stack is managed. Perhaps it would be simpler if I finish implementing my
plan to use native stacks. Or perhaps not.

I'm thinking it is at least worth a try to emit dwarf information. In that
process I'll see what we can encode in dwarf and how, and how useful gdb is in
that case.

Let's go a ways down this route and see where we get. Initial goals:
* Be able to set break points and step through .fble files.
* Be able to print data type values as structs/unions based on variables on
  the stack.

Don't worry about stack traces yet. And let's focus on debugging compiled
code, which I suspect would be easier.

What happens today if we try to run a compiled program and set a breakpoint
based on an fble source file and line number? It says no such source file.

The first step, then, should be to see how we can get my .fble files included
in the list from 'info sources'. Let's download the dwarf spec and see how
to start with that.

---

My sample assembly program passes the file using a '.file' assembly directive
at the top of the generated assembly:

.arch armv8-a
.file "foo.c"

Within the assembly, I also see directives of the form:

.file 1 "foo.c"

And:

.loc 1 9 3
.loc 1 13 12 discriminator 3
.loc 1 13 12 is_stmt 0
.loc 1 13 12 is_stmt 1

My guess is what we need is:
* .file 1 "foo.c" somewhere near the top of the generated assembly file.
* .loc 1 <line> <col> for each line, and after the last line.

What does the gnu assembly docs say about these?
* The plain .file "foo.c" directive is deprecated
* https://www.sourceware.org/binutils/docs/as/index.html seems to have decent
  documentation of the directives.

The .loc options are all related to the .debug_line state machine, which I can
probably read about in the dwarf spec, page 151:

* lines and cols start at '1'
* is_stmt is a recommended breakpoint location
* discriminator is used in case multiple blocks have the same line, column,
  and file.

My guess is I don't have to worry about any of the line number options.

So, plan is simple:
* At the top of the generated assembly, emit a .file 1 "foo.c" directive.
* At the start of each emitted instruction, ...

We have to decide and track somehow which code instructions should have line
numbers associated with them. Or at least, which are starts of statements. We
also need to start tracking line number information more generally in
FbleInstr.

I would say a statement is:
* let bindings, branch of case expression, expression in a block or 'stmt'
  form, union_select statement, function bind, proc_link, and proc_exec.

Other things are not statements.

Can we use our profiling block locations as statements? We already have that
information available in the code block, and it has the location information.

Let's try this: profile enter and profile replace emit locations which will
correspond to statements. Try that.

It works! I can now set breakpoints on .fble files. Stepping through doesn't
work too well at this point, but it's a good start.

Question also: the profile blocks are basic blocks, not statements. This means
we'll skip over let expressions and things like that. It would be good if we
could add statements there. Maybe we could add a fake kind of profile op to
mark the beginning of a statement?

---

Note: Turn off -O3 when debugging to get better info, hopefully.

How can I print the values of variables?

Maybe to start, can we list the available variables somehow in gdb? Perhaps
'info locals'?

And also, typing 'next' in gdb doesn't work at all. Would be nice if I could
fix that somehow. Perhaps because we don't have more statements in the same
block, and so it doesn't know where the statement ends?

Other things my sample assembly has:
.cfi_startproc
.cfi_def_cfa_offset 16
.cfi_endproc

And a .debug_info section.

---

I finally read through the dwarf5 spec in sufficient detail. My summary of
dwarf is:

Debugging information is represented as a tree of nodes. Nodes describe things
like programs, functions, call sites, declarations, etc. Each node has a tag
describing the type of the node and a collection of key,value pairs which are
attributes. The tree is flattened into a sequence of nodes stored in the
.debug_info section.

Along with the tree of nodes, there is a section for storing a mapping from
line numbers to machine addresses, stored in .debug_lines. There is also a
section for call frame information, stored in .debug_frame, that describes how
to unwind the stack and restore registers appropriately.

My guess is that the gnu assembler generates the .debug_lines section for me
based on my .loc directives, and it would generate the .debug_frames section
for me too if I add relevant cfi directives. I'll have to write the
.debug_info tree myself.

The dwarf spec has an appendix showing what all attributes you could expect
for various node types in the tree. I don't know what information gdb needs
for specific features, such as going to the next statement. But presumably if
I try to fill out the debug information tree with as much information as I
reasonably can that seems related, eventually I'll get to a place where gdb
can do good things.

Note that dwarf5 does support tagged unions. I think they call them variants.

What approach should I take for adding dwarf support? I would like to do it
well and complete. Not just hacky like I have so far. For example, statements
should include all the statements, not just the beginnings of blocks. Then it
should be fairly straight forward I think: start with a minimal compilation
unit debug tree, then slowly and recursively add more attributes until we get
to a place we are happy with.

A big challenge will be figuring out how to write tests for the generated
debug info.

Maybe libdwarf will be useful? Looks like it can do some sanity checks, and
dump to human readable format. So I could at least craft a particular .fble
file, dump the dwarf for it, and verify it has all the statements and
variables and types and such? Or perhaps objdump has some support?

dwarf.h and libdwarf.h exist on my computer, defining a bunch of the dwarf
contents. That will be useful.

For example, try objdump with --dwarf and see what it outputs. And it has
a --dwarf-check option too.

It looks like the assembler is generating a compilation unit entry for me. It
also says it is emitting dwarf2. Maybe I should start by generating dwarf2,
which is perhaps more widely supported than dwarf5 and simpler?

I think first step is to pick some attribute I want to add to the compilation
unit node. Figure out how to add that in the assembler. Next step is to figure
out how to add a broken attribute value and use objdump or dwarfdump to catch
the error. Then set up a dwarf test case that runs as part of build.

Once I have the infrastructure up and running to test dwarf, I guess I can
slowly start adding dwarf. For now we can just check for consistency in the
generated dwarf code.

---

Let me start with dwarf2, look at an example c file compiled by gcc. Dump the
debug info entries, and see where the functions/statements show up in the
tree. If statements are completely separate from functions, then let's start
by generating all the statement nodes. If, as I suspect, the statements are
parts of functions, then let's generate function nodes to start, and worry
about adding statement nodes after.

My sample foo.o file has:

DW_TAG_compile_unit
  DW_TAG_subprogram main, with low_pc and high_pc
  DW_TAG_subprogram sludge
  DW_TAG_subprogram foo
  

I see no nodes for statements. Presumably those are captured using low_pc and
high_pc along with line location info? Except .debug_abbrev might augment
that?

And from assembly, how is that encoded?
Maybe add
  .type foo, %function before a function label?
  .size foo, .-foo at the end of each function?

I don't know. This is hard. I should probably actually read and understand the
spec.

Let's try setting .type and .size and see if the assembler generates anything
for us for free from that.

No, it doesn't. I think what happens is GNU AS generates a .debug_info section
if there isn't one in the file, but in the case of gcc, it adds one explicitly
to the file. So I'll need to add my own to the file, with all the node info,
and presumably GNU AS will see it and avoid creating its own.

Any reason to keep the .type and .size info for symbols? How about no, until I
figure out what it's good for.

Note: my gcc appears to emit dwarf version 4 for the .debug_info section
(unlike dwarf version 2 for other sections). So maybe that's a good target to
start with? Or maybe stick with dwarf version 2 as long as it has what we
need, and upgrade to later version only as needed.

I suppose a decent place to start, then, is to emit my own compile_unit tag:

producer: FBLE
name: foo.fble
comp_dir: getcwd
low_pc: 0
high_pc: ??? get this with some asm magic? Yes. I can use a label to the end
of the text.

So probably we'll want to emit the debug_info all at the end, referencing
labels within things?

It looks like we need a .debug_abbrev section too. .debug_info stores the
attribute values, .debug_abbrev stores the attribute names.

Cool. This should be straight forward to start, if a little tedious in the
details. Let's emit a single compile_unit node.

---

The compile_unit should contain subroutine entries for each of the functions.

DW_TAG_subprogram
  DW_AT_name string "/foo/bar%.blah"
  DW_AT_external flag for externally visible functions. Just the top level?
  DW_AT_calling_convention - can be omitted for standard c calling convention.
  DW_AT_type - for the return type, but I don't have support for describing
               types yet.
  DW_AT_low_pc, DW_AT_high_pc - for the address range of the function.
  DW_AT_return_addr, DW_AT_frame_base 

So, to start, just name, external, low_pc, and high_pc I guess. Or even just
name, low_pc, and high_pc.

---

I could write tests for the debugging stuff using gdb scripts, right? Debug a
known program, verify I can place breakpoints and view things and step through
things.

It would be great if I knew what information gdb needed for certain tasks, so
I could do this based on what gdb needs instead of randomly adding information
and hoping for the best.

If the first debugging goal was to be able to set breakpoints on .fble files,
the next debugging goal would be to be able 'step' and 'next' through the code
reliably. I suppose we don't really have the first goal done yet, because you
can't set breakpoints at the start of a let body?

How about:
* figure out how to write a gdb based test of the debugging stuff.
* write a test that you can set a breakpoint at the start of a basic block.
* write a failing test that you can set a breakpoint at a let body.
* add debug info necessary to set a breakpoint at a let body.
* research what approach/info gdb needs to implement step and next.
* add a test for step/next.
* implement whatever is needed for step/next.

Apparently I can no longer set breakpoints at lines in .fble files, presumably
because I added my own debug_info section? No, looks like it's because I
specify the statement list as 0 instead of some relocatable value, and it
isn't being relocated properly.

Yeah, that was the problem.

I'm also getting some dwarf warnings about bogus end of sibling markers that I
don't understand. Maybe I need to check out the source code for dwarfdump to
see why it produces that warning.

dwarfdump -ka produces a lot more info, and I have source code so it's
possible to figure out what's up.

Here's one issue reported:
* DW_AT_stmt_list is apparently expected to use data4, not data8.

The trouble is, gcc generates a lot of errors according to dwarfdump too, and
given that some of the errors are generated by the assembler, it's hard to
know how I could use dwarfdump meaningfully as a test. Maybe just run it
occasionally in case of gdb issues?

Examples of current errors reported by dwarfdump associated with FBLE:
* .debug_line: Address 0x004220b4 DW_LNE_end_sequence address does not exactly match high function addr:  0x0041928c ***
* .debug_line: standard DWARF3 operands matched, but is DWARF2 linetable: count 12 at offset 0x000139b3  ( 80307 ) ***

The second one I see from GCC, so let's ignore that.
The first is specific to FBLE, so maybe worth tracking down.

This happens, for example, in /Fble/DebugTest% function.

I have no idea what's going on here.

---

Next steps with gdb: 'step' and 'next'.
* step apparently goes to whatever the next source line encountered is. I
  should be able to verify that works today.
* next: "Execution stops when control reaches a
   different line of code at the original stack level that was executing when
   you gave the next command. This command is abbreviated n."

Presumably 'next' is not going to work in the case where the frame pointer
gets mess up, or the backtrace gets messed up?

Step appears to work as specified, except it's a little annoying it steps into
C code. It would be nice if we could make it go to the next 'fble' source
file.

Next gets stuck at the address of the 'exit' trampoline. Somehow that stack
appears to be corrupted when we get there. Perhaps it would help to give each
function its own exit routine. More traditional and straight forward. I'm not
sure why the stack is messed up there though. Maybe gdb is just confused that
a part of the function isn't where it thought it would be?

Yeah, moving exit into the particular function it is for fixes gdb's
unhappiness about next. But next doesn't work the way you want because it
triggers when we do any call into a function, which causes us to move the
native stack to the managed stack for the current running function, so gdb
thinks we have exited the function and it's time to stop.

---

How will multithreading work?

gdb has support for pthreads. Otherwise I bet it will get confused.

But, can we use pthreads for light weight multithreading? For example, if I'm
going to allocate a separate stack per thread anyway, is there significant
overhead associated with pthreads?

I would be happy to use pthreads if:
* The overhead of creating threads isn't too high, because we do it with every
  proc/exec. Creating and joining threads should be light weight. Like, on the
  order of a function call, or maybe up to 4x a function call.
* We can set the scheduler to only allow one thread to run at once.
  I suppose we can have a big lock if we want to, to control this.

I fear it's just going to be way too much overhead though.

And the fble thoughts archive shows last time I considered pthreads, there's a
not very high limit on the total number of threads you can have.

Maybe multithreading won't be so big a problem in practice, because we tend to
execute a thread to completion whenever possible, so the only time we do a
context switch that could confuse gdb is when the thread gets blocked.
Straight line code should work just fine.

---

Another question: any way we can avoid calling into the .c files? How about we
avoid generating debugging symbols for .c files, so the only debug symbols we
have are for fble files. Step should then step through only the .fble files,
right?

Yes! That works great. As long as we can make it obvious to gdb what the stack
is, if we only have fble debug info produced, then 'step' goes to the next
fble line. In practice this would work by having a user link with a release
build of libfble that does not have debugging symbols.

---

With subprogram entries in place, we can now set breakpoints on function
names, assuming you can figure out what the right name to use is with regards
to '!' extensions.

---

Now that we do function calls in place instead of falling back to RunThread to
do function calls, next and backtrace work decently well. That's cool. I bet
we can step through the code in a useful way now. Aside from there not being
enough statement locations.

---

Next step is to have some way to print variable values. I think to start,
given a variable name, it would be nice to print the raw pointer value as an
FbleValue*, or worst case to start, as an intptr_t.

Looks like I'll want:
   DW_TAG_variable
     DW_AT_name string name
   DW_AT_location location at runtime
   DW_AT_type (for when I start supporting that)
   DW_AT_start_scope (offset from low_pc)
     For variables that are declared in the middle of a block.

If I want I can put these directly in the subprogram tag it looks like, or
introduce DW_TAG_lexical_block with low_pc and high_pc for grouping.

How to specify a location?
I want something like: a register specifies an address, we compute an offset.
So: memory[reg + X].

Looks like we can do it with one op:

  DW_OP_breg* <reg> <X>

Where we'll have to look up how aarch64 registers are numbered for dwarf. I
don't think that's in the dwarf spec.

One question is how I'll propagate this information from the fble compiler to
the aarch64 code generator.

Could we define an explicit dwarf like data structure that we pass around
along side an fble code description that refers to offsets in terms of fble pc
and variable offsets? Then the aarch64 code generator could convert that to
dwarf. It would be nice if we accurately tracked statements and braces and all
that fun stuff. Instead of overloading profiling info? Or could the profiler
reuse this same info for describing locations of blocks?

