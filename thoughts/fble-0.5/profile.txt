Fble Profiling
==============
Goal is to update fble runtime implementation of profiling to output in a form
suitable for consumption by pprof. See pprof.txt for context.

Actually, I think it's totally doable and simpler than what we have today.
Here's the proposal:

We keep to data structures:
1. The stack.
2. The profile.

The profile is a tree of nodes, where the path from the root to the node is a
compacted sample path. But we allow there to be back edges in case adding a
frame to a stack would cause us to compact and drop nodes. Each node keeps
track of time and entry counts.

The stack is a stack of pointers into the profile that tracks the current
position. When you enter a frame, you update the pointer in the profile based
on that frame and push it on the stack. When you tail call, you update the
pointer in the profile based on that frame and update the top of the stack.
When you exit a frame, you pop the stack and go back to whatever pointer into
the profile is left.

Really the only difficult operation is given a profile, a pointer into the
profile, and a new frame, traversing to the right next place into that profile
with compaction accounted for.

The general idea is:
* If the new frame is already a child node of this node, follow it and you're
  done. Easy. Fast. We can do binary search for child nodes. Most nodes will
  have only a few children, but some of the 'FbleCall' variety could have
  lots, so best to do binary search.
* Otherwise see if we can compact:
  If the current node matches. That's a 1 compaction.
  Else try a 2 compaction: 2 nodes up matches for two nodes.
  Else try a 3 compaction: ...
  Until we run out of possibilities.
  If you find a compaction, add a back edge to the start of that.
* If you can't compact, add a new node.

Our tree nodes will need a pointer to their parent to check for compaction. I
think we should also keep track of the depth of the tree node, so we can
quickly identify back edges so we traverse the tree.

It's going to be messy. Tests will need to be updated. But I think this will
be good. Let's give it a try and see how goes.

---

I'll need to change the FbleProfile data type. Can we make it not be public to
start? That seems like a decent first step?

It will mess up test cases, but I'll have to rewrite those anyway.

Can I use NULL instead of having an enabled flag? No. We want people to be
able to use the APIs not knowing if profiling is enabled or not. Best to make
that enabled flag internal and provide a function to manipulate it.

How will I update profiles-test.c? Should I add an API to be able to query the
profile? Anything more than just outputting a profiling report?

profiles-test.c at least would be useful to keep around.

---

I have two kinds of profile tests:
1. fble-profiles-test checks expected number of calls in /ProfilesTest%
2. fble-profile-test is unit test for the FbleProfile APIs.

Let's not worry about them for now. Revisit after I switch to the new API.

---

Sketching out the new implementation, the code looks pretty nice and easy so
far. I just need to do a few bits:
* EnterBlock is the fun one: binary search in the profile, if nothing found,
  search for compaction and insert a new node sorted.
* FreeNode should be straight forward.
* GenerateReport: Maybe just traverse the tree, and at each node, print the
  count (?), time, and then walk up the tree to figure out the sample path (in
  reverse order). Or pass the sample path prefix down as an arg.

---

Looks like the new implementation works now?

Let's compare performance and results before/after.

Here's the new implementation:

yes | head -n 200000 | /usr/bin/time -f "%E" ./out/pkgs/md5/fble-md5 --profile
md5.new.prof.txt --
c2938b130a1d2db9597a9c9a8ea2a5cf  -
2:37.36

Here's the old implementation:

yes | head -n 200000 | /usr/bin/time -f "%E" ./out/pkgs/md5/fble-md5 --profile
md5.old.prof.txt --
c2938b130a1d2db9597a9c9a8ea2a5cf  -
3:32.20

So definately performnace is improved. 2.5x overhead instead of 3.5x overhead.

Looking at the results themselves:
* Um, there are an absurd number of samples. Is canonicalization not working?

It's got the expected number of samples based on md5.old.prof.txt. But
pprof.py runs out of memory processing those all.

Let me see if I can hack up a script to canonicalize and see if we are
under-canonicalizing.

It doesn't look like we are missing any canonicalizations. I think md5 just
happens to have a large number of different paths with all the rounds and
stuff. Let me try a simpler program to compare results on.

Yeah, on core tests, the profiling info matches what we had before. Looks
good.

Awesome. I'm happy about this. Just a bunch of things to clean up now.

---

I need to get tests back in place. Which means I need a way to query the
profile.

For fble-profile-test, I want to be able to write what would be printed out
for the profile. But also I want to check counts as well as time?

The most general API would be something that can iterate over all the
sequences and get count and time for them. From that I could implement queries
for specific samples. Hmm... Yeah, maybe that's the way to go. It could be
slow to start, but I could implement queries like: count number of different
samples, assert count and time for a given sample. Etc. Worst case, I could
convert into some different structure that I can explicitly traverse.

How about:

FbleName FbleProfileBlockName(FbleProfile* profile, FbleBlockId block);
void (*FbleProfileQuery)(FbleProfile* profile, FbleBlockIdV sequence, uint64_t
count, uint64_t time, void* userdata);
void FbleQueryProfile(FbleProfile* profile, FbleProfileQuery query, void* userdata);

---

Trouble with fble-profiles-test:
* How to implement calls with this query interface?

If we have a -> b -> c, then a calls b 1 time, but the profile report is going
to look like:

1 a
1 a -> b
1 a -> b -> c

How can I tell the count for a -> b should be ignored for a -> b -> c? I guess
it's safe to look at sequences that end with a -> b?

Okay, it works out for calls, as long as I look at the end of the sequence,
under the assumption that if a -> b -> c, then there must be a count for 
the a -> b in a sequence ending with a->b.
