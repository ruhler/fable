Modular Compilation Review
==========================
We added modular compilation to fble-0.4. It was a messy discussion. It seems
to work in practice, but has a hole around the case when builtins and
non-builtins depend on the same builtin module.

Goal here is to review things at a high level, describing how they ended up
looking today, what does or does not make sense about that, and what the
vision is for how things should ultimately look.

If we can make sense of the behavior today, we'll want to add spec tests for
the corner cases if we can and get things implemented properly.

Let's start with a summary of the vision for how things should work today.

There are two important topics:
1. Type checking of dependent modules. When it needs to be done, when not.
2. Can builtin modules depend on modules that non-builtin modules cannot?

If we answer those questions, does that get to the bottom of everything of
interest?

1. Type checking of dependent modules.
To compile a module, we need to know the types of modules it depends on. That
means any time a non-builtin module depends on some other module (builtin or
not), we need to get the type of the module it depends on. We do that via
either .fble or .fble.@ files.

We don't need to know the type of a pre-compiled module's dependencies to use
it. We already compiled the module. We got the type of its dependencies at
compile time. Can we trust that the type of its dependencies hasn't changed
since then?

Kinds of trust:
* Given .fble and .fble.@ files, we can get type from both. No extra trust
  needed.
* Given .fble.@ and a compiled module, we trust that the .fble.@ matches the
  type of the compiled module. If we stored the actual type of the module with
  the compiled module, we could check against the .fble.@ file. But in that
  case, we could just use that type directly, no need for a .fble.@ file. And
  there's nothing stopping us from generated a compiled module with a broken
  type.
* Given a compiled module and another compiled module it depends on, we trust
  that the module it depends on has the type we expect. We could store the
  type with the compiled module instead of with a separate .fble.@ file. We
  could recheck the type if we wanted to at load time.

A compiled module could be stored with or without its type. A compiled module
could be stored with or without a human readable .fble.@ description of its
type. We have to take a leap of faith regardless that the type stored with a
compiled module is accurate. If there are two types stored with the compiled
module, binary and human readable, we could check them against each other. But
that doesn't really add much.

It would be difficult to make use of type errors in reference to a module
whose type is not available in a .fble.@ form that a user could read.

So, option to consider: do we rely solely on .fble.@ for describing the type
of a pre-compiled module, or do we also have some way to encode it with the
compiled module itself. For now, the approach is having just .fble.@. I could
imagine a future where we add some encoding in the compiled module itself.

My gut feeling is that it will be useful to store the type with a module and
double check the type is what we expect at link time. If the types don't match
at link time, give an error. Maybe we don't even need a type, maybe a hash of
the type is fine, because there's not much actionable you can do in this case.
You can't change either of the pre-compiled modules. You just get the sanity
check that something is wrong. It's like getting a version mismatch error. But
this also feels like a 'nice to have' feature, not something we need right
now.

2. Can builtin modules depend on modules that non-builtin modules cannot?
That would be nice. It would allow for completely hidden internal modules. I
vote yes. Like, maybe I have a library of modules I use internally at compile
time. I ship the compiled code for all my modules, including the private
internal ones, but I only supply .fble.@ files for the public interface. In
that case, a user should not be allowed direct access to the private internal
modules.

Builtin modules can depend on modules that non-builtin modules can also depend
on. Think of public interface A% and B%, where A% depends on B%, and some user
module depends on both A% and B%. Now B% is used both from A% and from C%.
Nothing out of the ordinary about that.

That's the groundwork. I should be able to answer all my questions now.

FbleLoadForExecution takes a list of public builtin modules, a module search
path, and a target module path to load. Builtin modules can directly depend on
other builtin modules without putting those in the public list.

Important questions:
1. Can a builtin module depend on a non-builtin module?
2. Can a builtin module depend on another public builtin module?

For (1), you could imagine either way, but I have a hard time trusting the
type dependency for a builtin module depending on a non-builtin module. It's
too easy to change the non-builtin module and cause things to break because it
has the wrong type. Though you could imagine use cases where you swap out an
existing pre-compiled module by searching for a non-builtin module first.

For (2), I should think yes, absolutely. But we could have the option of
having two separate copies of that module: one for the builtin reference and
one for the non-builtin reference. If needed to make things easier. Ideally
they both share the same module.

I feel close, but not quite there yet. I think I have all the pieces, I just
need to make some decisions and be resigned to the fact that my current loader
is buggy and will need fixes.

Summary of considerations:
* We have three types of modules: public builtin, private builtin, non-builtin.
* What combination of the three module types are allowed to depend on what
  combination of the three module types? And what type checking is done? There
  should be a 3x3 matrix I can fill in.

Come up with my 3x3 matrix for what is allowed, implement support for that. In
some cases what is allowed and what is possible will likely depend on whether
we can embed a type with a compiled module.

---

The question is: what happens if a module is referred to privately and
publicly? What if it is referred to multiple separate times privately? How
confident are we that those different instances with the same module path name
are the same? Could they not be different versions of the same named module?

It's difficult to say when I don't have a clear use case. Today we have two
use cases: 1. list of builtins that don't have dependencies, for public use.
2. Pre-compiled modules where the list of builtins has a single module and
that's the module we are running. We don't have the case of a list of multiple
builtins with dependencies and where the main module might be something
different in addition.

It's possible to check at runtime if two builtin modules are pointer
equivalent.

Imagine we have a common library Foo, with different versions. Then two
different packages A and B that depend on Foo, but they depend on different
versions of Foo. Can we use A and B from the same program? Assuming the types
are compatible? We ought to be able to, I think. That means two separate
instances of the modules in Foo in the program. If an external module depends
on Foo, which version does it get?

We could require that the builtins list does not have the same module path
more than once. That top level builtin module can then be the canonical one
used when requested. Internal references can be to different versions of the
module with the same module name. Then the linker can go based on pointer
equivalence of modules rather than name equivalence. But it also means keeping
track of whether a loaded module is public or private.

How does this relate to dll/dependency hell?

From wikipedia, issues seem to be:
* Having a single global registry mapping module name to implementation.
* Having a single loaded instance of a given module at runtime.
* Having multiple packages want to load the same named module, but at
  different versions.

So yeah, seems like this is a form of that. I should be careful to get things
right.

---

It's too soon to work out all the details of how packages and versions are
going to work. I don't have a single use case today of builtins depending on
other builtins while an external module depends on a builtin.

I think it's safe to say at this point that we want to support multiple
versions of the same named module to co-exist in the same program. For the
time being, we can use FblePreloadedModule* as a proxy for version.

Thus, proposal: Each unique FblePreloadedModule* is included at most once in
every program.

Add that to our existing: each .fble file is included at most once in every
program.

If we have the same name module in FblePreloadedModule* form and .fble form,
we can load both into the same program, using whichever form is appropriate
for the dependency in question.

The current search order is:
1. Search for main module in builtins.
2. Search for main module as .fble.
3. Search for dependant module in already loaded.
4. Search for dependant module type in .fble.@
5. Search for dependant module in builtins (if we have .fble.@)
6. Search for dependant module in .fble

That's fine. The key difference I want is to keep track of which of the loaded
modules are public and which are private. In step (3), only consider the
publicly loaded modules. A module is 'public' if it is in the top level list
of builtins or was loaded via .fble.@/.fble.

Any reason to prefer builtin over .fble file? With the new public/private
logic I have, I can see it making sense to prefer .fble first.

Anyway, the key idea is made: have a notion of publicly vs privately loaded
module, and avoid reuse of a privately loaded module (unless the pointer
matches). That leaves open a future where we can load modules with the same
path but different versions.

That's enough of an answer for now. What's left is:

* Review the search order. See if I would prefer something different.
* Document the search order clearly somewhere.
* Write some spec test cases to test that search order?
* Figure out how to implement the updated logic
 - That avoids making use of an already loaded private module inappropriately.
 - That loads type information for a builtin module appropriately.

Search order is either one of:
* Look for .fble before builtin.
* Look for builtin before .fble.

The benefit to .fble first would be you could 'patch' the builtin. On the
other hand, that means your could 'corrupt' the builtin too. .fble first seems
more flexible: you can chose to have the .fble present or not. But might also
break things. If we have compiled code and interpreted available, wouldn't you
prefer to use the compiled code? Or maybe interpreted can be made more up to
date?

My gut tells me .fble first is the right way to go, even though it's riskier
and harder to manage. Hmm... If you're going to go with .fble first, what is
the point of having builtin?

Maybe read more about things like gcc and standard include paths: does
standard come first or second? Surely it comes second, right?

---

Deciding whether builtin or non-builtin comes first on the search path isn't
enough to resolve concerns about two different packages depending on two
different versions of the same module. Not if those two packages are
distributed as .fble files rather than builtins.

What if I try to limit the problem for now. Assume each module path shows up
exactly once in the search path. No confusion about version.

This implies:
* There is never a builtin with the same module path as a .fble file.
* There are never two builtins with the same module path that are different.
* If there is a .fble.@ for a module path that is provided as a builtin, that
  .fble.@ file describes the type of that builtin module.

Under these restrictive assumptions, what's broken today in the loader is we
fail to load the .fble.@ file with type information for a builtin module used
by a non-builtin module, if it was first used by a builtin module.

I'm torn. On the one hand, it would be really nice to have clearly specified
loading behavior and implement that. On the other hand, I don't think I'm
ready to solve the problem for different versions of modules today, and
I think that's an important part to deal with in the specification.

Example: Say I should package A in .fble form, and A depends on some common
package C. Then I ship package B in .fble form, and B depends on some common
package C, but a different version. Then I want to run at runtime, given A, B,
C1, and C2. We need some way for A and B to indicate which version of C they
refer to.

If we had that, then the problem reduces to: when I look up a reference to
another module, it depends on the context of the module I'm looking up from.
And then, at that point, assume it's uniquely determined.

For example, maybe every module belongs to a single package, and modules are
identified by package and module path, and somehow we can enforce that you
can't have two of the same package or two of the same modules within a
package.

It seems like, regardless, we need a uniqueness assumption at some point
during the loading process. And we need an identification function. I don't
know what those are or should be, but I should be able to make loading work
right today assuming we have those. In other words, today we can assume module
paths are unique and there is a trivial identification function, but that
module name is not sufficient to determine these things. Get everything else
to work reasonably under those assumptions.

I think I should try to do at least this much, even if we don't have a spec
yet. Maybe even if we don't have any test cases yet. Get the implementation in
a decent enough state so that it works in theory, even if untested on weird
cases.

---

The FbleProgram data structure today does not allow to distinguish between two
different (version) modules with the same path. I'll need to fix that to
support that in general.

Idea: What if we treated the .fble.@ for a module as a separate module from
the .fble file? For example, we could say Foo.fble depends on Foo.fble.@
(optionally). If Bar.fble refers to /Foo%, it depends on Foo.fble.@.

The potential upsides are:
* No need for type_deps versus link_deps
* The type of a module can appear at a different point in the program load
  list than the value of the module.
* Clear explanation for why loading a builtin module doesn't require loading
  its .fble.@ file, even if one exists.

I think it's worth considering. If we split them out, it's pretty natural to
say we load a builtin via builtin first, then want to load it via non-builtin,
we already see the builtin loaded, but not the type. At that point we can
simply load the type. No need to have already loaded the type, or load the
type at the same place in the program.

In terms of long term vision, I think we need to talk about packages.

Let's say packages are versioned, not modules within a package. Makes more
sense. Packages depend on other packages, potentially specific versions of
other packages.

A module path within a package is mentioned as unversioned. The version
dependencies on the package determine the actual module you resolve to. That
way you can update package dependencies in the package specification without
having to modify any of the modules inside.

To load a program, you specify a package and module path. The package is
loaded first thing, it gives the location of all the modules inside. It also
gives the other packages it depends on and their versions. Those are used to
resolve the right version of modules references from the package.

I'm not convinced packages should be part of the language spec. But there
should be a convention people follow and that is supported by the fble
implementation.

So there you have it. The three key things:
1. FbleProgram data structure needs to change eventually.
2. Consider treating modules and their types as separate modules.
3. I have a long term vision for dealing with versioned packages.

Which brings us to the next question: what do I want to accomplish with
respect to all of this in this release?

---

My vote for this release is not to change or come up with any specifications
or anything to do with package formats and versions. But to make an attempt at
cleaning up the internals in preparation. In other words, try (1) and (2) from
above, don't worry about (3).

In terms of FbleProgram data structure, what if we loaded directly into what
is today called FblePreloadedModule? Or rather, the idea would be to directly
point to the other loaded/typed/compiled modules instead of going via list of
module path dependencies.

That way the loader can do what ever magic it wants to figure out exactly is
meant by a module path.

FbleLoadForExecution
 - returns the main module with pointers to what it depends on.
 - ... or an array of them, that has deduplicated already?

FbleTypeCheckProgram
 - recursively type checks a module's dependencies, then the module?
 - ... or goes through the program array in order, searching dependencies by
   pointer instead of module path?

FbleCompileProgram
 - Compiles each module in turn, or as requested. Doesn't care about
   dependencies between them, just counts.

FbleLink
 - Walks through each module in order, linking them together.

Given that loading, type checking, and linking modules all want a flattened
list of all the modules, I think it would be useful to do that as part of
FbleLoad and make the program be that full list of modules in topological
order.

Module state to keep track of:
* path, list of dependencies (by pointer),
* expr - type or value depending
* code - filled in after compile.
* exe - filled in after linking.
* profile_blocks.

It's pretty close to what we have now. And then FblePreloadedModule turns into
FbleModule directly and can be reused that way.

We can do the change incrementally. I think via the following steps:
1. Separate type and value versions of modules.
 - Merge .type and .value fields into a single field.
 - Merge .type_deps and .link_deps into a single field.
 - Add some way to distinguish between the type and the value of a specific
   module path. Needs some details worked out.
2. Change FbleModulePath to FbleModule* in the list of dependencies.

This feels like it will be nice cleanup. Nice de-duplication of code in
multiple places.

---

Here's my proposed path forward:

1. Change type_deps and link_deps fields of FbleModule from FbleModulePathV to
FbleModuleV.
 - Allows us to distinguish in theory between two modules from different
   packages with the same name.
 - Allows us to distinguish between the .fble.@ and the .fble for the same
   module path.
2. Change FbleProgram to be a synonym for FbleModule.
 - In other words, get rid of the topological sort/flattening of program
   during load time. Let loading, typecheck, compile, and link all traverse
   the DAG with logic to avoid duplication.
 - Probably need to add reference counting to modules at this point.
 - Will be a bit tedious, but I think worth it.
 - Makes module/program composition nicer conceptually. A module is a program.
   No need for 'the last module in the list is main'. Avoids the need for an
   FbleProgram separate from an FbleModule to make sense of the meaning of the
   FbleModule. Sounds nice for a future world where maybe we want to
   dynamically load and unload portions of a program.
 - After step (3), makes it easier for compilation to ignore whole parts of
   the graph used only for typecheck.
 - Discourages the hack of using a flat array of modules with flat arrays of
   side data and linear search for mapping module to side data. More incentive
   to switch to a proper data structure for that map later on.
3. Separate the .fble and .fble.@ for a given module path into two different
   FbleModules.
 - Add optional 'type' dependency from a module to its type.
 - Clears up semantics of when the .fble.@ does or does not need to be loaded.
   For example, a builtin referenced from a builtin and from a non-builtin,
   both load the .fble, but only the non-builtin depends on the .fble.@ as
   well.
 - Makes it easy to fix this bug of loading a builtin from a builtin first and
   then from a non-builtin. When you load from the non-builtin, just add the
   .fble.@ later. No need to contort or reorder things to make it work.
4. Reuse FbleModule for FblePreloadedModule.
 - Avoids the need for a separate type for prebuilts.
 - Loading of builtin modules is now as easy as taking a reference count.

It's going to be a little painful to get there. A little bit tedious. But look
at all the good stuff we get? My proposal for this release is to make the (4)
changes above and call it. We can save test and spec changes/updates for
another time.

Let's get going, see how things go.

---

Step (1) is done. It wasn't bad. Now for step (2) I can go incrementally.
Slowly phase out use of program->modules. Once it's all gone, it should be an
easy swap-out (ish, aside from having to add reference counting).

Step (2) is tedious...

For typecheck.c:
* I want to return a map from FbleModule* to FbleTc*.
* But I also want some way to distinguish between is something present in the
  map and NULL, or not present in the map. We can't use NULL for both 'type
  check failed' and 'I haven't tried doing type check yet'.

For compile.c:
* We assume everything type checks. I just need the map from FbleModule* to
  FbleTc* to get the FbleTc of the module to compile.
* We can check of module->code exists to know if we have compiled yet or not.
* I need to decide if I want to use recursion, or I need to manage an explicit
  stack data structure for the traversal.

For link.c:
* Things don't fail. So that's easier.
* I need to keep track of a map from FbleModule* to FbleValue* and decide if I
  want to use recursion or iteration for the traversal.

Is this really worth it? It's so convenient to have a traversal order laid out
in the program with perfect hashing of modules based on their index.

Can I just bite the bullet?  Rewrite the code once and be done with it? Start
with recursive implementations, switch to iterative sometime later when stacks
start getting smashed?

How about a helper data structure. Call it an FbleModuleMap. It maps from
FbleModule* to void*, with a method to check if an entry is present separately
from whether the value is NULL. I can reuse that for typecheck, compile, and
link, and do recursive traversal otherwise.

Maybe I can use #define macros to make it type safe. Or maybe that's not
needed. I can implement it in program.h, program.c. I think it's worth a try.

---

I decided to special case link.c, because it needs to form a separate array of
function values to pass as statics anyway.

typecheck.c wants to record, use, and then free the types of each module. And it
wants to record and return the FbleTcs of each module. compile.c just wants to
consume the FbleTcs of each module.

I wish we had better generic support in C. That way I could just write a map
implementation from FbleModule* to anything and use it in three different
places: typecheck.c (FbleType*, FbleTc*), compile.c (FbleTc*), and link.c
(size_t).

Let me try brute forcing again, using FbleModule* to void*, single insert,
NULL for not present. But, NULL for not present conflicts with size_t 0 value.

Sigh. Okay, have helper functions for link to convert size_t to and from
void*, using -1 as not found?

If I want 0 to be a valid value for both link and typecheck, why don't I
design the map that way? Return a hard coded -1 value for not present, or
return a boolean on lookup with an out parameter to get the value.

Sample expected uses:

FbleModuleMapInsert(map, module, type);
FbleModuleMapInsert(map, module, tc);
FbleModuleMapInsert(map, module, (void*)(intptr_t)index);
if (FbleModuleMapLookup(map, module, (void**)&type)) ...
if (FbleModuleMapLookup(map, module, (void**)&tc)) ...
if (FbleModuleMapLookup(map, module, (void**)(intptr_t*)&tc)) ...

It's not too bad, right? Yeah.

---

There's a complete breakdown of type safety with FbleModuleMap. It's really
annoying and has already resulted in a memory leak we could otherwise have
caught statically. Ugh.

Otherwise, things seem to be working now based on the module graph instead of
the program module list.

Next step is to add reference counts to FbleModule and ditch the program
module list.

---

How would I implement load in my new vision, using recursion instead of
iteration?

To load the main module:
* if for execution: see if it's builtin. If so, return that. Done.
* Parse the .fble.
* If it has a .fble.@, parse that...

Basically I want a helper function that takes a module path and a flag for
whether it is .fble or .fble.@ I'm trying to load. It returns the either
already loaded value for that module, or loads it.

Variations: for execution or not. Loading from builtin or .fble or .fble.@?

In all cases, the result is either: The loaded module, not found, or failed. I
need a way to distinguish between not found and failed.

For the main module:
* if for execution and builtin found: return result from builtin.
* Load the .fble: return the result, error if not found or failed.

For a builtin:
* search the list of builtins. Return if found, otherwise not found.

For a .fble:
* Parse the .fble. If not found, return not found.
* Recursively load the .fble.@: if found, add a 'type' dependency.
* Recursively load all dependencies
  Either for type or for execution...

Let me go through the cases again, assuming input is a module path.

1. main or submodule for execution
 Load from builtin if we can.
 Load from .fble otherwise, checking type against .fble.@ if available.
 Load all dependencies for execution (1)

2. main module for single compilation
 Load from .fble, checking type against .fble.@ if available.
 Load all dependencies for type (3)

3. module for type
 Load from .fble.@ if available.
 Load from .fble otherwise.
 Load all dependencies for type. (3)

The helper I want is given a module path and optional '.@', try to find and
parse that file. Tell us if found, if error, or if successful.

---

While trying to make the helper function for finding and parsing a file, I see
we have a special case for the location of a module path. I think a module's
module path should be set consistently to the modules .fble or .fble.@ file,
first line and column. Not the file where it was referenced from.

---

Pre step (3), if I want to switch to recursive implementation, I could do it
with one function that takes 'for_exe' and 'for_main' boolean arguments. The
three cases are:
* Load for execution: for_exe, don't care about for_main
* Load for compilation: !for_exe, for_main on main.
* Load for type: !for_exe, !for_main.

We pass through for_exe to dependency loads, we pass false for for_main for
dependency loads.

Our logic then becomes:

  if already loaded:
    Return what was previously loaded.

  if for_exe:
    Load from builtin if we can.

  Try load from .fble.@.

  if for_exe or for_main or no .fble.@:
    Require load from .fble

This suffers from the issue that we need to load the .fble.@ for a builtin if
!for_main. And if we have already loaded the builtin without the .fble.@,
we're screwed.

I suppose the hacky solution would be:
* Always try to load .fble.@, .fble, and builtin.
* If for_exe: require .fble or builtin
* If for_main: require .fble...

I guess there is a matrix: the three kinds of load, the 2^3 combinations of
.fble.@, .fble, and builtin.

General guidelines:
* If !for_main - always try to get the type?

No. The bug is there. I'm just spinning now.

How would things look after I split out exe and type modules?

* You load either an exe or a type.
* When loading an exe, if it's from .fble:
  Recursively try to load the type, but only from the .fble.@.
* When loading for type: try to load from .fble, fall back to .fble.@.

Maybe it works like this:
* When loading an exe, if it's from .fble:
  Recursively try to load the pure type.
* When loading an exe from builtin, don't worry about the type.
* When loading a dependency from a .fble:
  If for exe, load for exe. Don't worry about types? But what if it's builtin?
  If for type, load from type.

Sigh. It's complicated. We might have a link dependency on a builtin and a
type dependency on a .fble.@. We need some way to make it so at type check
type we use the .fble.@ for the dependency, while at execution time we use the
builtin for the dependency. There's no way to do that without tracking type
dependencies and execution dependencies separately for each module.

In other words, I still need to distinguish between type_deps and link_deps in
a module. We can still treat .fble and .fble.@ and builtin as separate
FbleModule*, but, for example, if you depend on a builtin, the builtin
FbleModule* will be on the link_deps list and its corresponding .fble.@ will
be on the type_deps list.

Back to the loading strategy. We load a module either for exe or for type. We
cache .fble -> FbleModule*, .fble.@ -> FbleModule*, and builtin ->
FbleModule*?

When I walk through dependencies, always load it for type. If for_exe, also,
separately, load it for execution. It may be both type and execution are .fble
file, so the same FbleModule* will end up being reused.

Loading for execution:
* Try loading from builtin. On success, return that.
* Else, try loading from .fble. On success, return that.
  Part of loading the .fble will subsequently load the module for type, which
  will return itself if we don't have .fble.@.
* Otherwise fail.

Loading for type:
* Try loading from .fble.@. On success, return that.
* Else, try loading from .fble.
* Otherwise fail.

When we load a .fble.@, we only fill in type_deps, not load_deps.

When we load a .fble, we always fill in type_deps. If for_exe, we also fill in
load_deps?

The funny case is when we have a builtin and a .fble but no .fble.@. We then
need the type from the .fble, but none of the load_deps for the .fble.

---

Claim:
* We must either have separate type_deps and link_deps or be willing to have
  types as part of builtin modules.

Say we have some module Foo that depends on a builtin module Bar. To typecheck
Foo, we have to have the type of Bar. To link Foo, we have to have the builtin
for Bar. If type_deps and link_deps are not separate, then a single
FbleModule* for Bar must have both the builtin and the type. QED.

Let's say I really want to have a single deps. That means we need a way to
load an FbleExpr* for the type of a builtin and store it with the FbleModule*
for that builtin.

Options:
A. We the builtin module to have a builtin type.
 - I worry about error reporting in this case.
B. We allow the loader to add a type to an existing builtin.
 - If the existing builtin is defined as a static FbleModule*, this feels
   really sketch.
C. Keep FblePrebuiltModule* and FbleModule* as separate types.
 - Allow the loader to update the FbleModule* type for a builtin. Nothing
   sketch here.
 - But we no longer get the magic of being able to take a reference to a
   builtin module.

Here's another, different puzzle.

Let's say module Foo depends on builtin Bar and we have a Bar.fble, but not a
Bar.fble.@. Let's say Bar.fble depends on another module Sludge, which has
Sludge.fble and Sludge.fble.@. Say Sludge.fble is malformed, but Sludge.fble.@
is not.

Is it an error to load Foo?

For execution, we have Foo and Bar. Done. No errors.
For type, we have Foo -> Bar.fble -> Sludge.fble.@. No errors.
But mix them together, and ???

You could argue it doesn't make sense to have builtin Bar and Bar.fble. Just
rename Bar.fble to Bar.fble.@ in that case, because you will always use the
builtin implementation anyway?

All of which is to say, this is entirely too complicated. Why? Why can't it be
simple? Simple is better for the user and the implementation.

What's awkward here?
* Having a builtin and a .fble file for the same module path.
* Having different dependency lists for a .fble vs .fble.@ file for the same
  module path.
* Builtins having direct access to other private builtins without type info.
* Allow a .fble to stand in for a .fble.@.

Let's imagine some alternate universes.

Let's say there is always a separate .fble and .fble.@ file. Copy them
manually or symlink if you like. Be willing to load the same FbleExpr twice.

Case: loading a builtin for execution
 - No need to worry about types. Use the builtin and its builtin dependencies
   directly.

Case: loading a .fble for compilation
 - Load its .fble.@ type to check against.
 - Load the .fble.@ for each of its dependencies, recursively for type
   checking.
 - No chance of duplicate loading (not counting symlink case). Clearly defined
   which files you load and check.

Case: loading a non-builtin for execution
 - Load .fble for the main module.
 - Load the .fble.@ for the main module? Why? What for?
 - Load .fble.@ for all dependencies, recursively for use in type check of the
   main module.
 - Load builtin/.fble for all dependencies, recursively for use in linking the
   main module.
 We have sharing of loaded .fble.@ files and .fble files where the same module
 is referenced from multiple other modules.

Conceptually I can think of it as having an FbleModuleImpl* and an
FbleModuleType*. An FbleModuleType* has only type dependencies on other
FbleModuleType*. An FbleModuleImpl* has link dependencies on other
FbleModuleImpl* if being loaded for execution rather than compilation. And it
has type dependencies on other FbleModuleType*. A builtin module is an
FbleModuleImpl* that happens to have no type dependencies at all.

That's clear, right? No magic? No craziness?

Back to our question from before:

Let's say module Foo depends on builtin Bar and we have a Bar.fble, but not a
Bar.fble.@. Let's say Bar.fble depends on another module Sludge, which has
Sludge.fble and Sludge.fble.@. Say Sludge.fble is malformed, but Sludge.fble.@
is not.

Is it an error to load Foo?

FooImpl depends on BuiltinBarImpl for link.
FooImpl depends on BarType via Bar.fble for type.
FooType depends on BarType via Bar.fble for type.
BarType depends on SludgeType via Sludge.fble.@ for type.

There is no path to Sludge.fble.

So no, there is no error to load Foo.

How about the other case: we load a builtin that loads another builtin and
then later try to load that other builtin from a non-builtin?

BuiltinAImpl depends on BuiltinBImpl for link.
X depends on BuiltinBImpl for link.
X depends on BuiltinBType for type.

No issue, since BuiltinBImpl and BuiltinBType are two separate FbleModule*
instances.

Now then, take a step back to where we came from. Say we use Foo.fble if there
is no Foo.fble.@ file for the type. Then we end up in a situation of:

FooImpl depends on BarImpl for link.
FooImpl depends on BarType for type.
FooType depends on BarType for type.

Which is, apparently, consistent. We can use the same FbleModule* for
FooImpl and FooType. No need to reload the file.

---

There are three sources of module information:
* builtin, .fble, and .fble.@.

There are two kinds of dependencies:
* link dependencies and type dependencies.

That gives us six combinations, two of which are invalid:
* builtin for link - valid. Only has link deps.
* builtin for type - not valid. builtins don't have type info.
* .fble for link - valid. Has link and type deps.
* .fble for type - valid. Only has type deps.
* .fble.@ for link - not valid. We don't use .fble.@ for execution.
* .fble.@ for type - valid. Only has type deps.

Semantically speaking, we should behave as if we treated these 4 valid
combinations separately. In particular:
* If Foo.fble depends on Bar, Bar is builtin and has Bar.fble.@ as its type, 
  Bar.fble.@ depends on Sludge, and there is both Sludge.fble and
  Sludge.fble.@, we must read Sludge.fble.@, not Sludge.fble. That is, we must
  not see errors in Sludge.fble.

Notably, .fble for link has separate link and type deps. For example, if it
depends on Bar and Bar has a builtin and a Bar.fble.@, then it depends on the
builtin for link deps and it depends on the .fble.@ for type deps.

Now we can ask which of these four combinations could share the same
FbleModule* data structure, if we had any desire to:
* builtin for link + .fble for link: no, conflicting link dependencies.
* builtin for link + .fble for type: yes, no overlap between link & type deps.
* builtin for link + .fble.@ for type: yes, no overlap between link & type deps.
* .fble for link + .fble for type: yes. type dependencies match.
* .fble for link + .fble.@ for type: maybe. I think yes.
  These have conflicting type dependencies: one might reference Foo, the other
  might reference Bar. But you could take the union of the type dependencies.
  Unlike for linking, it's okay to include unused type arguments during
  typecheck.
* .fble for type + .fble.@ for type: maybe. I think yes.
  Same argument as above: type dependencies may conflict, but you can take the
  union. If the same module is depended on by both, well, it will point to the
  same place.

Today I share everything, because we never get in case where you want both
builtin and .fble for link.

What makes sense to share:
* .fble for link and .fble for type.

Because otherwise we end up duplicating the FbleExpr* and the typechecking of
it.

What doesn't necessarily make sense to share:
* Anything else.

In particular, if we didn't share .fble and .fble.@, we could avoid duplicate
code in TypeCheckModule that is run for both the .type and the .value field.

Note that .fble for link will want to depend on .fble.@ for type checking if
it's available.

The last piece is: you can't know a-priori when loading a .fble file if you
need it both for link and for type. It depends on what you are loading it for.
You can have for_execution loading that loads a .fble file only for type. For
example: if Bar is builtin, Bar.fble.@ depends on Foo.fble, and nothing else
depends on Foo.fble for execution. And Foo depends on Sludge, which has
Sludge.fble and Sludge.fble.@.

Those are all the pieces. What's left is to put them together.

---

API first, assuming everything memoizes to avoid duplicate work.

LoadModuleForLink - top level entry into execution use case
 - Tries LoadBuiltin.
 - Tries LoadFble. On success, LoadModuleForLink on all dependencies.
LoadModuleForType - called to get type_deps for a module.
 - Calls LoadHeader to get .fble.@.
 - If none, calls LoadFble to get .fble.
 - Calls LoadModuleForType on all dependencies.
LoadBuiltin - called to load a builtin module + dependencies.
LoadFbleForType - top level entry into compilation use case
 - Tries LoadFble. On success, LoadModuleForType on all dependencies.
 - Tries LoadHeaderForType.
LoadHeaderForType
 - Tries LoadHeader. On success, LoadModuleForType on all dependencies.
LoadHeader
 - Tries to read a .fble.@ file: FbleExpr* and module path dependencies.
LoadFble
 - Tries to read a .fble file: FbleExpr* and module path dependencies.

So, an FbleModule* can be gotten from ModuleForType, ModuleForLink,
FbleForType, HeaderForType. And a raw file can be opened and parsed with
LoadHeader and LoadFble. Some are optional, some are required.

It's messy. There are corner cases I'm not handling. I need to keep track of
what we've tried before or not. I need to keep track of what we've succeeded
at before or not. Can I simplify?

When we load a builtin, it's easy. We do it recursively. We're done. We reuse
what we already tried or not. There is no failure.

When we load a header, we need to keep track of whether we tried and failed,
whether we tried and succeeded, or whether we haven't tried yet. And we can
always load all the type dependencies for it in one go, right?

When we load a .fble, we first load it for type. Then, if asked, we add on
link dependencies? But where would I keep track of the module paths for the
link dependencies? I would have to do it via the type dependencies, and make
sure those aren't polluted by header type dependencies?

Feels like from that I need to have separate FbleModule* for .fble and
.fble.@, so that I can keep track of dependencies on the .fble and later load
... But if we have a .fble.@, then we'll never load .fble for type, right?
Which means we will never be in a situation where we need to append to the
module?

So we could share .fble and .fble.@ module? Blah.
