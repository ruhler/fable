
* [compile] remove instruction block 'time' field
 - now that we use executed instructions at runtime instead.

* [profile] Label blocks in exec process bindings by binding name.

* [profile] Optimize profiling.
 - Introduce per-thread set tracking of current calls
   caller -> callee / 64 -> uint64_t, where callee % 64th bit is 1 if the call
   is on the stack, false otherwise. And the whole array is NULL if there are
   no calls to the block. ?
 - Idea: if forking is expensive, double check we avoid forking the profile
   thread if there is only one child of exec? Or only fork the profile thread
   for secondary children, not the primary child?

* [cc] Implement .fble -> .o compiler
 - Goal is to significantly increase performance by removing the instruction
   fetch decode logic.

* [gc] Optimize gc. 
 - Experiments suggest gc is 28% overhead for fble bench today.

* [test] Add fble-heap-test for splitting cycles
   Test that we don't retain a cycle a->b->c by referencing a separate object
   d that used to be in the cycle a->b->c->d.

* [snake] Test and fix bug when snake eats its tail.
* [snake] Ignore moves that aren't orthogonal to current snake direction.
* [snake] Keep track of and report score.
* [snake] Figure out why the background box gets lost some times.
* [pingpong] Render a static 3D table tennis scene.
* [invaders] Implement space invaders game.
 - Implement and test Ship simulation
 - Implement and test Alien simulation
 - etc...

* [lib] Add test coverage for the Int routines.
 - In particular, test Div and Mod.
* [lib] Separate Map from DataMap and EqMap.
* [lib] Add unit tests for /Map%.Equals.
* [lib] Separate List@ from S@ and P@ module wise.

* [api] Can fble-stdio check that the function has the right type?

* [compile] Is there a way to clean up compile.c, in terms of orders of setting fields
  of instructions vs scopes vs locals? It all seems very confused to me.
* [compile] Is there a way to avoid emitting instructions after a return/exit instruction?
* [compile] Optimization: Avoid REF_INSTR if we aren't going to ever use it.
 - Maybe have a way to list free vars in an expression and use that to compute
   'recursive' ahead of time?
 - gcov suggests this could have a noticable performance impact, both in terms
   of fewer REF_VALUE_INSTRs and spending less time unpeeling ref values.

* [compile] Test and fix error message for type of anonymous type let values.
 - The type should be the computed type for the value, not the introduced
   abstract type?

* [profile] Come up with a way to deal with irregular ticks.
 - For example, what if we block on user data. Then the ticks stop. Then the
   first sample afterwards gets charged a huge amount unfairly.

* [profile] I suspect there are still bugs around block id 0
 - test that calling into block 0 does the right thing. Though I'm not sure it
   makes much sense.

* [eval] Experiment with alternate garbage collection implementations.
 - For the purpose of improving memory and runtime performance.
* [eval] Make child thread execution fair.
  Children should be time multiplexed, where priority is assigned based on how
  far down the family tree the child belongs. The amount of time a family gets
  to spend evaluating should be independent of the number of children in the
  family.

* [lang] Add support for abstract types?
* [lang] Document the runtime memory model,
  - Including that tail recursive functions should not smash the stack.
* [lang] Document and test that put ports don't retain link values.

* [release] Better error messages on types that have the same name but different values?
* [release] Write man pages for fble and friends?
* [release] Better error message for importing something from a module that
  is not defined in the module?

* [heap] Change reference counting to be incrementally done on allocation.
  Maybe write a test that shows how something that should take no time gets
  charged for a big deallocation time today?

* [arena] Rethink arenas and documentation, because some cases appear to assume you
  have a bulk-free arena. Other cases its not well specified what is freed
  explicitly and what is expected to be freed implicitly.
  I claim a good model is: pass an arena to a function to say: the function
  allocates its result in this arena. The function creates and uses a separate
  arena for its intermediate allocations.

* [debugger] Implement an fble debugger. Features:
 - Set a breakpoint at a line in a file.
 - Step through code line by line.
 - Evaluate expressions in the context of the current scope and print the
   results.
 - Auto breakpoint at undefined behavior?
 
 Use cases:
 - Debug why sudoku solver isn't working properly by stepping through a line
   at a time and printing intermediate values.

   Turns out it wasn't too hard to figure out the problem in this case without
   a debugger.

 - Debug why snake AI wasn't working.

   It turns out we were using the wrong direction. A debugger to step through
   code and print variable values would have found this more quickly than my
   guess and check approach, which was pretty tedious.

