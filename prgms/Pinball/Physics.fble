
<@>@ List@ = /List%.List@;

@ Num@ = /Pinball/Num%.Num@;
% Add = /Pinball/Num%.Add;
% Sub = /Pinball/Num%.Sub;
% Neg = /Pinball/Num%.Neg;
% Mul = /Pinball/Num%.Mul;
% Div = /Pinball/Num%.Div;
% Sqrt = /Pinball/Num%.Sqrt;
% Eq = /Pinball/Num%.Eq;
% Gt = /Pinball/Num%.Gt;
% Ge = /Pinball/Num%.Ge;
% Lt = /Pinball/Num%.Lt;
% Le = /Pinball/Num%.Le;
% Int = /Pinball/Num%.Int;

@ Vec@ = *(Num@ x, Num@ y);

(Vec@, Vec@) { Vec@; } AddV = (Vec@ a, Vec@ b) {
  Vec@(Add(a.x, b.x), Add(a.y, b.y));
};

(Vec@, Vec@) { Vec@; } SubV = (Vec@ a, Vec@ b) {
  Vec@(Sub(a.x, b.x), Sub(a.y, b.y));
};

(Vec@, Num@) { Vec@; } MulVS = (Vec@ a, Num@ s) {
  Vec@(Mul(a.x, s), Mul(a.y, s));
};

# Norm --
#   Computes a unit vector in the direction of the given vector.
(Vec@) { Vec@; } Norm = (Vec@ a) {
  Num@ d = Sqrt(Add(Mul(a.x, a.x), Mul(a.y, a.y)));
  Vec@(Div(a.x, d), Div(a.y, d));
};

# RotateTo --
#   Given unit normal vector n and arbitrary vector v, rotate the vector v
#   to a coordinate system where n is at (0, 1).
(Vec@, Vec@) { Vec@; } RotateTo = (Vec@ n, Vec@ v) {
  Num@ x = Sub(Mul(n.y, v.x), Mul(n.x, v.y));
  Num@ y = Add(Mul(n.x, v.x), Mul(n.y, v.y));
  @(x, y);
};

# RotateFrom --
#   Given unit normal vector n and arbitrary vector v, rotate the vector v
#   out of a coordinate system where n is at (0, 1).
(Vec@, Vec@) { Vec@; } RotateFrom = (Vec@ n, Vec@ v) {
  Num@ x = Add(Mul(n.y, v.x), Mul(n.x, v.y));
  Num@ y = Sub(Mul(n.y, v.y), Mul(n.x, v.x));
  @(x, y);
};

@ Ball@ = *(Vec@ pos, Vec@ vel, Num@ radius);

@ Edge@ = *(
  Vec@ normal,      # Unit normal vector.
  Vec@ start,       # Starting position of the edge.
  Num@ length,      # Length of the edge.
  Num@ restitution  # Fraction of energy preserved during a collision.
);

@ Paddle@ = *(
  Vec@ end_down,   # The paddle's end position when off.
  Vec@ end_up,     # The paddle's end position when on.
  Num@ pos,        # The fraction of the way between end_up and end_pos.
  Num@ vel,        # The velocity of the paddle in units of pos per tick.
  Edge@ edge       # The edge of the paddle in its current position.
);

(Paddle@) { Paddle@; } RecomputeEdge = (Paddle@ p) {
  Vec@ end = AddV(p.end_down, MulVS(SubV(p.end_up, p.end_down), p.pos));
  Vec@ tangent = Norm(SubV(end, p.edge.start));
  Vec@ normal = Vec@(Neg(tangent.y), tangent.x);
  Paddle@(
    p.end_down, p.end_up, p.pos, p.vel,
    Edge@(normal, p.edge.start, p.edge.length, p.edge.restitution));
};

@ World@ = *(
  Vec@ gravity,      # acceleration due to gravity
  Ball@ ball,
  List@<Edge@> edges,
  List@<Paddle@> paddles
);

# BallT@ --
#   A ball at a particular point in time.
@ BallT@ = *(Ball@ ball, Num@ time);

# CollideEdge -- 
#   Check for and apply collision of ball with edge between start and end.
#
# If there is no collision, end is returned as is. If there is a collision,
# returns the ball in the state just after the collision at the time of
# collision.
(Ball@, BallT@, Edge@) { BallT@; }
CollideEdge = (Ball@ start, BallT@ end, Edge@ edge) {
  Num@ radius = start.radius;

  # For there to be considered a collision, the ball must start above the
  # edge, end within radius units of the edge, and be going towards the edge.
  Vec@ s = RotateTo(edge.normal, SubV(start.pos, edge.start));
  Lt(s.y, Int|0).?(true: end);

  Vec@ e = RotateTo(edge.normal, SubV(end.ball.pos, edge.start));
  Gt(e.y, radius).?(true: end);

  Vec@ v = RotateTo(edge.normal, start.vel);
  Ge(v.y, Int|0).?(true: end);

  # Potential collision detected.
  # r = y0 + vt ==>  t = (r-y0)/v
  Num@ t = Lt(s.y, radius).?(true: Int|0, false: Div(Sub(radius, s.y), v.y));

  # Verify the collision happens within the segment of the edge.
  Num@ x = Add(s.x, Mul(v.x, t));
  Lt(x, Int|0).?(true: end);
  Gt(x, edge.length).?(true: end);

  # Compute the new state just after the collision.
  Vec@ vc = Vec@(v.x, Mul(edge.restitution, Neg(v.y)));
  Vec@ end_pos = AddV(start.pos, MulVS(start.vel, t));
  Vec@ vel = RotateFrom(edge.normal, vc);
  BallT@(Ball@(end_pos, vel, radius), t);
};

# CollideEdgeS --
#   Check for and apply collision between ball and a list of edges.
#
# If there is no collision, end is returned as is. If there is a collision,
# returns the ball in the state just after the collision at the time of
# collision.
(Ball@, BallT@, List@<Edge@>) { BallT@; }
CollideEdgeS = (Ball@ start, BallT@ end, List@<Edge@> edges) {
  edges.?(nil: end);
  CollideEdgeS(start, CollideEdge(start, end, edges.cons.head), edges.cons.tail);
};

# MovePaddle -- 
#   Move a paddle by the given amount of time.
(Num@)(Paddle@) { Paddle@; } MovePaddle = (Num@ t)(Paddle@ p) {
  Num@ pos = {
    Num@ pos = Add(p.pos, Mul(p.vel, t));
    Lt(pos, Int|0).?(true: Int|0);
    Gt(pos, Int|1).?(true: Int|1);
    pos;
  };

  Eq(pos, p.pos).?(true: p);
  RecomputeEdge(Paddle@(p.end_down, p.end_up, pos, p.vel, p.edge));
};

# CollidePaddle --
#   Check for and apply collision between ball and paddle.
#
# If there is no collision, end is returned as is. If there is a collision,
# returns the ball in the state just after the collision at the time of
# collision.
(Ball@, BallT@, Paddle@) { BallT@; }
CollidePaddle = (Ball@ start, BallT@ end, Paddle@ paddle) {
  Num@ radius = start.radius;
  Num@ tm = end.time;

  # Compute time for the ball to reach the end position of the paddle.
  Paddle@ p0 = MovePaddle(tm)(paddle);
  Vec@ s0 = RotateTo(p0.edge.normal, SubV(start.pos, p0.edge.start));
  Vec@ v0 = RotateTo(p0.edge.normal, start.vel);
  Num@ t0 = Div(Sub(s0.y, radius), v0.y);

  # Compute time for the ball to reach the start position of the paddle.
  Paddle@ p1 = paddle;
  Vec@ s1 = RotateTo(p1.edge.normal, SubV(start.pos, p1.edge.start));
  Vec@ v1 = RotateTo(p1.edge.normal, start.vel);
  Num@ t1 = Div(Sub(s1.y, radius), v1.y);

  # Compute time for ball to collide with paddle, assuming paddle the paddle
  # moves towards the ball at a constant velocity along the path of the ball.
  Num@ td = Add(tm, Sub(t1, t0));
  Eq(td, Int|0).?(true: end);

  Num@ t = Div(Mul(t1, tm), td);
  Lt(t, Int|0).?(true: end);
  Gt(t, tm).?(true: end);

  # Verify the collision happens within the segment of the edge.
  Vec@ end_pos = AddV(start.pos, MulVS(start.vel, t));
  Paddle@ ph = MovePaddle(t)(paddle);
  Vec@ sh = RotateTo(ph.edge.normal, SubV(end_pos, ph.edge.start));
  Lt(sh.x, Int|0).?(true: end);
  Gt(sh.x, ph.edge.length).?(true: end);

  # Compute the new state just after the collision.
  # TODO: Properly take into account the velocity of the paddle at the point
  # of collision.
  Num@ w = Div(Int|4, Int|10);
  Num@ vp = Mul(w, sh.x);
  Vec@ vh = RotateTo(ph.edge.normal, start.vel);
  Vec@ vc = Vec@(vh.x, Sub(vp, vh.y));
  Vec@ vel = RotateFrom(ph.edge.normal, vc);
  BallT@(Ball@(end_pos, vel, radius), t);
};

# CollidePaddleS --
#   Check for and apply collision between ball and a list of paddles.
#
# If there is no collision, end is returned as is. If there is a collision,
# returns the ball in the state just after the collision at the time of
# collision.
(Ball@, BallT@, List@<Paddle@>) { BallT@; }
CollidePaddleS = (Ball@ start, BallT@ end, List@<Paddle@> paddles) {
  paddles.?(nil: end);
  CollidePaddleS(start, CollidePaddle(start, end, paddles.cons.head), paddles.cons.tail);
};

# Move --
#   Move the ball and paddles by the given amount of time, assuming velocity
#   stays constant.
#
# In case of collision, we break down the time period into smaller bits. The
# assumption that velocity is constant is intended to prevent the case where
# we break down the time period into smaller and smaller bits and end up never
# reaching the end of the time period as a result. This also assumes we
# don't have any super tight corners that would cause us to collide an
# excessive number of times in a single time period.
(World@, Num@) { World@; } Move = (World@ w, Num@ t) {
  Le(t, Int|0).?(true: w);

  Vec@ end_pos = AddV(w.ball.pos, MulVS(w.ball.vel, t));
  BallT@ end = BallT@(Ball@(end_pos, w.ball.vel, w.ball.radius), t);
  BallT@ edged = CollideEdgeS(w.ball, end, w.edges);
  BallT@ batted = CollidePaddleS(w.ball, edged, w.paddles);
  Num@ ct = batted.time;
  List@<Paddle@> paddles = /List%.Map<Paddle@, Paddle@>(w.paddles, MovePaddle(ct));
  World@ moved = World@(w.gravity, batted.ball, w.edges, paddles);
  Move(moved, Sub(t, ct));
};

# Tick --
#   Advance the world by one unit of time.
(World@) { World@; } Tick = (World@ w) {
  # Compute average expected ball velocity over the time period.
  Vec@ half_gravity = MulVS(w.gravity, Div(Int|1, Int|2));
  Vec@ v_avg = AddV(w.ball.vel, half_gravity);
  World@ updated = World@(w.gravity, Ball@(w.ball.pos, v_avg, w.ball.radius), w.edges, w.paddles);

  # Move the ball assuming constant velocity.
  World@ moved = Move(updated, Int|1);

  # Compute final ball velocity.
  Vec@ v = AddV(moved.ball.vel, half_gravity);
  World@(w.gravity, Ball@(moved.ball.pos, v, moved.ball.radius), moved.edges, moved.paddles);
};

@(Vec@, Ball@, Edge@, Paddle@, World@, Tick,
  AddV, SubV, MulVS);
