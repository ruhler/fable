The Fable of Damocrates 
=======================
Richard Uhler <ruhler@degralder.com>

Introduction
------------
Damocrates is a computer programming language from the Fable collection. It
builds on top of the Calvisus language, providing compile-time developer
features for modularity and abstraction geared at reducing the cost of
producing large fblc programs.

A core philosophy of fbld is that it can be statically compiled to fblc.
The abstractions introduced by fbld are zero-cost in the sense that they have
no overhead at runtime after compiling the program down to fblc. The developer
need not have to make a tradeoff between modularity/abstraction and runtime
performance.

Damocrates facilitates development of large scale programs by introducing two
broad features on top of the existing fblc language: modules and polymorphism.
Modules allow the same peice of code to be reused in many different programs,
and polymorphism allows the same peice of code to be reused in many different
contexts within a single program. These features allow a developer to easily
leverage the existing work of others to assemble and reuse large scale
programs.

Modules
-------
* Intro
  - module is a collection of entities.
  - module introduces its own namespace to avoid name conflicts.
  - module has an interface, to make it easier to use and restrict external
    access to internal implementation details. Interface defined separately
    from module, and can be shared by multiple modules.
  - modules and interfaces can be defined hierarchically, to allow the
    benefits of modules to scale to much larger programs.
* Module declaration syntax
* Namespaces
  - braces introduce new name space
  - import @ { ... } statement to access parent name space.
  - qualified references: foo@bar to access entity in module bar.
  - import bar { ... } shorthand
* Interfaces
  - interface declaration syntax.
  - kinds - type, struct, decl, func, proc, module, interf.
  - requirements for a module to implement an interface.
* Hierarchical modules and interfaces.
* Top level name space and programs.

Polymorphism
* Intro
  - Motivating example.
* Declaring polymorphic entities ("meta abstraction")
* Supplying static arguments to qrefs ("meta application")
* Partial application of static arguments.
  - Monad example.
* Entity aliases ("meta let")
  - kind = 'qref';

Syntax Reference
----------------
  type_kind ::= 'type' tname params ;
  struct_kind ::= 'struct' tname params '(' [qref fname [',' qref fname [...]]] ')' ;
  union_kind ::= 'union' tname params '(' qref fname [',' qref fname [...]] ')' ;
  func_kind ::= 'func' tname params '(' [qref vname [',' qref vname [...]]] ';' qref ')' ;
  proc_kind ::= 'proc' tname params '('
                     [qref polarity pname [',' qref polarity pname [...]]] ';'
                     [qref vname [',' qref vname [...]]] ';' qref ')' ;
  interf_kind ::= 'interf' tname params '{' [decl [decl [...]]] '}' ;
  module_kind ::= 'module' tname params '(' qref ')' ;

  kind ::= type_kind
         | struct_kind
         | union_kind
         | func_kind
         | proc_kind
         | interf_kind
         | module_kind
         ;

  import ::= 
      (* TODO: ['=' qref] instead of ['=' tname]? *)

     'import' '@'  '{' [tname ['=' tname]; [tname ['=' tname]; [...]]] '}'
   | 'import' qref '{' [tname ['=' tname]; [tname ['=' tname]; [...]]] '}'
   ;

  decl ::= kind ';'       (* TODO: allow kind '=' qref ';' too? *)
         | import ';'
         ;

  defn ::= struct_kind ';'
        |  union_kind ';'
        |  func_kind expr ';'
        |  proc_kind proc ';'
        |  interf_kind ';'
        |  module_kind '{' [defn [defn [...]]] '}' ';'
        |  kind '=' qref ';'
        |  import ';'
        ;
  
  prgm ::= (* collection of defn, organized into file by defn <name>.fbld *)
 
  params ::= ['<' [kind [',' kind [...]]] '>'] ;

  qref ::= tname ['<' [qref [',' qref [...]]] '>'] ['@' qref] ;

  expr ::= ... (* as in fblc, with qref in place of tname *)
  proc ::= ... (* as in fblc, with qref in place of tname *)

  polarity ::= ... (* as in fblc *)
  pname ::= ... (* as in fblc *)
  tname ::= ... (* as in fblc *)
  vname ::= ... (* as in fblc *)

Style Suggestions
-----------------
* Capitalize entities, including types, functions, procs, interfaces, and
  modules.
* Lowercase field names, including for structs, unions, function and proc
  arguments.
* Lowercase variable names.
* "true/something/cons" before "false/nothing/empty/error" when ordering
  fields of that kind of union declaration, so that ?(x; a, b) is
  consistent with (x ? a : b) behavior.

  But "0" before "1" for bit, decimal, byte, hex, etc?

Changes from Fbld 3
-------------------
* Instead of <[type...] ; [module...]> for params, we have <[kind...]>.
Which is surely an improvement in simplicity and generality.

* Kinds can themselves be parameterized.
Which avoids an artificial arbitrary limitation by allowing full generality.

* Partial application of qrefs.
Needed once kinds are parameterized.
Also generalizes import statements, which implicitly import parameterized
things, not fully applied things.

* kind = 'qref'
Which really is needed for full generality.

I approve these changes as improving the overall simplicity and generality of
the language. Parameterized kinds, partial application, and kind = 'qref' do
add complexity, but they do so in a simple way and provide important
capabilities.

