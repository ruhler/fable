% True = /Core/Bool%.True;
% False = /Core/Bool%.False;
% And = /Core/Bool%.And;

<@>@ Eq@ = /Core/Eq%.Eq@;

% Int = /Core/Int/Lit%.Int;

<@>% List = /Core/List%.List;

@ String@ = /Core/String%.String@;
% Str = /Core/String%.Str;

@ Test@ = /Core/Test%.Test@;
@ TestResult@ = /Core/Test%.TestResult@;
% Test = /Core/Test%.Test;
% TestSuite = /Core/Test%.TestSuite;
<@>% AssertEquals = /Core/Test%.AssertEquals;

@ Unit@ = /Core/Unit%.Unit@;
% Unit = /Core/Unit%.Unit;

@ Formula@ = /Sat/Cnf%.Formula@;
@ Clause@ = /Sat/Cnf%.Clause@;
@ VarId@ = /Sat/Cnf%.VarId@;
@ Var@ = /Sat/Cnf%.Var@;
@ Assignment@ = /Sat/Cnf%.Assignment@;
@ Result@ = /Sat/Cnf%.Result@;
% EqId = /Sat/Cnf%.EqId;
% Solve = /Sat/Cnf%.Solve;

% ShowResult = /Sat/Show%.ShowResult;
% ShowParsedFormula = /Sat/Show%.ShowParsedFormula;

<@>@ Parse@ = /Sat/Dimacs%.Parse@;
% Parse = /Sat/Dimacs%.Parse;


VarId@ X = /Core/Int%.1;
VarId@ Y = /Core/Int%.2;

Eq@<Var@> EqVar = (Var@ a, Var@ b) {
  And(EqId(a.id, b.id), /Core/Bool/Eq%.Eq(a.pos, b.pos));
};

Eq@<Clause@> EqClause = /Core/List/Eq%.Eq<Var@>(EqVar);

Eq@<Formula@> EqFormula = /Core/List/Eq%.Eq<Clause@>(EqClause);


Eq@<Parse@<Formula@>>
EqParsedFormula = (Parse@<Formula@> a, Parse@<Formula@> b) {
  a.?(error: b.?(error: /Core/String/Eq%.Eq(a.error, b.error), : False),
      parsed: b.?(parsed: EqFormula(a.parsed, b.parsed), : False));
};

Eq@<Assignment@> EqAssignment = /Core/List/Eq%.Eq<Var@>(EqVar);

Eq@<Result@> EqResult = (Result@ a, Result@ b) {
  a.?(
    sat: b.?(sat: EqAssignment(a.sat, b.sat), : False),
    unsat: b.?(unsat: True, : False));
};

(Result@, Result@) { TestResult@; }
AssertEq = (Result@ a, Result@ b) {
  AssertEquals<Result@>(EqResult, ShowResult, a, b);
};

Test@ Tests = TestSuite(Str|Sat, List<Test@>[
  Test(Str|Sat, (Unit@ _) {
    Formula@ f = List[
      List[Var@(X, True)]
    ];
    Result@ want = Result@(sat: List[Var@(X, True)]);
    Result@ got = Solve(f);
    AssertEq(want, got);
  }),

  Test(Str|Unsat, (Unit@ _) {
    Formula@ f = List[
      List[Var@(X, True)],
      List[Var@(X, False)]
    ];
    Result@ want = Result@(unsat: Unit);
    Result@ got = Solve(f);
    AssertEq(want, got);
  }),

  Test(Str|EmptyClause, (Unit@ _) {
    # Test that we properly detect an empty clause as one of the initial
    # clauses.
    Formula@ f = List[
      List[Var@(X, True)],
      List<Var@>[],
      List[Var@(Y, True)]
    ];
    Result@ want = Result@(unsat: Unit);
    Result@ got = Solve(f);
    AssertEq(want, got);
  }),

  Test(Str|AttemptedConflict, (Unit@ _) {
    # Test that attempts to cover the case where an attempted variable
    # assignment leads to a conflict.
    # (x' + y)(x' + y')(x + y)(x + y')
    Formula@ f = List[
      List[Var@(X, False), Var@(Y, True)],
      List[Var@(X, False), Var@(Y, False)],
      List[Var@(X, True), Var@(Y, True)],
      List[Var@(X, True), Var@(Y, False)]
    ];
    Result@ want = Result@(unsat: Unit);
    Result@ got = Solve(f);
    AssertEq(want, got);
  }),

  Test(Str|Dimacs, (Unit@ _) {
    String@ dimacs = Str|'c
c start with comments
c
c
p cnf 5 3
1 -5 4 0
-1 5 3 4 0
-3 -4 0
';
    Formula@ formula = List[
      List[Var@(Int|1, True), Var@(Int|5, False), Var@(Int|4, True)],
      List[Var@(Int|1, False), Var@(Int|5, True), Var@(Int|3, True), Var@(Int|4, True)],
      List[Var@(Int|3, False), Var@(Int|4, False)]];

    Parse@<Formula@> want = Parse@(parsed: formula);
    Parse@<Formula@> got = Parse(dimacs);
    AssertEquals(EqParsedFormula, ShowParsedFormula, want, got);
  })

]);

/Core/Stdio/IO%.Run(/Core/Test/Stdio%.Run(Tests));
