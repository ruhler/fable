
% Chars = /Char%.Chars;

% B = /Digits%.Bit;
% I = /Int/Int/Lit%.I;
% D = /Int/Int/Lit%.D;

@ Test@ = /Test%.Test@;
% Test = /Test%.Test;
% TestSuite = /Test%.TestSuite;
<@>% AssertEquals = /Test%.AssertEquals;

@ Addr@ = /Fblf/Program%.Addr@;
@ Program@ = /Fblf/Program%.Program@;
% Assign = /Fblf/Program%.Assign;
% Const = /Fblf/Program%.Const;
% Seq = /Fblf/Program%.Seq;

@ Instance@ = /Fblf/Module%.Instance@;
% Instantiate = /Fblf/Module%.Instantiate;

% AddM = /Fblf/Lib/Add%.AddM;
% IncM = /Fblf/Lib/Add%.IncM;
% AndM = /Fblf/Lib/Bitwise%.AndM;
% OrM = /Fblf/Lib/Bitwise%.OrM;
% XorM = /Fblf/Lib/Bitwise%.XorM;
% NotM = /Fblf/Lib/Bitwise%.NotM;
% ClsM = /Fblf/Lib/Bitwise%.ClsM;

@ Heap@ = /Fblf/Heap%.Heap@;
@ Ptr@ = /Fblf/Heap%.Ptr@;
% Heap = /Fblf/Heap%.Heap;
% HeapFromBitStr = /Fblf/Heap%.HeapFromBitStr;
% Equals = /Fblf/Heap%.Equals;

% Exec = /Fblf/Exec%.Exec;

# Import to test compilation.
% _ = /Fblf/Lib/Md5%;

Test@ Tests = TestSuite(Chars|Fblf, [
  /Fblf/Heap/Tests%.Tests,

  Test(Chars|AddF, !({
    Addr@ a = I(D|0);
    Addr@ b = I(D|4);
    Addr@ z = I(D|8);
    Addr@ free = I(D|12);

    Instance@ add = Instantiate(AddM(I(D|4), a, b, z), free);

    Program@ prgm = Seq([
      Assign(a, Const(B|0010), I(D|4)),   # a = 2
      Assign(b, Const(B|0111), I(D|4)),   # b = 7
      Assign(z, Const(B|0000), I(D|4)),   # clear z
      add.program                         # z = a + b
    ]);

    Heap@ heap = Heap(add.heap);
    Heap@ got = Exec(prgm, heap);

    # We only want to check the first 12 bits to make sure they contain
    # a = 0010, b = 0111, but now z = 1001.
    Heap@ wnt = HeapFromBitStr(B|001001111001);
    % Eq = (Heap@ a, Heap@ b) {
       Equals(Ptr@(a, I(D|0)), Ptr@(b, I(D|0)), I(D|12));
    };

    AssertEquals<Heap@>(Eq, /Fblf/Heap/Show%.Show, wnt, got);
  })),

  Test(Chars|IncF, !({
    Addr@ a = I(D|0);
    Addr@ free = I(D|5);

    Instance@ inc = Instantiate(IncM(I(D|5), a), free);

    Program@ prgm = Seq([Assign(a, Const(B|10011), I(D|5)), inc.program]);

    Heap@ heap = Heap(inc.heap);
    Heap@ got = Exec(prgm, heap);

    Heap@ wnt = HeapFromBitStr(B|10100);
    % Eq = (Heap@ a, Heap@ b) {
       Equals(Ptr@(a, I(D|0)), Ptr@(b, I(D|0)), I(D|5));
    };

    AssertEquals<Heap@>(Eq, /Fblf/Heap/Show%.Show, wnt, got);
  })),

  Test(Chars|'IncF Overflow', !({
    Addr@ a = I(D|0);
    Addr@ free = I(D|5);

    Instance@ inc = Instantiate(IncM(I(D|5), a), free);

    Program@ prgm = Seq([Assign(a, Const(B|11111), I(D|5)), inc.program]);

    Heap@ heap = Heap(inc.heap);
    Heap@ got = Exec(prgm, heap);

    Heap@ wnt = HeapFromBitStr(B|00000);
    % Eq = (Heap@ a, Heap@ b) {
       Equals(Ptr@(a, I(D|0)), Ptr@(b, I(D|0)), I(D|5));
    };

    AssertEquals<Heap@>(Eq, /Fblf/Heap/Show%.Show, wnt, got);
  })),

  Test(Chars|AndF, !({
    Addr@ a = I(D|0);
    Addr@ b = I(D|4);
    Addr@ z = I(D|8);
    Addr@ free = I(D|12);

    Instance@ and = Instantiate(AndM(I(D|4), a, b, z), free);

    Program@ prgm = Seq([
      Assign(a, Const(B|0011), I(D|4)),
      Assign(b, Const(B|0110), I(D|4)),
      Assign(z, Const(B|0000), I(D|4)),
      and.program
    ]);

    Heap@ heap = Heap(and.heap);
    Heap@ got = Exec(prgm, heap);

    Heap@ wnt = HeapFromBitStr(B|001101100010);
    % Eq = (Heap@ a, Heap@ b) {
       Equals(Ptr@(a, I(D|0)), Ptr@(b, I(D|0)), I(D|12));
    };

    AssertEquals<Heap@>(Eq, /Fblf/Heap/Show%.Show, wnt, got);
  })),

  Test(Chars|OrF, !({
    Addr@ a = I(D|0);
    Addr@ b = I(D|4);
    Addr@ z = I(D|8);
    Addr@ free = I(D|12);

    Instance@ or = Instantiate(OrM(I(D|4), a, b, z), free);

    Program@ prgm = Seq([
      Assign(a, Const(B|0011), I(D|4)),
      Assign(b, Const(B|0110), I(D|4)),
      Assign(z, Const(B|0000), I(D|4)),
      or.program
    ]);

    Heap@ heap = Heap(or.heap);
    Heap@ got = Exec(prgm, heap);

    Heap@ wnt = HeapFromBitStr(B|001101100111);
    % Eq = (Heap@ a, Heap@ b) {
       Equals(Ptr@(a, I(D|0)), Ptr@(b, I(D|0)), I(D|12));
    };

    AssertEquals<Heap@>(Eq, /Fblf/Heap/Show%.Show, wnt, got);
  })),

  Test(Chars|XorF, !({
    Addr@ a = I(D|0);
    Addr@ b = I(D|4);
    Addr@ z = I(D|8);
    Addr@ free = I(D|12);

    Instance@ xor = Instantiate(XorM(I(D|4), a, b, z), free);

    Program@ prgm = Seq([
      Assign(a, Const(B|0011), I(D|4)),
      Assign(b, Const(B|0110), I(D|4)),
      Assign(z, Const(B|0000), I(D|4)),
      xor.program
    ]);

    Heap@ heap = Heap(xor.heap);
    Heap@ got = Exec(prgm, heap);

    Heap@ wnt = HeapFromBitStr(B|001101100101);
    % Eq = (Heap@ a, Heap@ b) {
       Equals(Ptr@(a, I(D|0)), Ptr@(b, I(D|0)), I(D|12));
    };

    AssertEquals<Heap@>(Eq, /Fblf/Heap/Show%.Show, wnt, got);
  })),

  Test(Chars|NotF, !({
    Addr@ a = I(D|0);
    Addr@ z = I(D|4);
    Addr@ free = I(D|8);

    Instance@ not = Instantiate(NotM(I(D|4), a, z), free);

    Program@ prgm = Seq([
      Assign(a, Const(B|0011), I(D|4)),
      Assign(z, Const(B|0000), I(D|4)),
      not.program
    ]);

    Heap@ heap = Heap(not.heap);
    Heap@ got = Exec(prgm, heap);

    Heap@ wnt = HeapFromBitStr(B|00111100);
    % Eq = (Heap@ a, Heap@ b) {
       Equals(Ptr@(a, I(D|0)), Ptr@(b, I(D|0)), I(D|8));
    };

    AssertEquals<Heap@>(Eq, /Fblf/Heap/Show%.Show, wnt, got);
  })),

  Test(Chars|ClsF, !({
    Addr@ a = I(D|0);
    Addr@ z = I(D|5);
    Addr@ free = I(D|10);

    Instance@ cls = Instantiate(ClsM(I(D|5), I(D|3), a, z), free);

    Program@ prgm = Seq([
      Assign(a, Const(B|10011), I(D|5)),
      Assign(z, Const(B|00000), I(D|5)),
      cls.program
    ]);

    Heap@ heap = Heap(cls.heap);
    Heap@ got = Exec(prgm, heap);

    Heap@ wnt = HeapFromBitStr(B|1001111100);
    % Eq = (Heap@ a, Heap@ b) {
       Equals(Ptr@(a, I(D|0)), Ptr@(b, I(D|0)), I(D|10));
    };

    AssertEquals<Heap@>(Eq, /Fblf/Heap/Show%.Show, wnt, got);
  }))
]);

@(Tests);
