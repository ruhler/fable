module Md5TestM(Md5TestI) {
  import @ { UnitM; BoolM; Bit8M; HexM; ListM; MaybeM; Md5M; };
  import UnitM { Unit; };
  import Bit8M { Bit8; };
  import HexM { 0; 1; 2; 3; 4; 5; 6; 7; 8; 9; a; b; c; d; e; f; };
  import ListM { P; S; };
  import MaybeM { Maybe; };
  import Md5M { Md5Hash; Md5; Eq; };

  union TestName(
      Unit Md5_empty
  );

  struct TestFailure(TestName name, Md5Hash wnt, Md5Hash got);

  proc Test_empty( ; ; TestFailure) {
    Maybe<Bit8> +- put, get;
    Md5Hash wnt = $(Md5Hash(d(), 4(), 1(), d(), 8(), c(), d(), 9(),
          8(), f(), 0(), 0(), b(), 2(), 0(), 4(),
          e(), 9(), 8(), 0(), 0(), 9(), 9(), 8(),
          e(), c(), f(), 8(), 4(), 2(), 7(), e()));
    Md5Hash got = Md5(get; ), Unit ignored = {
      Maybe<Bit8> x_ = +put(Maybe<Bit8>:nothing(Unit()));
      $(Unit());
    };
    $(TestFailure(TestName:Md5_empty(Unit()), wnt, got));
  };


  func T(TestFailure x, S<TestFailure> l; S<TestFailure>) {
    ?(Eq(x.wnt, x.got); l, S<TestFailure>:cons(P<TestFailure>(x, l)));
  };

  proc Test( ; ; S<TestFailure>) {
    TestFailure empty = Test_empty( ; );
    $(T(empty, S<TestFailure>:nil(Unit())));
  };
};
