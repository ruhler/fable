Fble 0.3 Release Burndown
=========================
I'm satisfied on performance work for this release. Let's start the release
burndown. What to focus on next?

Potential big things are:
* SatGame
* Rewrite fbld in C.
* Redesign debugger.
* Fbld modularity.
* Modular compilation.

How about we do some fble coding and work on SatGame next?

---

SatGame is in decent enough shape now to start burndown of it. Do I want to
work on anything else big, or start burndown for the release now?

We've updated the language. We've updated the implementation. We've added new
fble programs. I would say modular compilation overlaps a bit with
implementation update, so maybe no need to pull that into this release. fbld
and debugger are separate. Should we try to make some notable progress on
those?

I'd like to start burndown of some things, otherwise the little things are
going to keep adding up. Let's put a little thought into fbld and debugger for
this release, while burning down other things.

---

On further thought, I think we've got enough big features for this release.
Let's burn down and get the release out. Save fbld updates, debugger updates,
modular compilation, etc. for the next release.

---

Summary of things done so far this release (since f6ead011908897a9a):

Starting from tag fble-0.2:

* Revise tutorials - to simplify and for partial application changes
* Windows msys support for native fble apps
* satgame sample app
* completely revamped memory allocation, do more stack allocation.
  - generational GC
  - for performance improvements
* language support for partial function application.
* Simplify and revamp FbleExecutable API
  - for performance improvements
  - gdb step capability sacrificed

It's worth doing a review of fble lib API changes too, and seeing what more we
want to do before finishing out the fble-0.3 release.

---

I would say all the big things are done now. What's left is going item by item
and either getting it done or pushing it out to a later release. We have 114
lines of todo items to go through.

---

Going through release items:
* rosetta code - not worth doing now. There are too many tasks without precise
  specifications. I'm not convinced it's worth doing at all honestly.
  Regardless, let's not worry about for this release.
* Spec tests for coverage
  - It's not worth checking compiled code errors in spec tests. The additional
    coverage is a single line, and we would know pretty quickly if things were
    broken there.
  - Not worth checking multi-chunk logic in spec tests, because it is so
    implementation detail specific. And we should know pretty soon from
    application level tests if there is something wrong there.
  - Test for warnings
    I don't feel like it. It's optional anyway, right? If we started testing
    for these, there are a whole bunch of different scenarios to test for.
    Hmm... On second thought, let me not give up on this yet.
* Share code between LinkInterpreted and LinkGenerated?
  The trouble is LinkInterpreted goes directly from FbleCode* to FbleValue*,
  and LinkGenerated goes from FbleExecutable* to FbleValue*. There's no clear
  path from FbleCode -> FbleExecutable we could use. The only way to share,
  then would be to factor out code for * -> FbleValue* -> Link. The logic we
  could share is for writing FbleCode, which is all about the dependency
  structure. It doesn't seem worth it. This is well contained code. We can
  worry about it later if it becomes a problem.

* Some better way to recover if build.ninja gets messed up than having to
  re-run configure.
  I can't reproduce the issue. We already have a mechanism in place that seems
  to work for me. I'll have to wait until we run into a similar problem again
  to have something more concrete to solve.

---

Does it make sense that a function that returns a poly has kind %?

For example, ???. Seems like the original example was List%.Map function has
kind <@>% instead of <@, @>%.
 
It's similar to the question of why we can wrap a poly in a struct and go from
higher order kind to kind %.

The purpose of kind is for dealing with abstract types, where we need to know
if we can do application or not. We need to know if type inference should be
done or not. Except now for types we ignore that. Maybe let's plan to review
this for next release?

For example, let's say you have something of kind <@>%. You apply it to get
something of kind %. There's nothing you can do with that without knowing its
type. If you know it's type you might be able to do more.

I'm inclined to say it does make sense to distinguish these. Is it useful
though? Is there any time we don't know the type of something when we could or
could not try to apply to it?

---

* Add a test case for fble-perf-profile?

The test would be given an input sample and output sample and verify they
match? We can't control when the sample happens, so it would be hard to run
perf as part of the test. We also wouldn't be able to run the test on
platforms without perf available, and it's not the easiest thing to install.

A sample input would be nice to document how the program is intended to work.

Let's try writing a test: hard code the sample input and output. See how it
goes.

---

Improving build times is so much tied to fbld. Let's worry about that later
as part of re-implementing fbld in C.

---

Saving library cleanup for a future release, because I think it's worth a much
deeper look into standard library design.

Overview of remaining categories:
* Some tricky test cases to write - it's worth trying at least.
* Debugger improvements - probably worth trying at least.
* Lots of fbld related stuff - see if I can do some of it at least?
* More tutorials and improvements. And other doc improvements.

Let's continue slogging through. Spend time on each item before giving up,
otherwise we'll continue to carry these things forever.
 
---


