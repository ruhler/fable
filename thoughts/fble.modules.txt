Fble Modules Revisited
----------------------
Yet another revisiting of modules. Specifically I want to work out the
appropriate language features and conventions to be used with modules to
address the following:

* Avoid introducing false dependencies.
  For example, I just added an Equals function to Map. That brings in a
  dependency on Bool that wasn't there before. And if I want to reuse EqMaybe,
  that would bring in a dependency on Maybe too. It was not obvious at the
  time how I could easily avoid that.

* Where to put different bits of code.
  For example, Foo vs. Foo_Tests vs. Foo/Tests, vs. Foo/Foo, Foo/Tests.
  I want to know how I ought to organize modules consistently. And clarify
  the conventional relationship is between a parent module and its children.
  Does the parent depend on the children? The children depend on the parent?
  Is there no conventional dependency relationship between parent and child?
  Are the children internal or public? Do they have access to internals or
  access to public stuff?

  For example, I would expect Foo/Tests not to have access to the internal
  data type for Foo, because they are testing the public API. But it's nice to
  put them in a subdirectory along with Foo just for organizational purposes.

* Abstract type support.
  I should be able to make types abstract, perhaps using the ?= statement
  suggested. But make sure this still allows me to give access to the
  definition of the type to multiple internal modules without giving access to
  the type externally.

* Add and test implementation support for private modules.


Proposal:
* How big a module is is determined by dependencies. If you use a module, you
  should only bring in dependencies you have to have to use the module. You
  shouldn't bring in other false dependencies.

* It should be possible to refine a large module into smaller submodules
  without users of the module noticing. Where the submodules can be private.
  This means a parent module has privileged access to its immediate children.

* If a module is marked as private, it produces private things.
  Ideas for how to mark a module as private:
   Foo!.fble
   Foo!/
   Foo._.fble
   Foo~.fble
   Foo~/ 
   Foo~

  Yeah, I like the last one. So if a file is Foo~.fble, the module Foo is
  marked as private. If a directory is Foo~/, it is marked as private. The
  module is referred to without the trailing tilde. There must not be both
  private and public versions of the same module.

* If a module is in a directory, it has privileged access to things in that
  directory and immediate child directories.

* Modules in the same directory are developed by the same developer.

* Use directories for organizing modules as well as privilege.
  For example, prefer Foo/Tests.fble over Foo_Tests.fble, just because it
  shows the relationship between the two better.


There are 4 kinds of modules, depending on whether they are privileged or not,
and whether they produce private stuff or not:

* private, privileged: put in subdirectory.
* private, non-privileged: put in subdirectory.
* public, privileged: put in subdirectory or at root.
* public, non-privileged: ??

My proposal, though this mixes up two different kinds of concerns, is to
group modules in the same directory that refer to the same thing, even if some
of those modules make use of privileged access while others don't.

Note: Any private stuff that needs to be shared by multiple modules must be
defined in a private module. You can only mix private and public in the same
module if only the public bits of that module are to be accessed.

Random idea: Could we use Foo/Tests.fble to say Tests does not have private
access to Foo~/FooInternal~.fble?  Uh... that looks confusing to me. It
suggests a module has the following:

  value
  privileged children - can access private children
  non-privileged children - can't access private children

In other words, we explicitly label the four kinds of children:
  privileged, private:      e.g. Foo~/FooInternal~.fble
  privileged, public:       e.g. Foo~/Data.fble
  non-privileged, private:  e.g. ???
  non-privileged, public:   e.g. Foo/Tests.fble

If that's the case, could we have two different symbols to track this in the
file system? Assume by default non-privileged, public? Then have, for example:

+ means privileged
- means private

So we have:
  Foo/Internal+-.fble
  Foo/Data+.fble
  Foo/Tests.fble

Or: '*' for read and write, '+' for read only, '-' for write only?
  Foo/Internal*.fble
  Foo/Data+.fble
  Foo/Tests.fble

Or: '-' for read and write. e.g. internal only private.
    '+' for public with private access.
        blank for public with public access.

That sounds like a nice proposal to me. Let's try it and see how it feels.
Then the only thing left is to figure out abstract data types.

---

When writing the spec for the above access controls, I realize having separate
privileged and non-privileged makes for an awkward situation.

If you just have public and private, then we assume a parent has private
access to its children and private access to its siblings. And children have
access to their parent.

If you add non-privileged, then there are two groups that a parent is involved
with: its children and its siblings. Then you need two specifications. Does it
have privileged access to its children? Does it have privileged access to its
siblings?

If all you get from privileged/non-privileged is an extra compile time check,
maybe it's not worth it? It doesn't really fit in the notion that a directory
is all owned by the same organization. It adds a strange corner case to the
spec.

Potentially you could work around it too, for example:

  Foo/
    Tests.fble
    Impl*/Impl.fble

Well, no. That doesn't really work. Because if Tests.fble doesn't have the
access it needs, neither does Foo. Unless Foo is just a re-export of an
internal module:
  
  Foo.fble        // re-exports Private.fble
  Foo/            
    Tests.fble    // uses Private.fble
    Private*.fble // re-exports API.fble
    Private*/
      Impl.fble
      API.fble
    
So yeah, worst case, using reexport, which is trivial, you could separate the
access into privileged and non-privileged just using directory structure with
public and private. My vote is to get rid of the notion of privileged and
non-privileged for the first implementation.

---

Experience Report: It feels like module organization is a hard problem.
Consider integers. I figure I want IntP, IntS, and Int. But IntP decrement
wants to use IntS and IntP subtraction wants to use Int. Then IntS division
wants to use Int subtraction, and so on. We end up with a long dependency
chain if we split everything up:

  IntP -> IntS -> Int -> IntP.Sub -> Int.Sub -> IntP.Div -> Int.Div

It is nice to have each module be a small focused thing. None of them really
have any private internal functions, so the only practical value at the moment
for using separate modules seems to be to separate them into small focused
things and for namespace support, so that we can have an Eq function for IntP,
an Eq function for IntS, and an Eq function for Int.

This is actually a deeper question I think. Is it better to define separate
IntP, IntS, and Int types that constrain the data type, or is it better to use
a generic Int type? It's certainly proving inconvenient to keep track of which
types all the functions are used for and converting between them when I have
IntP, IntS, and Int types.

Or: is it better to define these across a bunch of modules to avoid false
dependencies, or better to just define them all in one module and avoid the
headache of splitting them up?

---

Things I want to try to see how well they work:
* Lots of little modules. Because what, really, is the cost of that? I think
it's just being able to remember what module to import. It doesn't reduce the
number of import statements you would use.

* Don't require modules to all be imported at the top of the file. I'm not
convinced it adds much. For example, /Bool/Show%.Show is just as good or
better to use than locally defining ShowBool. Take a little more risk here and
see if it leads to any problems.

---

In practice, splitting things up into very fine modules hasn't caused me any
problems for things like separate Show, Eq, List/Sort, List/Length. It's nice
to have them separate. They are still organized. It doesn't really cost
anything in import statements in practice I don't think.

But I will say, picking between IntP@, IntS@, and Int@ is annoying. For
example, I want to print the number of tests ran, passed, and failed in the
test runner. A simple thing like computing passed = ran - failed suddenly runs
into problems if I'm using IntS@ as the type instead of Int@.

---

Experience after a fair bit of time has gone by:
* Little modules are fine and nice. Slightly inconvenient sometimes to
  remember where something is defined, and in the case of Abs, I ended up
  defining it twice in two different places. Otherwise, I like it.
* For the Int@ question, I'm very much trending towards always use Int@, and
  think of IntP@ and IntS@ as internal implementation detail. The potential
  runtime savings are not worth the inability to easily compose functions
  involving IntP@, IntS@, and Int@.

---

Now that we've added an initial form of abstract types to fble, it begs
revisiting modules. Some time back I removed support for expressing and
controlling access to private modules, because it seemed messy and worth
revisiting later rather than maintaining. I think now is a good time to
revisit, at least in thought, what to do about modules.

Modules are many things, which makes it confusing at times:
* A way to load things without bringing in unused dependencies.
* A way to organize code.
* A way to control who has access to what parts of code, primarily to make it
  possible to update the internal implementation of a module without breaking
  users.
* A way to package, share, and deliver code to users?
* A way to improve compilation times?
* A way to deliver code to users without sharing source code?

Conceptually an organization wants to deliver a collection of modules, call it
a package. A package ideally is hierarchical, i.e. made up of a number
of sub-packages delivered by sub-organizations. The package will include
public interface modules and internal modules used in the implementation of
the public interface.

Organizations will want to be able to update their package and make new
releases. Users will want to download new releases compatible with their code
and switch to using those. Users may want to make use of packages X and Y that
both depend on package Z, and share the package Z between X and Y instead of
duplicating it.

Packages will depend on other packages at particular versions or ranges of
versions. You probably want it to be possible to have more than one version of
a package at a time in the same executable, for example if X depends on Z
version 1 and Y depends on Z version 2, and you want both X and Y in the same
program.

Package management sounds hard. Does it make sense to make it a part of the
language, or does it make sense to let people use whatever package management
mechanism they want? Let's do a survey of some existing languages.

C/C++
  Tends to rely on OS distribution for package management. You ship a library,
  user has to download the write version of the library. pkgconfig can help
  organize things a little bit.

Python
  Has a whole bunch of stuff. It looks confusing and complicated.

Let's look at this another way. What's important for me as a developer is:
* Can I easily install packages I can compile against for development of my
  package?
* Can I easily publish my package for others to install?
* Note that distributing libraries may have different requirements than
  distributing end applications.

From the language point of view, you are writing source code. Your source code
refers to types and entities of the package you want to use. You should only
be able to access public entities of the package in your source code. You
should have a way to describe what is public or private to your package.

How do you know what is exported by the package? I have this idea that
anything private to the package can just be omitted from the public
interface. For example, you compile in internal stuff when compiling your
package, but don't let users have access to that internal stuff when using
your package. But you don't always want to compiler your dependencies into the
package. If you use a common library, you want users to provide the library.

So, what is a package?
* An interface for use in compiling source code.
* An implementation for use in running
 - depends on if you run with interpreter or native machine code for example.
* A list of dependencies your package has that the user is responsible for
  providing.

In fble, I suppose module is the link unit. You link against modules, not
functions. That means at runtime you access the module value, and if it is a
struct, any entities inside it.

So we could use something like an ELF format, where there are public and
private symbols, for public and private modules.

That suggests we may want to have multiple modules compiled to a single
library file. As it gets bigger, we would want to have multiple library files
representing a collection of packages.

How do we generate these library files? Because that's where we will want to
specify what is public and private. And we'll want some way to specify the
interface to a package.

Perhaps I can think of fble as responsible for describing a single module. And
we want some other language or mechanism for describing how to compile modules
together into reusable packages. That other mechanism is where we would
specify what modules are public or private.

---

ld has an option --exclude-libs which I think can be used to mark certain
modules as internal only. For example, we could link together a bunch of .o
files for compiled modules using ld, and indicate then which modules are
public and which modules are private. If we distribute the resulting .so file
as a package, then you can only access exported modules.

It would be strange if your program could compile but not link though. The
compiler needs to know types for all the modules you reference. How can it get
that information?

I think the original plan for module compilation was to have the compiler
generate Foo.fble.@ files describing the type of a module using restricting
fble syntax that doesn't allow for module references. If we have that, then
when we distribute a package, we could distribute a .so file with the compiled
code and a collection of Foo.fble.@ files, where we remove .@ files for
internal modules.

There is a subtle consequence to this approach: access to internal modules is
no longer based on location in the hierarchy. It's based on an explicit list
of things when compiled. In other words, you have visibility to everything you
are compiled together with. That seems entirely reasonable to me. The
assumption being the group of modules you are compiled with is the same group
of modules that a single organization has sufficient control over.

I don't necessarily want elf files to be part of the language spec. That
depends very much on the language implementation. If you are using an
interpreter, you would want .fble source files, including internal modules, as
part of the package distribution. Or maybe compile to some other format the
interpreter understands.

I guess the question for packages in fble is what I want to include as part of
the language specification in terms of package formats.

---

Modules came up as potentially useful for printf debugging. The idea is you
want to be able to compile a module with only type information about the other
modules it depends on. That's useful for distributing modules too.

So, here's what I'm thinking:

/Foo% is implemented in Foo.fble. Foo.fble.@ is an fble file containing just
the type of /Foo%. The compiler can read the .@ files to get type information
for dependencies without needing to access their implementations.

I'm thinking we may as well have Foo.fble.@ have the same syntax as a normal
fble file. It might be useful to share type definitions among these header
files, and it might be useful to make them human readable. At the same time,
we still have the option to make them compiler generated.

It will be important for the compiler to be able to confirm when compiling
Foo.fble that it's type matches what is in Foo.fble.@.

There may be duplication of code between Foo.fble and Foo.fble.@. I think
that's okay. Hopefully it means you have to think twice any time you go to
change the interface to a module. Hopefully it's not too bad to duplicate.

I think Foo.fble.@ would be a good place to document the public interface to a
module, separate from its implementation.

How would this look from an implementation standpoint?

Currently we always load and compile all modules, but we only generate aarch64
code for the main module. We'll want a different way to load modules.

Maybe we can load for each module a type and a value, either of which is
optional? I'll need some thought to work out exactly how to do it, but the
idea seems simple enough. Just need to manage the two different ways of
loading things: full source versus mostly type dependencies.

---

Let me summarize what I think I may have said above, but I'm not sure.

Modules:
* Compile an individual module to a .o file.
* Group .o files for modules from the same developer into a library file.
* When reading dependencies, search for .fble or .fble.@ files to represent
  the dependency. Type check, but don't generate code for these.

A package is distributed as a library file along with a collection of
.fble/.fble.@ files.

How this supports private modules:
* When you generate the library file, you have access to internal modules.
* When you publish the library file, you do not provide a .fble/.fble.@ for
  internal modules.

There are two broad cases to consider:
1. Compilation. fble-compile acts as described above. Generates a .o file for
a module. Loads dependencies for types from .fble/.fble.@ files. The user can
link against the distributed libraries.

2. Interpreter. It's nice if we can avoid the extra compile step, otherwise we
may as well make this a different compiler.

The interpreter mode is kind of funny. You need the source for everything, or
the ability to find and load .so files dynamically because you can't link them
into the interpreter itself.

---

How I would implement modular compilation, assuming I didn't have to worry
about the interpreter case:
* FbleLoadedModule contains FbleExpr* type and FbleExpr* value.
  FbleLoad loads value and optional type for main module.
  FbleLoad loads type only for dependant modules, wrapping in typeof as needed
  in case of .fble vs. .fble.@ file loaded.
* FbleTypeCheck knows to get types for dependent modules.
* FbleCompile returns code only for the main module.

And the interpreter case?
* Do things as we do today: load full, type check all, compile all, interpret
  all, link together all.

Perhaps what I want, then, is Module and Program variations on everything:
* Add an FbleExpr* type field to FbleLoadedModule.
  This is the value of the loaded .fble.@ file, if any.
  States:
   1. type && value: main module, loaded both. Typecheck confirms they match.
   2. type only: loaded .fble.@. Use that for the type.
   3. value only: loaded .fble. Use that for the type.
* FbleLoadModule
  Loads type && value for main, prefers type over value for non-main.
* FbleLoadProgram
  Loads type && value for main, loads type and value for non-main.

Okay, so this brings up a tricky point I think I mentioned before. The graph
for .fble could be different from the graph for .fble.@. Is that an issue? Can
we assume they can be sorted the same way?

For modular compilation, we do want to check that the type of main.fble.@
matches the type of the value main.fble. We need to load both main.fble.@ and
main.fble. Then main.fble.@ loads its own graph and main.fble loads its own
graph. Either we process them as two separate graphs, or we load them all at
once. To load them all at once requires the merged graph not be cyclic. I
think that's fine. It maybe means we have to load all the dependencies for
main.fble.@ and main.fble before we can add the FbleLoadedModule. That's fine.
Should be straight forward if we do them as a group.

* FbleTypeCheck
  Type checks all loaded type && value for all modules.
  Verifies type matches value for all modules if both are present.

* FbleCompileModule
  Compiles only the main module (type checks all).
  In particular, does not compile .fble files used just for type information.

* FbleCompileProgram
  Compiles all modules.

* FbleCompile
  To simplify things getting started, maybe just have the compiler compile any
  module with a value loaded. We can ignore the results of any we don't care
  about. The performance optimization is to skip compilation for modules we
  don't care about.

Yeah, so incrementally we want:
* Add 'type' field to FbleLoadedModule.
* FbleLoad implements FbleLoadProgram behavior: load whatever .fble.@ and
  .fble we find.
* FbleTypeCheck checks all types and values and types against values.
* FbleCompile compiles everything with a value.

And we later optimize to not load .fble if we can load just .fble.@, and to
not compile any values we aren't going to use.

This raises a question: should we have a compilation mode that generates code
for an entire program in one go? It would be faster, because we don't have to
reload all the dependencies for everything in separate calls to the compiler.
But it would complicate the interface because we need to generate multiple
files instead of a single file, and need to come up with names for those. No.
Let's not worry about compilation time for now. Maybe some day I can have an
option to compile an entire package specified by directory root or something.

Good. I think the next steps are clear. And I think this is worth implementing
so we can start to split up fble programs more realistically.
 
---

What does it mean if a .fble.@ depends on a module that the .fble doesn't?
There's nothing to stop it. Should we say that means both the .fble and
.fble.@ modules depend on that module? Or should we distinguish between them?

I expect in the normal case that the .fble.@ file depends on a subset of
modules depended on by .fble. How about I don't make things complicated, just
say you depend on all modules referenced from .fble.@ and .fble file if you
are trying to load them both.

I worry this is introduces some confusing, questioning cases. Having two
definitions of a module. But we know they have to match, enforced by the
compiler, and we know one is a type, so it's not like two different
implementations really.

Hopefully I can find a reasonable place to document the difference and
interplay between .fble and .fble.@ files.

---

Trying out to see how some .fble.@ files would look written by hand... it
feels rather tedious to me. It feels almost like I want a different language
for the .fble.@ file, which is like the normal .fble file, except with the
definitions of things removed, in some cases.

For example, what if I used Undef to define all values?

Or, should I prefer auto-generated .fble.@ files? But then, what's a good way
to read documentation for the library? Is it bad to try and overload the
purpose of .fble.@ for compiler and human consumption? If it's not for human
consumption, why not just use the .fble file for the implementation file?

Remember the goal: only read what we need from the modules to know their type.
If we use the full .fble file, we end up reading dependencies that exist
solely for the implementation.

Also, I'm not sure how abstract data types can work with separate .fble.@ and
.fble files, because they will be considered as having two different types.
How do we map the type in the .fble.@ file to the type in the .fble file?

---

Revisiting the goal of modules. There are a few different ones:
1. Providing documentation for users on how to use a module without the
distraction of implementation details.

2. Efficiently providing the type of a module to a compiler.

3. Making it possible to compile a module without the full implementation of
the modules it depends on, so it's possible to restrict access to internal
parts of that implementation.

4. Making it possible to implement a module outside of the language.
For example, for printf, or a hypothetical optimized integer library.

Thoughts on documentation:

In practice when programming I use man pages, reference guides, wikis for
documentation. It's only my own code where I tend to refer to comments on the
prototypes of functions. I've never found things like Deoxygen output useful.
Occasionally it's useful to read comments in code, and that tends to be in the
implementation file anyway.

In other words, I'm not convinced documenting code via comments on a header
file like thing separate from the implementation is anything fundamental.
There are lots of ways to document code. We could have doc comments in the
implementation and write tools to auto generate online reference guides or
documentation.

Items (2), (3) and (4) are, to me, really about specifying just the type of a
module, separate from its implementation. This could be a machine
representation, it need not be human produced or consumed.

The dream is that you specify the type of a module in a human readable format
where you can also document things.

In practice, most modules I write have a struct type.

But fble can already be used to describe types. What's so tedious about it?
Really, honestly?

* Annoying to do @<Foo@> Foo@ for a type. I rather do @(Foo@, ...).
* Annoying to have indent of *( T@ t, ... ). I rather directly do 
   T@ t;
* Annoying to have to duplicate a complex type like Char@ from implementation
  to type.
* Annoying to have to give the type of something like Chars, which we
  otherwise never have to write explicitly.

I almost wish we had a special language construct designed to help here.
For example, what if we had a special kind of statement:

type name ';' stmt

The meaning of this is declare a variable of given type and name. The type is
the type of the body of the statement. At runtime this gives a runtime error
'unimplemented'.

It's okay to use for describing types, because you don't ever run the code.

This gets around the tedious concerns. And there's nothing I can do to get
around having to give the type of something like Char@ or Chars. And that's a
fairly special case. We don't often have some complicated types. And users
would need to know those types regardless.

@ Chars@ = *(Char@ nl, Char@ tab, Char@ ' ', ...);
Chars@ Chars;

This is the best of all worlds, right? You get full fble syntax for describing
types in a human readable format. You can put documentation with those types.
You have a pleasant syntax for putting the types. We don't have to have two
separate syntaxes for header and implementations.

A couple of questions to follow up on:
1. Should we require a .fble.@ file for every module?
2. How do we support abstract types this way?
3. Should the .fble.@ file give the value or the type? Like, end in @(...) or 
  @<@(...)>?
4. Should there be a way to reference the type from a .fble.@ in the .fble
file, or do we really need to duplicate things like the definition of Char@?

---

Here's an idea, just for the fun of it. What if we allowed you to write
abstract values and abstract types, such as:

@ Bool@;
Bool@ True;
...

And we said the way you provide an interface for a module is by providing a
file with the same type as the module.

And we said this replaces abstract types. That way, instead of having two
different mechanisms for access control, we have a single one that works for
both.

For example, say you have two versions of Map.fble, the public and the private
one. The private one has the full type def. Anyone allowed access to the
internals sees the private one. Anyone without access to the internals sees
the public one. For the purpose of typecheck, the public Map@ type is an
abstract type you can't create or access.

This brings up a question of how hard it should be to break abstraction. For
example, let's say you use the Map@ library and want to work around the access
issue. What do you have to do?

Without any restriction, you have to try hard not to accidentally modify the
Map. With abstract data types, you have to not import the token type. It's
much harder to accidentally access internals. If we say you can implement fble
modules outside the language, then there is nothing stopping you from
accessing internals of the type that way.

I think, in practice, it's good enough if we just provide a .so file and
public Map.fble to prevent people from accessing internals. They would have to
go out of their way, and then it's on them.

But what if you have access to both the internal and external Map.fble? For
example, because you want to run the interpreter, or because you are the
implementer of Map.fble and some modules that should treat it as an abstract
type?

I'm basically saying access control is done at build time based on how you
compile. You pick what can access something by pointing it to the public files
or the private files. Again, if you don't have the private files, that's easy.
But if you have both, it's on you to make sure you don't access what you
shouldn't be accessing.

Could we have two different types? The internal Map@ type, and the public Map@
type, so that an extra step is required to explicitly access internals?

How would the build setup look like, if I were to follow this? Conceptually I
don't really want to manage on a per file basis what files things can access.
I want packages. So each package has the source code and the public API, let's
say they belong in different folders.

To compile a package P, with public code in P_api and source code in P_src, I
say P_src code has access to *_api for all packages it depends on, and P_src
for implementation.

If only there was some lighter weight way to group modules together. For
example, Int@ and Map@ seem like good candidates for a core package, but it
would be nice if Int@ couldn't see inside Map@. Or, for pinball, Num@ should
be part of the package, but still not visible. It's like, it would be nice to
have sub-packages. A fine grained hierarchy of packages.

How might I describe that for the current collection of modules I have
written? In general it's a graph. Not a total order. It's an abstraction of
the module graph.

Let's think about packages then. A package is a named set of modules. A
package can depend on other packages. A module within a package may only
reference modules from the package or packages the package depends on.

That's not too hard. We could have a package format, like, name, list of
modules, list of packages depended on.

Next we introduce the notion of a subpackage. Or, conversely, a way to group
together a collection of packages into a bigger package.

A composite package is a named package that depends on other packages and
provides a list of packages implementing it. Packages inside the composite
package can only depend on each other or packages depended on by the composite
package. A module acts as an atomic package.

So, essentially, I just want a package to be able to denote the boundary
between where the internal version of a module is used instead of the
external version of the module. Well, that and restricting the set of
dependencies a module is allowed to have. That's important too.

---

I'm sort of leaning towards my old package idea.

A module is a module and a package. For example, /Foo% is the module /Foo% and
the package /Foo%. These are organized hierarchically. For example:

Core/
  Map/...
Pinball/...

The package /Foo% includes the module /Foo% and all modules / packages in the
/Foo/ directory.

A package has a name, a list of direct modules/packages in the implementation,
and a subset of those that are 'public', meaning they can be accessed by
modules that are not in a sibling package. And a package has a list of other
packages it can depend on.

By default a package can depend on any other package that any of it's modules
depends on, and a package exports all entities as public.

If you want, you can specify a .fble.@ file for a module to give its public
interface. Modules in sibling packages have access to the .fble file, all
others see it using the .fble.@ interface.

If you want, you can specify a .fble.# (or whatever syntax I want) file, which
gives non-default package info: a list of packages it can depend on, and the
list of children that it exports publicly. Not sure what the syntax should be.
Maybe:

  a; b; c;    (Imported)
  @(x, y, z, ...);  (Exported)

This gives us fined grain packaging. And we can distribute a package as a set
of just .fble.@ files and .o files, or .fble.@ files and a .so file.

Let me play around with this idea and see what it might look like in practice.
