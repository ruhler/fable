Fable E
=======
Richard Uhler <ruhler@degralder.com>

1. Introduction
---------------
Fble is a general purpose, Turing-complete functional programming language
with support for polymorphism and concurrent processes.

1.1 Goals
---------
The primary design goals of fble are:

* Fble should be as simple a language as possible while still being useful.
  A simple language should hopefully be simple to specify, simple to learn,
  simple to understand, simple to program, powerful, and low cost to develop
  high quality tools for.

* Fble should support high performance, low overhead computing. This is
  achieved by using a static type system and having a very clear performance
  model that a developer can optimize for.

* Fble should be a joy to program in. It should be easy to describe the
  majority of programs we want to describe, not tediously difficult. To
  accomplish this, fble allows functions to be declared locally with access to
  variables in the context where they are declared, and fble supports
  polymorphic types and functions.

* Fble, or an extension thereof, should support programming at scale. That is,
  namespace control and composition of modules developed by different
  individual developers or organizations.

2. Language Overview
--------------------
The primitive data types of fble are structs, unions, functions, and
processes.

Data values and the expressions that describe them are strongly typed. A
value's type describes the kinds of operations that can legally be performed
on that value. Types are used to check that an fble programs is well formed
statically. Types do not take part in the dynamic execution of an fble program
after it has been statically checked.

Local variables allow data values to be reused throughout a program, including
recursively. Analogously, type variables allow types to be reused throughout a
program and recursively.

Both expressions and types can be polymorphic, which is to say they can be
made abstract with respect to type parameters. To facilitate more advanced use
of polymorphism, types themselves are strongly typed; we call the type of a
type its kind.

3. Structs
----------
A struct value is a grouping of other values. The items of a struct are
organized into a finite number of fields. Each field has a name, used to
identify the field, and a type, specifying the type of value for that field.

Struct values are constructed by supplying values for all fields of the
struct. Individual components of a struct can be accessed by field name.

3.1 Struct Type
---------------
Abstract Syntax:
  Type ::= struct_type (fields :: [(Type, Name)])

Concrete Syntax:
  type ::= '*(' [type name [',' type name [...]]] ')'

Examples:
  *()                 is the Unit type
  *(Int@ x, Int@ y)   is the type of a pair of ints x, y.

Struct types are considered equal if their fields are equal, including field
types, field names, and the order of the fields.

3.2 Struct Value
----------------
Abstract Syntax:
  Expr ::= struct_value (type :: Type) (args :: [Expr])

Concrete Syntax:
  expr ::= type '(' [expr [',' expr [...]]] ')'

Example:
  Coord@(3, 5)

3.3 Struct Access
-----------------
Abstract Syntax:
  Expr ::= struct_access (object :: Expr) (field :: Name)

Concrete Syntax:
  expr '.' name

Example:
  x.first

Returns the value passed to the struct at the corresponding field position
when the struct was constructed.

4. Unions
---------
A union value is a particular value chosen amongst a group of possible values.
The possible choices are organized into a finite number of fields. Each field
has a name, used to identify the field, and a type, specifying the type of
value for that field.

Union values are constructed by supplying a value for a particular field of
the union. The particular value for the union can be accessed by field name,
and the union can be used to select among other values and expressions based
on the field present in the union value.

4.1 Union Type
--------------
Abstract Syntax:
  Type ::= union_type (fields :: [(Type, Name)])

Concrete Syntax:
  type ::= '+(' type name [',' type name [...]] ')'

Example:
  +(Unit@ true, Unit@ false)

Union types are considered equal if their fields are equal, including field
types, field names, and the order of the fields.

4.2 Union Value
---------------
Abstract Syntax:
  Expr ::= union_value (type :: Type) (field :: Name) (arg :: Expr)

Concrete Syntax:
  expr ::= type '(' name ':' expr ')'

Example:
  Maybe@(Just: 3)

4.3 Union Access
----------------
Abstract Syntax:
  Expr ::= union_access (object :: Expr) (field :: Name)

Concrete Syntax:
  expr ::= expr '.' name

Example:
  x.Just

Returns the value passed to the union at the corresponding field position when
the union was constructed. Behavior is undefined if the union tag does not
match the field being accessed.

4.4 Conditional
---------------
Abstract Syntax:
  Expr ::= cond (condition :: Expr) (choices :: [(Name, Expr)])

Concrete Syntax:
  expr ::= '?(' expr ';' name ':' expr [',' name ':' expr [...]] ')'

Example:
  ?(mfoo; Just: mfoo.Just, Nothing: 3)

The condition must have union type. Returns the value of the choice selected
by the tag of the condition, without causing any other choices to be
evaluated.

5. Functions
------------
A function is a mapping from argument values to result value. The arguments
are organized into a finite number of args. Each arg has a name, used to
identify the argument in the body of the function, and a type, specifying the
type of value that can be supplied for that argument. A function has a return
type, specifying the type of value that will result when applying the
function.

Functions are described using the fble expression language. A function can be
applied to a set of arguments of appropriate type to produce a value with the
return type of the function.

5.1 Function Type
-----------------
Abstract Syntax:
  Type ::= func_type (args :: [(Type, Name)]) (return :: Type)

Concrete Syntax:
  type ::= '\(' type name [',' type name [...]] ';' type ')'

Examples:
  \(Int@ a, Int@ b; Bool@)

The function type describes the type of a function value by specifying the
function value's type and name of input arguments and return type.

Function arguments can be structs, unions, functions, or processes.

Two function types are equal if they take the same args and return type, with
possible renaming of argument names. For example, the following two function
types are equal:
  \(Int x; Int)
  \(Int y; Int)

The rationale for including argument names in the function type when they are
not involved in the equality check is because argument names often, but not
always, serve as documentation suggestive to the programmer as to the intent
of when the function should be called.

5.2 Function Value
------------------
Abstract Syntax:
  Expr ::= func_value (args :: [(Type, Name)]) (body :: Expr)

Concrete Syntax:
  expr ::= '\(' type name [',' type name [...]] ')' '{' stmt '}'

Example:
  \(Bool@ a) ?(a; true: False, false: True)

The function value expression is used to describe a primitive function value
given the list of arguments and the body of the function. The return type of
the function is inferred to be the type of the body of the function.

Rationale for Concrete Syntax: The body of the function requires use of braces
to avoid ambiguity that would arise otherwise with an expression such as:

  \(T@ x) f (y)

In this case it isn't clear if the argument 'y' is being applied to the
function \(T@ x) f, or to the function f.

5.3 Application
---------------
Abstract Syntax:
  Expr ::= apply (func :: Expr) (args :: [Expr])

Concrete Syntax:
  expr ::= expr '(' [expr [',' expr [...]]] ')'

Example:
  foo(x, 3)

The application expression is used to apply a function to arguments. Partial
application of arguments are allowed. The supplied arguments must match the
types of arguments specified for the function. If not all arguments are
supplied, the resulting value is a function value parameterized by the
remaining arguments.

If all arguments are supplied, the application expression evaluates to the
value of the body of the function in the context of the supplied arguments.

TODO: Can extra arguments be supplied to a function if the function returns a
function, thus causing the returned function to be called with those extra
arguments supplied as well?

5.4 Bind
--------
Abstract Syntax:
  Expr ::= bind (args :: [(Type, Name)]) (func :: Expr) (body :: Expr)

Concrete Syntax:
  stmt ::= type name [',' type name [...]] '<-' expr ';' stmt

Example
  Int@ x <- map(l); f(x, y)

Bind is syntactic sugar for applying a function to a function value. It is
equivalent to:

  apply func (func_value args body)

6 Processes
-----------
A process is a computation with side effects that produces a value. Side
effects take the form of getting and putting values to and from links that can
be accessed by other running processes.

There are primitive processes for getting a value from a link, putting a value
to a link, and creating and using a new link. Processes can be combined by
executing them in parallel and serial.

We make a distinction between when a process is evaluated and when a process
is executed. Evaluating a process means evaluating the fble expression that
describes the process, producing a process value. Executing a process means
executing the process described by a process value, producing the result of
the process.

6.1 Process Type
----------------
Abstract Syntax:
  Type ::= proc_type (return :: Type)

Concrete Syntax:
  type ::= type '!'

Example:
  Int@!

6.2 Input Type
--------------
Abstract Syntax:
  Type ::= input_type (type :: Type)

Concrete Syntax:
  type ::= type '-'

Example:
  Int@-

An input port is a handle to a link that can be used to get values from
the link. An input port is typed, so that only values of the given type can be
taken from the port.

An input port is created for every link that is created. An input port can be
used as a process that takes a value off its link.

6.3 Output Type
---------------
Abstract Syntax:
  Type ::= output_type (type :: Type)

Concrete Syntax:
  type ::= type '+'

Example:
  Int@+

An output port is a handle to a link that can be used to put values onto the
link. An output port is typed, so that only values of the given type can be
put onto the link.

An output port is created for every link that is created. An output port can
be used as a process that puts a value onto its link.

6.4 Get
-------
Abstract Syntax:
  Expr ::= get (port :: Expr)

Concrete Syntax:
  expr ::= expr '()'

Example:
  input()

The port must have type input_type. If the port has type T@-, evaluates to a
process value of type T@! that when executed gets the next value from the port.

6.5 Put
-------
Abstract Syntax:
  Expr ::= put (port :: Expr) (value :: Expr)

Concrete Syntax:
  expr ::= expr '(' expr ')'

Example:
  output(3)

The port must have type output_type. If the port has type T@+, evaluates to a
process value of type T@! that when executed puts the given value onto the
port and returns that same value. The value put onto the port is evaluated
as part of evaluation of the process.

The rationale for having put return its argument value is to
avoid the complexity of introducing a builtin notion of a unit type or a
process that doesn't return anything. In most cases we expect the return value
of a put process to be ignored.

6.6 Eval
--------
Abstract Syntax:
  Expr ::= eval (expr :: Expr)

Concrete Syntax:
  expr ::= '$(' expr ')'

Example:
  $(3)

A process that returns the value of expr without performing any other
actions. The value to return is evaluated as part of evaluating the process.

6.7 Link
--------
Abstract Syntax:
  Expr ::= link (type :: Type) (get :: Name) (put :: Name) (body :: Expr)

Concrete Syntax:
  stmt ::= type '~' name ',' name ';' expr

Example:
  Int@ ~ input, output; f(input, output)

The body must have type process_type. When executed, creates a new link, then
evaluates and executes the body with get and put ports of type type- and type+
respectively added to the context.

6.8 Exec
--------
Abstract Syntax:
  Expr ::= exec (bindings :: [(Type, Name, Expr)]) (body :: Expr)

Concrete Syntax:
  stmt ::= type name ':=' expr [',' type name ':=' expr [...]] ';' stmt

Example:
  Int@ x := getx(), Int@ y := gety(); $(add(x, y))

Executes each process in parallel, then evaluates and executes the body with
the results of the processes assigned to variables in scope. The binding
processes are evaluated at the same time the overall exec process is
evaluated.

7. Local Variables
------------------
Let expressions can be used to define local variables that allow values to be
reused in multiple places in a program. Let expressions support recursive
definitions of variables, which makes it possible to define recursive values.

In the same way, type variables can be defined to allow types to be reused in
multiple places in a program. Recursive definitions of type variables makes it
possible to define recursive types.

Type variables are distinguished syntactically from regular variables by
adding the '@' character as a suffix to the variable name:

7.1 Variable
------------
Abstract Syntax:
  Expr ::= var (name :: Name)

Concrete Syntax:
  expr ::= name

Example:
  x

Expressions are evaluated in a context that maps variable names to values and
the types of those values. The value of the variable expression is the value
associated with the variable name in the context. The type of the variable
expression is the type associated with the variable name in the context.

7.2 Let
-------
Abstract Syntax:
  Expr ::= let (bindings :: [(Type, Name, Expr)]) (body :: Expr)

Concrete Syntax:
  stmt ::= type name '=' expr [',' type name = expr [...]] ';' stmt

Example:
  Int@ x = mul(3, 3); mul(x, x)

The let expression is used to define variables. For each binding, a new
variable is defined. The value of the variable is the result of evaluating the
expression for the variable's binding.

The defined variables are visible in the body of the let expression. To
support self and mutually recursive values, the defined variables
are also visible in all of the bindings expressions.

TODO: Are bindings allowed to defined variables with the same name as
variables already in scope, thus shadowing the variable already in scope?

The value of the let expression is the value of its body.

7.3 Type Variable
-----------------
Abstract Syntax:
  Type ::= type_var (name :: Name)

Concrete Syntax:
  type_name ::= name '@'
  type ::= type_name

Example:
  Int@

Types and expressions are evaluated in a context that maps type variable names
to types and the kinds of those types. The type of the type variable is
the type associated with the type variable name in the context. The kind of
the type variable is the kind associated with the type variable name in the
context.

7.4 Type Let
------------
Abstract Syntax:
  Kind ::= basic_kind
  Type ::= type_let_type (bindings :: [(Kind, Name, Type)]) (body :: Type)
  Expr ::= type_let_expr (bindings :: [(Kind, Name, Type)]) (body :: Expr)

Concrete Syntax:
  kind ::= '@'
  type_stmt ::= kind type_name '=' type [',' kind type_name = type [...]] ';' type_stmt
  stmt ::= kind type_name '=' type [',' kind type_name = type [...]] ';' stmt

Example:
  @ Unit@ = *(); Unit@();
  @ Unit@ = *(); +(Unit@ true, Unit@ false);
  @ P@ = *(Int@ head, S@ tail), @ S@ = +(Unit@ nil, P@ cons); P@(3, S@:nil(Unit@()))

The type let is used to define type variables, when describing either types or
expressions. For each binding, a new type variable is defined. The type of the
type variable is the result of evaluating the type for the variable's binding.

The defined type variables are visible in the body of the let. To support self
and mutually recursive types, the defined type variables are also visible in
all of the bindings expressions.

TODO: Are bindings allowed to defined variables with the same name as
variables already in scope, thus shadowing the variable already in scope?

The value of the type let is the value of its body.

8. Polymorphism
---------------
Polymorphism allows expressions and types to be parameterized by abstract
types.

8.1 Poly Kind
-------------
Abstract Syntax:
  Kind ::= poly_kind (args :: [Kind]) (return :: Kind)

Concrete Syntax:
  kind ::= '\<' kind [',' kind [...]] ';' kind '>'

Examples:
  \<@ ; @>

A poly kind describes the kind of a polymorphic type, analogous to the way
function types describe the type of functions.

Two poly kinds are equal if they have the same args and return kinds.

The rationale for not including argument names in the poly kind the way they
are included in function types is that poly kinds are much less common and the
name of the arguments typically does not convey much useful information for
how to use the corresponding polymorphic type.

8.2 Poly
--------
Abstract Syntax:
  Type ::= poly_type (args :: [(Kind, Name)]) (body :: Type)
  Expr ::= poly_expr (args :: [(Kind, Name)]) (body :: Expr)

Concrete Syntax:
  type ::= '\<' kind type_name [',' kind type_name [...]] '>' '{' type_stmt '}'
  expr ::= '\<' kind type_name [',' kind type_name [...]] '>' '{' stmt '}'
 
Examples:
  \<@ T@> { +(T@ just, Unit@ nothing); }
  \<@ T@> { \(T@ x; Maybe@<T@>) { Maybe@<T@>(just: x); }; }

8.3 Poly Application
--------------------
Abstract Syntax:
  Type ::= poly_type_apply (poly :: Type) (args :: [Type])
  Expr ::= poly_expr_apply (poly :: Expr) (args :: [Type])

Concrete Syntax:
  type ::= type '<' type [',' type [...]] '>'
  expr ::= expr '<' type [',' type [...]] '>'

Examples:
  Maybe@<Int@>
  fromJust<Int@>(3)

9. Program
----------
A program is an fble expressions that creates a value that is used however is
deemed suitable by whoever is executing the program. Commonly this could be:

* struct: evaluate and output the value
* union: evaluate and output the value
* function: apply the function to arguments provided on the command line,
  evaluate and output the resulting value
* process: run the process, evaluate and output the resulting value.
  
10. Abstract Syntax Reference
-----------------------------
Name ::= (* A string of characters *)

Kind ::=
   basic_kind
 | poly_kind (args :: [Kind]) (return :: Kind)
 ;

Type ::=
   struct_type (fields :: [(Type, Name)])
 | union_type (fields :: [(Type, Name)])
 | func_type (args :: [(Type, Name)]) (return :: Type)
 | proc_type (return :: Type)
 | input_type (type :: Type)
 | output_type (type :: Type)
 | type_var (name :: Name)
 | type_let_type (bindings :: [(Kind, Name, Type)]) (body :: Type)
 | poly_type (args :: [(Kind, Name)]) (body :: Type)
 | poly_type_apply (poly :: Type) (args :: [Type])
 ;

Expr ::=
   struct_value (type :: Type) (args :: [Expr])
 | struct_access (object :: Expr) (field :: Name)
 | union_value (type :: Type) (field :: Name) (arg :: Expr)
 | union_access (object :: Expr) (field :: Name)
 | cond (condition :: Expr) (choices :: [(Name, Expr)])
 | func_value (args :: [(Type, Name)]) (body :: Expr)
 | apply (func :: Expr) (args :: [Expr])
 | bind (args :: [(Type, Name)]) (func :: Expr) (body :: Expr)
 | get (port :: Expr)
 | put (port :: Expr) (value :: Expr)
 | eval (expr :: Expr)
 | link (type :: Type) (get :: Name) (put :: Name) (body :: Expr)
 | exec (bindings :: [(Type, Name, Expr)]) (body :: Expr)
 | var (name :: Name)
 | let (bindings :: [(Type, Name, Expr)]) (body :: Expr)
 | type_let_expr (bindings :: [(Kind, Name, Type)]) (body :: Expr)
 | poly_expr (args :: [(Kind, Name)]) (body :: Expr)
 | poly_expr_apply (poly :: Expr) (args :: [Type])
 ;

11. Concrete Syntax Reference
-----------------------------
name ::= (* [a-zA-Z--9_]+ *)

type_name ::= name '@'

kind ::=
   '@'                                        (* basic_kind *)
 | '\<' kind [',' kind [...]] ';' kind '>'    (* poly_kind *)
 ;

type ::= 
   '*(' [type name [',' type name [...]]] ')'                            (* struct_type *)
 | '+(' type name [',' type name [...]] ')'                              (* union_type *)
 | '\(' type name [',' type name [...]] ';' type ')'                     (* func_type *)
 | type '!'                                                              (* proc_type *)
 | type '-'                                                              (* input_type *)
 | type '+'                                                              (* output_type *)
 | type_name                                                             (* type_var *)
 | '\<' kind type_name [',' kind type_name [...]] '>' '{' type_stmt '}'  (* poly_type *)
 | type '<' [type [',' type [...]]] '>'                                  (* poly_type_apply *)
 | '{' type_stmt '}'                                                     (* type_stmt *)
 ;

type_stmt ::=
   type ';'                                                                   (* type *)
 | kind type_name '=' type [',' kind type_name '=' type [...]] ';' type_stmt  (* type_let_type *)
 ;

expr ::=
   type '(' [expr [',' expr [...]]] ')'                             (* struct_value *)
 | type '(' name ':' expr ')'                                       (* union_value *)
 | expr '.' name                                                    (* access *)
 | '?(' expr ';' name ':' expr [',' name ':' expr [...]] ')'        (* cond *)
 | '\(' [type name [',' type name [...]]] ')' '{' stmt '}'          (* func_value *)
 | expr '(' [expr [',' expr [...]]] ')'                             (* apply *)
 | '$(' expr ')'                                                    (* eval *)
 | name                                                             (* var *)
 | '\<' kind type_name [',' kind type_name [...]] '>' '{' stmt '}'  (* poly_expr *)
 | expr '<' [type [',' type [...]]] '>'                             (* poly_expr_apply *)
 | '{' stmt '}'                                                     (* statement *)
 ;

stmt ::=
   expr ';'                                                             (* expr *)
 | type name [',' type name [...]] '<-' expr ';' stmt                   (* bind *)
 | type '~' name ',' name ';' stmt                                      (* link *)
 | type name ':=' expr [',' type name ':=' expr [...]] ';' stmt         (* exec *)
 | type name '=' expr [',' type name = expr [...]] ';' stmt             (* let *)
 | kind type_name '=' type [',' kind type_name = type [...]] ';' stmt   (* type_let_expr *)
 ;

Notes:
* struct and union access share the same form. The type of the object is used
  to distinguish between the two kinds of expressions.
* apply, get, and put share the same form. The type of the expr is used to
  distinguish between the three kinds of expressions.

12. Thoughts
------------
* Is there really any need for a type let type? It seems like you could always
  use either a type let expression or a polymorphic type function.
* When it comes time to add module support, here are three concepts to think
  about:
 1. How to group types and values into single objects. For values we can just
 use struct values. For types, maybe introduce an analogous concept?

 2. Namespace control: Ideally a child module cannot break if its parent
 brings starts using a new name that conflicts with the child's internals. Can
 a child use a named entity that the parent doesn't have in scope?

 3. Dependency questions: Modules depend on other modules. As a user of a
 module, it's not easy or fair to have to keep track of all the internal
 dependencies of other modules to figure out what order to define the modules.
 So it might be nice for the system to take care of that. Should a parent
 module explicitly report all required dependencies of all child modules, or
 is it okay for dependencies to be explicit?
