
@ Bool@ = /Bool%.Bool@;
% True = /Bool%.True;
% False = /Bool%.False;
% And = /Bool%.And;

@ Data@ = /Data%.Data@;

@ Unit@ = /Unit%.Unit@;
% Unit = /Unit%.Unit;

<@>@ Maybe@ = /Maybe%.Maybe@;
<@>% Nothing = /Maybe%.Nothing;
<@>% Just = /Maybe%.Just;

<@,@>@ Entry@ = <@ K@, @ V@> { *(K@ key, V@ value); };

<@ K@, @ V@>(Maybe@<Entry@<K@, V@>>) { Maybe@<V@>; }
MValue = <@ K@, @ V@>(Maybe@<Entry@<K@, V@>> m) {
  ?(m; just: Just<V@>(m.just.value), nothing: Nothing<V@>);
};

# A map from K@ to V@, using Data@ as the lookup hash for K@.
<@,@>@ DataMap@ = <@ K@, @ V@>{ +(Unit@ empty, DataMapP@<K@, V@> map); },
<@,@>@ DataMapP@ = <@ K@, @ V@>{ 
  *(Maybe@<Entry@<K@,V@>> unit,
    *(DataMap@<K@, V@> a, DataMap@<K@, V@> b) sum,
    DataMap@<Unit@, DataMap@<K@, V@>> product);
};

<@ K@, @ V@>{ DataMap@<K@, V@>; } Empty = <@ K@, @ V@>{
  DataMap@<K@, V@>(empty: Unit);
};

<@ K@, @ V@>(DataMap@<K@, V@>, Data@) { Maybe@<V@>; }
Lookup = <@ K@, @ V@>(DataMap@<K@, V@> map, Data@ hash) {
  ?(map;
     empty: Nothing<V@>,
     map: {
       ?(hash;
          unit: MValue<K@, V@>(map.map.unit),
          sum: ?(hash.sum;
                   a: Lookup<K@, V@>(map.map.sum.a, hash.sum.a),
                   b: Lookup<K@, V@>(map.map.sum.b, hash.sum.b)),
          product: {
            Maybe@<DataMap@<K@, V@>> mm = Lookup<Unit@, DataMap@<K@, V@>>(map.map.product, hash.product.a);
            ?(mm;
                just: Lookup<K@, V@>(mm.just, hash.product.b),
                nothing: Nothing<V@>);
          });
     });
};

# Insert that transforms the existing value, if any.
<@ K@, @ V@>(DataMap@<K@, V@>, K@, Data@, (Maybe@<V@>){ V@; }) { DataMap@<K@, V@>; }
InsertWith = <@ K@, @ V@>(DataMap@<K@, V@> map, K@ key, Data@ hash, (Maybe@<V@>){ V@; } with) {
  DataMapP@<K@, V@> p =
    ?(map;
       empty: DataMapP@<K@, V@>(
         Nothing<Entry@<K@, V@>>,
         @(a: Empty<K@, V@>, b: Empty<K@, V@>),
         Empty<Unit@, DataMap@<K@, V@>>),
       map: map.map);
  DataMap@<K@, V@>(map:
   ?(hash;
     unit: DataMapP@<K@, V@>(
       Just<Entry@<K@, V@>>(Entry@<K@, V@>(key, with(MValue<K@, V@>(p.unit)))),
       p.sum,
       p.product
     ),
     sum: ?(hash.sum;
              a: DataMapP@<K@, V@>(p.unit, @(a: InsertWith<K@, V@>(p.sum.a, key, hash.sum.a, with), b: p.sum.b), p.product),
              b: DataMapP@<K@, V@>(p.unit, @(a: p.sum.a, b: InsertWith<K@, V@>(p.sum.b, key, hash.sum.b, with)), p.product)),
     product: {
       DataMapP@<K@, V@>(p.unit, p.sum,
         InsertWith<Unit@, DataMap@<K@, V@>>(p.product, Unit, hash.product.a, (Maybe@<DataMap@<K@, V@>> mm) {
           InsertWith<K@, V@>(?(mm; just: mm.just, nothing: Empty<K@, V@>), key, hash.product.b, with);
         }));
     }));
};

<@ K@, @ V@>(DataMap@<K@, V@>, K@, Data@, V@) { DataMap@<K@, V@>; }
Insert = <@ K@, @ V@>(DataMap@<K@, V@> map, K@ key, Data@ hash, V@ value) {
  InsertWith<K@, V@>(map, key, hash, (Maybe@<V@> _) { value; });
};

<@ K@, @ V@, @ B@>(DataMap@<K@, V@>, B@, (K@, V@, B@) { B@;}) { B@; }
For = <@ K@, @ V@, @ B@>(DataMap@<K@, V@> m, B@ base, (K@, V@, B@) { B@;} body) {
  ?(m;
    empty: base,
    map: {
      B@ b2 = ?(m.map.unit;
                  just: body(m.map.unit.just.key, m.map.unit.just.value, base),
                  nothing: base);
      B@ b3 = For<K@, V@, B@>(m.map.sum.a, b2, body);
      B@ b4 = For<K@, V@, B@>(m.map.sum.b, b3, body);
      B@ b5 = For<Unit@, DataMap@<K@, V@>, B@>(m.map.product, b4,
        (Unit@ _, DataMap@<K@, V@> v, B@ b) {
          For<K@, V@, B@>(v, b, body);
      });
      b5;
    });
};

# TODO: Should this be in another module? It's the only reason we need to
# import Bool%.
<@ K@, @ V@>((V@, V@) { Bool@; }, DataMap@<K@, V@>, DataMap@<K@, V@>) { Bool@; }
Equals = <@ K@, @ V@>((V@, V@) { Bool@;} eq, DataMap@<K@, V@> a, DataMap@<K@, V@> b) {
  ?(a;
      empty: ?(b; empty: True, map: False),
      map: ?(b;
        empty: False,
        map: {
          Bool@ unit_eq = ?(a.map.unit;
            just: ?(b.map.unit;
              just: eq(a.map.unit.just.value, b.map.unit.just.value),
              nothing: False),
            nothing: ?(b.map.unit; just: False, nothing: True)
          );

          Bool@ sum_eq = And(
            Equals<K@, V@>(eq, a.map.sum.a, b.map.sum.a),
            Equals<K@, V@>(eq, a.map.sum.b, b.map.sum.b)
          );

          Bool@ product_eq = 
            Equals<Unit@, DataMap@<K@, V@>>(
              Equals<K@, V@>(eq), a.map.product, b.map.product);
          And(unit_eq, And(sum_eq, product_eq));
        }));
};

# Map@ interface parameterized by key type.
<@>@ Map@ = <@ K@> {
  <@>@ M@ = DataMap@<K@>;
  *(@<M@> Map@,
    M@ Empty,
    <@ V@>(M@<V@>, K@) { Maybe@<V@>; } Lookup,
    <@ V@>(M@<V@>, K@, (Maybe@<V@>){ V@; }) { M@<V@>; } InsertWith,
    <@ V@>(M@<V@>, K@, V@) { M@<V@>; } Insert,
    <@ V@, @ B@>(M@<V@>, B@, (K@, V@, B@) { B@; }) { B@; } For,
    <@ V@>((V@, V@) { Bool@; }, M@<V@>, M@<V@>) { Bool@; } Equals
   );
};
  
# An implementation of the Map interface.
<@ K@>((K@) { Data@; }) { Map@<K@>; }
Map = <@ K@>((K@) { Data@; } ToData) {
  <@>@ M@ = DataMap@<K@>;
  Map@<K@>(M@,
    Empty<K@>,
    <@ V@>(M@<V@> m, K@ k) {
      Lookup<K@, V@>(m, ToData(k));
    },
    <@ V@>(M@<V@> m, K@ k, (Maybe@<V@>) { V@; } w) {
      InsertWith<K@, V@>(m, k, ToData(k), w);
    },
    <@ V@>(M@<V@> m, K@ k, V@ v) {
      Insert<K@, V@>(m, k, ToData(k), v);
    },
    <@ V@, @ B@>(M@<V@> m, B@ b, (K@, V@, B@) { B@; } body) {
      For<K@, V@, B@>(m, b, body);
    },
    <@ V@>((V@, V@) { Bool@; } eq, M@<V@> a, M@<V@> b) {
      Equals<K@, V@>(eq, a, b);
    }
  );
};

@(Map@, Map);
