Pinball Game
============

There are so many different games we could redo as a pinball game. For
example:
* skiball
* bowling
* breakout
* space invaders
* soccer
* platformer, like mario brothers or celeste
* Air hockey.

Initial proposal:
* Have a half court with sloping sides and paddles with a single object at the
  top of the screen that goes back and forth left and right in a fixed
  pattern. You have a score multiplier. Hit the object, you score the number
  of points on the score multiplier and double the score multiplier. Hit the
  ceiling you reset the score multiplier to 1. The game ends when the ball
  drops down the drain.

  Ideally we can print a score on the screen and keep track of high score and
  all that stuff. No fancy graphics required.

Current challenge:
* With just a ball and fixed edges, it's going way too slow. Averaging 4
  frames per second. We want to get it up to 60 frames per second. So let's do
  some profiling to figure out what's up.

Without looking at profiles yet, what I expect is:
* Maybe collision detection is expensive, given the performance seems tied
  directly to the number of edges in the screen. Maybe we can add a fast path
  cutout?
* Maybe drawing the circle every frame. We could just cache the drawing and
  translate it instead?

* Making a compiled version of pinball helps a bit.

Pinball app benchmark profile says:
* 70% of the time is spent drawing the triangles for the edges.

Let's fix that. Maybe it's finally time to add the optimization of drawing
triangles that are tall and skinny.

Actually, no need to redraw the triangles. Do the background drawing once and
reuse it.

---

The next performance issue is the rational arithmetic, mostly Add and Sub for
Rat@, which involves calls to /Int/Int%.Mul. Those multiplications account for
70% of the time now.

Perhaps this is because we introduced 3/5, 4/5 as rational numbers and we
don't reduce Rat@, so the denominator goes up and up and up leading to large
multiplications?

---

Reducing Rat@ made a big difference. That fixed the issue with integer
multiplication taking up all the time.

Setting restitution to 1 so that the ball bounces forever, it's starting to
look pretty good, except that there is a pause every time we collide with an
edge.

Perhaps not surprisingly, now all of our time is spent normalizing rational
numbers? Though maybe changing the ball to bounce forever isn't the right way
to look at things, if the performance issue is when collisions actually occur.

In particular, it's when the ball bounces off the diagonal edge that it
noticeably lags. Bouncing off vertical or horizontal edges appear to be fine.

Less than 5% of the profile is time spent in collisions, which suggests the
profile is not terribly meaningful for understanding the lag at time of
collision.

I tried changing the world to do lots of collisions against the diagonal
walls, but then it didn't lag so much.

I want to try using integers instead of rational numbers and see if it makes a
noticeable difference. Have everything be scaled by a factor of 128 and see
how that goes.

---

Turns out, the collision lag issue goes away if we fix precision to 1/128 at
intermediate computations of rational numbers. In that case, why not use Int@
instead of Rat@?

I'm not more prominently running into the issue where the ball manages to
escape it's box. I was having that with Rat@ too, but it seems more likely to
happen now with the precision limits. Any easy way to address that?

Switching from Rat@ to Int@ is almost 4x improvement in benchmark performance.

---

Next issue is the details of collision to make sure the ball doesn't magically
get energy from hitting a corner and eventually runs out of energy, but is
still able to roll on an incline.

It seems to do a collision at the end corner of an edge and get significant
boost to velocity in the negative tangential direction.

It's not about hitting the end of an edge, because it happens even if the two
intersecting edges intersect in the middle. And it only appears to happen on
the left hand corner, not the right hand corner.

Specifically, this is the ball rolling left on the floor towards the left
slope. It gets to the left slope, then slides up the left slope.

The order in which we test for collision doesn't seem to matter.

Try this math:

pos = (-2325/128, -11678/128)
vel = (-126/128, -4/128)

Understand why we go to
pos = (-2616/128, -11507/128)
vel = (-38/128, 98/128)

And in particular, how we can jump to the left by 291 units at once when the
X velocity is somewhere between -126 and -38.

Checking the math suggests the issue may be that 3/5 and 4/5 don't divide 128
evenly, so rotating forward and then backwards leads to funny behavior at time
of collision.

Seems things are better if we avoid use of RotateFrom for computing the new X
position. I worry that could lead to the possibility of the ball sinking
through the wall over time, but maybe that's not the case. It looks okay.
Gravity pushes it down, it doesn't actually go down, then the velocity from
collision pushes it back up a little. I think we are okay.

---

Computing cos/sin for integers is pretty doable I think. From some
experiments, important notes:
* Do the intermediate computation with double the precision requested.
* Do expansion only close to 0, so first 90 degrees, and compute rest based on
  those numbers. Or first 45 degrees sin and cos.
* Compute as many terms as needed until we run out of precision to store the
  result.

---

Issue: Collision with paddle leaves ball on the edge of the paddle, but then
moves the ball from there. The ball is at the edge of the paddle. Should it be
considered a collision or not? If we say yes, the we get stuck at the edge. If
we say no, then could we possibly get unlucky and go through the edge?

Perhaps the right solution is don't count it as a collision if the ball is
moving away from the edge at the time of collision.

Issue: Computation of paddle velocity is wrong if the paddle is at rest but
paddle.vel is not zero.

Is it wrong for paddle.vel to be non-zero when the paddle has reached its
limit? When do we have the paddle reach its limit?

Here's what I think:
* We should treat the paddle reaching it's end point as a collision. It should
  break up a Move. It should set the paddle velocity to 0. So paddle velocity
  is 0 when the paddle is stopped.

* We should decouple the computation of a collision from whether that happens
  before or after something else.

What kinds of movements can we have?
* Ball moves, doesn't run into anything.
  Position changes.
* Paddle moves, doesn't run into anything.
  Position changes.
* Paddle moves, hits end of range.
  Position and velocity of paddle changes.
* Ball moves, hits edge.
  Position and velocity of ball changes.
* Ball moves, paddle moves, they hit.
  Paddle position, ball position, and ball velocity all change.

Ideally each can be concerned just with its own thing. But we also don't want
to have to calculate super far out in time, for example, how long it would
take the ball to collide with an edge that it is running almost parallel to,
because that could be expensive to compute.

Part of the annoyance is how we can easily specify which paddle is updated in
a world. It would be nice if we could name the paddles somehow.

Let's take this one step at a time. What's the first test case I want to add
that would demonstrate the problem?

A paddle going up, hits the top edge and stops before the ball then collides
with that stationary edge, all in one tick of the world. The solution will be
to add a check for when the paddle reaches its end and treat that as a kind of
collision.

The position of the ball and all paddles are effected by time. The velocity of
the ball and paddles are effected by collisions. There's nothing to say you
couldn't have a ball collide with a paddle at the same time multiple paddles
reaches their end point, which suggests we want a way to describe updates to
multiple things at once somehow.

The way rocinante worked is we first check for events. Events give the time of
the event and all the information needed to update the ball as a result of the
event. Namely, the velocity and point of collision of the object with the
ball. We would advance the ball until the time of the event, and if there was
an event, update the ball velocity based on the information it has.

I like the idea of having the ball update its own velocity, to factor out
common code for edge and paddle collisions. If we stop worrying about
performance for just a bit, then we could have a function

(Ball@, Vec@, Num@) { Ball@; } Collide = (Ball@ ball, Vec@ pos, Num@ vel) { ...  };

Where pos is the absolute position of the point of collision, vel is the
magnitude of velocity...

But it seems a shame to throw away and recompute what we've already computed.
Hmm... There are a couple of ideas here:
1. How to compactly express a ball collision event.
2. What logic for updating the ball velocity can we localize with the ball
code instead of the edge collision code?

The information we need:
* The new velocity of the ball.
  Depends on:
  - the (normal) velocity of the object the ball collides with.
  - the normal vector of the object the ball collides with (or, equivalently,
    the point on the circumference of the ball where the collision took place).
  - the coefficient of restitution between ball and edge.

The information we already have:
* the velocity of the ball at time of collision relative to the edge.
* the velocity of the edge at time of collision relative to the edge.
* the tangential velocity of the ball at time of collision relative to the
  edge.

So it would seem to me that there is very little code specific to the ball
that we would like to localize:
  v_ball.tangent = v_ball.tangent
  v_ball.normal = R * (v_edge - v_ball.normal)
  v = Rotate(normal, v_ball.tangent, v_ball.normal)

And we could always factor out a function for that logic if desired.

The collision logic makes use of the end position of the ball. We could
recompute that or not.

I'm fine with the event giving the new state for the ball. And we could treat
'time up' as an event. The issue is, some events effect the ball and some
events effect a specific paddle. How can we accumulate those and act
accordingly?

Imagine we have multiball. Then events could involve a particular ball. The
time up event doesn't make sense any more, because time up depends on the time
of another event.

Maybe we have two kinds of events:
* Paddle Stop - sets paddle velocity to zero because the edge has been
  reached.
* Ball Collide - gives direction and magnitude of collision.

We have the following functions:
* Ball Collide Edge - gives a maybe ball collide event.
* Ball Collide Paddle - gives a maybe ball collide event.
* Paddle End - gives a maybe paddle stop event.

We process all possible events, end up with a list of all the events that
happen as soon as some time t. Advance Ball and Paddle by t, then apply each
event.

The key idea being, we need some way to refer to a specific ball or paddle in
the event. That's something we'll want anyway for user input, for example, to
indicate which paddle's velocity to change.

Imagine we have an id. Then things are easy.

Paddle Stop - specifies the id of the paddle.
Ball collide - specifies the id of the ball.

Ball collide edge - takes the id of the ball.
Ball collide paddle - takes the id of the ball and the paddle.
Paddle end - takes the id of the paddle.

Then we have a function to apply an event to a World@. Get the list of events,
filter out any with greater times than any others (via an event queue
abstraction?), advance the world, by the time of the events, apply all the
events to the world, and continue.

More and more I feel like we should use an abstract data type to represent the
world, with methods on the world such as apply event.

The number of balls in play could be dynamic. The number of paddles could be
dynamic, but the names need to be fixed in some sense to know which paddle to
operate? Unless it's just a left paddle or a right paddle that we need to
know.

My question is, what should we use to refer to a specific ball or paddle? An
integer id? A user provided type? A string name?

For the sake of development we could restrict the world to a single ball and
single paddle and not worry about ids yet. Figure out the physics first, add
ids later. That sounds reasonable to me.

Actually, the annoying thing about having one paddle always is for testing we
don't have an easy way to have no paddles.

Perhaps it would be worth having some finer grain unit testing. Better
targeted tests with simpler descriptions. Factor out the core logic in a
better way. And hope the interfaces don't change too much.

For example, to start:
* Pull Ball@ out into its own module, define Eq@ and Show@ and Move.
* Pull Edge@ out into its own module.
* Pull Paddle@ out into its own module, define Eq@ and Show@ and Move.
* Pull Collision routines out into a separate module.

---

I want to summarize what physics seems to work well for stationary edge in
terms of the ball not double colliding or passing through, even in the
presence of gravity:
* It's not considered a collision if the ball is moving in the same direction
  the edge is facing.
* It's not a collision if the ball center starts below the edge.
  - This is the case where the ball starts past the edge.
  - We would expect t is negative if the ball is moving in the direction
    opposite the edge is facing.
  - Maybe it's better to do this by position than time, to avoid large numbers
    in the computation of time.
* It's not a collision if the ball bottom edge ends above the edge.
  - This is the case where the ball doesn't reach the edge.
  - We would expect t is less than tm if the ball is moving in the direction
    opposite the edge is facing.
  - Maybe it's better to do this by position than time, to avoid large numbers
    in the computation of time.
* The ball has to be within the segment of the edge at the point of collision.
* v_normal = R * -v_normal

That works great.

For a paddle, we should be able to apply the same thing. The differences are:
* After filtering out invalid ball start and end positions, computed time of
  collision may still be negative or greater than tm. That should be checked
  for.
* paddle could be moving with some normal velocity v_paddle, so the new ball
  velocity would be: v_normal_ball = R * (v_paddle - v_normal_ball)
  - Example: v_normal_ball is -5, v_paddle is 10, final velocity is 15R.

---

On naming paddles: if the goal is to figure out the physics first, how about
just move all the paddles together? Or say there is at most one paddle in the
list? Or make it a Maybe paddle instead of a list of paddles?

I would like to specify edges using start and end point, rather than normal
and length. Let me write a helper function for that. That way I can write a
bunch of tests for a collide edge function.

The API for collide edge ought to be:
* Inputs: ball, edge, max time.
* Outputs: Maybe<time, Ball@>

And we'll have a function to move a ball with a fixed velocity by a given
time to help.
