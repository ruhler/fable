
@ Char@ = /Char%.Char@;
% Chars = /Char%.Chars;

@ Bit@ = /Digits%.Bit@;
% Bit = /Digits%.Bit;

@ Output@ = /Fblf/Compile/Output%.Output@;
% Line = /Fblf/Compile/Output%.Line;
% Do = /Fblf/Compile/Output%.Do;
% Return = /Fblf/Compile/Output%.Return;

@ Addr@ = /Fblf/Program%.Addr@;
@ ProgramId@ = /Fblf/Program%.ProgramId@;
@ Env@ = /Fblf/Program%.Env@;
@ Assign@ = /Fblf/Program%.Assign@;
@ Condition@ = /Fblf/Program%.Condition@;
@ IfElse@ = /Fblf/Program%.IfElse@;
@ Sequence@ = /Fblf/Program%.Sequence@;
@ While@ = /Fblf/Program%.While@;
@ Shared@ = /Fblf/Program%.Shared@;
@ Value@ = /Fblf/Program%.Value@;
@ Program@ = /Fblf/Program%.Program@;
% Ref = /Fblf/Program%.Ref;
<@>% ForEachProgram = /Fblf/Program%.ForEachProgram;

@ Int@ = /Int/Int%.Int@;
% Add = /Int/Int%.Add;
% Sub = /Int/Int%.Sub;
% Eq = /Int/Int/Eq%.Eq;
% Le = /Int/Int/Eq%.Le;
% Mod = /Int/Int/Div%.Mod;
% Int = /Int/Int/Lit%.Int;

<@>@ List@ = /List%.List@;
<@>% Nil = /List%.Nil;
<@>% Cons = /List%.Cons;
<@>% Concat = /List%.Concat;

<@>% Drop = /List/Length%.Drop;
<@>% Length = /List/Length%.Length;
<@>% Take = /List/Length%.Take;

@ String@ = /String%.String@;
% Str = /String%.Str;

@ Unit@ = /Unit%.Unit@;

Int@ BitsPerWord = Int|64;

(List@<String@>) { String@; } Strs = Concat<Char@>;

(Addr@) { String@; } CompileAddr = /Int/Int/Show%.Show;

# Compile a constant that is assumed to fit within BitsPerWord.
(List@<Bit@>) { String@; } 
CompileSmallConstant = {
  # Convert a list of bits to hex string, assuming the number of elements on
  # the list is a multiple of 4.
  (List@<Bit@>) { String@; } ToHex = (List@<Bit@> l) {
    l.?(
      cons: {
        Bit@ a = l.cons.head;
        Bit@ b = l.cons.tail.cons.head;
        Bit@ c = l.cons.tail.cons.tail.cons.head;
        Bit@ d = l.cons.tail.cons.tail.cons.tail.cons.head;
        String@ tail = ToHex(l.cons.tail.cons.tail.cons.tail.cons.tail);
        Char@ h = a.?(
          0: b.?(
            0: c.?(0: d.?(0: Chars.0, 1: Chars.1), 1: d.?(0: Chars.2, 1: Chars.3)),
            1: c.?(0: d.?(0: Chars.4, 1: Chars.5), 1: d.?(0: Chars.6, 1: Chars.7))),
          1: b.?(
            0: c.?(0: d.?(0: Chars.8, 1: Chars.9), 1: d.?(0: Chars.A, 1: Chars.B)),
            1: c.?(0: d.?(0: Chars.C, 1: Chars.D), 1: d.?(0: Chars.E, 1: Chars.F))));
        Cons<Char@>(h, tail);
      },
      nil: Nil<Char@>);
  };

  (List@<Bit@> c) {
    Int@ length = Length<Bit@>(c);
    Eq(Mod(length, Int|4), Int|0).?(
      true: Strs[Str|'0x', ToHex(c)],
      false: {
        # TODO: We could improve performance by adding just the right number
        # of bits here, instead of having to recompute the length of the list
        # each time.
        CompileSmallConstant(Cons<Bit@>(Bit.0, c));
      });
  };
};

# Compile an equals condition into an atomic boolean expression in C, where
# the number of bits is assumed to fit within BitsPerWord.
(Value@, Value@, Int@) { String@; }
CompileSmallEquals = (Value@ a, Value@ b, Int@ n) {
  a.?(
    ref: b.?(
      ref: Strs[
        Str|'FblfHeapEqual(heap, ',
        CompileAddr(a.ref), Str|', ',
        CompileAddr(b.ref), Str|', ',
        /Int/Int/Show%.Show(n), Str|')'],
      const: Strs[
        Str|'FblfHeapEquals(heap, ',
        CompileAddr(a.ref), Str|', ',
        CompileSmallConstant(b.const), Str|', ',
        /Int/Int/Show%.Show(n), Str|')']),
    const: b.?(
      ref: Strs[
        Str|'FblfHeapEquals(heap, ',
        CompileAddr(b.ref), Str|', ',
        CompileSmallConstant(a.const), Str|', ',
        /Int/Int/Show%.Show(n), Str|')'],
      const: Strs[
        Str|'(',
        CompileSmallConstant(a.const),
        Str|' == ',
        CompileSmallConstant(b.const),
        Str|')']));
};

# Split the first n bits off of the given value, returning the n most
# significant bits of the value as 'hi', and the remaining least significant
# bits of the value in 'lo'.
(Value@, Int@) { *(Value@ hi, Value@ lo); } Split = (Value@ v, Int@ n) {
  v.?(
    ref: @(
      hi: v,
      lo: Ref(Add(v.ref, n))),
    const: @(
      hi: Value@(const: Take<Bit@>(n, v.const)),
      lo: Value@(const: Drop<Bit@>(n, v.const))));
};

# Compile an equals condition into an atomic boolean expression in C.
(Value@, Value@, Int@) { String@; }
CompileEquals = (Value@ a, Value@ b, Int@ n) {
  Le(n, BitsPerWord).?(
    true: CompileSmallEquals(a, b, n),
    false: {
      % as = Split(a, BitsPerWord);
      % bs = Split(b, BitsPerWord);
      String@ hi = CompileSmallEquals(as.hi, bs.hi, BitsPerWord);
      String@ lo = CompileEquals(as.lo, bs.lo, Sub(n, BitsPerWord));
      Strs[Str|'(', hi, Str|' && ', lo, Str|')'];
    });
};

# Compile a condition into an expression suitable for use in the condition of
# an if or while statement in C.
(Condition@) { String@; } CompileCondition = (Condition@ cond) {
  String@ equals = CompileEquals(cond.a, cond.b, cond.n);
  cond.op.?(
    eq: equals,
    ne: Cons<Char@>(Chars.'!', equals));
};

# Compile an assignment statement assuming the number of bits fits within
# BitsPerWord.
(String@, Assign@) { Output@; }
CompileSmallAssign = (String@ indent, Assign@ assign) {
  assign.value.?(
    ref: Line(Strs[
      indent,
      Str|'FblfHeapCopy(heap, ',
      CompileAddr(assign.ref),
      Str|', ',
      CompileAddr(assign.value.ref),
      Str|', ',
      /Int/Int/Show%.Show(assign.n),
      Str|');']),
    const: Line(Strs[
      indent,
      Str|'FblfHeapWrite(heap, ',
      CompileAddr(assign.ref),
      Str|', ',
      CompileSmallConstant(assign.value.const),
      Str|', ',
      /Int/Int/Show%.Show(assign.n),
      Str|');']));
};

# SharedFuncName --
#   The C function name used for the implementation of the program with given
#   id.
(ProgramId@) { String@; } SharedFuncName = (ProgramId@ id) {
  Strs[Str|'__prog_', /Int/Int/Show%.Show(id)];
};

(String@, Shared@) { Output@; } CompileShared = (String@ indent, Shared@ id) {
  Line(Strs[indent, SharedFuncName(id), Str|'(heap);']);
};

# Compile an assignment statement into a sequence of statements in C.
(String@, Assign@) { Output@; } CompileAssign = (String@ indent, Assign@ assign) {
  Le(assign.n, BitsPerWord).?(
    true: CompileSmallAssign(indent, assign),
    false: {
      % vs = Split(assign.value, BitsPerWord);
      Unit@ _ <- Do(CompileSmallAssign(indent, Assign@(assign.ref, vs.hi, BitsPerWord)));
      Unit@ _ <- Do(CompileSmallAssign(indent, Assign@(Add(assign.ref, BitsPerWord), vs.lo, Sub(assign.n, BitsPerWord))));
      Return;
    });
};

(String@, Sequence@) { Output@; } CompileSequence = (String@ indent, Sequence@ seq) {
  seq.?(
    cons: {
      Unit@ _ <- Do(CompileProgram(indent, seq.cons.head));
      Unit@ _ <- Do(CompileSequence(indent, seq.cons.tail));
      Return;
    },
    nil: Return);
},

(String@, IfElse@) { Output@; } CompileIfElse = (String@ indent, IfElse@ ifelse) {
  String@ nested = Strs[indent, Str|'  '];
  Unit@ _ <- Do(Line(Strs[indent, Str|'if (', CompileCondition(ifelse.condition), Str|') {']));
  Unit@ _ <- Do(CompileProgram(nested, ifelse.if_body));
  Unit@ _ <- Do(Line(Strs[indent, Str|'} else {']));
  Unit@ _ <- Do(CompileProgram(nested, ifelse.else_body));
  Unit@ _ <- Do(Line(Strs[indent, Str|'}']));
  Return;
},

(String@, While@) { Output@; } CompileWhile = (String@ indent, While@ while) {
  String@ nested = Strs[indent, Str|'  '];
  Unit@ _ <- Do(Line(Strs[ indent, Str|'while (', CompileCondition(while.condition), Str|') {']));
  Unit@ _ <- Do(CompileProgram(nested, while.body));
  Unit@ _ <- Do(Line(Strs[indent, Str|'}']));
  Return;
},

(String@, Program@) { Output@; } CompileProgram = (String@ indent, Program@ prgm) {
  prgm.?(
    assign: CompileAssign(indent, prgm.assign),
    sequence: CompileSequence(indent, prgm.sequence),
    ifelse: CompileIfElse(indent, prgm.ifelse),
    while: CompileWhile(indent, prgm.while),
    shared: CompileShared(indent, prgm.shared));
};

# Compile_ --
#   Compile an fblf program to a C function with the given name.
#
# TODO: Clarify in documentation the dependence on CompileEnv.
#
# The signature of a function named 'Foo' will be:
#   void Foo(FblfHeap* heap);
(String@, Program@) { Output@; }
Compile = (String@ name, Program@ program) {
  Unit@ _ <- Do(Line(Strs[ Str|'void ', name, Str|'(FblfHeap* heap)']));
  Unit@ _ <- Do(Line(Str|'{'));
  Unit@ _ <- Do(CompileProgram(Str|'  ', program));
  Unit@ _ <- Do(Line(Str|'}'));
  Return;
};

# CompileEnv --
#   Compile an fblf program environment to static C function that can be
#   referenced from programs compiled with Compile.
(Env@) { Output@; } CompileEnv = (Env@ env) {
  Unit@ _ <- Do(ForEachProgram<Output@>(env, Return, (ProgramId@ id, Program@ p, Output@ o) {
    Unit@ _ <- Do(o);
    Unit@ _ <- Do(Line(Strs[ Str|'void ', SharedFuncName(id), Str|'(FblfHeap* heap);']));
    Return;
  }));

  Unit@ _ <- Do(ForEachProgram<Output@>(env, Return, (ProgramId@ id, Program@ p, Output@ o) {
    Unit@ _ <- Do(o);
    Unit@ _ <- Do(Compile(SharedFuncName(id), p));
    Return;
  }));

  Return;
};

@(Compile, CompileEnv);
