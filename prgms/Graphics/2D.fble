
@ Drawing@ = /Drawing%.Drawing@;
@ Color@ = /Drawing%.Color@;
@ Point@ = /Drawing%.Point@;
% Affine = /Drawing%.Affine;
% Blank = /Drawing%.Blank;
% Over = /Drawing%.Over;
% Rect = /Drawing%.Rect;
% Translate = /Drawing%.Translate;

@ Int@ = /Int/Int%.Int@;
% Abs = /Int/Int%.Abs;
% Add = /Int/Int%.Add;
% Sub = /Int/Int%.Sub;
% Neg = /Int/Int%.Neg;
% Mul = /Int/Int%.Mul;
% Int = /Int/Int/Lit%.Int;
% Le = /Int/Int/Eq%.Le;
% Lt = /Int/Int/Eq%.Lt;
% Div = /Int/Int/Div%.Div;
% Mod = /Int/Int/Div%.Mod;
% Range = /Int/Int/Iter%.Range;

# Point --
#   Draw a point.
(Point@, Color@) { Drawing@; }
Point = (Point@ point, Color@ color) {
  Rect(point.x, point.y, Int|1, Int|1, color);
};

# DivR --
#   Division with rounding.
#
# Does a/b, rounding to the nearest whole number.
# Assumes both a and b are non-negative.
(Int@, Int@) { Int@; } DivR = (Int@ a, Int@ b) {
  Int@ q = Div(a, b);
  Int@ r = Mod(a, b);
  Int@ p = Div(b, Int|2);
  Le(r, p).?(true: q);
  Add(Int|1, q);
};

# LineX --
#   Draw a line from the origin to (x, y) by putting a pixel at every x
#   coordinate. x and y are assumed to be non-negative.
(Int@, Int@, Color@) { Drawing@; }
LineX = (Int@ x, Int@ y, Color@ color) {
  x.?(0: Point(Point@(Int|0, Int|0), color));

  /Iter%.For<Int@, Drawing@>(Range(Int|0, Add(Int|1, x)), Blank,
    (Int@ xi, Drawing@ d) {
      Int@ yi = DivR(Mul(xi, y), x);
      Over(d, Point(Point@(xi, yi), color));
    });
};

# LineY --
#   Draw a line from the origin to (x, y) by putting a pixel at every y
#   coordinate. x and y are assumed to be non-negative.
(Int@, Int@, Color@) { Drawing@; }
LineY = (Int@ x, Int@ y, Color@ color) {
  y.?(0: Point(Point@(Int|0, Int|0), color));

  /Iter%.For<Int@, Drawing@>(Range(Int|0, Add(Int|1, y)), Blank,
    (Int@ yi, Drawing@ d) {
      Int@ xi = DivR(Mul(x, yi), y);
      Over(d, Point(Point@(xi, yi), color));
    });
};

# Line --
#   Draw a line from point a to point b.
(Point@, Point@, Color@) { Drawing@; }
Line = (Point@ a, Point@ b, Color@ color) {
  % s = @(dx: Sub(b.x, a.x), dy: Sub(b.y, a.y), ax: Int|1, ay: Int|1);

  % s_ = {
    Lt(s.dx, Int|0).?(true: {
      @(dx: Neg(s.dx), dy: s.dy, ax: Neg(s.ax), ay: s.ay);
    });
    s;
  };
  % s = s_;

  % s_ = {
    Lt(s.dy, Int|0).?(true: {
      @(dx: s.dx, dy: Neg(s.dy), ax: s.ax, ay: Neg(s.ay));
    });
    s;
  };
  % s = s_;

  % LineF = Lt(Abs(s.dx), Abs(s.dy)).?(true: LineY, false: LineX);
  Translate(a.x, a.y,
    Affine(Point@(s.ax, s.ay), Point@(Int|0, Int|0), LineF(s.dx, s.dy, color)));
};

@(Point@, Point, Line);
