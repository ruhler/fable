
@ Bool@ = /Bool%.Bool@;
% And = /Bool%.And;
% Not = /Bool%.Not;

@ Drawing@ = /Drawing%.Drawing@;
@ Color@ = /Drawing%.Color@;
@ Point@ = /Drawing%.Point@;
% Blank = /Drawing%.Blank;
% Over = /Drawing%.Over;

@ Vec@ = /Graphics/3D%.Vec@;

@ Camera@ = /Graphics/Camera%.Camera@;
% Perspective = /Graphics/Camera%.Perspective;

@ Int@ = /Int/Int%.Int@;
% Add = /Int/Int%.Add;
% Mul = /Int/Int%.Mul;
% Le = /Int/Int/Eq%.Le;
% Gt = /Int/Int/Eq%.Gt;
% Ge = /Int/Int/Eq%.Ge;
% Int = /Int/Int/Lit%.Int;

# Draw@ --
#   A function to draw a triangle in 3D.
@ Draw@ = (Camera@, Vec@, Vec@, Vec@, Color@) { Drawing@; };

# Clipped --
#   Draw an already clipped triangle.
Draw@ Clipped = (Camera@ camera, Vec@ a, Vec@ b, Vec@ c, Color@ color) {
  Point@ a_ = Perspective(camera, a);
  Point@ b_ = Perspective(camera, b);
  Point@ c_ = Perspective(camera, c);
  /Graphics/2D%.Triangle(a_, b_, c_, color);
};

# RightOf --
#   Returns true if the point (ax, ay) is to the right of the point (bx, by),
#   or if it is aligned with point (bx, by).
(Int@, Int@, Int@, Int@) { Bool@; }
RightOf = (Int@ ax, Int@ ay, Int@ bx, Int@ by) {
  Ge(Mul(ax, by), Mul(bx, ay));
};

# LeftOf --
#   Returns true if the point (ax, ay) is to the left of the point (bx, by),
#   or if it is aligned with point (bx, by).
(Int@, Int@, Int@, Int@) { Bool@; }
LeftOf = (Int@ ax, Int@ ay, Int@ bx, Int@ by) {
  Le(Mul(ax, by), Mul(bx, ay));
};

@ Sorted@ = *(Vec@ a, Vec@ b, Vec@ c);

# Sort --
#   Sort three vectors based on the predicate p.
#
# Vectors satisfying the predicate are moved to the front and vectors not
# satisfying the predicate are moved to the back. The relative order of points
# is kept in tact to preserve clockwise/counterclockwiseness of the points.
((Vec@) { Bool@; }, Vec@, Vec@, Vec@) { Sorted@; }
Sort = ((Vec@) { Bool@; } p, Vec@ a, Vec@ b, Vec@ c) {
  And(Not(p(a)), p(b)).?(true: @(a: b, b: c, c: a));
  And(Not(p(b)), p(c)).?(true: @(a: c, b: a, c: b));
  @(a, b, c);
};

# IntersectX --
#   Returns the point at the intersection of a plane parallel to the Y axis
#   going through points (0, *, 0) and (x, *, z) with the line going through
#   points a and b. Behavior is undefined if no such point exists.
(Int@, Int@, Vec@, Vec@) { Vec@; }
IntersectX = (Int@ x, Int@ z, Vec@ a, Vec@ b) {
  # TODO: Implement me.
  b;
};

# IntersectY --
#   Returns the point at the intersection of a plane parallel to the X axis
#   going through points (*, 0, 0) and (*, y, z) with the line going through
#   points a and b. Behavior is undefined if no such point exists.
(Int@, Int@, Vec@, Vec@) { Vec@; }
IntersectY = (Int@ x, Int@ z, Vec@ a, Vec@ b) {
  # TODO: Implement me.
  b;
};

# ClipLeft --
#   Draw a triangle after clipping any bits too far to the left for the camera
#   to see.
(Draw@) { Draw@; } ClipLeft = (Draw@ draw) {
  (Camera@ camera, Vec@ a, Vec@ b, Vec@ c, Color@ color) {
    (Vec@) { Bool@; } in_bounds = (Vec@ v) {
      RightOf(v.x, v.z, camera.clip.x, camera.focus);
    };

    % s = Sort(in_bounds, a, b, c);
    Vec@ a = s.a;
    Vec@ b = s.b;
    Vec@ c = s.c;

    in_bounds(c).?(true: {
      # All three points are in bounds. Nothing to clip.
      draw(camera, a, b, c, color);
    });

    in_bounds(b).?(true: {
      # Point c is out of bounds. We need to clip a corner of the triangle.
      Vec@ ca = IntersectX(camera.clip.x, camera.focus, c, a);
      Vec@ cb = IntersectX(camera.clip.x, camera.focus, c, b);
      Over(
        draw(camera, a, b, cb, color),
        draw(camera, a, cb, ca, color));
    });

    in_bounds(a).?(true: {
      # Points b and c are out of bounds. We need to clip a side of the
      # triangle.
      Vec@ ab = IntersectX(camera.clip.x, camera.focus, a, b);
      Vec@ ac = IntersectX(camera.clip.x, camera.focus, a, c);
      draw(camera, a, ab, ac, color);
    });

    # None of the points are in bounds. Nothing to draw.
    Blank;
  };
};

# ClipRight --
#   Draw a triangle after clipping any bits too far to the right for the camera
#   to see.
(Draw@) { Draw@; } ClipRight = (Draw@ draw) {
  (Camera@ camera, Vec@ a, Vec@ b, Vec@ c, Color@ color) {
    Int@ xmax = Add(camera.clip.x, camera.clip.w);

    (Vec@) { Bool@; } in_bounds = (Vec@ v) {
      LeftOf(v.x, v.z, xmax, camera.focus);
    };

    % s = Sort(in_bounds, a, b, c);
    Vec@ a = s.a;
    Vec@ b = s.b;
    Vec@ c = s.c;

    in_bounds(c).?(true: {
      # All three points are in bounds. Nothing to clip.
      draw(camera, a, b, c, color);
    });

    in_bounds(b).?(true: {
      # Point c is out of bounds. We need to clip a corner of the triangle.
      Vec@ ca = IntersectX(xmax, camera.focus, c, a);
      Vec@ cb = IntersectX(xmax, camera.focus, c, b);
      Over(
        draw(camera, a, b, cb, color),
        draw(camera, a, cb, ca, color));
    });

    in_bounds(a).?(true: {
      # Points b and c are out of bounds. We need to clip a side of the
      # triangle.
      Vec@ ab = IntersectX(xmax, camera.focus, a, b);
      Vec@ ac = IntersectX(xmax, camera.focus, a, c);
      draw(camera, a, ab, ac, color);
    });

    # None of the points are in bounds. Nothing to draw.
    Blank;
  };
};

# ClipTop --
#   Draw a triangle after clipping any bits too far to the top for the camera
#   to see.
(Draw@) { Draw@; } ClipTop = (Draw@ draw) {
  (Camera@ camera, Vec@ a, Vec@ b, Vec@ c, Color@ color) {
    Int@ ymax = Add(camera.clip.y, camera.clip.h);

    (Vec@) { Bool@; } in_bounds = (Vec@ v) {
      LeftOf(v.y, v.z, ymax, camera.focus);
    };

    % s = Sort(in_bounds, a, b, c);
    Vec@ a = s.a;
    Vec@ b = s.b;
    Vec@ c = s.c;

    in_bounds(c).?(true: {
      # All three points are in bounds. Nothing to clip.
      draw(camera, a, b, c, color);
    });

    in_bounds(b).?(true: {
      # Point c is out of bounds. We need to clip a corner of the triangle.
      Vec@ ca = IntersectY(ymax, camera.focus, c, a);
      Vec@ cb = IntersectY(ymax, camera.focus, c, b);
      Over(
        draw(camera, a, b, cb, color),
        draw(camera, a, cb, ca, color));
    });

    in_bounds(a).?(true: {
      # Points b and c are out of bounds. We need to clip a side of the
      # triangle.
      Vec@ ab = IntersectY(ymax, camera.focus, a, b);
      Vec@ ac = IntersectY(ymax, camera.focus, a, c);
      draw(camera, a, ab, ac, color);
    });

    # None of the points are in bounds. Nothing to draw.
    Blank;
  };
};

# ClipBottom --
#   Draw a triangle after clipping any bits too far to the bottom for the
#   camera to see.
(Draw@) { Draw@; } ClipBottom = (Draw@ draw) {
  (Camera@ camera, Vec@ a, Vec@ b, Vec@ c, Color@ color) {
    (Vec@) { Bool@; } in_bounds = (Vec@ v) {
      RightOf(v.y, v.z, camera.clip.y, camera.focus);
    };

    % s = Sort(in_bounds, a, b, c);
    Vec@ a = s.a;
    Vec@ b = s.b;
    Vec@ c = s.c;

    in_bounds(c).?(true: {
      # All three points are in bounds. Nothing to clip.
      draw(camera, a, b, c, color);
    });

    in_bounds(b).?(true: {
      # Point c is out of bounds. We need to clip a corner of the triangle.
      Vec@ ca = IntersectY(camera.clip.y, camera.focus, c, a);
      Vec@ cb = IntersectY(camera.clip.y, camera.focus, c, b);
      Over(
        draw(camera, a, b, cb, color),
        draw(camera, a, cb, ca, color));
    });

    in_bounds(a).?(true: {
      # Points b and c are out of bounds. We need to clip a side of the
      # triangle.
      Vec@ ab = IntersectY(camera.clip.y, camera.focus, a, b);
      Vec@ ac = IntersectY(camera.clip.y, camera.focus, a, c);
      draw(camera, a, ab, ac, color);
    });

    # None of the points are in bounds. Nothing to draw.
    Blank;
  };
};

# ClipBehind --
#   Draw a triangle after clipping any bits behind the camera.
#
# TODO: This shouldn't be needed once the other clipping functions are
# implemented, right?
(Draw@) { Draw@; } ClipBehind = (Draw@ draw) {
  (Vec@) { Bool@; } ZGt0 = (Vec@ p) { Gt(p.z, Int|0); };
  (Camera@ camera, Vec@ a, Vec@ b, Vec@ c, Color@ color) {
    # Rotate the points [a, b, c] such that any points behind the camera are at
    # the end of the list [a, b, c].
    % l = Sort(ZGt0, a, b, c);
    Vec@ a = l.a; Vec@ b = l.b; Vec@ c = l.c;

    # Only draw the triangle if all points are in front of the camera for now.
    Le(c.z, Int|0).?(true: Blank);
    draw(camera, a, b, c, color);
  };
};

# Triangle --
#   Draw a triangle from the point of view of a camera.
#
# The input points should all be from calling /Graphics/Camera%.Vertex with
# the same camera.  That is, the input points are relative to the position and
# orientation of the camera.
(Camera@, Vec@, Vec@, Vec@, Color@) { Drawing@; }
Triangle = {
  ClipBehind(ClipTop(ClipLeft(ClipRight(ClipBottom(Clipped)))));
};

@(Triangle);
