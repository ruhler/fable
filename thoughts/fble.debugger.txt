Fble Debugger
=============
Features:
 - Set a breakpoint at a line in a file.
 - Step through code line by line.
 - Evaluate expressions in the context of the current scope and print the
   results.
 - Auto breakpoint at undefined behavior?
 - Any way we could do this just by using dwarf + gdb?

Times in the past I wished I have an fble debugger:
 - Debug why sudoku solver isn't working properly by stepping through a line
   at a time and printing intermediate values.

   Turns out it wasn't too hard to figure out the problem in this case without
   a debugger.

 - Debug why snake AI wasn't working.

   It turns out we were using the wrong direction. A debugger to step through
   code and print variable values would have found this more quickly than my
   guess and check approach, which was pretty tedious.

 - Debug why sat solver test is failing.
   Manual code inspection doesn't reveal the issue. I really want to trace the
   code to see which unexpected branch is being taken.

   Manually tracing through the code by profiling block led straight to the
   problem: bad implementation of boolean Eq.

 - Debug why List Eq test is failing. I want to step through again.
   Sigh. I definitely need a debugger.

   Turns out False was being defined as True instead of False. I figured that
   out by changing the body of ListEq to always return False and being
   surprised when the result was as if it returned True.

 - Debug why map equality is failing when show shows identical maps
   { (1,1) => 1; } vs. { (1,1) => 1; }

   Turns out it was a bug in map quality, not too hard to find by code
   inspection.

 - Debug where we're getting stuck in an infinite recursion in fble that
   exhibits as a fast memory leak followed by OOM kill.

   This turned out to be big memory use, not infinite recursion. I tracked it
   down by minimizing the test case enough to run it to completion, and using
   profiling to see how many times different functions were being called.

 - Debug wrong tag in fble tests, where the invariants for what the tag should
   be are a bit complicated.
   
   Ideally we can run until we hit the error, then get a stack trace in the
   debugger and have a way to look at local variables and the stack trace to
   figure out where things are going wrong.

   Turned out to be a flaw in the code. Identified by minimizing the test case
   and working out the issue on paper. It would have been much easier if I
   could have stepped through the code and printed values of local variables
   along the way.

 - Debug why drawing a line from (0, 0) to (-2, -2) actually draws a line from
   (-1, -1) to (-3, -3), ideally by stepping through the code and viewing
   local variables at each step.
 
---

It doesn't look like gdb can easily support languages that are far different
from C. Perhaps it's worth trying to develop a custom debugger for fble. I can
avoid any overhead/dependency on gdb that way. But it also means I have to
implement the entire thing myself.

There are guides online for how to add a new language to gdb, which requires
modifying the gdb source code. That includes ways to specify how to print
types and expressions and how to parse types and expressions.

Could we use dwarf to pretend we are executing C code, and encode structs and
unions in a way that gdb can understand? Then at least for structs we could
see all the fields, and for unions, perhaps we could see the names of tag?
That's about as good as we could do anyway, right?

Dealing with the stack will be challenging, given tail calls and the fact that
the stack is managed. Perhaps it would be simpler if I finish implementing my
plan to use native stacks. Or perhaps not.

I'm thinking it is at least worth a try to emit dwarf information. In that
process I'll see what we can encode in dwarf and how, and how useful gdb is in
that case.

Let's go a ways down this route and see where we get. Initial goals:
* Be able to set break points and step through .fble files.
* Be able to print data type values as structs/unions based on variables on
  the stack.

Don't worry about stack traces yet. And let's focus on debugging compiled
code, which I suspect would be easier.

What happens today if we try to run a compiled program and set a breakpoint
based on an fble source file and line number? It says no such source file.

The first step, then, should be to see how we can get my .fble files included
in the list from 'info sources'. Let's download the dwarf spec and see how
to start with that.

