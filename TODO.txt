
* Clean up fble test framework
 - Define Test function that takes CharLit and start using it.
 - Use AssertEquals for more of the tests.
 - Print out total tests passed, failed, and run in RunTest.
 - Separate Test tests out into separate module and properly test the test
   infra.

* Figure out why we need an extra print in RunTest.
 Does the program end before we have a chance to put all the output?

* Figure out memory leak when 3 Bool Or tests were set to failing.

* Add more Sat tests.

* Fix failing sat solver test.

* Improve type error in case of this?
  <@ T@>{ Maybe@<T@>; } Nothing = <@ T@> { Maybe@<T@>(nothing: Unit@()); };
  True.?(true: Nothing<Bool@>, false: True);

  We get: expected type <@ T@> { Maybe@<T@>; }<Bool@>
  Should we instead get: expected type Maybe@<Bool@>? 

* Make VLIW like instructions to reduce overhead of dispatching instructions?
 - RETURN + RELEASES
 - CALL + RELEASES
 - REF_VALS 
 - REF_DEFS

* Store function pointer in FbleInstr instead of tag
 - Requires we also store functions for disassembly, abort and freeing of
   instructions.

* Pull out definition of architectural state and instruction functions.
 - Would be nice to separate them from the evaluator I think.

* Avoid setting local values to NULL when done?
 - It helps debugging, but otherwise we shouldn't rely on it?
 - Note, we should still set local values to NULL when aborting, so that when
   we release those NULL values, we aren't releasing garbage.

* Add some conditional instructions for retain and release of values
  Instead of doing things conditionally in return and tail call instructions?
 - allows us to take advantage of static info about whether a value is a
   static or an arg or a local.
 - but increases number of generated instructions. It seems like, performance
   wise, the bigger the individual instructions the better.

* Should 'exec' be a flag passed to compile expression?
 That way we could distinguish between normal let and exec let while reusing a
 lot of the same code: change the body from CompileExpr to CompileExec.
 Otherwise we create a process function only to immediately apply it, when we
 could inline the body of the process directly.
 - I would guess this is low impact to performance, given how rarely we do let
   of process inside a process?

* Allow the lifetime of a value to depend on the lifetime of another value.
 - Track lifetimes statically. Lazily retain a value only if and when its
   previous retainer is released.
 - Don't assume all locals are NULL in replace frame?
 - I fear we don't clearly track locals across case branches, which could lead
   to bugs. Perhaps have the concept of reserving the result local, and
   require all expressions to leave the locals unchanged except
   for possibly using the reserved result local?

* Consider dynamically tracking whether returned value is retained by args
  or not.
 - If returned value is retained by args, lazily retain the returned value only
   if and when one of the corresponding args is released.

* Should we do function inlining in the compiler?
 - At least when the function being called is known and the call is not behind
   a condition?
 - How to make the tradeoff between runtime performance and program size?

* Distinguish between RELEASE_VALUE_INSTR and RELEASE_ARG_INSTR?
  Because we can do the check of release->value >= stack->func->argc
  statically? Or is it as expensive to add another instruction as it is to
  check if the value is an arg or not?

* Should we avoid capturing an unused 'type' as a static?
  For example, if we have Unit@() in a function body.
  Proposal: whenever we look up a variable, if the kind is a type kind, return
  a special FBLE_TYPE_VAR type and don't mark the variable as accessed.
  Eliminate all let bindings of type kind.

  The trouble is:
  - This is such a small fraction of runtime, I don't expect any significant
    performance improvement in practice.
  - It feels sketchy to me to remove code that could contain errors. For
    example: ??? is there an example?

* Consistently document ownership of args to functions?
 Borrowed: no transfer of ownership.
 Consumed: ownership transferred from caller to callee.
 Outlives: caller responsible for keeping alive as long as returned result is.

* Move FblePrintName and FbleNamesEqual to fble-name.h?
  The question is if they should be public or private.
  If they should be private, they should go into name.h rather than syntax.h,
  right?

* We don't get a warning about an unused self recursive function.
  More generally, we don't get warnings about variables that are referenced
  only by unused variables.

* Fix broken vacuous_value test.
 - is this feasible to fix, now that we no longer allow errors in compile.c? 
 - is this feasible to fix in general? Try adding a more complicated test
   where we define a function and apply it to get a vacuous value?
 - Make the test more obviously failing, by trying to use the resulting value?

* Add coverage for parse destructors
 - names, module_ref, kinds, tagged_kinds, tagged_type, tagged_expr

* Move implementations corresponding to fble-name.h to name.c?

* [eval] Would it improve performance to merge statics into the locals array?
  We don't have to own them. Just copy them all over when we push a frame.
  Then we avoid the need to switch when looking up a value, and we can store a
  frame index in a single word. FrameGet goes away.

* [eval] Have option to turn off checking for nulls and other runtime errors?

* Clean up how we track io activity?

* [profile] Remove special block 0
 - Add block data at the profile level representing 'total' and special case
   that way instead. So that literally it is impossible for anyone to call
   into the root block except via new profile thread.
 - Except... does that make for lots of messy special casing?

* [profile] Cleanup
 - Switch to convention that caller is responsible for enter block?
 - Replace AutoExitBlock with ReplaceBlock?

* [type] Inline fields and args data into FbleType objects?

* [gc] Implement generational gc?
 - Low priority, because experiments suggest at best we save like, 8 seconds
   on fble bench.

* [eval] Thread management cleanup
 - Use fair thread traversal by starting over from root when yield occurs.

* [app] Change App% back to drawing over the previous screen?
 - It can figure out how to double buffer appropriately on the implementation
   side, for example by drawing the last two updates to the buffer.
 - Because presumably, if not much has changed, that can be much more
   efficient? And if a lot has changed, we can optimize 'Over' to throw away
   the previous frame entirely if you start with a blank screen?

   Maybe more accurate is, if your point of view isn't changing, delta is
   better. If your point of view is changing, you probably have to redraw
   everything regardless and it would be nice to avoid drawing a bunch of
   stuff and then covering it up right away.

* [invaders] Implement space invaders game.
 - Add aliens to the game.

* [compile] Figure out why Normal is called so often
 - See if we can fix that to reduce the now annoyingly long compile times.
 - Profiling said its all in TypeEquals. Maybe something pathological?

* [cc] Implement .fble -> .o compiler
 - Goal is to significantly increase performance by removing the instruction
   fetch decode logic.

* [snake] Switch to a target 60 FPS?
* [snake] Test and fix bug when snake eats its tail.
* [snake] Ignore moves that aren't orthogonal to current snake direction.
* [snake] Keep track of and report score.
* [snake] Figure out why the background box gets lost some times.
* [pingpong] Render a static 3D table tennis scene.
* [gameoflife] Switch to a target 60 FPS?
* [invaders] Optimize space invaders game.
 - Figure out how I'm going to get to 60 FPS.
   Maybe try getting 60 FPS on the C implementation to see if it's reasonable?
 - Implement and test Alien simulation

* [lib] Add test coverage for the Int routines.
 - In particular, test Div and Mod.
* [lib] Separate Map from DataMap and EqMap.
* [lib] Add unit tests for /Map%.Equals.
* [lib] Separate List@ from S@ and P@ module wise.

* [api] Can fble-stdio check that the function has the right type?

* [compile] Test and fix error message for type of anonymous type let values.
 - The type should be the computed type for the value, not the introduced
   abstract type?

* [eval] Make child thread execution fair.
  Children should be time multiplexed, where priority is assigned based on how
  far down the family tree the child belongs. The amount of time a family gets
  to spend evaluating should be independent of the number of children in the
  family.

* [lang] Add support for abstract types?
* [lang] Document the runtime memory model,
  - Including that tail recursive functions should not smash the stack.
* [lang] Document and test that put ports don't retain link values.

* [release] Better error messages on types that have the same name but different values?
* [release] Write man pages for fble and friends?
* [release] Better error message for importing something from a module that
  is not defined in the module?

* [debugger] Implement an fble debugger. Features:
 - Set a breakpoint at a line in a file.
 - Step through code line by line.
 - Evaluate expressions in the context of the current scope and print the
   results.
 - Auto breakpoint at undefined behavior?
 - Any way we could do this just by using dwarf + gdb?
 
 Use cases:
 - Debug why sudoku solver isn't working properly by stepping through a line
   at a time and printing intermediate values.

   Turns out it wasn't too hard to figure out the problem in this case without
   a debugger.

 - Debug why snake AI wasn't working.

   It turns out we were using the wrong direction. A debugger to step through
   code and print variable values would have found this more quickly than my
   guess and check approach, which was pretty tedious.

 - Debug why sat solver test is failing.
   Manual code inspection doesn't reveal the issue. I really want to trace the
   code to see which unexpected branch is being taken.

   Manually tracing through the code by profiling block led straight to the
   problem: bad implementation of boolean Eq.

