Revisiting Fble Profiling
=========================
For two reasons:
1. We've hit the bug where we say AUTO_EXIT, but fail to do an ENTER right
after that, which messes up the stack and is producing bad profile data.

In this case because we do a tail call of a PUT value, and the PUT function
doesn't do a profile ENTER.

More generally, I've known that AUTO_EXIT is dangerous for a while and that we
should switch to REPLACE. Maybe now's the time to figure that out.

2. We ought to support profiling with compiled code. So that we can get rid of
the interpreter entirely if we want, and because we just ought to.

Let's start with (1).

To be clear about the bug, we have the following call structure:

R calls A
  A calls B
    B tail calls C
  A calls D

So the profile should say:
  R called A
  A called B, D
  B called C

Normally this is done as:

(init)              R
ENTER_A             R->A
ENTER B             R->A->B
AUTO_EXIT (B)       R->A->B
ENTER C             R->A->B->C
EXIT (C)            R->A
ENTER D             R->A->D
EXIT (D)            R->A
EXIT (A)            R

But in this case we don't have the ENTER C or EXIT (C). So instead we get:

(init)              R
ENTER_A             R->A
ENTER B             R->A->B
AUTO_EXIT (B)       R->A->B
ENTER D             R->A->B->D
EXIT (D)            R->A
EXIT (A)            R

And now it looks like B called D, when it did not.

The proposed fix is to replace AUTO_EXIT with REPLACE:

(init)              R
ENTER_A             R->A
ENTER B             R->A->B
REPLACE C           R->A(->B)->C
EXIT (C)            R->A
ENTER D             R->A->D
EXIT (D)            R->A
EXIT (A)            R

But that requires more coordination between B and C than we currently have
infrastructure for in the fble ISA. IN particular, B has to say if it's a tail
call or not, and C has to say what block is being called into.

---

I bet we've been running into this profiling issue unnoticed for a while now.

There are two places we use AUTO_EXIT in practice:
1. For exiting select expressions, where we know (by assumption between
compile.c and typecheck.c) that we will do an ENTER/EXIT around each branch.

2. For tail calls, where we don't know what function will be called, but we
assume (incorrectly) that the function will start with an ENTER call.

Regardless of whether we use AUTO_EXIT or REPLACE, it seems like we have to
require every function to have a profiling block associated with it. The
function we call has to mark when it exits, otherwise we can't properly track
instructions executed by the function. Unless we assume there will be no
samples in the body of the function?

The tricky part about this is how do we know what profiling block ID to use
for PUT and GET values, given those function's were not generated by the
compiler? More generally, how to handle any user constructed functions, where,
once again, the compiler didn't generate the function, so we don't know what
block ID to use for it?

Note that blocks are uniquely determined by name and location (because the
user couldn't tell the difference otherwise). Name alone is not enough. I see
in practice we have some blocks with the same names. May or may not be a bug,
but it doesn't seem unreasonable to have two blocks with the same name in
general.

I feel like we ought to just have every FbleExecutable* have a profile block
id associated with it. When you call it, that enters the profile block. When
you return from it, that exits the profile block. The executable can do it's
own enter/exit inside that if it wants to, the caller need not care.

For PUT and GET functions, it would be great for the profile block to be named
and located based on the link where they are declared. How about we require
the user to pass a block ID as input to FbleNewGetValue and
FbleNewPutValue?

For profiling with compilation, how about we say block ids in generated code
are relative to the FbleExecutable block, and we reserve the FbleExecutable
block id when we allocate the (top level) FbleExecutable. Perhaps an
FbleExecutable keeps track of how many profile block ids it wants.

Maybe we shouldn't be reallocating FbleExecutable for every new function in
the generated code...

That all sounds reasonable and doable to me. Add Profile as an argument to the
compiler generated linking function so we can add profiling block info then.

Is there any way we could turn off profiling for a function? Like have a
special profile ID that means: don't take stats on this transition, just keep
proper track of the stack. Then you could always use the special profile ID if
you don't want to support profiling. That would allow you to mix profiling
code with non-profiling code. And then we could make GET and PUT functions
non-profiling code to start. Which probably makes the most sense for them
anyway.

The last bit needed for profiling compiled code is a reasonably efficient way
to sample. In the interpreter we randomly sample about 0.1% of the time on
every instruction. Could we group instructions together somehow so we only
have to sample when we come into an instruction? But what if there are
multiple ENTER/EXITs in a block?

I suppose we could just emit a call to a Sample function before each
instruction, and worry about optimizing later. Yeah. That sounds good.

I wonder if this notion of a phantom block ID could be an easy fix for the
AUTO_EXIT issue? No. We would need a phantom EXIT call that corresponds to a
phantom REPLACE call, and that's what we are missing today.

---

How do we get to the end target?

End target:
* BlockId for each FbleExecutable.
* Call, TailCall do implicit ENTER, REPLACE.
* Return does implicit EXIT.
* May as well make the profiling ops into instructions instead of separate
  ops.
* Profile loaded as part of loading compiled code.
* Replace instead of AutoExit in profiling API.
* FbleExecutable block id relative block ids.
* PUT/GET block ID comes from Link instruction.
* Phantom block ID?

Certainly there are some parts of this I can do separately and incrementally.
For example:
* We can add an FbleProfileReplaceBlock function to wrap AutoExit + Enter.
 - And maybe figure out how to use that for union select?
* We can add PUT/GET block IDs from the instruction.
* We could turn PROFILE_OPs into FbleInstrs.

But the big one that sounds hard is requiring all FbleExecutable to have block
IDs and making other block id references relative to those block ids.

---

While I'm at it, perhaps I should clean up handling of profiling in
typecheck.c versus compile.c? I feel like typecheck.c has the job of giving
labels and locations for those expressions we want to wrap in profiling blocks
while compile has the job of actually emitting the profiling ops. Might work
better if the two were coordinated. For example, build profiling into to the
FbleTc data type: typecheck.c populates the information needed by the
compiler. Both agree on exactly what gets labelled for profiling. 

And as part of that, consider going through FbleTc to cover what should be
labelled for profiling. Perhaps anywhere we have a multiple sub FbleTc*? That
would give us:
* let bindings (body is default)
* struct args? Is this useful for anything?
* union select choices
* func args? Is this useful? What names to use?
* exec bindings (body is default)

I would say, ditch struct and func args. I don't think those are too useful.
And as long as we have let, you could always wrap it in a variable if you
prefer.

Definitely let bindings. Definitely union select choices, because we want to
know which ones calls and time goes to. And I think exec bindings, for the
benchmark example I ran into above. Nothing else is needed.

In terms of execution:
- top level body
- function body

So the block id for a function will be named after whatever labels
(let/exec/union select) the function value is defined in.

That sounds like a nice place to start to me.

I guess the issue I'm running into with benchmark exec labels missing is
because the labels are for a function returned from another function. We
aren't defining a new function (or process), so we don't get a new name.
Hopefully, if we at least add labels for exec bindings and make sure to wrap
them in Enter/Exit blocks in compile.c, then we'll see the exec binding
labelled block calling into whatever that function being returned was.

---

Now that we support modular profiling, the question becomes: how do we link
custom profiling block info into the overall profile? If we use the value of a
profile block name to identify the name, we could lazily resolve things in the
profile. But that's expensive.

We could pass builtin profiling blocks to the linker that always have the same
known value and use those for put and get and user defined functions?

Or, have the compiler generate blocks in compiled code to pass to put and get.
And for external functions... it's the users job to provide a profile id, and
they can initialize the profile with that. I think that works actually.

In summary:
* We set profile_id as field of a function. This can be different from
  profile_base_id.
* The compiler make sure to generate these for every executable, in place of
  the enter/exit calls currently done at the top level of a function.
* FbleNewPutValue and FbleNewGetValue take the profile id as an argument
  (along with a base id? not sure).
* Users will have to supply their own id profile when creating new functions.
  They can allocate those via the profile before or after linking as desired.
* Function call does an EnterBlock, tail call does a ReplaceBlock, and Return
  does an ExitBlock as part of the semantics of those instructions.

Then we no longer need AutoExitBlock and the profiling issue is solved.

---

How should we label blocks for compiling a top level program? Remember that a
top level program gets turned into:

m1 = <m1%>;
m2 = <m2%>;
...

Where <m1%>, <m2%> are treated as zero argument functions.

But the equals and application are done in the linker. So for each individual
<m%>, we want to return a zero argument function. Seems like a special case
here for profile name?

For a normal function, we have something like
  foo = ...;
  foo(...);

We have two separate profile labels: "foo" is the label covering what runs
when creating the function, "foo!" is the label covering what runs when we
execute the function. That makes a lot of sense.

For a module... there is nothing interesting done when creating its function:
it's just a wrapper around an FbleExecutable. I guess the question is: if we
were consistent, we would have "/foo%!" be the label for running the top level
module and "/foo%" is, conceptually, the time to wrap the executable in a
function. But that happens at link time. It's nicer for a user to see "/foo%"
everywhere rather than "/foo%!" everywhere. Just like how we do things today.

So here's how to transition to a world where every executable has a profile id
with it:
* Add a PushBlock function which does the same as EnterBlock, except it
  doesn't emit the profile op to enter and instead returns the profile block id.
* Change EnterBodyBlock to PushBodyBlock, returning the profile block id
  instead of emitting a profile op.
* Change InitScope to take a profile block id that it enters.

---

All done and fixed. We no longer have AutoExit, so we no longer have to worry
about that bug. And we support profiling with compiled code.

There is perhaps some minor cleanup left around how we disable profiling
cleanly and efficiently.

---

How can we disable profiling cleanly and efficiently?

Current problems:
* It's tedious to enable profiling for compiled code, because you have to
  recompile. It would be a much nicer user experience if you didn't have to
  recompile.
* The code for dealing with profiles is tedious, because you always have to
  check if you have a profile or not. It would be much nicer of the code could
  behave as if there was always a profile, and we had other implicit
  mechanisms to disable profiling.

The only reason to have this conditional behavior is the overheads of
profiling. Let's do some experiments to see what the costs are.

Experiments based on compiled code fble bench. I'm not so concerned about
overheads in interpreted code.

A. Profiling not compiled.
  What we do today for compiled code without the option of profiling. This
  could be thought of as fastest option available today. Though you could
  imagine a more extreme approach where all profiling code is compiled out,
  not just the profiling code in generated c code.

  fble-bench compiled: 4m56s

B. Profiling compiled but not enabled.
  Represents the overhead of unused compiled profiling code.

  fble-bench compiled: 5m12s

C. Profiling compiled and enabled.
  Represents the overhead of doing the actual profiling.

  fble-bench compiled: 8m26s

I really would love to have profiling support always compiled in, just enabled
or disabled at runtime. Then the question we have is: how can we effectively
disable profiling at runtime?

Some options I think:
1. Check a local variable before seeing if we should call into profiling
functions. For example, check profile == NULL before calling
FbleProfileEnterBlock. I think this is the fastest case I could imagine.

2. Check a non-local variable before seeing if we should call into profiling
functions. For example, check profile->enabled before calling
FbleProfileEnterBlock. This has the advantage that we can allocate a profile
always, adding blocks to it. The cost is potentially the extra load.

3. Call into profiling functions, check in there.
I fear the overheads of calling into the profiling functions. This would allow
us to have a much nicer interface though.

Anything else clever we could do?

The assembly code I imagine we want to generate is something where we do a
conditional branch over profiling code, and rely on branch prediction to make
that free. Then we have to avoid the function call wherever possible.

5m12s compared to 4m56s is more than I wanted for the overhead of unused
compiled code. Could we perhaps shrink that by putting conditional calls
around ... hmm... That already has fully conditionalized all the calls for
profiling using a local variable to know if profiling is enabled or not.

If profiling is going to be a compile time decision, why not have all of
profiling be compile time flagged? Then there is even less overhead when
profiling is disabled, and, more importantly, the code for profiling that we
write can assume profiling is enabled.

Taking a peak at the assembly code generated for calls to FbleProfileSample:

    19d4: e59b0014  ldr r0, [fp, #20]      // r0 = thread
    19d8: e2800004  add r0, r0, #4         // r0 = &thread->profile
    19dc: e5901000  ldr r1, [r0]           // r1 = thread->profile
    19e0: e3511000  cmp r1, #0             // thread->profile == NULL
    19e4: 0a00000c  beq 1a1c <_Run_0x17f2844+0x136c>

Well... I suppose there is some opportunity here if we can keep the profile
pointer as a local variable instead of always reading it from thread. But I'm
not convinced tcc would keep it in a register.

Let's try and see. Maybe we can cut that 16s overhead in half. That would be
pretty good, right?

With that change we get, as expected:

    19c4:	e51b0004 	ldr	r0, [fp, #-4]
    19c8:	e3500000 	cmp	r0, #0
    19cc:	0a000008 	beq	19f4 <_Run_0x1763844+0x1344>

Better than nothing. Not as good as if we kept profile in a register, because
then we could avoid the load. But who am I to say if that's a worthwhile use
of the register? Seems a shame to have to occupy a register the entire time
just to turn off profiling.

Now we have:

  fble-bench compiled: 5m04s.

Not bad. We cut the overhead in half, down to 8 seconds.

Could we annotate it somehow to tell tcc to keep it in a register?

No. tcc is ignoring the 'register' attribute, unsurprisingly.

I guess the questions are:
* Is 8s overhead too much for me to always compile in profiling?
* Do I want to try generating, for example, llvm to reduce that 8s to
  hopefully almost nothing?
* Do I want to always do profiling with compile time switch, and just deal
  with the annoyance of having to recompile everything whenever I want to do
  profiling?
* Any way we could get meaningful profiling info out of prof without needing
  to have any builting profiling support?

---

The answer, for now, is to take the 8s hit and always have profiling support
compiled in. 3% overhead is not the bulk of what I need to make fble programs
run efficiently, and there is always opportunity to reduce that overhead or
compile it away in the future. Clean up first, optimize later.

After we get rid of FBLE_ENABLE_PROFILING, we can change the profiling
functions to accept NULL as if it were a valid profile, and experiment with
adding macros to avoid doing the call if the profile is NULL.

