
@ Bool@ = /Bool%.Bool@;
% True = /Bool%.True;
% False = /Bool%.False;

@ Bit@ = /Digits%.Bit@;
% B = /Digits%.Bit;

@ Int@ = /Int/Int%.Int@;
% Add = /Int/Int%.Add;
% Sub = /Int/Int%.Sub;
% Neg = /Int/Int%.Neg;
% 0 = /Int/Int%.0;
% Le = /Int/Int/Eq%.Le;
% Ge = /Int/Int/Eq%.Ge;
% Div = /Int/Int/Div%.Div;

% Int = /Int/Int/Lit%.Int;

<@>@ List@ = /List%.List@;
<@>% Nil = /List%.Nil;
<@>% Cons = /List%.Cons;
<@>% Drop = /List/Length%.Drop;

# Heap@ --
#   A bit-addressable heap of bits.
#
# This should be treated as an opaque type externally.
#
# Fields:
#   m - The size of 'left' and the address of the first value in 'right'.
@ HeapB@ = *(Heap@ left, Int@ m, Heap@ right),
@ Heap@ = +(Bit@ value, HeapB@ binary);

# Addr@ --
#   The address of a bit on the heap.
@ Addr@ = Int@;

# Heap --
#   Create a heap of at least n uninitialized bits.
(Int@) { Heap@; } Heap = (Int@ n) {
  Le(n, Int|1).?(
    true: Heap@(value: B.1),
    false: {
      Int@ m = Div(n, Int|2);
      Heap@(binary: HeapB@(Heap(m), m, Heap(Sub(n, m))));
    });
};

# Read_ --
#   Read n bits from the bit heap starting at the given address.
#
# Prepends the bits to the given list of bits.
# Behavior is undefined if there are't enough bits in the heap to get n.
(Heap@, Addr@, Int@, List@<Bit@>) { List@<Bit@>; }
Read_ = (Heap@ heap, Addr@ addr, Int@ n, List@<Bit@> tail) {
  heap.?(
    value: Le(n, 0).?(
      true: tail,
      false: Cons<Bit@>(heap.value, tail)),
    binary: {
      Int@ m = Add(addr, n);
      Le(m, heap.binary.m).?(
        true: Read_(heap.binary.left, addr, n, tail),
        false: Ge(addr, heap.binary.m).?(
          true: Read_(heap.binary.right, Sub(addr, heap.binary.m), n, tail),
          false: {
            Int@ nl = Sub(heap.binary.m, addr);
            Int@ nr = Sub(n, nl);
            Read_(heap.binary.left, addr, nl,
              Read_(heap.binary.right, Int|0, nr, tail));
          }));
    });
};

# Read --
#   Read n bits from the bit heap starting at the given address.
#
# Behavior is undefined if there are't enough bits in the heap to get n.
(Heap@, Addr@, Int@) { List@<Bit@>; }
Read = (Heap@ heap, Addr@ addr, Int@ n) {
  Read_(heap, addr, n, Nil<Bit@>);
};

# Write --
#   Assign the first n bits at ptr with the value of the given bits.
#
# Returns the updated Heap for ptr after the assignment.
#
# Behavior is undefined if there aren't n bits to assign from or to.
(Heap@, Addr@, List@<Bit@>, Int@) { Heap@; }
Write = (Heap@ heap, Addr@ addr, List@<Bit@> bits, Int@ n) {
  heap.?(
    value: Le(n, 0).?(
      true: heap,
      false: Heap@(value: bits.cons.head)),
    binary: {
      Int@ m = Add(addr, n);
      Le(m, heap.binary.m).?(
        true: {
          Heap@ left = Write(heap.binary.left, addr, bits, n);
          Heap@(binary: HeapB@(left, heap.binary.m, heap.binary.right));
        },
        false: Ge(addr, heap.binary.m).?(
          true: {
            Heap@ right = Write(heap.binary.right, Sub(addr, heap.binary.m), bits, n);
            Heap@(binary: HeapB@(heap.binary.left, heap.binary.m, right));
          },
          false: {
            Int@ nl = Sub(heap.binary.m, addr);
            Int@ nr = Sub(n, nl);
            Heap@ left = Write(heap.binary.left, addr, bits, nl);
            Heap@ right = Write(heap.binary.right, Int|0, Drop<Bit@>(nl, bits), nr);
            Heap@(binary: HeapB@(left, heap.binary.m, right));
          }));
    });
};

# Equals --
#   Return true if the n bits at the given address match the first n given
#   bits.
#
# Behavior is undefined if there aren't enough bits in the heap or list to
# compare.
(Heap@, Addr@, List@<Bit@>, Int@) { Bool@; }
Equals = (Heap@ heap, Addr@ addr, List@<Bit@> bits, Int@ n) {
  n.?(
    p: {
      heap.?(
        value: /Digits/Eq%.EqBit(heap.value, bits.cons.head),
        binary: {
          Int@ dm = Sub(heap.binary.m, addr);
          Int@ nl = dm.?(p: Le(n, dm).?(true: n, false: dm), : Int|0);
          Equals(heap.binary.left, addr, bits, nl).?(
            true: {
              Int@ nr = Sub(n, nl);
              Int@ right_addr = dm.?(p: Int|0, : Neg(dm));
              Equals(heap.binary.right, right_addr, Drop<Bit@>(nl, bits), nr);
            },
            false: False);
        });
    },
    : True);
};

# Copy --
#   Assign the first n bits at ptr with the value of the first n bits from val.
#
# Returns the updated Heap after the assignment.
#
# Behavior is undefined if there aren't n bits to assign from or to.
(Heap@, Addr@, Addr@, Int@) { Heap@; }
Copy = (Heap@ heap, Addr@ dest, Addr@ src, Int@ n) {
  Write(heap, dest, Read(heap, src, n), n);
};

# Equal --
#   Return true if the n bits at a and b are the same.
#
# Behavior is undefined if there aren't n bits in a and b to compare.
(Heap@, Addr@, Addr@, Int@) { Bool@; }
Equal = (Heap@ heap, Addr@ a, Addr@ b, Int@ n) {
  Equals(heap, a, Read(heap, b, n), n);
};

@(Heap@, Addr@, Heap, Read, Write, Copy, Equals, Equal);
