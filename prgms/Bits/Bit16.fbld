
import @ { Bit8M=Bit8; Bit@Bit; Bit1; BitNI; BoolM=Bool@StdLib; };
import Bit8M { Bit8; };

struct Bit16(Bit8 hi, Bit8 lo);

module BitN(BitNI<Bit16>) {
  import @ { Bit16; B = BitN@Bit8M; Bit1; Bit; BoolM; };
  import BoolM { Bool; And; };

  func not(Bit16 a ; Bit16) {
    Bit16(not@B(a.hi), not@B(a.lo));
  };

  func and(Bit16 a, Bit16 b; Bit16) {
    Bit16(and@B(a.hi, b.hi), and@B(a.lo, b.lo));
  };

  func or(Bit16 a, Bit16 b; Bit16) {
    Bit16(or@B(a.hi, b.hi), or@B(a.lo, b.lo));
  };

  func xor(Bit16 a, Bit16 b; Bit16) {
    Bit16(xor@B(a.hi, b.hi), xor@B(a.lo, b.lo));
  };

  func add(Bit16 a, Bit16 b; Bit16) fulladd(a, b, zero@Bit1()).z;

  func zero(; Bit16) {
    Bit16(zero@B(), zero@B());
  };

  func iszero(Bit16 a; Bool) {
     And(iszero@B(a.hi), iszero@B(a.lo));
  };

  func eq(Bit16 a, Bit16 b; Bool) {
     And(eq@B(a.hi, b.hi), eq@B(a.lo, b.lo));
  };

  func clshift(Bit16 a; Bit16) lshift(a, a.hi.7).z;

  struct Result(Bit16 z, Bit cout);

  func fulladd(Bit16 a, Bit16 b, Bit cin; Result) {
    Result@B rlo = fulladd@B(a.lo, b.lo, cin);
    Result@B rhi = fulladd@B(a.hi, b.hi, rlo.cout);
    Result(Bit16(rhi.z, rlo.z), rhi.cout);
  };

  func lshift(Bit16 a, Bit cin; Result) {
    Result@B rlo = lshift@B(a.lo, cin);
    Result@B rhi = lshift@B(a.hi, rlo.cout);
    Result(Bit16(rhi.z, rlo.z), rhi.cout);
  };
};
