
{ /App%; @(App@, Event@, Effect@); };
{ /Bool%; @(Bool@, And, True, False); };
{ /Drawing%; @(Drawing@, Color@, Point@, Rect, Over, Transform); };
{ /GameOfLife%; @(World@, Coord@, World, ForWorld, Step); };
{ /Int/Int%; @(Int@, 0, 1, 2, 3, 4, 5, 6, Add, Mul, Dec, Neg, Sub); };
{ /Int/IntP%; @(IntP@); };
{ /Int/Int/Div%; @(Div); };
{ /Int/Int/Eq%; @(IsZero, Ge, Lt); };
{ /Int/Int/Lit%; @(I, D); };
{ /List%; @(S@, S, S0, ConsS); };
{ /Maybe%; @(Maybe@, Just, Nothing, MapMaybe); };
{ /Process%; @(Get@, Put@); };
{ /Unit%; @(Unit@, Unit); };

(Int@, Int@) { Coord@; } C = (Int@ x, Int@ y) { Coord@(x, y); };

Int@ XMin = Neg(I(D|50));
Int@ XMax = I(D|50);
Int@ YMin = Neg(I(D|50));
Int@ YMax = I(D|50);
Int@ Width = Sub(XMax, XMin);
Int@ Height = Sub(YMax, YMin);

World@ acorn = World([
  C(I(D|0), I(D|1)),

  C(I(D|1), I(D|3)),

  C(I(D|2), I(D|0)),
  C(I(D|2), I(D|1)),
  C(I(D|2), I(D|4)),
  C(I(D|2), I(D|5)),
  C(I(D|2), I(D|6))
]);

(World@) { Drawing@; } DrawWorld = (World@ w) {
  Drawing@ clear = Rect(XMin, YMin, Width, Height, Color@(black: Unit));
    
  # 2. For each live cell in range, draw a green unit square.
  ForWorld<Drawing@>(w, clear, (Coord@ coord, Unit@ _, Drawing@ d) {
    Int@ r = coord.row;
    Int@ c = coord.col;
    ?(And(And(Lt(YMin, r), Lt(XMin, c)),
          And(Lt(r, YMax), Lt(c, XMax)));
       true: Over(d, Rect(c, r, 1, 1, Color@(green: Unit))),
       false: d);
  });
};

@ Input@ = +(Unit@ quit, Unit@ step);

(Get@<Event@>) { Get@<Input@>; } GetInput = (Get@<Event@> in) {
  Event@ e := in;
  ?(e; tick: $(Input@(step: Unit)),
       key: ?(e.key; Q: $(Input@(quit: Unit)), : GetInput(in)));
};

(Get@<Input@>, Put@<Effect@>, Int@, World@) { Unit@!; }
StepUI = (Get@<Input@> in, Put@<Effect@> out, Int@ n, World@ w) {
  Unit@ _ := out(Effect@(draw: DrawWorld(w)));
  Unit@ _ := out(Effect@(tick: I(D|200)));
  Input@ x := in;
  ?(x; quit: $(Unit),
       step: ?(IsZero(n);
                true: $(Unit),
                false: StepUI(in, out, Dec(n), Step(w))));
};

App@ Main = (Int@ width, Int@ height, Get@<Event@> in, Put@<Effect@> out) {
  # Map game coordinates into screen coordinate.
  Int@ ax = Div(width, Width);
  Int@ bx = Div(width, 2);
  Int@ ay = Div(height, Height);
  Int@ by = Div(height, 2);

  (Point@) { Point@; } f = (Point@ p) {
    @(x: Add(Mul(ax, p.x), bx), 
      y: Add(Mul(ay, p.y), by));
  };

  Put@<Effect@> game_out = (Effect@ e) {
    Effect@ transformed = ?(e;
      tick: e,
      draw: Effect@(draw: Transform(f, e.draw)));
    out(transformed);
  };

  Unit@ _ := StepUI(GetInput(in), game_out, I(D|100), acorn);


  Unit@! WaitForKeyPress = {
    Event@ e := in;
    ?(e; tick: WaitForKeyPress, key: $(Unit));
  };
  WaitForKeyPress;
};

Main;
