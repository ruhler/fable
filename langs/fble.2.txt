Fable E
=======
Richard Uhler <ruhler@degralder.com>

1. Introduction
---------------
Fble is a general purpose, Turing-complete functional programming language
with support for polymorphism and concurrent processes.

1.1 Goals
---------
The primary design goals of fble are:

* Fble should be as simple a language as possible while still being useful.
  A simple language should hopefully be simple to specify, simple to learn,
  simple to understand, simple to program, powerful, and low cost to develop
  high quality tools for.

* Fble should support high performance, low overhead computing. This is
  achieved by using a static type system and having a very clear performance
  model that a developer can optimize for.

* Fble should be a joy to program in. It should be easy to describe the
  majority of programs we want to describe, not tediously difficult. To
  accomplish this, fble allows functions to be declared locally with access to
  variables in the context where they are declared, and fble supports
  polymorphic types and functions.

* Fble, or an extension thereof, should support programming at scale. That is,
  namespace control and composition of modules developed by different
  individual developers or organizations.

2. Language Overview
--------------------
The primitive data types of fble are structs, unions, functions, and
processes.

Data values and the expressions that describe them are strongly typed. A
value's type describes the kinds of operations that can legally be performed
on that value. Types are used to check that an fble programs is well formed
statically. Types do not take part in the dynamic execution of an fble program
after it has been statically checked.

Local variables allow data values to be reused throughout a program, including
recursively. Analogously, type variables allow types to be reused throughout a
program and recursively.

Both expressions and types can be polymorphic, which is to say they can be
made abstract with respect to type parameters. To facilitate more advanced use
of polymorphism, types themselves are strongly typed; we call the type of a
type its kind.

3. Structs
----------
A struct value is a grouping of other values. The items of a struct are
organized into a finite number of fields. Each field has a name, used to
identify the field, and a type, specifying the type of value for that field.

Struct values are constructed by supplying values for all fields of the
struct. Individual components of a struct can be accessed by field name.

3.1 Struct Type
---------------
Abstract Syntax:
  Type ::= struct_type (fields :: [(Type, Name)])

Concrete Syntax:
  type ::= '*(' [type name [',' type name [...]]] ')'

Examples:
  *()                 is the Unit type
  *(Int@ x, Int@ y)   is the type of a pair of ints x, y.

Struct types are considered equal if their fields are equal, including field
types, field names, and the order of the fields.

3.2 Struct Value
----------------
Abstract Syntax:
  Expr ::= struct_value (type :: Type) (args :: [Expr])

Concrete Syntax:
  expr ::= type '(' [expr [',' expr [...]]] ')'

Example:
  Coord@(3, 5)

3.3 Struct Access
-----------------
Abstract Syntax:
  Expr ::= struct_access (object :: Expr) (field :: Name)

Concrete Syntax:
  expr '.' name

Example:
  x.first

Returns the value passed to the struct at the corresponding field position
when the struct was constructed.

4. Unions
---------
A union value is a particular value chosen amongst a group of possible values.
The possible choices are organized into a finite number of fields. Each field
has a name, used to identify the field, and a type, specifying the type of
value for that field.

Union values are constructed by supplying a value for a particular field of
the union. The particular value for the union can be accessed by field name,
and the union can be used to select among other values and expressions based
on the field present in the union value.

4.1 Union Type
--------------
Abstract Syntax:
  Type ::= union_type (fields :: [(Type, Name)])

Concrete Syntax:
  type ::= '+(' type name [',' type name [...]] ')'

Example:
  +(Unit@ true, Unit@ false)

Union types are considered equal if their fields are equal, including field
types, field names, and the order of the fields.

4.2 Union Value
---------------
Abstract Syntax:
  Expr ::= union_value (type :: Type) (field :: Name) (arg :: Expr)

Concrete Syntax:
  expr ::= type '(' name ':' expr ')'

Example:
  Maybe@(Just: 3)

4.3 Union Access
----------------
Abstract Syntax:
  Expr ::= union_access (object :: Expr) (field :: Name)

Concrete Syntax:
  expr ::= expr '.' name

Example:
  x.Just

Returns the value passed to the union at the corresponding field position when
the union was constructed. Behavior is undefined if the union tag does not
match the field being accessed.

4.4 Conditional
---------------
Abstract Syntax:
  Expr ::= cond (condition :: Expr) (choices :: [(Name, Expr)])

Concrete Syntax:
  expr ::= '?(' expr ';' name ':' expr [',' name ':' expr [...]] ')'

Example:
  ?(mfoo; Just: mfoo.Just, Nothing: 3)

The condition must have union type. Returns the value of the choice selected
by the tag of the condition, without causing any other choices to be
evaluated.

5. Functions
------------
A function is a mapping from argument values to result value. The arguments
are organized into a finite number of args. Each arg has a name, used to
identify the argument in the body of the function, and a type, specifying the
type of value that can be supplied for that argument. A function has a return
type, specifying the type of value that will result when applying the
function.

Functions are described using the fble expression language. A function can be
applied to a set of arguments of appropriate type to produce a value with the
return type of the function.

5.1 Function Type
-----------------
Abstract Syntax:
  Type ::= func_type (args :: [(Type, Name)]) (return :: Type)

Concrete Syntax:
  type ::= '\(' type name [',' type name [...]] ';' type ')'

Examples:
  \(Int@ a, Int@ b; Bool@)

The function type describes the type of a function value by specifying the
function value's type and name of input arguments and return type.

Function arguments can be structs, unions, functions, or processes.

Two function types are equal if they take the same args and return type, with
possible renaming of argument names. For example, the following two function
types are equal:
  \(Int x; Int)
  \(Int y; Int)

The rationale for including argument names in the function type when they are
not involved in the equality check is because argument names often, but not
always, serve as documentation suggestive to the programmer as to the intent
of when the function should be called.

5.2 Function Value
------------------
Abstract Syntax:
  Expr ::= func_value (args :: [(Type, Name)]) (body :: Expr)

Concrete Syntax:
  expr ::= '\(' type name [',' type name [...]] ')' '{' stmt '}'

Example:
  \(Bool@ a) ?(a; true: False, false: True)

The function value expression is used to describe a primitive function value
given the list of arguments and the body of the function. The return type of
the function is inferred to be the type of the body of the function.

Rationale for Concrete Syntax: The body of the function requires use of braces
to avoid ambiguity that would arise otherwise with an expression such as:

  \(T@ x) f (y)

In this case it isn't clear if the argument 'y' is being applied to the
function \(T@ x) f, or to the function f.

5.3 Application
---------------
Abstract Syntax:
  Expr ::= apply (func :: Expr) (args :: [Expr])

Concrete Syntax:
  expr ::= expr '(' [expr [',' expr [...]]] ')'

Example:
  foo(x, 3)

The application expression is used to apply a function to arguments. Partial
application of arguments are allowed. The supplied arguments must match the
types of arguments specified for the function. If not all arguments are
supplied, the resulting value is a function value parameterized by the
remaining arguments.

If all arguments are supplied, the application expression evaluates to the
value of the body of the function in the context of the supplied arguments.

TODO: Can extra arguments be supplied to a function if the function returns a
function, thus causing the returned function to be called with those extra
arguments supplied as well?

5.4 Bind
--------
Abstract Syntax:
  Expr ::= bind (args :: [(Type, Name)]) (func :: Expr) (body :: Expr)

Concrete Syntax:
  stmt ::= type name [',' type name [...]] '<-' expr ';' stmt

Example
  Int@ x <- map(l); f(x, y)

Bind is syntactic sugar for applying a function to a function value. It is
equivalent to:

  apply func (func_value args body)

6. Local Variables
------------------
Let expressions can be used to define local variables that allow values to be
reused in multiple places in a program. Let expressions support recursive
definitions of variables, which makes it possible to define recursive values.

In the same way, type variables can be defined to allow types to be reused in
multiple places in a program. Recursive definitions of type variables makes it
possible to define recursive types.

Type variables are distinguished syntactically from regular variables by
adding the '@' character as a suffix to the variable name:

6.1 Variable
------------
Abstract Syntax:
  Expr ::= var (name :: Name)

Concrete Syntax:
  expr ::= name

Example:
  x

Expressions are evaluated in a context that maps variable names to values and
the types of those values. The value of the variable expression is the value
associated with the variable name in the context. The type of the variable
expression is the type associated with the variable name in the context.

6.2 Let
-------
Abstract Syntax:
  Expr ::= let (bindings :: [(Type, Name, Expr)]) (body :: Expr)

Concrete Syntax:
  stmt ::= type name '=' expr [',' type name = expr [...]] ';' stmt

Example:
  Int@ x = mul(3, 3); mul(x, x)

The let expression is used to define variables. For each binding, a new
variable is defined. The value of the variable is the result of evaluating the
expression for the variable's binding.

The defined variables are visible in the body of the let expression. To
support self and mutually recursive values, the defined variables
are also visible in all of the bindings expressions.

TODO: Are bindings allowed to defined variables with the same name as
variables already in scope, thus shadowing the variable already in scope?

The value of the let expression is the value of its body.

6.3 Type Variable
-----------------
Abstract Syntax:
  Type ::= type_var (name :: Name)

Concrete Syntax:
  type_name ::= name '@'
  type ::= type_name

Example:
  Int@

Types and expressions are evaluated in a context that maps type variable names
to types and the kinds of those types. The type of the type variable is
the type associated with the type variable name in the context. The kind of
the type variable is the kind associated with the type variable name in the
context.

6.4 Type Let
------------
Abstract Syntax:
  Kind ::= basic_kind
  Type ::= type_let_type (bindings :: [(Kind, Name, Type)]) (body :: Type)
  Expr ::= type_let_expr (bindings :: [(Kind, Name, Type)]) (body :: Expr)

Concrete Syntax:
  kind ::= '@'
  type_stmt ::= kind type_name '=' type [',' kind type_name = type [...]] ';' type_stmt
  stmt ::= kind type_name '=' type [',' kind type_name = type [...]] ';' stmt

Example:
  @ Unit@ = *(); Unit@();
  @ Unit@ = *(); +(Unit@ true, Unit@ false);
  @ P@ = *(Int@ head, S@ tail), @ S@ = +(Unit@ nil, P@ cons); P@(3, S@:nil(Unit@()))

The type let is used to define type variables, when describing either types or
expressions. For each binding, a new type variable is defined. The type of the
type variable is the result of evaluating the type for the variable's binding.

The defined type variables are visible in the body of the let. To support self
and mutually recursive types, the defined type variables are also visible in
all of the bindings expressions.

TODO: Are bindings allowed to defined variables with the same name as
variables already in scope, thus shadowing the variable already in scope?

The value of the type let is the value of its body.

----------

V.4 Process
-----------
A process is a computation with side effects that produces a value. Side
effects take the form of getting and putting values to and from links that can
be accessed by other running processes.

There are primitive processes for getting a value from a link, putting a value
to a link, and creating and using a new link. Processes can be combined by
executing them in parallel and serial.

V.5 Input Port
--------------
An input port is a handle to a link that can be used to get values from
the link. An input port is typed, so that only values of the given type can be
taken from the port.

An input port is created for every link that is created. An input port can be
used as a process that takes a value off its link.

V.6 Output Port
---------------
An output port is a handle to a link that can be used to put values onto the
link. An output port is typed, so that only values of the given type can be
put onto the link.

An output port is created for every link that is created. An output port can
be used as a process that puts a value onto its link.

T.4 Process Type
----------------
Abstract Syntax:
  proc_type (return :: Type)

Concrete Syntax:
  type '!'

Example:
  Int!

T.5 Input Type
--------------
Abstract Syntax:
  input_type (type :: Type)

Concrete Syntax:
  type '-'

Example:
  Int-

T.6 Output Type
---------------
Abstract Syntax:
  output_type (type :: Type)

Concrete Syntax:
  type '+'

Example:
  Int+

E.13 Process Type
-----------------
Abstract Syntax:
  proc_type (return :: Type)

Concrete Syntax:
  type '!'

Example:
  Int!

E.14 Input Type
---------------
Abstract Syntax:
  input_type (type :: Type)

Concrete Syntax:
  type '-'

Example:
  Int-

E.15 Output Type
----------------
Abstract Syntax:
  output_type (type :: Type)

Concrete Syntax:
  type '+'

Example:
  Int+

E.16 Eval
---------
Abstract Syntax:
  eval (expr :: Expr)

Concrete Syntax:
  '$(' expr ')'

Example:
  $(3)

A process that returns the value of expr without performance any other
actions.

E.17 Get
--------
Abstract Syntax:
  get (port :: Expr)

Concrete Syntax:
  expr '()'

Example:
  input()

The port must have type input_type. If the port has type T-, evaluates to a
process value of type T! that gets the next value from the port.

E.18 Put
--------
Abstract Syntax:
  put (port :: Expr) (value :: Expr)

Concrete Syntax:
  expr '(' expr ')'

Example:
  output(3)

The port must have type output_type. If the port has type T+, evaluates to a
process value of type T! that puts the given value onto the port and returns
that same value.

E.19 Link
---------
Abstract Syntax:
  link (type :: Type) (get :: Name) (put :: Name) (body :: Expr)

Concrete Syntax:
  type '~' name ',' name ';' expr

Example:
  Int ~ input, output; f(input, output)

The body must have type process_type. Evaluates to the value of the body with
get and put ports of type type- and type+ respectively added to the context.

E.20 Exec
---------
Abstract Syntax:
  exec (bindings :: [(Type, Name, Expr)]) (body :: Expr)

Concrete Syntax: (* in statement context *)
  type name ':=' expr [',' type name ':=' expr [...]] ';' stmt

Example:
  Int x := getx(), Int y := gety(); $(add(x, y))

Runs each process in parallel, then executes the body with the results of the
processes assigned to variables in scope.

P. Program
----------
A program is an expressions that creates a value that is used however is
deemed suitable by whoever is executing the program. Commonly this could be:

* func value: apply the function to arguments provided on the command line,
  evaluate and output the resulting value
* struct value: evaluate and output the value
* union value: evaluate and output the value
* process value: run the process, evaluate and output the resulting value.

  
Abstract Syntax Reference
-------------------------
Name ::= (* A string of characters *)
Type ::= (* Expr that evaluates to a type value *)

Expr ::=
   var (name :: Name)
 | let (bindings :: [(Type, Name, Expr)]) (body :: Expr)

 | type_type

 | func_type (args :: [(Type, Name)]) (return :: Type)
 | func_value (args :: [(Type, Name)]) (body :: Expr)
 | apply (func :: Expr) (args :: [Expr])

 | struct_type (fields :: [(Type, Name)])
 | struct_value (type :: Type) (args :: [Expr])

 | union_type (fields :: [(Type, Name)])
 | union_value (type :: Type) (field :: Name) (arg :: Expr)

 | access (object :: Expr) (field :: Name)
 | cond (condition :: Expr) (choices :: [(Name, Expr)])

 | proc_type (return :: Type)
 | input_type (type :: Type)
 | output_type (type :: Type)
 | eval (expr :: Expr)
 | get (port :: Expr)
 | put (port :: Expr) (value :: Expr)
 | link (type :: Type) (get :: Name) (put :: Name) (body :: Expr)
 | exec (bindings :: [(Type, Name, Expr)]) (body :: Expr)
 | bind (args :: [(Type, Name)]) (func :: Expr) (body :: Expr)
 ;

Concrete Syntax Reference
-------------------------
name ::= (* [a-zA-Z--9_]+ *)
typename ::= name '@'

kind ::= '@'                                                    (* basic_kind *)
 | '\<' kind typename [',' kind typename [...]] ';' kind '>'    (* poly_kind *)

type ::= 
   '{' type_stmt '}'                                        (* type_stmt *)
 | typename                                                 (* type_var *)
 | '\<' kind typename [',' kind typename [...]] '>' '{' type_stmt '}'  (* poly_type *)
 | type '<' [type [',' type [...]]] '>'                     (* poly_type_apply *)
 | '\(' type name [',' type name [...]] ';' type ')'        (* func_type *)
 | '*(' [type name [',' type name [...]]] ')'               (* struct_type *)
 | '+(' type name [',' type name [...]] ')'                 (* union_type *)
 | type '!'                                                 (* proc_type *)
 | type '-'                                                 (* input_type *)
 | type '+'                                                 (* output_type *)
 ;

type_stmt ::=
   type ';'                                                 (* type *)
 | kind typename '=' type [',' kind typename '=' type [...]] ';' type_stmt      (* let *)
 ;

expr ::=
   '{' stmt '}'                                           (* statement *)
 | name                                                   (* var *)
 | '\<' kind typename [',' kind typename [...]] '>' '{' stmt '}'  (* poly *)
 | expr '<' [type [',' type [...]]] '>'                   (* poly_apply *)
 | '\(' [type name [',' type name [...]]] ')' '{' stmt '}'  (* func_value *)
 | expr '(' [expr [',' expr [...]]] ')'                   (* apply *)
 | type '(' [expr [',' expr [...]]] ')'                   (* struct_value *)
 | type '(' name ':' expr ')'                             (* union_value *)
 | expr '.' name                                          (* _access *)
 | '?(' expr ';' name ':' expr [',' name ':' expr [...]] ')'  (* cond *)
 | '$(' expr ')'                                          (* eval *)
 | expr '()'                                              (* get *)
 | expr '(' expr ')'                                      (* put *)
 ;

stmt ::=
   expr ';'                                                      (* expr *)
 | kind name '@' '=' type [',' kind name '@' '=' type [...]] ';' stmt   (* type_let *)
 | type name '=' expr [',' type name = expr [...]] ';' stmt      (* let *)
 | type '~' name ',' name ';' stmt                               (* link *)
 | type name ':=' expr [',' type name ':=' expr [...]] ';' stmt  (* exec *)
 | type name [',' type name [...]] '<-' expr ';' stmt            (* bind *)
 ;

Notes:
* apply, get, and put share the same form. The type of the expr
  is used to distinguish between the four kinds of expressions.
  
