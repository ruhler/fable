
@ Bool@ = /Bool%.Bool@;
% True = /Bool%.True;
% False = /Bool%.False;
% And = /Bool%.And;
<@>@ Eq@ = /Eq%.Eq@;
<@,@>@ Map@ = /Map%.Map@;
@ Unit@ = /Unit%.Unit@;

# IsEmpty --
#   Returns true if the map is empty.
#
# Type Parameters:
#   K@ - the type of keys in the map.
#   V@ - the type of values in the map.
#
# Inputs:
#   map - the map to test.
#
# Returns:
#   True if the map is empty, false otherwise.
<@ K@, @ V@>(Map@<K@, V@>) { Bool@; } IsEmpty = <@ K@, @ V@>(Map@<K@, V@> map) {
  map.?(empty: True, map: False);
};


# Eq --
#   Implementation of Eq@ for Map@. See documentation of /Eq%.Eq@.
<@ K@, @ V@>(Eq@<V@>) { Eq@<Map@<K@, V@>>; }
Eq = <@ K@, @ V@>(Eq@<V@> eq)(Map@<K@, V@> a, Map@<K@, V@> b) {
  a.?(
    empty: b.?(empty: True, map: False),
    map: b.?(
      empty: False,
      map: {
        Bool@ unit_eq = a.map.unit.?(
          just: b.map.unit.?(
            just: eq(a.map.unit.just.value, b.map.unit.just.value),
            nothing: False),
          nothing: b.map.unit.?(just: False, nothing: True)
        );

        Bool@ sum_eq = And(
          Eq<K@, V@>(eq)(a.map.either.a, b.map.either.a),
          Eq<K@, V@>(eq)(a.map.either.b, b.map.either.b)
        );

        Bool@ pair_eq = 
          Eq<Unit@, Map@<K@, V@>>(
            (Map@<K@, V@> a, Map@<K@, V@> b) {
              Eq<K@, V@>(eq)(a, b);
            })(a.map.pair, b.map.pair);
        And(unit_eq, And(sum_eq, pair_eq));
      }));
};

@(IsEmpty, Eq);
