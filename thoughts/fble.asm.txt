Compiling Fble to Assembly
==========================
The idea of compiling fble to llvm has come up a few times. LLVM seems like a
nice balance between supporting a variety of architectures (arm, arm64, intel,
etc.) and being a low level target. Maybe better to generate LLVM code instead
of C?

Potential advantages:
* We can use something fancier than tcc to compile generated code.
* We have more control over low level code generation, such as storing
  thread->profile in a register to reduce the overhead of disabled profiling.
* We can learn more about llvm, which seems interesting and useful in general.

I don't want to link the llvm libraries, but I would be happy to generate llvm
text IR and have users install and run llc (or whatever) on the result.

First test:
* I expect clang will take too many resources to compile our generated C code.
  Confirm that, then try compiling with clang to llvm text IR and see how much
  time it takes to compile the llvm text IR. Hopefully all the problem with
  clang on the C code goes away by the time we are running llc on the
  generated IR.

---

Results of the first test on /Md5% show that the clang part takes 10s of the
total 2m44s. The llc part takes 1m26s. So, unfortunately, it looks like the
expensive part of using llvm isn't the part we would bypass by generating the
llvm code directly. It takes 3 seconds to assemble the generated .s file.

I don't see any obvious way to make this faster. This is looking to be a
non-starter.

Could I generate arm assembly code directly instead? The main concern with
generating arm code directly is that it limits what platforms we support, but
perhaps there aren't that many to deal with and we could introduce an
abstraction to make it easy to add more?

Let's continue exploring the idea of compiling directly to assembly.

---

Switching from generating C to generating assembly code should be fun. It
gives us an opportunity to improve performance and feels more like a real
language. It's going to be a pain to maintain when I start changing data
structures and I'm going to be unhappy when I try running fble on a different
architecture though. Is it worth it?

For the fun of it and the learning, sure. Why not?

The official justification I can use is something like: gcc and clang cannot
handle the C code I'm generating. That leaves me with just tcc, which we know
produces not great code for a limited number of architectures. I may as well
change that to producing great code for a limited number of architectures.

Now then, where to start?

Concepts to work out how to do:
* Function calls.
* Field access (read and write).
* String literals.
* Loops.
* Switch for pc entry table.

I'm currently running a 32 bit arm OS: armv7l. I suppose we can start there.
First step: figure out how to implement a function:

  int foo(int x) { return x + 1; }

The arm procedure call standard says:
  r15 = pc,
  r14 = lr,
  r13 = sp,
  r12 = ip (intra procedure scratch register),
  r11, r10 = v8, v7,
  r9 = v6, sb, tr,
  r8-r4 = v5-v1,
  r3-r0 = a4-a1 (args/scratch, where r1 and r0 can also be results).

Subroutine must preserve:
 * variable registers: r4-r8, r10, r11, and r9 if used as v6
 * SP

Flags NZCVQ are undefined on entry or return.

Stack is full descending. At interface, it must be 8 byte aligned.

Looks like in my case, int will be returned in r0. And arguments are passed
starting from r0, so all I need to do is increment r0 and return. Something
like:

foo:
  incr r0
  ret
    
Next:
* What is the increment instruction?
  Maybe "add r0, r0, #1"?
* What is the return instruction?
  tcc generates an "ldm fp, {fp, sp, pc}"
  Maybe all we need is to copy lr to pc?
  Yeah, something like "move pc, lr" I bet.
  Or "bx lr" to support going between arm and thumb states.

The assembly code for foo generated by gcc is a bit more complicated.
* It saves the frame point to the stack and updates the framepointer.
* It stores the arg to the stack then reloads it.
* It does the increment on a separate register instead of in place.
* It resets the frame pointer.

But I bet my version will work. There are a bunch of attributes and other
things in the .s file. What are all those? Specifically:
  .arch
  .eabi_attribute
  .fpu
  .file
  .text
  .align
  .global
  .type
  .size 
  .ident 
  .section

Looks like "@" is being used to introduce comments.

Limiting to the following works:

  .arch armv6
  .text
  .align  2
  .global foo
  .type foo, %function
foo:
  add r0, r0, #1
  bx  lr

---
Other things learned:
* rsb r0, r0, #0  can be used for negate (it's reverse subtraction).
* Some instructions, like rsb, you add 'S' to tell it to update the condition
  flags based on the results.
* Many instructions you can append a condition code to conditionally execute
  the instruction. For example, movpl r0, r1 means move r1 to r0 in case the
  condition result is "plus".

How to properly save registers to call another instruction?
* gcc generates stmfd and ldmfd instructions

stmfd sp!, {fp, lr}
  means store multiple registers to a full descending stack.

But it just stores the registers in the list. I guess we don't need to save
caller registers unless we want to use them ourselves first, because the
callee is responsible for saving those for us.

Is that enough to get us going? Should I start trying to write the real fble
compiler to assembly and just figure out the rest from there?

Local variables that would be nice to keep in registers:
* profile, so we can easily disable profiling.
* heap
* thread->stack->locals - for fast access to local vars
* thread->stack->func->statics - for fast access to static vars

Perfect. So, use r0-r3 for scratch, r4-r8 for the five values above. We can
store 'threads' and 'io_activity' on r10, r11 I guess. Or stack if we want
more registers to work with. We can create aliases for these registers so that
it's very convenient to emit code and have them easily updated.

---

Switching over to aarch64, because I have more interest in learning that than
32 bit arm.

Procedure Call Standard:
* r0-r7     input/output args
* r8        indirect result location
* r9-r15    temp registers
* r16, r17  intra procedure call scratch registers
* r18       platform register
* r19-r28   callee saved registers
* r29       frame pointer
* r30       link register
* SP        stack pointer

---

First step, for warmup, generate the export function in assembly.

Sequence of calls:

heap := r0
profile := r1
program = FbleRawAlloc(sizeof(FbleExecutableProgram), "file:line")
program->modules.size = 0
program->modules.xs = FbleRawAlloc(sizeof(FbleExecutableModule), "file:line")
<module>(program)
value = FbleLink(heap, program, profile)
FbleFreeExecutableProgram(program)
return value

We know r0-r7 could be wiped on function calls, so we probably want to save
intermediate values to temp registers. Which means we'll need to save whatever
is there to start. Proposed register assignments:

x9: heap
x10: profile
x11: program
x12: value

So, assembly should be something like:

alloc 4 double words on stack
save x9, x10, x11, x12 to stack
move x9, x0
move x10, x1
move x0, #sizeof(FbleExecutableProgram)
move x1, #str
bl FbleRawAlloc
move x11, r0
store x11 + ->modules.size, #0
move x0, #sizeof(FbleExecutableProgram)
move x1, #str
bl FbleRawAlloc
store x11 + ->modules.xs, x0
move x0, x11
bl <module>
move x12, x0
move x0, x9
move x1, x11
move x2, x10
bl FbleLink
move x12, x0
move x0, x11
bl FbleFreeExecutableProgram
move x0, x12
restore x9, x10, x11, x12 from stack
dealloc stack 4 double words
ret

That's basically what gcc generates, except gcc stores temporary values on the
stack instead of in the registers, which means you don't need to do the
save/store of caller registers. It's pretty close in terms of total numbers of
loads and stores. Maybe easier to do it gcc way. Okay? Go with that? Then I
guess all we need to do is reuse the code generated by gcc. Seems like
cheating, but as long as I understand it.

Um, this is pretty painful. Does it really make sense to generate assembly for
the export function? Why not just have it call a precompiled function, passing
in the address of the function to call? Why not just have it define an alias
for the raw module function, and let people manually call
FbleLoadCompiled(heap, profile, &MyModuleFunction)? Maybe we could even do
that with some linker magic? No extra instructions needed?

Would it be possible to write a CPP macro that, given the path to the module,
turns into the name of the generated C identifier? Then we don't need to
export anything at all, you can literally use the path to the module.

---

How to describe the static data for an FbleExecutableModule in assembly:

gcc does something like:

For an FbleString:

foo:
  .data
  .align 3                (what for?)
  .xword 1                (refcount)
  .xword 5333369          (magic)
  .string "foo"           (str)

For an FbleName:
foo:
  .data
  .align 3                (what for?)
  .xword str              (name)
  .word 0                 (space)
  .zero 4                 (?? alignment for Loc?)
  .xword src              (source)
  .word 1                 (line)
  .word 2                 (col)

For data with pointers, it goes into .data.rel,"aw" or .data.rel.local
sections.

So, things to figure out:
* why align 3?
 - Does that mean align by 2^3 bytes, to get 64 bit alignment, as required
   given it contains 64 bit pointers?
 - Yes. For this architecture it must be "the number of low-order zero bits the
   location counter must have after advancement."
* why zero 4
 - I'm thinking because FbleLoc has 64 bit alignment because it contains a
   pointer, so we need to pad 32 bits between the 32 bit enum and the FbleLoc.
 - Yeah. that makes sense.
* Difference between sections .rodata, .data.rel.local,"aw",, .data.rel.local,
  .data.rel,"aw"
  - "aw" are flags: 'a' for allocatable, 'w' for writeable.
  - presumably .rodata is read only data, .data.rel relocatable data, not sure
    what the .local is. But are these just arbitrary names for debugging
    purpose, or does the assembler/linker treat them specially semantically?

From reading the linker manual:
* A "loadable" section is loaded into memory at runtime.
* An "allocatable" section is allocated in memory at runtime, but doesn't get
  anything loaded into it.
* Otherwise a section is probably just debug info that need not be accessed at
  runtime.
* The section names, like .data.rel.local, are referenced by the linker
  script. There is a default linker script that says what order to put the
  different sections in.
* The elf spec ('man elf') has some notion of sections. The linker's job is to
  convert input sections to different output sections. Maybe the output
  sections are what matter for relocation? Yeah, looks like that's the case.

---

After setting up build support for using assembly, we are getting segfaults in
the tests. That's not really what I expect at this point. At this point I
expect aborts when the _Run_ function is called. What's up?

FbleLoadFromCompiled is being passed a module '0'. Why?

Looks like some issue with the linker.

Before linking:

_Fble_2f_test_25_:
  mov x1, L.24
  mov x2, 0
  mov x3, L.25
  b FbleLoadFromCompiled

After linking:

0000000000400f94 <_Fble_2f_test_25_>:
  400f94: d2800001  mov x1, #0x0                    // #0 (module)
  400f98: d2800002  mov x2, #0x0                    // #0 (depc)
  400f9c: d2800b03  mov x3, #0x58                   // #88 (deps)
  400fa0: 14001768  b 406d40 <FbleLoadFromCompiled>

It looks like the references to the labels in the assembly are being turned
directly into constants relative to the start of the label's section, rather
than being tied to where the section actually ends up getting loaded to. Why?

Let's compare to some custom C code that references a static value.

Instead of using something like mov x0, X, the C code uses:

 adrp  x0, X
 add x0, x0, :lo12:X

What does this mean?

That gets turned into, in the .o file:

 adrp x0, 0
 add x0, x0, #0

And in the executable file:

 73c:   b0000080        adrp    x0, 11000 <__cxa_finalize@GLIBC_2.17>
 740:   9100c000        add     x0, x0, #0x30

Reading the ARM manual suggests that:

 adrp  x0, X
 add x0, x0, :lo12:X

adrp means set x0 to the value of (X << 12) relative to the current pc.
Presumably :lo12:X gives the low 12 bits of X. I'm not sure I understand. I
have to assume the value for 'X' in the adrp does not include the bottom 12
bits. Then this would make sense.

I think I can just use adr. Let's see if that makes the assembler/linker any
happier.

Switching to adr gets us to our expected abort. And 'objdump -r -D' gives
better insight as to how this information is tracked.

---

Keep track of local variables / registers used by the run function:
* We need to at least keep pointers to heap, threads, thread and io_activity
  from the run function.
* These can be saved on the stack. We can use dedicated registers for anything
  we want faster access to.

So, how do I save some registers to the stack?

FbleInterpreterRunFunction as compiled by gcc starts with:

    1898:       a9ba7bfd        stp     x29, x30, [sp, #-96]!
    189c:       910003fd        mov     x29, sp
    18a0:       f90017e0        str     x0, [sp, #40]
    18a4:       f90013e1        str     x1, [sp, #32]
    18a8:       f9000fe2        str     x2, [sp, #24]
    18ac:       f9000be3        str     x3, [sp, #16]

It ends with:
    1a18:       a8c67bfd        ldp     x29, x30, [sp], #96
    1a1c:       d65f03c0        ret
 
The meaning of 'stp' is:
  Store Pair: it stores x29 and x30 to the stack pointer offset by -96.

Where do we update the stack pointer?
  That's part of the address mode for stp and ldp.

Pre Indexed form: stp rA, rB, [rX, #C]!
  addr = rX + C
  rX := addr

So the stp instruction advances the stack pointer by 12 8-byte words and saves
x29 (FP) and x30 (LR) at the top.

That looks pretty easy. What if I update the existing code to use this instead
of direct tail calls to functions, so that we get a better stack frame when
debugging? Yeah. That looks great.

Note to self: SP should stay a multiple of 16, not just a multiple of 8,
otherwise I get bus errors.

---

How varargs works:

It's not entirely clear to me from the spec.
First 8 args go in registers.
Next args go in stack.
But what order do they go in the stack, and on what side of the stack pointer?

Experiment suggests the args go as:

x0, x1, x2, x3, x4, x5, x6, x7, x8, [sp], [sp, 8], [sp, 16], ...

So we'll need to allocate space on the stack for however many more than 8 args
we have, then fill reg x0-x8, then sp+0 to sp+N, in that order.

---

How to load from far away offsets?

Some examples of various offsets:

ldr x0, [x0, 40]
ldr x0, [x0, 320]
ldr x0, [x0, 3200]
...

  add x0, x0, 65536
  ldr x0, [x0, 14464]

This suggests we can go up to 65536. Why is the assembler yelling at me for
more than 256? Is it this use of '#'?

I'm not longer able to reproduce the issue of loading from far away offsets.
Odd...
