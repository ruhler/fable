
<@>@ List@ = /List%.List@;

<@>@ Maybe@ = /Maybe%.Maybe@;

@ Ball@ = /Pinball/Ball%.Ball@;

@ BallT@ = /Pinball/Collide%.BallT@;

@ Edge@ = /Pinball/Edge%.Edge@;

@ Paddle@ = /Pinball/Paddle%.Paddle@;

@ Num@ = /Pinball/Num%.Num@;
% Sub = /Pinball/Num%.Sub;
% Div = /Pinball/Num%.Div;
% Le = /Pinball/Num%.Le;
% Int = /Pinball/Num%.Int;

@ Vec@ = /Pinball/Vec%.Vec@;
% AddV = /Pinball/Vec%.AddV;
% MulVS = /Pinball/Vec%.MulVS;

@ World@ = *(
  Vec@ gravity,      # acceleration due to gravity
  Ball@ ball,
  List@<Edge@> edges,
  List@<Paddle@> paddles
);

# CollideEdge -- 
#   Check for and apply collision of ball with edge between start and end.
#
# If there is no collision, end is returned as is. If there is a collision,
# returns the ball in the state just after the collision at the time of
# collision.
(Ball@, BallT@, Edge@) { BallT@; }
CollideEdge = (Ball@ start, BallT@ end, Edge@ edge) {
  Maybe@<BallT@> mcr = /Pinball/Collide%.BallEdge(start, edge, end.time);
  mcr.?(nothing: end);
  mcr.just;
};

# CollidePaddle -- 
#   Check for and apply collision of ball with paddle between start and end.
#
# If there is no collision, end is returned as is. If there is a collision,
# returns the ball in the state just after the collision at the time of
# collision.
(Ball@, BallT@, Paddle@) { BallT@; }
CollidePaddle = (Ball@ start, BallT@ end, Paddle@ paddle) {
  Maybe@<BallT@> mcr = /Pinball/Collide%.BallPaddle(start, paddle, end.time);
  mcr.?(nothing: end);
  mcr.just;
};

# CollideEdgeS --
#   Check for and apply collision between ball and a list of edges.
#
# If there is no collision, end is returned as is. If there is a collision,
# returns the ball in the state just after the collision at the time of
# collision.
(Ball@, BallT@, List@<Edge@>) { BallT@; }
CollideEdgeS = (Ball@ start, BallT@ end, List@<Edge@> edges) {
  edges.?(nil: end);
  CollideEdgeS(start, CollideEdge(start, end, edges.cons.head), edges.cons.tail);
};

# CollidePaddleS --
#   Check for and apply collision between ball and a list of paddles.
#
# If there is no collision, end is returned as is. If there is a collision,
# returns the ball in the state just after the collision at the time of
# collision.
(Ball@, BallT@, List@<Paddle@>) { BallT@; }
CollidePaddleS = (Ball@ start, BallT@ end, List@<Paddle@> paddles) {
  paddles.?(nil: end);
  CollidePaddleS(start, CollidePaddle(start, end, paddles.cons.head), paddles.cons.tail);
};

# Move --
#   Move the ball and paddles by the given amount of time, assuming velocity
#   stays constant.
#
# In case of collision, we break down the time period into smaller bits. The
# assumption that velocity is constant is intended to prevent the case where
# we break down the time period into smaller and smaller bits and end up never
# reaching the end of the time period as a result. This also assumes we
# don't have any super tight corners that would cause us to collide an
# excessive number of times in a single time period.
(World@, Num@) { World@; } Move = (World@ w, Num@ t) {
  Le(t, Int|0).?(true: w);

  Vec@ end_pos = AddV(w.ball.pos, MulVS(w.ball.vel, t));
  BallT@ end = BallT@(Ball@(end_pos, w.ball.vel, w.ball.radius), t);
  BallT@ edged = CollideEdgeS(w.ball, end, w.edges);
  BallT@ batted = CollidePaddleS(w.ball, edged, w.paddles);
  Num@ ct = batted.time;
  List@<Paddle@> paddles = /List%.Map<Paddle@, Paddle@>(w.paddles, (Paddle@ p) {
    /Pinball/Paddle%.Move(p, ct);
  });
  World@ moved = World@(w.gravity, batted.ball, w.edges, paddles);
  Move(moved, Sub(t, ct));
};

# Tick --
#   Advance the world by one unit of time.
(World@) { World@; } Tick = (World@ w) {
  # Compute average expected ball velocity over the time period.
  Vec@ half_gravity = MulVS(w.gravity, Div(Int|1, Int|2));
  Vec@ v_avg = AddV(w.ball.vel, half_gravity);
  World@ updated = World@(w.gravity, Ball@(w.ball.pos, v_avg, w.ball.radius), w.edges, w.paddles);

  # Move the ball assuming constant velocity.
  World@ moved = Move(updated, Int|1);

  # Compute final ball velocity.
  Vec@ v = AddV(moved.ball.vel, half_gravity);
  World@(w.gravity, Ball@(moved.ball.pos, v, moved.ball.radius), moved.edges, moved.paddles);
};

@(World@, Tick);
