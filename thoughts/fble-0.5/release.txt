Fble 0.5 Release
================
Proposed focus area: performance.

Goal: Make fble pprof viewer fast enough to be useful in practice.

Possible features:
* Re-implement profiling in fble to generate samples.
* Optimize fble pprof viewer.
* Optimize function calls in runtime.

---

Bug: If we allocate a literal with 25746910 characters, it looks like we smash
the stack. That corresponds to 196MB allocation on the stack for the args.

Ugh. Any easy way around that? Do I need to make this a dynamic allocation?

We already end up using a vector for this. Why not use the vector from the
start? Regardless, I should probably write a test for this. But what limit is
reasonable? Sigh.

Let's write a test case, see if I can fix it. If no easy fix, leave it as a
todo for now and work around in the short term.

It's a bit tedious that we need a 1.2MB fble file to reproduce the error. Is
that really reasonable? Should we be supporting such large literals? What's
the alternative for my benchmark?

Anyway, see if we can get it to work. Then decide if I want to check it in.

I can get rid of the stack smashing issue. I need to figure out the aarch64
mov instruction to load a larger number into a register. What does GCC do?

  mov x0, 62977
  movk  x0, 0x11, lsl 16

Sigh. Looks like I'll have to fix that everywhere.

Let's read up on the details of mov and movk:
* mov takes a 16 bit number.
* movk moves a 16 bit shifted number in a register, keeping whatever else was
  already there.

---

I declare the performance improvement goal of this release met. What do I want
to shift my focus to next? I think to pprof. Figure out what UI I want. I can
prototype it in python. Then try implementing in fble. We can see how
performance is there.

When I have something I'm happy with, revisit the profiling implementation in
fble runtime itself. See if I can simplify and generalize it at the same time.
Though honestly it's hard to believe I can make it go faster by recording a
lot more detail in the profile...

I would like to make a decision on GC native values. That's a separate kind of
track to follow. Of course we'll want to do release cleanup/burndown when I
feel like I've finished with the meat of things. I do feel like I've finished
with the meat of the runtime changes, but plenty of other areas still worth
exploring.

---

Profiling work is feature complete. I'm happy with it. We now generate
google/pprof format (uncompressed) and can view it nicely in the fble-pprof
viewer. Performance of fble-pprof could certainly be improved, but it is
definitely useable.

We have a decision on gc native values: keep general OnFree support, but don't
use it for streams.

The fble-pprof viewer covers my fble application work for the release.

That means we can start the release burndown.

---

* Add an fble-pprof benchmark to fble-benchmark?

The hardest part to deal with is embedding so much data as the input file for
use in pure fble code.

The md5.prof file I have that takes about 2 minutes to parse is 3.1M large.
And we take up like half the memory on my raspberri pi. It's 8M in hex. gzip
compressed and then put in hex it goes to 630K.

It's too much data to be easily used in a benchmark, and I suspect stdio IO
monad contributes a fair amount to the performance cost. Pulling it into pure
computation seems unfair in that case?

All the other benchmarks have relatively small inputs and run a while.

I don't see a feasible way to implement a pure fble-pprof benchmark. The
quantity of input data needed to get decently long runtimes is too high.

As it stands, I can't easily look at a --profile for fble-pprof, because
there's no clean way to exit the server. Maybe I could compromise: add a
--benchmark option to the server that runs a few fixed queries and then exits?
It would be a shame not to have that as part of fble-bench though.

---

* Remove duplicate code for String StartsWith and List StartsWith?

Don't bother. The costs/benefits of sharing or duplicating the code are small.
We have test cases for them both, we can leave it however we want. I don't see
sufficient motivation to spend the effort to change it one way or the other.

---

* Remove unnecessary FbleProfile apis now that blocks and enabled fields are
  public again.

A function API has more value than direct access to FbleProfile, because it
is less likely to have to change in the future. Any FbleProfile API I have
today that makes sense I should keep, even if it isn't necessary.

Specifically:
* FbleEnableProfiling, FbleDisableProfiling - keep
* FbleProfileBlockName - 
  I'm inclined to drop, because the lifetime of the return result is unclear.
  Also, turns out there is only a single use in a test case, so it's easy to
  drop.
* FbleLookupProfileBlockId - drop
  It doesn't make sense to look up by char*, we need to lookup by name, right?
  Although, I'm not sure we could distinguish by name in the output profile.

Let's see how much work it will be to drop the last two APIs.

---

* Remove enabled argument to FbleNewProfile?

Cases for enable/disable:
* test.c, stdio.fble.c, app.c - disables by default, enabled implicitly via FbleMain.
* fble-perf-profile.c - enabled by default.
* profile tests - mostly enabled by default.

There is a single use of FbleEnableProfiling. It could easily be inlined.
There are no uses of FbleDisableProfiling.

We have disable by default, enable implicitly. Could we switch to enable by
default, disable implicitly? Yes. I think we could. Then no need to pass an
argument to new profile.

I think that makes the most sense. No need for enable/disable APIs, and always
enable by default.

The one tricky bit is test/profiles-test, which uses FbleMain, but doesn't
currently explicitly enable profiling.

