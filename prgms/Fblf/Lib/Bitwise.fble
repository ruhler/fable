
@ Var@ = /Fblf/Program%.Var@;
@ Stmt@ = /Fblf/Program%.Stmt@;
% Assign = /Fblf/Program%.Assign;
% Eq = /Fblf/Program%.Eq;
% IfElse = /Fblf/Program%.IfElse;
% Seq = /Fblf/Program%.Seq;
% Binary = /Fblf/Program%.Binary;
% Offset = /Fblf/Program%.Offset;
% Var = /Fblf/Program%.Var;

<@>@ Module@ = /Fblf/Module%.Module@;
@ Method@ = /Fblf/Module%.Method@;
<@>% Module2 = /Fblf/Module%.Module2;
<@>% Module3 = /Fblf/Module%.Module3;
% Method = /Fblf/Module%.Method;

@ Int@ = /Int/Int%.Int@;
% Add = /Int/Int%.Add;
% Sub = /Int/Int%.Sub;
% Lt = /Int/Int/Eq%.Lt;

% Int = /Int/Int/Lit%.Int;

% CountUpTo = /Int/Int/Iter%.CountUpTo;
<@,@>% For = /Iter%.For;

<@>@ List@ = /List%.List@;
<@>% Nil = /List%.Nil;
<@>% Cons = /List%.Cons;

@ String@ = /String%.String@;
% Str = /String%.Str;
% Strs = /String%.Strs;

# Bitwise --
#   Helper function for describing bitwise computations.
#
# Inputs:
#   n - the number of bits.
#   f - the statement to execute to compute the ith bit.
#
# Results:
#   A statement that calls f on each bit.
(Int@, (Int@) { Stmt@; }) { Module@<Method@>; }
Bitwise = (Int@ n, (Int@) { Stmt@; } f) {
  Method(Str|'main', Seq(For<Int@, List@<Stmt@>>(CountUpTo(n), Nil<Stmt@>,
    (Int@ i, List@<Stmt@> l) {
      Cons<Stmt@>(f(i), l);
    }))); 
};

# And --
#   n-bit bitwise AND.
#
# Inputs:
#   n - The number of bits in each operand.
#   a - The address of the first operand.
#   b - The address of the second operand.
#   z - The address of the result.
(Int@)(Var@, Var@, Var@) { Module@<Method@>; }
And = (Int@ n) {
  String@ name = Strs[Str|'Bitwise/And', /Int/Int/Show%.Show(n)];
  Module3<Method@>(name, (Var@ a, Var@ b, Var@ z) {
    Bitwise(n, (Int@ i) {
      Var@ ai = Offset(a, i);
      Var@ bi = Offset(b, i);
      Var@ zi = Offset(z, i);

      IfElse(Eq(Var(ai), Binary|0, Int|1),
        Assign(zi, Binary|0, Int|1),
        Assign(zi, Var(bi), Int|1));
    });
  });
};

# Or --
#   n-bit bitwise OR.
#
# Inputs:
#   n - The number of bits in each operand.
#   a - The address of the first operand.
#   b - The address of the second operand.
#   z - The address of the result.
(Int@)(Var@, Var@, Var@) { Module@<Method@>; }
Or = (Int@ n) {
  String@ name = Strs[Str|'Bitwise/Or', /Int/Int/Show%.Show(n)];
  Module3<Method@>(name, (Var@ a, Var@ b, Var@ z) {
    Bitwise(n, (Int@ i) {
      Var@ ai = Offset(a, i);
      Var@ bi = Offset(b, i);
      Var@ zi = Offset(z, i);

      IfElse(Eq(Var(ai), Binary|1, Int|1),
        Assign(zi, Binary|1, Int|1),
        Assign(zi, Var(bi), Int|1));
    });
  });
};

# Xor --
#   n-bit bitwise XOR.
#
# Inputs:
#   n - The number of bits in each operand.
#   a - The address of the first operand.
#   b - The address of the second operand.
#   z - The address of the result.
(Int@)(Var@, Var@, Var@) { Module@<Method@>; }
Xor = (Int@ n) {
  String@ name = Strs[Str|'Bitwise/Xor', /Int/Int/Show%.Show(n)];
  Module3<Method@>(name, (Var@ a, Var@ b, Var@ z) {
    Bitwise(n, (Int@ i) {
      Var@ ai = Offset(a, i);
      Var@ bi = Offset(b, i);
      Var@ zi = Offset(z, i);

      IfElse(Eq(Var(ai), Binary|0, Int|1),
        Assign(zi, Var(bi), Int|1),
        IfElse(Eq(Var(bi), Binary|0, Int|1),
          Assign(zi, Binary|1, Int|1),
          Assign(zi, Binary|0, Int|1)));
    });
  });
};

# Not --
#   n-bit bitwise NOT.
#
# Inputs:
#   n - The number of bits in the operand.
#   a - The address of the operand.
#   z - The address of the result.
(Int@)(Var@, Var@) { Module@<Method@>; }
Not = (Int@ n) {
  String@ name = Strs[Str|'Bitwise/Not', /Int/Int/Show%.Show(n)];
  Module2<Method@>(name, (Var@ a, Var@ z) {
    Bitwise(n, (Int@ i) {
      Var@ ai = Offset(a, i);
      Var@ zi = Offset(z, i);

      IfElse(Eq(Var(ai), Binary|1, Int|1),
        Assign(zi, Binary|0, Int|1),
        Assign(zi, Binary|1, Int|1));
    });
  });
};

# Cls --
#   n-bit circular left shift.
#
# Inputs:
#   n - The number of bits in the operand.
#   s - The number of bits to shift left.
#   a - The address of the operand.
#   z - The address of the result.
(Int@, Int@)(Var@, Var@) { Module@<Method@>; }
Cls = (Int@ n, Int@ s) {
  String@ name = Strs[
    Str|'Bitwise/Cls',
    /Int/Int/Show%.Show(n),
    Str|'_',
    /Int/Int/Show%.Show(s)
  ];
  Module2<Method@>(name, (Var@ a, Var@ z) {
    Bitwise(n, (Int@ i) {
      Var@ ai = Offset(a, i);
      Int@ offset = Lt(i, s).?(
        true: Sub(Add(n, i), s),
        false: Sub(i, s));
      Var@ zi = Offset(z, offset);

      Assign(zi, Var(ai), Int|1);
    });
  });
};

@(And, Or, Xor, Not, Cls);
