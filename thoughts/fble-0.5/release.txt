Fble 0.5 Release
================
Proposed focus area: performance.

Goal: Make fble pprof viewer fast enough to be useful in practice.

Possible features:
* Re-implement profiling in fble to generate samples.
* Optimize fble pprof viewer.
* Optimize function calls in runtime.

---

Bug: If we allocate a literal with 25746910 characters, it looks like we smash
the stack. That corresponds to 196MB allocation on the stack for the args.

Ugh. Any easy way around that? Do I need to make this a dynamic allocation?

We already end up using a vector for this. Why not use the vector from the
start? Regardless, I should probably write a test for this. But what limit is
reasonable? Sigh.

Let's write a test case, see if I can fix it. If no easy fix, leave it as a
todo for now and work around in the short term.

It's a bit tedious that we need a 1.2MB fble file to reproduce the error. Is
that really reasonable? Should we be supporting such large literals? What's
the alternative for my benchmark?

Anyway, see if we can get it to work. Then decide if I want to check it in.

I can get rid of the stack smashing issue. I need to figure out the aarch64
mov instruction to load a larger number into a register. What does GCC do?

  mov x0, 62977
  movk  x0, 0x11, lsl 16

Sigh. Looks like I'll have to fix that everywhere.

Let's read up on the details of mov and movk:
* mov takes a 16 bit number.
* movk moves a 16 bit shifted number in a register, keeping whatever else was
  already there.

---

I declare the performance improvement goal of this release met. What do I want
to shift my focus to next? I think to pprof. Figure out what UI I want. I can
prototype it in python. Then try implementing in fble. We can see how
performance is there.

When I have something I'm happy with, revisit the profiling implementation in
fble runtime itself. See if I can simplify and generalize it at the same time.
Though honestly it's hard to believe I can make it go faster by recording a
lot more detail in the profile...

I would like to make a decision on GC native values. That's a separate kind of
track to follow. Of course we'll want to do release cleanup/burndown when I
feel like I've finished with the meat of things. I do feel like I've finished
with the meat of the runtime changes, but plenty of other areas still worth
exploring.

---

Profiling work is feature complete. I'm happy with it. We now generate
google/pprof format (uncompressed) and can view it nicely in the fble-pprof
viewer. Performance of fble-pprof could certainly be improved, but it is
definitely useable.

We have a decision on gc native values: keep general OnFree support, but don't
use it for streams.

The fble-pprof viewer covers my fble application work for the release.

That means we can start the release burndown.

---

* Add an fble-pprof benchmark to fble-benchmark?

The hardest part to deal with is embedding so much data as the input file for
use in pure fble code.

The md5.prof file I have that takes about 2 minutes to parse is 3.1M large.
And we take up like half the memory on my raspberri pi. It's 8M in hex. gzip
compressed and then put in hex it goes to 630K.

It's too much data to be easily used in a benchmark, and I suspect stdio IO
monad contributes a fair amount to the performance cost. Pulling it into pure
computation seems unfair in that case?

All the other benchmarks have relatively small inputs and run a while.

I don't see a feasible way to implement a pure fble-pprof benchmark. The
quantity of input data needed to get decently long runtimes is too high.

As it stands, I can't easily look at a --profile for fble-pprof, because
there's no clean way to exit the server. Maybe I could compromise: add a
--benchmark option to the server that runs a few fixed queries and then exits?
It would be a shame not to have that as part of fble-bench though.

---

* Remove duplicate code for String StartsWith and List StartsWith?

Don't bother. The costs/benefits of sharing or duplicating the code are small.
We have test cases for them both, we can leave it however we want. I don't see
sufficient motivation to spend the effort to change it one way or the other.

---

* Remove unnecessary FbleProfile apis now that blocks and enabled fields are
  public again.

A function API has more value than direct access to FbleProfile, because it
is less likely to have to change in the future. Any FbleProfile API I have
today that makes sense I should keep, even if it isn't necessary.

Specifically:
* FbleEnableProfiling, FbleDisableProfiling - keep
* FbleProfileBlockName - 
  I'm inclined to drop, because the lifetime of the return result is unclear.
  Also, turns out there is only a single use in a test case, so it's easy to
  drop.
* FbleLookupProfileBlockId - drop
  It doesn't make sense to look up by char*, we need to lookup by name, right?
  Although, I'm not sure we could distinguish by name in the output profile.

Let's see how much work it will be to drop the last two APIs.

---

* Remove enabled argument to FbleNewProfile?

Cases for enable/disable:
* test.c, stdio.fble.c, app.c - disables by default, enabled implicitly via FbleMain.
* fble-perf-profile.c - enabled by default.
* profile tests - mostly enabled by default.

There is a single use of FbleEnableProfiling. It could easily be inlined.
There are no uses of FbleDisableProfiling.

We have disable by default, enable implicitly. Could we switch to enable by
default, disable implicitly? Yes. I think we could. Then no need to pass an
argument to new profile.

I think that makes the most sense. No need for enable/disable APIs, and always
enable by default.

The one tricky bit is test/profiles-test, which uses FbleMain, but doesn't
currently explicitly enable profiling.

---

* Change FbleOutputProfile function to take a file name instead of FILE*?

FILE* can do more than filename. In particular, it can do stdout.

Reasons to suggest we use a filename:
* The output needs to be binary
* It doesn't make sense to interleave with other stuff.

Reasons to use FILE*:
* You can output to stdout.

Reasons you might want to use stdout:
* For use with redirection, e.g. fble-perf-profile.

Alternatives to stdout for fble-perf-profile:
* --output, -o flag

Surely 'fble-perf-profile -o foo.prof' isn't that much worse than 
'fble-perf-profile > foo.prof'? Worst case you could manually do
'fble-perf-profile -o /dev/stdout'?

When it comes time to support gzip compression and we want to use zlib, maybe
it's better to have the file name format?

I don't see good enough motivation to change this right now. Let's hold off
until we have better motivation. It will be easy enough to change then.

---

* Avoid emitting 'call' counts in pprof for fble-perf-profile?

Not worth doing.

Pros:
* Save a small amount of space in generated profile. Probably less than 10 or
  20%.
* Avoid potential confusion looking at call counts in fble-perf-profile.
* Avoid need to document potential confusion looking at call counts in
  fble-perf-profile.

Cons:
* Small added complexity in implementation.
* Added complexity in API for generating a profile.
* Added complexity in test coverage to cover cases with and without.

The cons outweigh the pros in my mind.

---

* Figure out a nicer way to switch between -O0 and -O3 as needed for debug.

I should set up rules in the build system to provide .dbg variants of binaries
I want to debug. Don't build those by default, but make it so they can be
built on demand. I bet it's not too complicated to set up.

But also, let's hold off until next time I have a concrete use case. We can
add support for this in a lazy fashion.

If we don't build as part of 'ninja check', it's likely to bit rot. That's
okay with me. Better to figure out how to fix it when it rots than deal with
the tedium of modifying -O switch back and forth for debug.

---

* Add explicit close to OStream API.

I think it will be easiest to change OStream to output a stream of
Maybe@<Int@> rather than be a struct with a pair of putting Int@ and closing.
Maybe there are minor performance implications, but let's not worry about that
for now. We can change later if need be.

This type change is pretty tedious. What if I instead define an Int@ value for
EOF and use that? And maybe we should update the input stream to match too?

How about I hack up a thing where if you send -1, it closes the socket, and
see if it fixes elinks on fble-pprof?

Yeah, that fixes the elinks issue. I should think about this some more, then
do a proper job of it.

---

I'm thinking in circles on the OStream issue. I don't know the 'perfect' way
to do it. For now, let's just do something that lets us explicitly close an
output stream and stop using GC for that.

Easiest thing: Passing -1 to existing output stream closes. No need to change
types everywhere that way.

Here's a new issue that maybe I want to not worry about now: how can we close
an input stream? For example, maybe we want to open a bunch of files in a loop
and read the first 10 bytes. How do we avoid leaking file descriptors? The API
has no way to close the file descriptors. Should we rely on GC here? Sigh.

---

* Split FbleDataType into FbleStructType and FbleUnionType?
  Get rid of FbleDataTypeTag?

There is a lot of identical code between them though. I don't want to have to
duplicate that all. Maybe we do part way, encode the data type tag in the tag
for the type, but share the common structure.

I don't see the benefit of splitting the types here. The code for them is
identical except for printing as '+' versus '*'.

---

* Improve performance of fble-pprof?
  Currently dominated by the time to generate seq block and seq name lists for
  the full sequences.

I say don't bother. I could encode sequences as views on full sequences. That
wouldn't help seq name lists, and would be pretty involved. Performance is
plenty good enough when I use --profile-sample-period. Save this for another
time if/as performance of fble-pprof starts to bother me more.

---

* Pull undef check into separate instruction?
  So we can remove the check entirely if the compiler knows about it?
  Downside is the need for an extra GetFrameVar call on the value?

We've done enough performance optimizations for this release. This is low down
on the list. It won't buy us anything if we have to call GetFrameVar twice.
Another option would be to put extra info in each instruction about whether it
can assume something is strict or not.

Let me punt this into a slightly more general performance improvement to
consider down the line.

---

* Add fble to rosettacode.org?
  Or at least implement all the tasks, perhaps in a separate RosettaCode
  package to start.
  Probably start with all the 'Simple' tasks.

The tasks pretty heavily depend on the standard library. I think it would be
good to sketch them out, but I'd rather wait until after revamping the
standard library.

---

* Add spec test to catch case of tbnz not having enough limit for undef check.

For the three undef checks, we used to have:
  fprintf(fout, "  tbnz x0, #1, .Lo.%04zx.%zi.u\n", func_id, pc);

Now we have:
  fprintf(fout, "  tst x0, #2\n");
  fprintf(fout, "  b.ne .Lo.%04zx.%zi.u\n", func_id, pc);

Let me temporarily revert that, recreate the bug, write a spec test to catch
it (presumably a really long literal?), then revert back the fix.

I have a super long literal test already. Does that not catch it? Apparently
not.

It's because the super long literal stores data in the data section, not the
text section. I need to somehow generate super big code. Like, lots of
instructions. Maybe lots of nested case expressions? Or function calls?

Let me try a bunch of case expressions.
