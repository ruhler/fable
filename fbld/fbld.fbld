@doc Fbld
 @section Introduction
  Fbld is a lightweight markup language for structured text. It aims to
  balance the readibilty of markup languages like asciidoc and markdown with
  the extensibility and clarity of structure of markup languages like xml.
 
  Note: Fbld should not be confused with the predecessor to fble, which was
  also called fbld. We reuse the name @l[fbld] in this case to suggest the
  term "Fable Doc Language".
 
  @subsection Goals
   The primary design goals of fbld are:
 
   @item
    It should be easy to parse, by both human and computer. There should not
    be weird corner cases, ambiguity, or complex resolution rules for parsing
    like there are for markdown, for example.
 
   @item
    The main textual content should be easy to read from source by a human.
    It should not include excessive clutter from tags that overly distract
    from the contents of the text, as is the case with roff and xml, for
    example.
 
   @item
    It should be easy to provide custom processing of the document. For
    example, conversion to html, latex, roff, or anything you might like.
 
   @item
    It should support custom structure, allowing a user to define their own
    new kinds of structures and use those structures in their documents.
 
  @subsection Use Cases
   The original use cases motivating development of the fbld language are:
 
   @item
    Document functions in code and automatically generate man pages from it.
 
   @item
    Document command line usage and automatically generate both man page and
    help usage text from it.
 
   @item
    Mark up README files, tutorials, and language specifications to add
    clarity to structure and make it possible to generate books, webpages,
    etc. with that information.
 
  @subsection Alternatives
   There are many alternatives for document markup. Each of the ones I tried
   had their own issues. Some of the issues are subtle and quite subjective.
   Here are a list of alternatives I considered before deciding to develop my
   own markup language.

   @definition Markdown
    @item Subtleties in how to parse correctly.
    @item No support for custom structure components.

   @definition Asciidoc
    @item Complex to parse and provide custom processing of the document.
    @item Vim syntax highlighting doesn't work well, if at all.
    @item
     You have to know what particular symbols mean to understand the structure
     of a document. For example, @l[......] versus @l[////////].

   @definition XML
    @item Tags clutter the doc too much.

   @definition roff
    @item Tags clutter the doc too much.

   @definition tcl
    @item Too tedious to have nested inlined structure.

   @definition doxygen
    @item Not generally extensible to things beyond code documentation.

 @section Inline Structure
  Fbld interprets text as a sequence of commands to execute. The way fbld
  converts text into a sequence of commands depends on whether the text is
  treated as inline structure or as block structure. This section introduces
  the main concepts of fbld from the point of view of parsing inline
  structure.
 
  For example, consider the following paragraph of text annotated with fbld
  inline structure:
 
  @code[fbld]
   It's @emph[really] important to check the result of the @code[malloc]
   function in C, in case it returns @NULL. See @link[the malloc man
   page][https://manpages.org/malloc] for more details.
 
  Explicit commands are introduced with the @l[@] character. In this example
  we use commands @l[@emph], @l[@code], @l[@NULL], and @l[@link]. The meaning
  of these commands is entirely user defined. There are no commands built in
  to fbld.
 
  Arguments to commands are passed within square brackets. For example,
  @l[really] is an argument passed to the @l[@emph] command, @l[malloc] is the
  argument passed to the @l[@code] command. The @l[@NULL] command is given no
  arguments and the @l[@link] command is given two arguments.
 
  Any text not explicitly part of a command or its arguments is grouped
  together into a single argument and passed to an implicit default inline
  command. For example, let's say the default command was called @l[@default].
  The first, implicit command from the above text is then @l[@default[It's ]].
 
  In summary, the above text is parsed into the following sequence of nine
  commands, using tcl syntax for clarity:
 
  @code[tcl]
   default "It's "
   emph "really"
   default " important to check the result of the "
   code "malloc"
   default "\nfunction\nin C, in case it returns "
   NULL
   default ". See"
   link "the malloc man\npage" "https://manpages.org/malloc" 
   default " for more details."
 
  And that's it. The core of how fbld works. Once in the form of a sequence of
  commands, users can provide whatever implementation they like for the
  commands to process the structure of the document the way they desire.
 
  @subsection Lexical Details
   When parsing inline structure, all whitespace is preserved.
 
   Command names are a sequence of one or more alphanumeric or underscore
   characters. No other characters are allowed in command names.
 
   The following are special characters in fbld:
 
   @item @par @l[@], @l[\[], @l[\]], @l[\\]
 
   To use these characters without special processing, prefix them with a
   backslash character. For example:
 
   @code[fbld]
    My email is ruhler\@degralder.com \[I think\].
 
   Would be converted into the single command:
 
   @code[tcl]
    default {My email is ruhler\@degralder.com \[I think\].}
 
   It is illegal to specify @l[@] without a valid command name immediately
   following. It is illegal to use @l[\[] or @l[\]] outside of specifying
   arguments, and braces must be properly closed.
 
   The fbld parser has no knowledge of how many arguments a command expects.
   It is up to the command to report any misuse in the number of arguments
   when it is executed. It is possible for multiple invocations of the same
   command to be supplied a different number of arguments.
 
  @subsection Nested Commands
   It is possible to use inline structure in arguments to commands. For
   example:
 
   @code[fbld]
    Go @link[@bold[here]][www.degralder.com] for cool stuff.
 
   When parsing the first argument to the @l[@link] command, the text from
   opening @l[\[] to matching @l[\]] is used. This is just like how braces
   work in tcl. In this case, the sequence of commands would be:
 
   @code[tcl]
    default "Go "
    link "@bold[here]" "www.degralder.com"
    default " for cool stuff."
 
   It's up to the @l[@link] command to parse its first argument as inline
   structured text if it so desires.
 
 @section Block Structure
  Fbld parses block structured text into a sequence of commands using the same
  concepts as inline structure, with a few syntactic differences.
 
  The idea behind block structure is that we expect it to span one or more
  lines of text. Three things different about block structed text compared to
  inline structed text:

  @item Block commands start on a new line.
  @item Text on the same line after a block command is an additional argument.
  @item
   Text indented on the lines following the block command is an additional
   argument.

  @subsection Same Line Args
   Consider the following block structed text:
   
   @code[fbld]
    @def[triangle] Has three sides
    @def[square] Has four sides

   This is a sequence of two commands, each with two arguments:

   @code[tcl]
    def triangle "Has three sides"
    def square "Has four sides"

   The same line argument starts after a single space following the command
   and any explicit command arguments.

   If there is no space on the same line after the command and any explicit
   command arguments, no same line argument is passed to the command. For
   example:

   @code[fbld]
    @item[first item]
    @item[second item]
   
   Is parsed as:

   @code[tcl]
    item "first item"
    item "second item"
  
  @subsection Following Lines Arg
   Any indented lines following a block command are grouped together and
   passed as an additional argument to the block command. For example:

   @code[fbld]
    @section[First Section]
     Contents of the first section.

     Spanning multiple lines.
    @section[Second Section]
     Contents of the second section.

   Is parsed as:
   
   @code[tcl]
    section "First Section" "Contents of the first section.\n\nSpanning multiple lines.\n"
    section "Second Section" "Contents of the second section.\n"

   Indentation is a single space character at the beginning of each line. This
   space character is stripped from the line before it is passed in the
   following lines argument.

   Blank lines in the middle of an indented block are treated as blank lines
   in the following lines argument. Blank lines at the end of an indented
   block are removed.

   If there are no indented lines following the block command, no following
   lines argument is supplied.

  @subsection Default Block Commands
   If a line starts with something other than a block command, then that line
   and all subsequent lines up until a blank line are grouped together and
   passed as a single argument to the default block command.

   For example:
   
   @code[fbld]
    This is the first paragraph
    of a document.

    Here is the second.

   Parses as:

   @code[tcl]
    default "This is the first paragraph\nof a document.\n"
    default "Here is the second.\n"

  @subsection Starting a Line with an Inline Command
   Sometimes you may want to start a paragraph with an inline command. To
   prevent the command from being treated as a block command, either pass it
   explicitly to the default command, or add a space before. For example:

   @code[fbld]
    @default
     @emph{Yeah!}. Fbld is so great!

   In this case, @l[@emph] is considered an inline command because the
   @l[@default] command parses its argument as inline structed text instead of
   block structured text.


  @subsection A Bigger Example
   Here's an example demonstrating various uses of block structed text.
 
   @code[fbld]
    @doc A Bigger Example
    
     Some introductory text here.
    
     @section[First Section]
      @paragraph
       Here is a paragraph in the first
       section of the doc.
    
      @list
       @item First item of a list.
       @item Second item of a list.
 
   The top level parses as a single doc command:

   @code[tcl]
    doc "A Bigger Example" "Some introductory text here.\n\n@section..."

   The doc command itself can interpet its second argument as block structed
   text. In that case it parses into two commands:

   @code[tcl]
    default "Some introductory text here.\n"
    section "First Section" "@paragraph\n Here is a paragraph in..."

   The section command parses its second argument as block structured text:

   @code[tcl]
    paragraph "Here is a paragraph in the first\nsectionof the doc.\n"
    list "@item First item of a list.\n@item Second item of a list.\n"

   Finally, the list command parses its argument as block structured text:

   @code[tcl]
    item "First item of a list."
    item "Second item of a list."

   Notice that block commands end up indented in practice, even though we said
   they have to start at the beginning of the line. This is because the indent
   is stripped away from the lines before the block command gets processed.

 @section Handling of Escape Characters
  The characters @l[@], @l[\[], @l[\]], and @l[\\] are special and need to be
  escaped using @l[\\] to avoid being processed specially. At the end of the
  day, users will need to manually remove the escapes.
 
  For example, imagine we want to put an email address in a document that we
  convert to markdown:
 
  @code[fbld]
   @block[Example]
    My email address is @bold[ruhler\@degralder.com].
 
  This gets parsed via block structured text as:
 
  @code[tcl]
   block "Example" {My email address is @bold[ruhler\@degralder.com].}
 
  The second argument gets parsed as inline structured text as:
 
  @code[tcl]
   default "My email address is "
   bold {ruhler\@degralder.com}
   default "."
 
  To actually display the text, the @l[@bold] command should remove the
  backslash before rendering the text.
 
 @section TODO
  @item
   Is the following valid? @l[hello \] \[ @there]. The square brackets are
   supposed to be special, but it's not within a command, so there shouldn't
   be any need to escape them, right? Only need to escape square brackets when
   parsing arguments? This would be a problem if it was within an argument.
   Maybe best to require escaping in all cases for consistency.
 
  @item
   Clarify behavior of end of input for block commands, after @l[\]].
