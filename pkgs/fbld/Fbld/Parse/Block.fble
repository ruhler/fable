
@ Bool@ = /Core/Bool%.Bool@;

@ Char@ = /Core/Char%.Char@;

@ Int@ = /Core/Int%.Int@;
% Incr = /Core/Int%.Incr;

<@>@ List@ = /Core/List%.List@;
<@>% Cons = /Core/List%.Cons;
<@>% Nil = /Core/List%.Nil;
<@>% List = /Core/List%.List;
<@>% Concat = /Core/List%.Concat;

<@>@ Maybe@ = /Core/Maybe%.Maybe@;

@ String@ = /Core/String%.String@;
% Str = /Core/String%.Str;
% StrE = /Core/String%.StrE;

@ Unit@ = /Core/Unit%.Unit@;
% Unit = /Core/Unit%.Unit;

@ Loc@ = /Fbld/Loc%.Loc@;

@ Markup@ = /Fbld/Markup%.Markup@;
% Empty = /Fbld/Markup%.Empty;
% Append = /Fbld/Markup%.Append;

<@>@ M@ = /Fbld/Parse/M%.M@;
<@>@ M_@ = /Fbld/Parse/M%.M_@;
<@>% M = /Fbld/Parse/M%.M;
<@>% Return = /Fbld/Parse/M%.Return;
<@>% Return_ = /Fbld/Parse/M%.Return_;
<@>% Error = /Fbld/Parse/M%.Error;
<@>% Error_ = /Fbld/Parse/M%.Error_;
<@>% Do = /Fbld/Parse/M%.Do;
<@>% Do_ = /Fbld/Parse/M%.Do_;
% Loc = /Fbld/Parse/M%.Loc;
% Loc_ = /Fbld/Parse/M%.Loc_;
% Get = /Fbld/Parse/M%.Get;
% Get_ = /Fbld/Parse/M%.Get_;
% GetIndent_ = /Fbld/Parse/M%.GetIndent_;
<@>% Try_ = /Fbld/Parse/M%.Try_;
<@>% _Try_ = /Fbld/Parse/M%._Try_;
<@>% Test = /Fbld/Parse/M%.Test;
<@>% Test_ = /Fbld/Parse/M%.Test_;
<@>% _Test_ = /Fbld/Parse/M%._Test_;
% String = /Fbld/Parse/M%.String;
% String_ = /Fbld/Parse/M%.String_;
% Or_ = /Fbld/Parse/M%.Or_;
% EndOfInput_ = /Fbld/Parse/M%.EndOfInput_;
<@>% Indented = /Fbld/Parse/M%.Indented;

% Inline = /Fbld/Parse/Inline%.Inline;
% Name = /Fbld/Parse/Inline%.Name;
% InlineArgs = /Fbld/Parse/Inline%.Args;

# Parses a blank line. Fails if we aren't at a blank line.
M_@<Unit@> BlankLine = {
  Loc@ l <- Do_(Loc_);
  Int@ indent <- Do_(GetIndent_);
  /Core/Int/Eq%.Lt(Incr(indent), l.col).?(true: {
    Error_<Unit@>;
  });
  String_(StrE|'\n');
};

M_@<Unit@> SkipBlankLines = {
  Bool@ blank <- Do_(_Try_(BlankLine));
  blank.?(true: SkipBlankLines);
  Return_(Unit);
};

M_@<Unit@> BlankToEnd = {
  Unit@ _ <- Do_(SkipBlankLines);
  EndOfInput_;
};

# Parses raw text to end of file
M@<String@> Raw = {
  # TODO: For now we don't include blank lines at the end. It's not clear if
  # this is the right behavior though.
  Bool@ end <- Do(Try_(BlankToEnd));
  end.?(true: Return(Str|''));

  Char@ head <- Do(Get);
  String@ tail <- Do(Raw);
  Return(Cons(head, tail));
};

# Parses the rest of the args for a block command.
(Loc@, String@, List@<Markup@>) { M@<Markup@>; }
Args = (Loc@ l, String@ name, List@<Markup@> args) {
  List@<Markup@> inline_args <- Do(InlineArgs);

  M_@<Unit@> EndOfSameLine = Or_(String_(StrE|'\n'),
    Or_(String_(StrE|' @\n'), String_(StrE|' @@\n')));

  List@<Markup@> same_line <- Do({
    Bool@ none <- Do(Test_(EndOfSameLine));
    none.?(true: Return(Nil<Markup@>));

    Unit@ _ <- Do(String|' ');
    Markup@ m <- Do(Inline({
      Bool@ end <- Do_(_Test_(EndOfSameLine));
      end.?(true: Return_(Unit));
      Error_<Unit@>;
    }));
    Return(List[m]);
  });

  Bool@ final_same_line <- Do(Try_(String_(StrE|' @@\n')));
  final_same_line.?(true: {
    Markup@ arg <- Do(Block);
    Return(/Fbld/Markup%.Command(l, name)(Concat[
        args, inline_args, same_line, List[arg]]));
  });

  List@<Markup@> literal <- Do({
    Bool@ none <- Do(Try_(String_(StrE|'\n')));
    none.?(true: Return(Nil<Markup@>));

    Unit@ _ <- Do(String(StrE|' @\n'));
    Markup@ e <- Do(Indented({
      Loc@ l <- Do(Loc);
      String@ raw <- Do(Raw);
      Return(/Fbld/Markup%.Plain(l, raw));
    }));
    Return(List[e]);
  });

  List@<Markup@> next <- Do({
    Bool@ present <- Do(Try_(String_|' '));
    present.?(false: Return(Nil<Markup@>));
    Markup@ m <- Do(Indented(Block));
    Return(List[m]);
  });

  Bool@ final <- Do(Try_(String_(StrE|'@@\n')));
  final.?(true: {
    Markup@ arg <- Do(Block);
    Return(/Fbld/Markup%.Command(l, name)(Concat[
        args, inline_args, same_line, literal, next, List[arg]]));
  });

  Bool@ continue <- Do(Test_(Or_(String_|'@ ', String_|'@[')));
  continue.?(true: {
    Unit@ _ <- Do(String|'@');
    Args(l, name, Concat[
      args, inline_args, same_line, literal, next]);
  });

  Return(/Fbld/Markup%.Command(l, name)(Concat[
      args, inline_args, same_line, literal, next]));
},

# Parses a command starting just after the initial '@'.
M@<Markup@> Command = {
  Loc@ l <- Do(Loc);
  String@ name <- Do(Name);
  name.?(nil: Error<Markup@>(l, Str|'missing command name'));

  Args(l, name, Nil<Markup@>);
},

# Parses block structured text.
M@<Markup@> Block = {
  Unit@ _ <- Do(M(SkipBlankLines));

  Bool@ cmd <- Do(Try_(String_|'@'));
  cmd.?(true: {
    Markup@ command <- Do(Command);
    Markup@ tail <- Do(Block);
    Return(Append(command, tail));
  });

  Loc@ loc <- Do(Loc);
  Maybe@<Char@> c <- Do(Test(Get_));
  c.?(nothing: Return(Empty));

  Markup@ inline <- Do(Inline(Or_(EndOfInput_, BlankLine)));
  Markup@ tail <- Do(Block);
  Return(Append(/Fbld/Markup%.Command(loc, Str|'.block')[inline], tail));
};

@(Block);
