
@ Bool@ = /Bool%.Bool@;
% True = /Bool%.True;
% False = /Bool%.False;
% And = /Bool%.And;
% Not = /Bool%.Not;

% Chars = /Char%.Chars;

<@>@ List@ = /List%.List@;
<@>% Nil = /List%.Nil;
<@>% Cons = /List%.Cons;

<@>@ Maybe@ = /Maybe%.Maybe@;

% Str = /String%.Str;

<@>@ Structured@ = /Structured%.Structured@;

@ Test@ = /Test%.Test@;
@ TestResult@ = /Test%.TestResult@;
@ TestSuite@ = /Test%.TestSuite@;
% TestSuite = /Test%.TestSuite;

@ Unit@ = /Unit%.Unit@;
% Unit = /Unit%.Unit;

% UnitS = /Structure%.UnitS;
% LeftS = /Structure%.LeftS;
% RightS = /Structure%.RightS;
% PairS = /Structure%.PairS;

@ Bit1@ = +(Unit@ 0, Unit@ 1);
@ Bit2@ = *(Bit1@ h, Bit1@ l);

Bit2@ A = Bit2@(Bit1@(0: Unit), Bit1@(0: Unit));
Bit2@ B = Bit2@(Bit1@(0: Unit), Bit1@(1: Unit));
Bit2@ C = Bit2@(Bit1@(1: Unit), Bit1@(0: Unit));

(Bit1@, Bit1@) { Bool@; } EqBit1 = (Bit1@ a, Bit1@ b) {
  a.?(0: b.?(0: True, 1: False),
      1: b.?(0: False, 1: True));
};

(Bit2@, Bit2@) { Bool@; } EqBit2 = (Bit2@ a, Bit2@ b) {
  And(EqBit1(a.h, b.h), EqBit1(a.l, b.l));
};

Structured@<Bit2@> Bit2S = (Bit2@ x) {
  PairS(
    x.h.?(0: LeftS(UnitS), 1: RightS(UnitS)),
    x.l.?(0: LeftS(UnitS), 1: RightS(UnitS)));
};

<@>@ Map@ = /Map%.Map@<Bit2@>;
<@>% Empty = /Map%.Empty<Bit2@>;
<@>% Lookup = /Map%.Lookup<Bit2@>(Bit2S);
<@>% Insert = /Map%.Insert<Bit2@>(Bit2S);
<@,@>% ForEach = /Map%.ForEach<Bit2@>;


TestSuite@ Tests = TestSuite(Chars|Map, [
  Test@(Str(Chars|'empty'), !({
    Lookup<Unit@>(Empty<Unit@>, B).?(
      just: TestResult@(fail:
        Str(Chars|'Lookup found something in an empty map')),
      nothing: TestResult@(pass: Unit));
  })),

  Test@(Str(Chars|'not found'), !({
    Map@<Unit@> map = Insert<Unit@>(Empty<Unit@>, C, Unit);
    Lookup<Unit@>(map, B).?(
      just: TestResult@(fail:
        Str(Chars|'Lookup found B in a map with only C')),
      nothing: TestResult@(pass: Unit));
  })),

  Test@(Str(Chars|'found'), !({
    Map@<Bool@> map = Insert<Bool@>(Insert<Bool@>(Insert<Bool@>(Empty<Bool@>,
      A, False),
      B, True),
      C, False);
    Maybe@<Bool@> mv = Lookup<Bool@>(map, B);
    mv.?(
      just:
        mv.just.?(
          true: TestResult@(pass: Unit),
          false: TestResult@(fail:
            Str(Chars|'Wrong value found for B.'))
        ),
      nothing: TestResult@(fail:
        Str(Chars|'Failed to find B in map.')));
  })),

  Test@(Str(Chars|'replace'), !({
    Map@<Bool@> map = Insert<Bool@>(Insert<Bool@>(Empty<Bool@>,
      B, False),
      B, True);
    Maybe@<Bool@> mv = Lookup<Bool@>(map, B);
    mv.?(
      just:
        mv.just.?(
          true: TestResult@(pass: Unit),
          false: TestResult@(fail:
            Str(Chars|'Wrong value found for B.'))
        ),
      nothing: TestResult@(fail:
        Str(Chars|'Failed to find B in map.')));
  })),

  Test@(Str(Chars|'for'), !({
    Map@<Bool@> map =
      Insert<Bool@>(
        Insert<Bool@>(
          Insert<Bool@>(Empty<Bool@>,
            B, True),
          A, True),
        B, False);
    @ Entry@ = *(Bit2@ key, Bool@ value);
    List@<Entry@> entries = ForEach<Bool@, List@<Entry@>>(map, Nil<Entry@>,
      (Bit2@ k, Bool@ v, List@<Entry@> l) {
        Cons<Entry@>(Entry@(k, v), l);
      });

    entries.?(
      cons:
        entries.cons.tail.?(
          cons:
            entries.cons.tail.cons.tail.?(
              cons: TestResult@(fail: Str(Chars|'Too many entries.')),
              nil: {
                % _ = EqBit2(A, entries.cons.head.key).?(
                  true: @(a: entries.cons.head, 
                          b: entries.cons.tail.cons.head),
                  false: @(a: entries.cons.tail.cons.head, 
                           b: entries.cons.head));
                And(And(EqBit2(A, _.a.key), EqBit2(B, _.b.key)),
                      And(_.a.value, Not(_.b.value))).?(
                  true: TestResult@(pass: Unit),
                  false: TestResult@(fail: Str(Chars|'key/value mismatch'))
                );
              }),
          nil: TestResult@(fail: Str(Chars|'Only 1 entry iterated over.'))),
      nil: TestResult@(fail: Str(Chars|'No entries iterated over.')));
  }))
]);

@(Tests);
