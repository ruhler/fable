
@ Bool@ = /Bool%.Bool@;
% True = /Bool%.True;
% False = /Bool%.False;
% And = /Bool%.And;
% Or = /Bool%.Or;
% Not = /Bool%.Not;

@ Int@ = /Int/Int%.Int@; 
% Inc = /Int/Int%.Inc;

<@>@ List@ = /List%.List@;

<@>@ Maybe@ = /Maybe%.Maybe@;
<@>% Just = /Maybe%.Just;
<@>% Nothing = /Maybe%.Nothing;

@ Unit@ = /Unit%.Unit@;
% Unit = /Unit%.Unit;

@ Coord@ = *(Int@ x, Int@ y);

/Eq%.Eq@<Coord@> CoordLt = {
  % IntEq = /Int/Int/Eq%.Eq;
  % IntLt = /Int/Int/Eq%.Lt;
  (Coord@ a, Coord@ b) {
    Or(IntLt(a.x, b.x), And(IntEq(a.x, b.x), IntLt(a.y, b.y)));
  };
};

/Eq%.Eq@<Coord@> CoordEq = {
  % IntEq = /Int/Int/Eq%.Eq;
  (Coord@ a, Coord@ b) {
    And(IntEq(a.x, b.x), IntEq(a.y, b.y));
  };
};

@ Data@ = +(Unit@ 0, Unit@ 1);
Data@ 0 = Data@(0: Unit);
Data@ 1 = Data@(1: Unit);

# PortSpec@ --
#   Describes how a given port is used in a gate.
@ PortSpec@ = *(Bool@ input, Bool@ output);
PortSpec@ InputPort = PortSpec@(True, False);
PortSpec@ OutputPort = PortSpec@(False, True);
PortSpec@ IOPort = PortSpec@(True, True);
PortSpec@ UnusedPort = PortSpec@(False, False);

<@>@ Ports@ = <@ T@> { *(T@ ul, T@ ur, T@ ll, T@ lr); };

# GateFunction@ --
#   Describes the behavior of a gate when it is triggered. The input is the
#   data value for each port, where 0 is passed for any non-input port. The
#   output is a new data value for each port, where values for non-output
#   ports are ignored. This allows us to have a uniform gate function
#   specification regardless of how the gate's ports are configured as
#   input/output/unused ports.
@ GateFunction@ = (Ports@<Data@>) { Ports@<Data@>; };

@ Gate@ = *(Ports@<PortSpec@> ports, GateFunction@ function);

@ Cells@ = /Map%.Map@<Coord@, Data@>;
@ GateEntry@ = *(Coord@ coord, Gate@ gate);
@ Gates@ = /List%.List@<GateEntry@>;

# EmptyCells -- 
#  An empty array of data cells.
Cells@ EmptyCells = /Map%.Empty<Coord@, Data@>;

# EmptyGates --
#  An empty array of gates.
Gates@ EmptyGates = /List%.Nil<GateEntry@>;

# GetData --
#   Get the data of a particular cell.
(Cells@, Coord@) { Maybe@<Data@>; } GetData = {
  /Map%.Lookup<Coord@>(CoordLt)<Data@>;
};

# SetData --
#   Set the data value of the given cell.
(Cells@, Coord@, Data@) { Cells@; } SetData = {
  /Map%.Insert<Coord@>(CoordLt)<Data@>;
};

# ClearData --
#   Clear the data value of the given cell, leaving the cell empty.
(Cells@, Coord@) { Cells@; } ClearData = {
  /Map%.Delete<Coord@>(CoordLt)<Data@>;
};

# SetGate --
#   Configure the gate whose upper left corner is at the given coordinates of
#   the layout.
(Gates@, Coord@, Gate@) { Gates@; }
SetGate = (Gates@ gates, Coord@ coord, Gate@ gate) {
  /List%.Cons<GateEntry@>(@(coord, gate), gates);
};

# Gates --
#   Specify a complete Gates configuration.
#
# Example Use:
#   Gates@ gates = Gates(List<GateEntry@>[@(coord: c1, gate: g1), @(coord: c2, gate: g2), ...]);
(List@<GateEntry@>) { Gates@; } Gates = (List@<GateEntry@> l) { l; };

# ForEachGate --
#   Iterate over a set of gates.
#
# Conceptually:
#   B@ b = base
#   foreach (coord, gate) in gates:
#     b = body(coord, gates, b)
#   return b
<@ B@>(Gates@, B@, (Coord@, Gate@, B@) { B@; }) { B@; }
ForEachGate = <@ B@>(Gates@ gates, B@ base, (Coord@, Gate@, B@) { B@; } body) {
  /List%.ForEach<GateEntry@, B@>(gates, base, (GateEntry@ ge, B@ b) {
    body(ge.coord, ge.gate, b);
  });
};

# Step --
#   Run a single step of the hardware.
#
# Returns the update data cells, or Nothing if no gates are enabled. The exact
# meaning of a single step is not currently well specified.
#
# TODO: Test and fix the case when conflicting gates are simultaneously
# enabled.
(Gates@, Cells@) { Maybe@<Cells@>; } Step = {
  (PortSpec@, Maybe@<Data@>) { Bool@; } Blocked = (PortSpec@ ps, Maybe@<Data@> d) {
    Bool@ empty = d.?(just: False, nothing: True);
    And(ps.input, empty).?(true: True);
    And(ps.output, And(Not(ps.input), Not(empty)));
  };

  (PortSpec@, Maybe@<Data@>) { Data@; } InputData = (PortSpec@ ps, Maybe@<Data@> d) {
    Not(ps.input).?(true: 0);
    d.?(nothing: 0);
    d.just;
  };

  @ B@ = *(Cells@ cells, Bool@ updated);
  (B@, Coord@, PortSpec@, Data@) { B@; } UpdateResult = (B@ b, Coord@ c, PortSpec@ ps, Data@ d) {
    ps.output.?(true: @(cells: SetData(b.cells, c, d), updated: True));
    ps.input.?(true: @(cells: ClearData(b.cells, c), updated: True));
    b;
  };

  (Gates@ gates, Cells@ cells) {
    B@ b = ForEachGate<B@>(gates, B@(cells, False),
      (Coord@ c, Gate@ g, B@ b) {
        Ports@<Coord@> coords = Ports@<Coord@>(
          Coord@(c.x, c.y),
          Coord@(Inc(c.x), c.y),
          Coord@(c.x, Inc(c.y)),
          Coord@(Inc(c.x), Inc(c.y)));

        Ports@<Maybe@<Data@>> data = Ports@<Maybe@<Data@>>(
          GetData(cells, coords.ul), GetData(cells, coords.ur),
          GetData(cells, coords.ll), GetData(cells, coords.lr));

        Bool@ blocked_ul = Blocked(g.ports.ul, data.ul);
        Bool@ blocked_ur = Or(blocked_ul, Blocked(g.ports.ur, data.ur));
        Bool@ blocked_ll = Or(blocked_ur, Blocked(g.ports.ll, data.ll));
        Bool@ blocked_lr = Or(blocked_ll, Blocked(g.ports.lr, data.lr));

        blocked_lr.?(
          true: b,
          false: {
            Ports@<Data@> inputs = Ports@<Data@>(
              InputData(g.ports.ul, data.ul),
              InputData(g.ports.ur, data.ur),
              InputData(g.ports.ll, data.ll),
              InputData(g.ports.lr, data.lr));

            Ports@<Data@> outputs = g.function(inputs);
            B@ b_ul = UpdateResult(b, coords.ul, g.ports.ul, outputs.ul);
            B@ b_ur = UpdateResult(b_ul, coords.ur, g.ports.ur, outputs.ur);
            B@ b_ll = UpdateResult(b_ur, coords.ll, g.ports.ll, outputs.ll);
            B@ b_lr = UpdateResult(b_ll, coords.lr, g.ports.lr, outputs.lr);
            b_lr;
          });
      });
    b.updated.?(true: Just<Cells@>(b.cells), false: Nothing<Cells@>);
  };
};

# Run --
#   Run the given hardware layout as long as any gates are enabled.
(Gates@, Cells@) { Cells@; } Run = (Gates@ gates, Cells@ cells) {
  Maybe@<Cells@> mc = Step(gates, cells);
  mc.?(just: Run(gates, mc.just), nothing: cells);
};

@(Cells@, Gates@, GateEntry@, Coord@, Data@, Gate@, Ports@, PortSpec@,
  0, 1, InputPort, OutputPort, IOPort, UnusedPort, CoordEq,
  EmptyCells, GetData, SetData, ClearData, EmptyGates, Gates, SetGate, ForEachGate,
  Step, Run);
