@(Unit@, Bool@: Bool.Bool@) {
  # P - A list of 1 or more elements: T+
  # S - A list of 0 or more elements: T*
  \<@ ; @> P@ = \<@ T@> { *(T@ head, S@<T@> tail); },
  \<@ ; @> S@ = \<@ T@> { +(P@<T@> cons, Unit@ nil); };

  \<@ T@> { \(S@<T@> l; T@); } HeadS = \<@ T@> {
    \(S@<T@> l) {
      l.cons.head;
    };
  };

  \<@ T@> { \(T@ a, S@<T@> l; S@<T@>); } ConsS = \<@ T@> {
    \(T@ a, S@<T@> l) {
      S@<T@>(cons: P@<T@>(a, l));
    };
  };

  # Append list b to the end of list a.
  \<@ T@> { \(S@<T@> a, S@<T@> b; S@<T@>); } Append = \<@ T@> {
    \(S@<T@> a, S@<T@> b) {
      ?(a; cons: ConsS<T@>(a.cons.head, Append<T@>(a.cons.tail, b)), nil: b);
    };
  };

  \<@ T@> { S@<T@>; } S0 = \<@ T@> {
    S@<T@>(nil: Unit@());
  };

  \<@ T@> { \(T@ a; S@<T@>); } S1 = \<@ T@> {
    \(T@ a) {
      ConsS<T@>(a, S0<T@>);
    };
  };

  \<@ T@> { \(T@ a, T@ b; S@<T@>); } S2 = \<@ T@> {
    \(T@ a, T@ b) {
      ConsS<T@>(a, S1<T@>(b));
    };
  };

  \<@ T@> { \(T@ a, T@ b, T@ c; S@<T@>); } S3 = \<@ T@> {
    \(T@ a, T@ b, T@ c) {
      ConsS<T@>(a, S2<T@>(b, c));
    };
  };

  \<@ T@> { \(T@ a, T@ b, T@ c, T@ d; S@<T@>); } S4 = \<@ T@> {
    \(T@ a, T@ b, T@ c, T@ d) {
      ConsS<T@>(a, S3<T@>(b, c, d));
    };
  };

  \<@ T@> { \(T@ a, T@ b, T@ c, T@ d, T@ e; S@<T@>); } S5 = \<@ T@> {
    \(T@ a, T@ b, T@ c, T@ d, T@ e) {
      ConsS<T@>(a, S4<T@>(b, c, d, e));
    };
  };

  \<@ T@> { \(T@ a, T@ b, T@ c, T@ d, T@ e, T@ f, T@ g, T@ h, T@ i; S@<T@>); } S9 = \<@ T@> {
    \(T@ a, T@ b, T@ c, T@ d, T@ e, T@ f, T@ g, T@ h, T@ i) {
      Append<T@>(S5<T@>(a, b, c, d, e), S4<T@>(f, g, h, i));
    };
  };

  # InitP - Return all but the last element in 'list'.
  \<@ T@> { \(P@<T@> list; S@<T@>); } InitP = \<@ T@> {
    \(P@<T@> list) {
      ?(list.tail; cons: ConsS<T@>(list.head, InitP<T@>(list.tail.cons)), nil: S0<T@>);
    };
  };

  # LastP - Return the last element in 'list'.
  func LastP<type T>(P<T> list; T) {
    ?(list.tail; cons: LastP<T>(list.tail.cons), nil: list.head);
  };

  # Concat: Flatten a list of lists into a single list of all the elements.
  func Concat<type T>(S<S<T>> x; S<T>) {
    ?(x; cons: Append<T>(x.cons.head, Concat<T>(x.cons.tail)), nil: S0<T>());
  };

  func MapS<type A, type B, func F(A x; B)>(S<A> a; S<B>) {
    ?(a; cons: S<B>:cons(MapP<A, B, F>(a.cons)), nil: S<B>:nil(Unit()));
  };

  func MapP<type A, type B, func F(A x; B)>(P<A> a; P<B>) {
    P<B>(F(a.head), MapS<A, B, F>(a.tail));
  };

  # Sort the given list of elements, using LE for the comparisons.
  func SortS<type T, func LE(T a, T b; Bool)>(S<T> l; S<T>) {
    ?(l; cons: S<T>:cons(SortP<T, LE>(l.cons)), nil: l);
  };

  # Insert the element 'x' into 'l' at the sorted position based on the LE
  # comparision function.
  priv func SortInsert<type T, func LE(T a, T b; Bool)>(T x, S<T> l; P<T>) {
    ?(l; cons: ?(LE(x, l.cons.head);
                  true: P<T>(x, l),
                  false: P<T>(l.cons.head, S<T>:cons(SortInsert<T, LE>(x, l.cons.tail)))),
         nil: P<T>(x, S<T>:nil(Unit())));
  };

  # Sort the given list of elements, using LE for the comparisons.
  # TODO: Use something more efficient than an insertion sort.
  func SortP<type T, func LE(T a, T b; Bool)>(P<T> l; P<T>) {
    SortInsert<T, LE>(l.head, SortS<T, LE>(l.tail));
  };

  @(P@, S@,
    HeadS, ConsS, Append, S0, S1, S2, S3, S4, S5, S9,
    InitP, LastP, Concat, MapS, MapP, SortS, SortP);
};
