
import @ { StdLib; };

module Hex;
module Bit;
module Bit1(BitNI<Bit@Bit>);

module Bit2 {
  import @ { Bit@Bit; Bit1; BitNI; Bit2XN; };

  struct Bit2(Bit hi, Bit lo);
  module BitN(BitNI<Bit2>) = Bit2XN<Bit, Bit1, Bit2>;
};

module Bit8;
module Bit16;
module Bit32;
module Bit64;

# TODO: Put the body of this into its own file once that is supported.
interf BitNI<type T> {
  import @ { T; Bit@Bit; Bool@Bool@StdLib; };

  func not(T a ; T);        # !a
  func and(T a, T b; T);    # a & b
  func or(T a, T b; T);     # a | b
  func xor(T a, T b; T);    # a ^ b
  func add(T a, T b; T);    # a + b
  func zero(; T);           # 0
  func iszero(T a; Bool);   # a == 0
  func eq(T a, T b; Bool);  # a == b
  func msb(T a; Bit);       # most significant bit
  func clshift(T a; T);     # circular left shift by 1

  struct Result(T z, Bit cout);
  func fulladd(T a, T b, Bit cin; Result);
  func lshift(T a, Bit cin; Result); # left shift by 1
};

module Bit2XN<
  type T,
  module B(BitNI<T>),
  struct Bit2X(T hi, T lo)>(BitNI<Bit2X>);
