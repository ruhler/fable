
@ Bool@ = /Bool%.Bool@;
% True = /Bool%.True;
% False = /Bool%.False;

@ IntP@ = /Int/IntP%.IntP@;

@ Int@ = /Int/Int%.Int@;
% Inc = /Int/Int%.Inc;
% Dec = /Int/Int%.Dec;

% IsZero = /Int/Int/Eq%.IsZero;

<@>@ List@ = /List%.List@;
<@>% List = /List%.List;
<@,@>% ForEach = /List%.ForEach;

<@,@>@ Lit@ = /Literal%.Lit@;

<@>% Map = /Map%.Map;

<@>@ Maybe@ = /Maybe%.Maybe@;

% UnitS = /Structure%.UnitS;
% LeftS = /Structure%.LeftS;
% RightS = /Structure%.RightS;
% PairS = /Structure%.PairS;
<@>@ Structured@ = /Structured%.Structured@;

@ Unit@ = /Unit%.Unit@;
% Unit = /Unit%.Unit;

@ Coord@ = *(Int@ row, Int@ col);

Structured@<IntP@> NatS = (IntP@ n) {
  n.?(1: UnitS, 2p0: LeftS(NatS(n.2p0)), 2p1: RightS(NatS(n.2p1)));
};

Structured@<Int@> IntS = (Int@ n) {
  n.?(n: LeftS(NatS(n.n)), 0: UnitS, p: RightS(NatS(n.p)));
};

Structured@<Coord@> CoordS = (Coord@ c) {
  PairS(IntS(c.row), IntS(c.col));
};

# The world is a set of Coord@ where there are live cells.
% MapCoord = Map<Coord@>(CoordS);
@ World@ = MapCoord.Map@<Unit@>;
% EqWorld = (World@ a, World@ b) {
   MapCoord.Equals<Unit@>((Unit@ _a, Unit@ _b) { True; }, a, b);
};
% W = @(
  Empty: /Map%.Empty<Coord@, Unit@>,
  Insert: /Map%.Insert<Coord@>(CoordS)<Unit@>,
  For: /Map%.For<Coord@, Unit@>
);

# Create a world from a list of coordinates of live cells.
(Lit@<Coord@>){ World@; } World = (Lit@<Coord@> mkCells) {
  mkCells<World@>(
    (Coord@ c, World@ w) {
      W.Insert(w, c, Unit);
    },
    W.Empty);
};

# A count of neighboring cells. 4p stands for anything greater than or equal
# to 4.
@ Count@ = +(Unit@ 0, Unit@ 1, Unit@ 2, Unit@ 3, Unit@ 4p);

(Count@) { Count@; } IncCount = (Count@ c) {
  c.?(0: Count@(1: Unit),
      1: Count@(2: Unit),
      2: Count@(3: Unit),
      3: Count@(4p: Unit),
      4p: Count@(4p: Unit));
};

@ Status@ = *(Bool@ alive, Count@ neighbors);

# Returns true if a cell with the given status should be a live cell in the
# next generation.
(Status@) { Bool@; } Lives = (Status@ status) {
  status.alive.?(
      true: status.neighbors.?(2: True, 3: True, : False),
      false: status.neighbors.?(3: True, : False));
};

# Map from Coord to the status of the cell.
@ Cand@ = MapCoord.Map@<Status@>;
% C = @(
  Empty: /Map%.Empty<Coord@, Status@>,
  InsertWith: MapCoord.InsertWith<Status@>,
  For: /Map%.For<Coord@, Status@>
);

# Advance the world by one unit of time.
(World@) { World@; } Step = (World@ w) {
  # 1. Create the candidate map.
  #   For each cell in world,
  #     Set this cell alive in candidate
  #     Inc neighbors for each neighbor cell
  Cand@ candidates = W.For<Cand@>(w, C.Empty,
    (Coord@ coord, Unit@ _, Cand@ cand_in) {
      Cand@ cand_alive = C.InsertWith(cand_in, coord, (Maybe@<Status@> ms) {
        ms.?(just: Status@(True, ms.just.neighbors),
             nothing: Status@(True, Count@(0: Unit)));
      });

      List@<Coord@> neighbors = List<Coord@>([
        Coord@(Dec(coord.row), Dec(coord.col)),
        Coord@(Dec(coord.row),     coord.col ),
        Coord@(Dec(coord.row), Inc(coord.col)),
        Coord@(    coord.row , Dec(coord.col)),
        Coord@(    coord.row , Inc(coord.col)),
        Coord@(Inc(coord.row), Dec(coord.col)),
        Coord@(Inc(coord.row),     coord.col ),
        Coord@(Inc(coord.row), Inc(coord.col))]);

      ForEach<Coord@, Cand@>(neighbors, cand_alive, (Coord@ n, Cand@ c) {
        C.InsertWith(c, n, (Maybe@<Status@> ms) {
          ms.?(just: Status@(ms.just.alive, IncCount(ms.just.neighbors)),
               nothing: Status@(False, Count@(1: Unit)));
        });
      });
    }
  );

  # 2. Filter live cells from the map.
  C.For<World@>(candidates, W.Empty,
    (Coord@ coord, Status@ status, World@ w_in) {
    Lives(status).?(
       true: W.Insert(w_in, coord, Unit),
       false: w_in);
  });
};

(Int@, World@) { World@; } StepN = (Int@ n, World@ w) {
  IsZero(n).?(true: w, false: StepN(Dec(n), Step(w)));
};

@(Coord@, World@, World, ForWorld: W.For, EqWorld, Step, StepN);
