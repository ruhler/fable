* [lang] Draft revision of spec for modules. Test and implement.
 - Add parser support for loading dependent modules.
 - Port all prgms to use modules.
 - Remove 'include' support.

* [lang] Document and test that variable declarations shadow other variables.

* [prgm] TicTacToe cleanup
 - Switch to using shared modules.
 - Use monads, monoids, and maps and such to simplify ChooseBestMove.
 - Hook up to the 'Test' infrastructure (assuming the tests are fast enough to
   run).
* [prgm] Game of Life

* [clean] Better error message at runtime in case of:
      S@<Foo@> s = ...
      S@<Foo@> s = s.cons.tail;
  Currently we get a TaggedPop assertion error at runtime, which is no good.
* [clean] PrintKind for <@>@ shows up as \<@; @>. Fix that.
* [clean] Nicer way of printing error messages in compiler
 - particularly those that include names and types inside of them.
* [test] Rename tests to match new spec, and clean up tests.
   typeof, var, let,
   func_bind
   proc_link, proc_exec
   poly_value, poly_apply
* [prgm] Optimize Md5.cls function
  - change << and >> to take number of bits to shift instead of a single bit.
  - change cls to use or(x << n, x >> (K - n))
* [prgm] Optimize the fble implementation of tictactoe
  - Using monadic operations where feasible?
* [prgm] Implement game of life.
* [clean] Tracking of time in the compiler is really messy
  Especially that we extract the pointer to the time field from NewBlock by
  assuming what NewBlock does. Figure out some way to clean this up.
* [clean] Figure out a nicer way to deal with fble-ref-test having access to
  internal ref.h
* [perf] Collect benchmarks somewhere?
  - md5 run on 6k file. ~7 minutes
  - tictactoe find best move for empty board. ~50 minutes
* [clean] Factor out common code for thunks used by func, link, and exec.
* [perf] figure out how to use 'perf' for profiling?
  perf record --call-graph dwarf [COMMAND]
  perf report -g --stdio
* [build] move 'perf' logic to build.fble.tcl
* [test] multi arg func, poly, kind are equivalent to nested single arg.
* [perf] Optimize FbleRefAdd
* [perf] Store scope size as part of InstrBlock and use an array for vars.
 - replace all AddToVector callbacks in ref.c if feasible.
* Test that explicit type struct values can take type args and poly args?
  And same for all other kinds of struct expressions.
* Update abstract syntax and parser to match spec.
  - in terms of names of things and order of things.
* Test namespace eval with mixed type and normal fields.
* Better error messages on types that have the same name but different values.
* Figure out how to make a version of 7.4-06-* for values.
* Test what gets evaluated at eval vs. exec time for each kind of process.
* Make sure all "see documentation in ..." lines are accurate.
* Improve test coverage around polymorphic types.
* Test that we don't smash the stack with many nested child threads.
* Test that we don't leak (Thread) memory with tail recursive single binding
  exec processes.
* Pick a better name for FbleChoice, which is used now for more than just
  conditional expressions. Maybe FbleNamedValue? NamedExpr?
* Better error message when the difference between a type is accidentally
  defining + vs. *, and it contains substituted polymorphic type variables.
* Use consistent style for error messages. Capitalize? Punctuate?
* Port rest of fbld tests and programs to fble.
  - Sudoku partial draft
  - fblc spec test coverage
  - fbld spec test coverage
* It's very unintuitive that $(f(...)) calls f(...) before executing the
  process $(...). Clarify the spec on that and make sure we implement it
  correctly. And think about the other kinds of procs too, like put and get.
* Remove iquota from Thread data structure. It should be managed separately.

Fble Lib:
* Should Eq just be a function or an interface?
* Write Test library.
* Random number generator / tester?

Fble App Ideas:
* compress/deflate
* snake - text based and graphics
* tictactoe - text based and graphics
* space invaders
* scrabble crush
* 2d minigolf
* game of life

Space Invaders:
* Render objects - how to test?
  manual test: Draw all objects to the screen as a gallery of them.
* Game loop driven by timer - how to test? 
  manual test: Have app with just ship that can be moved left and right (and
  fire bullets into space?)
* Pseudo-random bullet attack, UFO - how to test?
* Collision detection

Snake:
* Make food appear randomly instead of at the tail.
* Speed up the snake every time it eats something.
* Test and fix bug when snake eats its tail.
* Ignore moves that aren't orthogonal to current snake direction.
* Keep track of and report score.

Game of Life:
* live if
  A. is alive and have 2 or 3 live neighbors
  B. is dead and have 3 live neighbors

Miscellaneous:
* Use consistent naming in spec tests to distinguish between:
  - Something with the wrong syntax, such as ???. "malformed"
  - Something that cannot be typed, such as x, when x is not defined.  "maltyped"
  - Something with the wrong type, such as Donut(), when Unit() is expected. "mistyped"

* Test that tail recursive procedures don't smash the stack.
  - And document the performance model which says tail recursive functions
    should not smash the stack.

* Write man pages for fble and friends?

* Rethink arenas and documentation, because some cases appear to assume you
  have a bulk-free arena. Other cases its not well specified what is freed
  explicitly and what is expected to be freed implicitly.

  I claim a good model is: pass an arena to a function to say: the function
  allocates its result in this arena. The function creates and uses a separate
  arena for its intermediate allocations.

* Document performance model.
  Specifically that we use strict evaluation to model performance because it
  is a simple model, which is essential for writing high performance code.
  Lazy evaluation is not 'performance modular' in the sense that the runtime
  of a function depends on how its arguments were computed and how its result
  is going to be used, rather than just the value of arguments. Lazy
  evaluation has some benefits I'll miss, but not nearly enough to justify
  loss of a simple, modular performance model. Implementations should focus on
  improving constant factors, not improving complexity over the performance
  model.

Future:
* Implement compiler to C. Idea is translate a function body into a sequence
  of commands like we have in the current interpreter. Split the command
  sequence into blocks any place there is a function call. Gather up all the
  blocks of all the command sequences in the program, give each a unique name
  starting from zero, then generate a loop containing one large switch
  statement with a case for each block. Global state is a list of thread
  contexts. Thread context is a frame, which has variables, ports, the id of
  the block that currently needs to be executed, and a pointer to the frame to
  execute after executing this block.

* Implement compiler to hardware. Same idea as compiler to C: break up into
  blocks. Now each block can be its own hardware block. Frames are queued up
  at their block, all blocks can execute in parallel as inputs are available,
  and we can pipeline or duplicate the blocks to allow for even more
  parallelism.

* Implement an fble debugger. Where at minimum you can trace through source
  locations as the program executes. Maybe we want fancy stuff like viewing
  variables, breakpoints, setting values, etc... but mostly to start tracing
  through source locations.

