Fbld Test:
* Port remainder of fblc tests to fbld.
* Test case when struct or union type is not redeclared in mdefn from mdecl.
* Test case when an mdefn decl doesn't match its corresponding mdecl decl.
* Test case when abstract type is used as select for conditional.
* Test case when type from module not listed as a dependency is used as select
  for conditional.
* Test that all imported names exist in the module they are imported from.
* Test case when type from module not listed as a dependency is used as obj
  for field access.

Fbld Cleanup:
* Document that parse returns FBLC_NULL_ID for field ids and check fills in
  field ids. Ditto for var ids.
* Update comments on FbldCompile functions to clarify assumptions about the
  input program, namely that entity modules have already been resolved.
* Update comments on FbldCheck functions to clarify that module names are
  resolved as a side effect.
* Define an FbldNamesEqual function instead of using strcmp everywhere.
* Define FBLD_*_EXPR tags separate from FBLC_*_EXPR tags.
* Don't allocate and leak FbldLocs like crazy in the lexer/parser.
* Better organize the contents parse.y.
* Add support for returning multiple errors from check.
* Cleanup fbld types to have less pointers - don't include an indirection just
  because it makes parsing easier. Copy values in parser as needed instead.

Fbld Application:
* Set up vector graphics interface.
 - Define a basic vector-graphics interface suitable for drawing colored
   squares.
 - Write program to draw fixed set of colored squares on screen and quit on
   command.
 - Implement libsdl graphics interface so program is actually rendered to
   screen.

Fblc Front End Cleanup:
* Make fblcs structure standalone rather than tied to fblc structure.
 - Parser should create fblcs structure only.
 - Perform check entirely on fblcs structure before resolution.
 - Resolution to convert fblcs structure to (correct by construction) fblc
   structure.

General Cleanup:
 - Verify all document comments are present and up to date.
 - Document allocations for every function that takes an FblcArena,
   specifically, what the caller should do to free all allocations.
 - Increase test code coverage as much as reasonably possible.

MiniGolf Arc:
* Design 2D minigolf game and implement.

Snake Arc:
* Make food appear randomly instead of at the tail.
* Speed up the snake every time it eats something.
* Test and fix bug when snake eats its tail.
* Ignore moves that aren't orthoginal to current snake direction.
* Keep track of and report score.

Space Invaders Arc:
* Implement space invaders game in fbld.

Miscellanous:
* Add test to fblc-test that we don't leak memory in FblcExecute.
* Use consistent naming in spec tests to distinguish between:
  - Something with the wrong syntax, such as ???. "malformed"
  - Something that cannot be typed, such as x, when x is not defined.  "maltyped"
  - Something with the wrong type, such as Donut(), when Unit() is expected. "mistyped"

* Test that tail recursive functions and procedures don't smash the stack.
  - And document the performance model which says tail recursive functions
    should not smash the stack.
* Test that a link's type is valid.
* Test that a link action's ports can't shadow ports already in scope.
* Test that a link can't use the same name for the get and put ports.
* Test that a proc can't have multiple ports of the same name, with or without
  the same polarity.
* Test what happens when we try to access the wrong field of a union.

* Better document that for binary encodings of values, the top level value is
  guarenteed to take at least one bytes, regardless of whether or not it is
  part of a stream.

* Change fblc-check-error and friends to take the program last, and switch to
  a style where an anonymous program is passed rather than setting a $prg
  variable?

* Test writing a stream of Units
 - which requires some alignment be done.

* Test that error messages don't contain garbled characters.

* Write man pages for fblc and friends?

* Rethink arenas and documentation, because some cases appear to assume you
  have a bulk-free arena. Other cases its not well specified what is freed
  explicitly and what is expected to be freed implicitly.

* Document performance model.
  Specifically that we use strict evaluation to model performance because it
  is a simple model, which is essential for writing high performance code.
  Lazy evaluation is not 'performance modular' in the sense that the runtime
  of a function depends on how its arguments were computed and how its result
  is going to be used, rather than just the value of arguments. Lazy
  evaluation has some benefits I'll miss, but not nearly enough to justify
  loss of a simple, modular performance model. Implementations should focus on
  improving constant factors, not improving complexity over the performance
  model.

Future:
* Implement compiler to C. Idea is translate a function body into a sequence
  of commands like we have in the current interpreter. Split the command
  sequence into blocks any place there is a function call. Gather up all the
  blocks of all the command sequences in the program, give each a unique name
  starting from zero, then generate a loop containing one large switch
  statement with a case for each block. Global state is a list of thread
  contexts. Thread context is a frame, which has variables, ports, the id of
  the block that currently needs to be executed, and a pointer to the frame to
  execute after executing this block.

* Implement compiler to hardware. Same idea as compiler to C: break up into
  blocks. Now each block can be its own hardware block. Frames are queued up
  at their block, all blocks can execute in parallel as inputs are available,
  and we can pipeline or duplicate the blocks to allow for even more
  parallelism.

* Implement an fblc debugger. Where at minimum you can trace through source
  locations as the program executes. Maybe we want fancy stuff like viewing
  variables, breakpoints, setting values, etc... but mostly to start tracing
  through source locations.

* Implement fblc code coverage tool. Input is a program to run. Output is a
  list of error messages for each line of code not exercise by the program?

