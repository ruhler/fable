Fbld In C
=========
Goal is to implement fbld in C.

Benefits:
* Breaks circular dependency of usage files on libfble and fbld package. So we
  can clean up usage generated help.
* I expect fbld to run much faster, which should fix long build times.
* We can separate out fbld from fble into a separate repo if we want, for
  better modularity.
* It should give a nice baseline of expected performance for fbld in fble, and
  hopefully some ideas for how to improve fble performance.
* I'll get to see how fbld language compares to C.

I'll want a test suite separate from the fble-fbld based test suite,
preferably reusble by both implementations. I can build that up a little at a
time, and implement the C version as we go.

---

The main data structure for documents is clear. Just mirror the abstract
syntax in the fbld spec.

For test suite, I'm thinking something like fble. We definitely want to be
able to test for errors and error locations.

The most natural way to describe an fbld test, in my mind, is:

* Provide input fbld text.
* For error cases, provide location of error message.
* For passing cases, provide expected output.

For example, a passing test might look like:

  @asserteq @
   a: hello, b: there
  @@
  @define[foo][a b] a: @a, b: @b @@
  @foo[hello][there]

And a test expected to fail.

  @assertfail[4][5] @@
  @define[foo][a b] a: @a, b: @b @@
  @foo[hello][there]

The passing case we could implement entirely in fbld. We could define asserteq
as if not equal, error.

The failing case we need outside support for, because we can't get the error
message inside fbld. That suggests maybe we want:

@expect_error 4:1 @@
...

The wrapper script can grep for that signature at the top and handle it
appropriately.

Otherwise, run the conversion, ignore the output, make sure we don't get an
@error.

Sample test cases to start off with:

To verify we get errors as desired:

  @expect_error 2:1 @@
  @error This is an error.

To verify things pass as desired:

  Hello. This is text.

A test to assert the correct value of things:

  @define[assert_eq][a][b] @ifeq[@a][@b][][@error['@a' != '@b']] @@

Or, perhaps simpler:

  @ifeq
   Hello. This is text.
  @ @
   Hello. This is text.
  @[] @error[mismatch]
   
No. Better to have the assert_eq, so we see what the mismatch is in case of
failure.

Then we can do two tests to start:

  @expect_okay @@
  @define[assert_eq][a][b] @ifeq[@a][@b][][@error['@a' != '@b']] @@
  @assert_eq[hello][hello]

  @expect_error 2:45 @@
  @define[assert_eq][a][b] @ifeq[@a][@b][][@error['@a' != '@b']] @@
  @assert_eq[hello][there]

An interesting question: where do we expect the error location in the second
case? Let's try and see!

  @define[assert_eq][a b] @ifeq[@a][@b][][@error['@a' != '@b']] @@
  @assert_eq[hello][there]

The error happens at 1:42. I can't have @expect_error there and undefined. So
how about we make a tiny library that we always supply first.

Library is:

  @define[expect_error][loc][body] @@
  @define[assert_eq][a b] @ifeq[@a][@b][][@error['@a' != '@b']] @@

The test is as before.

Slight refinement:

For passing tests:

  @test[pass] @@
  ...

For tests that hit an assert failure:

  @test[fail] @@
  ...

For tests that hit an explicit error:

  @test[error 3:1] @@
  ...

The test framework can grep for those initial lines in the file.

---

It would be much easier if we could capture an error in fbld itself. For
example:

@try @@

Turns into the body, or in case of error, turns into the error message.

Or, more generally:

@try[onfail][body]

Where onfail is a function that can refer to @file, @line, @col, @msg?

Have that be built in.

Then all we have to do is run fbld, no need for a wrapper test framework.

Can we catch parse errors this way though?

---

Because we want to catch parse errors cleanly, I vote doing the error
detection stuff outside of fbld. I've got the test framework all drafted up
now.

Possible next steps:
* Add more fbld spec tests.
* Draft initial implementation of fbld in C with support for:
  @error, @ifeq, @define

---

Drafting up the initial implementation.

Where to start with parser support for no-error.fbld:

* block command, inline args, same line arg, same line final arg is all we
  need to start.

Sketch of parsing block:
* If it starts with '@', parse a block command, then parse the rest as a
  block.
* If we are at end of file, it's empty document.

Parsing a block command:
* Parse the name.

etc.

Should we just bail out right away if there is an error? Rather than propagate
it up? That seems decent enough for this simple program. Easier API and
implementation, right?

---

Parser question: how to parse inline text where the end of the inline text
depends on context?
* End at ']' when parsing an inline arg.
* End at '\n', ' @\n', or ' @@\n' when parsing same line arg.
* End at EOF or blank line when parsing implicit block.

In the fble based implementation we have a 'try' function that parses, tests
for error, then resets. Currently I abort right away in case of error, and we
don't have a mechanism to go backward in the input.

For same line arg, it seems natural to read in the line, strip the trailing '
@' or ' @@', then parse the rest of inline to end of string. That feels
inefficient though. I don't have a way to parse from string at this point
either.

We could add a custom state machine when parsing inline that takes context as
input. If looking for ']' and we see it, end then. If looking for same line
arg end and we see ' @', check for \n after, or @ after, and we know that should
be the end. Save somewhere where we saw \n, @\n or @@\n and return that.

What if we had a way to test for a string at the current position without
advancing the position? I should be able to hack that up.

Let's try that. Pass a function to check if end of inline without advancing
lex state. It can go until end.

To check if starts with string, maybe I can use seek, or pull characters into
a side buffer for processing.
* seek isn't good, because it's not supported on FIFOs.
* ungetc only guarantees one character pushback.

Or just use special casing. If we see lex->c is '@', and the previous
character was space, and the next character is \n or @, we should be all set.
That's doable. Let's try that approach. No fancy pushback or rewind or what
not needed. Just need to remember the previous character.

---

Let me take the time to create a better interface for lexing. Specifically I
want to be able test if the current position matches a string without
advancing the current position yet.

Current lexer API:
* Next() - Advance past the next character.
* lex->c - The next character.
* lex->loc - The location of the next character.

Proposed lexer API:
* lex->loc - The location of the next character.
* Char() - Gets the next character without advancing.
* Is(const char*) - Tests if the next few characters match, without
  advancing.
* Advance(const char*) - Advance by number of characters in argument.

The Inline function can either take an enum for context, of pass a function to
match the end as a bool without advancing. I think enum is simpler and easier
to understand?

Let's try it, see how it goes.

In terms of implementation, read into a growing buffer. Advance can do a
memmove.

How to encode end of file as a character? How about 0x03 End Of Text character
for now? And hope we don't get into trouble with utf8 encodings. No need to
worry about those for now.

---

Parser issues to revisit:
* Don't skip empty args []
* Why/how is args getting nulled out after parsing inline args?
  We aren't actually appending in FbldAppendToVector

---

We have enough of the parser for the first test case it seems. I haven't
checked to see if it's parsing correctly, but at least it finishes without
error.

Next step is to implement FbldEval.

Commands to support:
* @define, @ifeq, @error
* Custom commands and variables.

A custom command is: name + list of arg names + markup body. We can start with
a linked list of them with linear search. Tedious bits:
* Generalize FbldVector to work on any kind of type, so we can use it for list
  of args.
* Implement function to split arg list string into arg list list.

---

Okay, we have the first basic test case passing with the C based fbld
implementation. With a fair number of hacks and assumptions.

What's the next step from here?

We want to improve spec test coverage to the point where once all those tests
pass, we can process, say, fble.fbld. So I think the approach is clear:
1. Get all spec tests to pass. Preferably with clean, general code solution.
2. If fble.fbld doesn't pass, add a spec test to catch that case and go to (1).

Keep iterating until we are done. Then we can see how bad performance is and
what we can do to fix it.

---

How to implement equality check? There are three cases:
1. The strings are equal. Doesn't matter how you do the check. You have to
read all of both strings to compute the result.
2. The strings are strings but not equal. You could try reading the entire
strings, or for better performance (?) you could read up until the first
difference.
3. The strings aren't strings.

The semantics aren't clear. If you have, for example:

  @if[a@x][b@x] ...

Should it say not equal, or should it give an error?

Probably it should give an error. Current implementation is to return false in
this case.

Worth having a test case for it I guess.

Is there any real performance benefit for not evaluating the entirety of the
strings? Yes! For example, we often check if we have reached the end of a
large chunk of text. In this case, you want to avoid reading the large chunk
of text to find it isn't empty.

So let's implement things the same way, and worry about clarifying the
semantics later. Or, better yet, restructure fbld to avoid having partially
evaluated markup.

---

It's pretty tedious to implement Eq. To need to iterate over markup for string
comparison. I'm tempted to think about how to redo the semantics now to avoid
partially evaluated markup.

There's really only one case where we make use of @eval with partially
evaluated markup. That's for doc comments. Can we come up with a better
approach for those?

Conceptually the idea is to encode the information in a value (string), and
write code to process the info from the string as needed. As a start, we can
go to a string. Eventually we can go to struct/dictionary/etc. So don't worry
about it being annoyingly complicated to process the string for now.

Consider @arg, @returns, @sideeffects.

---

Tricky bit to work out: parsing of indented blocks. Where/how should I process
the indent computation?

Handling it in GetC or in Is/Char seems like two potential options.

Is/Char ideally skips over whitespace that makes up the indent. If it turns
out not to go far enough for the indent, ideally it keeps that whitespace. So
maybe we read in whitespace in Is/Char as long as we need to verify it meets
the indent. If it doesn't meet the indent, return EOF. If it does meet the
indent, erase the whitespace of the indent?

If we did it in GetC, we have to remember how much whitespace we encountered
in case we don't reach full indent.

Here's what I think:
* Read in all the whitespace into the next buffer. Keep it there. Don't erase
  it. That way Is, Char, and IsEof continue to not have conceptual side
  effects. We don't have to worry about a call to one messing things up for a
  later call in a different indent.
* Update Is, Char, and Advance to be indent aware.
 - Is skips over indent when doing the check.
 - Char skips over indent when doing the check.
 - Advance skips past indent.

We just need to sort out all the various cases:
* Is the newline in the next buffer, or we already advanced past it?
* etc.

Hopefully shouldn't be too hard to work out the details given the concept and
approach is clear.

Let's take one case at a time:
* Is
* Char
* Advance

Starting with 'Is'.

Current approach is to read in enough characters, then do a strncmp. With
indent, we don't know how many characters we may need. So perhaps do it more
lazily. For each character in the input string: get or fetch the next
character. If the next character is an indent, skip past it. No?
