
@ Int@ = /Int/Int%.Int@;
% Sub = /Int/Int%.Sub;
% Mul = /Int/Int%.Mul;
% Exp2 = /Int/Int%.Exp2;
% Int = /Int/Int/Lit%.Int;

@ Var@ = /Fblf/Program%.Var@;
@ Cond@ = /Fblf/Program%.Cond@;
@ Stmt@ = /Fblf/Program%.Stmt@;
@ Value@ = /Fblf/Program%.Value@;
% Assign = /Fblf/Program%.Assign;
% Eq = /Fblf/Program%.Eq;
% Ne = /Fblf/Program%.Ne;
% IfElse = /Fblf/Program%.IfElse;
% If = /Fblf/Program%.If;
% While = /Fblf/Program%.While;
% Binary = /Fblf/Program%.Binary;
% Hex = /Fblf/Program%.Hex;
% Var = /Fblf/Program%.Var;
% Offset = /Fblf/Program%.Offset;
% Seq = /Fblf/Program%.Seq;

<@>@ Module@ = /Fblf/Module%.Module@;
<@>@ ModuleM@ = /Fblf/Module%.ModuleM@;
@ Method@ = /Fblf/Module%.Method@;
<@>% Module2 = /Fblf/Module%.Module2;
<@>% Module5 = /Fblf/Module%.Module5;
<@>% DoAlloc = /Fblf/Module%.DoAlloc;
<@>% DoMethod = /Fblf/Module%.DoMethod;
<@>% DoExport = /Fblf/Module%.DoExport;
<@,@>% Do = /Fblf/Module%.Do;
<@>% Inst = /Fblf/Module%.Inst;
<@,@>% DoInst = /Fblf/Module%.DoInst;
<@>% Return = /Fblf/Module%.Return;

% Add = /Fblf/Lib/Add%.Add;
% IncI = /Fblf/Lib/Add%.IncI;
% DecI = /Fblf/Lib/Add%.DecI;
% And = /Fblf/Lib/Bitwise%.And;
% Or = /Fblf/Lib/Bitwise%.Or;
% Xor = /Fblf/Lib/Bitwise%.Xor;
% Not = /Fblf/Lib/Bitwise%.Not;
% Cls = /Fblf/Lib/Bitwise%.Cls;

<@>@ List@ = /List%.List@;

% Str = /String%.Str;

<@>@ BlockOf@ = <@ T@> {
  *(T@ 00, T@ 01, T@ 02, T@ 03,
    T@ 04, T@ 05, T@ 06, T@ 07,
    T@ 08, T@ 09, T@ 10, T@ 11,
    T@ 12, T@ 13, T@ 14, T@ 15);
};

BlockOf@<Value@> T1 = BlockOf@<Value@>(
  Hex|D76AA478, Hex|E8C7B756, Hex|242070DB, Hex|C1BDCEEE,
  Hex|F57C0FAF, Hex|4787C62A, Hex|A8304613, Hex|FD469501,
  Hex|698098D8, Hex|8B44F7AF, Hex|FFFF5BB1, Hex|895CD7BE,
  Hex|6B901122, Hex|FD987193, Hex|A679438E, Hex|49B40821
);

BlockOf@<Value@> T2 = BlockOf@<Value@>(
  Hex|F61E2562, Hex|C040B340, Hex|265E5A51, Hex|E9B6C7AA,
  Hex|D62F105D, Hex|02441453, Hex|D8A1E681, Hex|E7D3FBC8,
  Hex|21E1CDE6, Hex|C33707D6, Hex|F4D50D87, Hex|455A14ED,
  Hex|A9E3E905, Hex|FCEFA3F8, Hex|676F02D9, Hex|8D2A4C8A
);

BlockOf@<Value@> T3 = BlockOf@<Value@>(
  Hex|FFFA3942, Hex|8771F681, Hex|6D9D6122, Hex|FDE5380C,
  Hex|A4BEEA44, Hex|4BDECFA9, Hex|F6BB4B60, Hex|BEBFBC70,
  Hex|289B7EC6, Hex|EAA127FA, Hex|D4EF3085, Hex|04881D05,
  Hex|D9D4D039, Hex|E6DB99E5, Hex|1FA27CF8, Hex|C4AC5665
);

BlockOf@<Value@> T4 = BlockOf@<Value@>(
  Hex|F4292244, Hex|432AFF97, Hex|AB9423A7, Hex|FC93A039,
  Hex|655B59C3, Hex|8F0CCC92, Hex|FFEFF47D, Hex|85845DD1,
  Hex|6FA87E4F, Hex|FE2CE6E0, Hex|A3014314, Hex|4E0811A1,
  Hex|F7537E82, Hex|BD3AF235, Hex|2AD7D2BB, Hex|EB86D391
);

# SeqM --
#   Helper function for instantiating a list of modules and executing the
#   methods from each in order in a single statement.
(List@<ModuleM@<Stmt@>>) { ModuleM@<Stmt@>; }
SeqM = (List@<ModuleM@<Stmt@>> ms) {
  ms.?(
    cons: {
      Stmt@ x <- Do<Stmt@, Stmt@>(ms.cons.head);
      Stmt@ xs <- Do<Stmt@, Stmt@>(SeqM(ms.cons.tail));
      Return<Stmt@>(Seq[x, xs]);
    },
    nil: Return<Stmt@>(Seq[]));
};

# X@ -- 
#   The type of functions F, G, H, I.
#
# Inputs: x, y, z, r
#   Computes r = X(x, y, z)
@ X@ = (Var@, Var@, Var@, Var@) { ModuleM@<Stmt@>; };

# XX@ --
#   The type of functions FF, GG, HH, II.
#
# Inputs: a, b, c, d, x, s, t, r
#
#   Computes r = X(a, b, c, d, x, s, t);
@ XX@ = (Var@, Var@, Var@, Var@, Var@, Int@, Value@, Var@) { ModuleM@<Stmt@>; };

(X@) { XX@; }
XX = (X@ xf)(Var@ a, Var@ b, Var@ c, Var@ d, Var@ x, Int@ s, Value@ t, Var@ r) {
  # r = add(b, cls(add(add(a, xf(b, c, d)), add(x, t)), s));
  Var@ tv <- DoAlloc<Stmt@>(Int|32);
  Var@ xtv <- DoAlloc<Stmt@>(Int|32);
  Var@ xfv <- DoAlloc<Stmt@>(Int|32);
  Var@ axfv <- DoAlloc<Stmt@>(Int|32);
  Var@ axfxtv <- DoAlloc<Stmt@>(Int|32);
  Var@ clsv <- DoAlloc<Stmt@>(Int|32);

  SeqM[
    Return<Stmt@>(Assign(tv, t, Int|32)),
    Inst<Stmt@>(Add(Int|32)(x, tv, xtv)),
    xf(b, c, d, xfv),
    Inst<Stmt@>(Add(Int|32)(a, xfv, axfv)),
    Inst<Stmt@>(Add(Int|32)(axfv, xtv, axfxtv)),
    Inst<Stmt@>(Cls(Int|32, s)(axfxtv, clsv)),
    Inst<Stmt@>(Add(Int|32)(b, clsv, r))];
};

XX@ FF = XX((Var@ x, Var@ y, Var@ z, Var@ r) {
  # r = or(and(x, y), and(not(x), z));
  Var@ nx <- DoAlloc<Stmt@>(Int|32);
  Var@ anxz <- DoAlloc<Stmt@>(Int|32);
  Var@ xy <- DoAlloc<Stmt@>(Int|32);

  SeqM[
    Inst<Stmt@>(Not(Int|32)(x, nx)),
    Inst<Stmt@>(And(Int|32)(nx, z, anxz)),
    Inst<Stmt@>(And(Int|32)(x, y, xy)),
    Inst<Stmt@>(Or(Int|32)(xy, anxz, r))];
});

XX@ GG = XX((Var@ x, Var@ y, Var@ z, Var@ r) {
  # r = or(and(x, z), and(y, not(z)));
  Var@ nz <- DoAlloc<Stmt@>(Int|32);
  Var@ aynz <- DoAlloc<Stmt@>(Int|32);
  Var@ xz <- DoAlloc<Stmt@>(Int|32);

  SeqM[
    Inst<Stmt@>(Not(Int|32)(z, nz)),
    Inst<Stmt@>(And(Int|32)(y, nz, aynz)),
    Inst<Stmt@>(And(Int|32)(x, z, xz)),
    Inst<Stmt@>(Or(Int|32)(xz, aynz, r))];
});

XX@ HH = XX((Var@ x, Var@ y, Var@ z, Var@ r) {
  # r = xor(x, xor(y, z));
  Var@ yz <- DoAlloc<Stmt@>(Int|32);

  SeqM[
    Inst<Stmt@>(Xor(Int|32)(y, z, yz)),
    Inst<Stmt@>(Xor(Int|32)(x, yz, r))];
});

XX@ II = XX((Var@ x, Var@ y, Var@ z, Var@ r) {
  # r = xor(y, or(x, not(z)));
  Var@ nz <- DoAlloc<Stmt@>(Int|32);
  Var@ xnz <- DoAlloc<Stmt@>(Int|32);

  SeqM[
    Inst<Stmt@>(Not(Int|32)(z, nz)),
    Inst<Stmt@>(Or(Int|32)(x, nz, xnz)),
    Inst<Stmt@>(Xor(Int|32)(y, xnz, r))];
});

# Round@ --
#   A Round module.
#
# Inputs:
#   a, b, c, d - The 32 bit words of ABCD
#   block - The input block.
#
# Updates values of ABCD in place based on the input block.
@ Round@ = (Var@, Var@, Var@, Var@, BlockOf@<Var@>) { ModuleM@<Stmt@>; };

# RoundX --
#   Returns the round module based on the given parameters.
#
# Inputs:
#   xx - The FF, GG, HH, or II function to use for the round.
#   s0, s1, s2, s3 - The four shift values used in the round.
#   t - The T constants to use in the round.
#   permute - How to permute the input block.
(XX@, Int@, Int@, Int@, Int@, BlockOf@<Value@>, (BlockOf@<Var@>) { BlockOf@<Var@>; }) { Round@; }
RoundX = (XX@ xx, Int@ s0, Int@ s1, Int@ s2, Int@ s3, BlockOf@<Value@> t, (BlockOf@<Var@>) { BlockOf@<Var@>; } permute)
(Var@ a, Var@ b, Var@ c, Var@ d, BlockOf@<Var@> block) {
  BlockOf@<Var@> permuted = permute(block);
  SeqM[
    xx(a, b, c, d, permuted.00, s0, t.00, a),
    xx(d, a, b, c, permuted.01, s1, t.01, d),
    xx(c, d, a, b, permuted.02, s2, t.02, c),
    xx(b, c, d, a, permuted.03, s3, t.03, b),
    xx(a, b, c, d, permuted.04, s0, t.04, a),
    xx(d, a, b, c, permuted.05, s1, t.05, d),
    xx(c, d, a, b, permuted.06, s2, t.06, c),
    xx(b, c, d, a, permuted.07, s3, t.07, b),
    xx(a, b, c, d, permuted.08, s0, t.08, a),
    xx(d, a, b, c, permuted.09, s1, t.09, d),
    xx(c, d, a, b, permuted.10, s2, t.10, c),
    xx(b, c, d, a, permuted.11, s3, t.11, b),
    xx(a, b, c, d, permuted.12, s0, t.12, a),
    xx(d, a, b, c, permuted.13, s1, t.13, d),
    xx(c, d, a, b, permuted.14, s2, t.14, c),
    xx(b, c, d, a, permuted.15, s3, t.15, b)];
};

Round@ Round1 = RoundX(FF, Int|7, Int|12, Int|17, Int|22, T1, (BlockOf@<Var@> b) {
  b;
});

Round@ Round2 = RoundX(GG, Int|5, Int|9, Int|14, Int|20, T2, (BlockOf@<Var@> b) {
  BlockOf@<Var@>(
    b.01, b.06, b.11, b.00,
    b.05, b.10, b.15, b.04,
    b.09, b.14, b.03, b.08,
    b.13, b.02, b.07, b.12);
});

Round@ Round3 = RoundX(HH, Int|4, Int|11, Int|16, Int|23, T3, (BlockOf@<Var@> b) {
  BlockOf@<Var@>(
    b.05, b.08, b.11, b.14,
    b.01, b.04, b.07, b.10,
    b.13, b.00, b.03, b.06,
    b.09, b.12, b.15, b.02);
});

Round@ Round4 = RoundX(II, Int|6, Int|10, Int|15, Int|21, T4, (BlockOf@<Var@> b) {
  BlockOf@<Var@>(
    b.00, b.07, b.14, b.05,
    b.12, b.03, b.10, b.01,
    b.08, b.15, b.06, b.13,
    b.04, b.11, b.02, b.09);
});

(Var@, Var@, Var@, Var@, BlockOf@<Var@>) { ModuleM@<Stmt@>; }
DoBlock = (Var@ a, Var@ b, Var@ c, Var@ d, BlockOf@<Var@> block) {
  Var@ save_a <- DoAlloc<Stmt@>(Int|32);
  Var@ save_b <- DoAlloc<Stmt@>(Int|32);
  Var@ save_c <- DoAlloc<Stmt@>(Int|32);
  Var@ save_d <- DoAlloc<Stmt@>(Int|32);

  SeqM[
    Return<Stmt@>(Assign(save_a, Var(a), Int|32)),
    Return<Stmt@>(Assign(save_b, Var(b), Int|32)),
    Return<Stmt@>(Assign(save_c, Var(c), Int|32)),
    Return<Stmt@>(Assign(save_d, Var(d), Int|32)),
    Round1(a, b, c, d, block),
    Round2(a, b, c, d, block),
    Round3(a, b, c, d, block),
    Round4(a, b, c, d, block),
    Inst<Stmt@>(Add(Int|32)(a, save_a, a)),
    Inst<Stmt@>(Add(Int|32)(b, save_b, b)),
    Inst<Stmt@>(Add(Int|32)(c, save_c, c)),
    Inst<Stmt@>(Add(Int|32)(d, save_d, d))];
};

# Store --
#   Stores a single word in a 2^k-element array of n-bit words.
#
# When run, the program does:
#   memory[addr] = value;
(Int@, Int@, Var@, Var@, Var@) { Stmt@; }
Store = (Int@ k, Int@ n, Var@ memory, Var@ addr, Var@ value) {
  /Int/Int/Eq%.Eq(k, Int|0).?(
    true: Assign(memory, Var(value), n),
    false: {
      Int@ sk = Sub(k, Int|1);
      Var@ saddr = Offset(addr, Int|1);
      IfElse(Eq(Var(addr), Binary|0, Int|1),
        Store(sk, n, memory, saddr, value),
        Store(sk, n, Offset(memory, Mul(n, Exp2(sk))), saddr, value));
    });
};

# PackWord@ --
#   Interface to the PackWord module.
#
# To use the PackWord module:
# 1. Run the 'reset' program.
# 2. For each byte of the input in order,
#   Set the 'byte' register to the value of the byte.
#   Run the 'feed' program.
# The packed 'word' should be read after every 4 bytes are fed.
# The 'packed' condition can be used to check after feeding an input byte
# whether a full word has been assembled.
@ PackWord@ = *(Method@ reset, Method@ feed, Cond@ packed);

(Var@, Var@) { Module@<PackWord@>; }
PackWord = Module2<PackWord@>(Str|'Md5.PackWord', (Var@ word, Var@ byte) {
  Var@ addr <- DoAlloc<PackWord@>(Int|2);

  Method@ reset <- DoMethod<PackWord@>(Assign(addr, Binary|11, Int|2));

  Method@ feed <- DoMethod<PackWord@>(Seq[
    Store(Int|2, Int|8, word, addr, byte),
    DecI(Int|2, addr)
  ]);

  Var@ exported_addr <- DoExport<PackWord@>(addr);

  Cond@ packed = Eq(Var(exported_addr), Binary|11, Int|2);

  Return<PackWord@>(@(reset, feed, packed));
});

# PaddedMd5@ -- 
#   Interface to a PaddedMd5 compute module.
#
# PaddedMd5 computes md5sum for a pre-padded input.
#
# To use the PaddedMd5 compute module:
# 1. Run the 'reset' program
# 2. For each byte of the input in order, 
#   Set the 'byte' register to the value of the byte.
#   Run the 'feed' program.
#
# The result of the Md5 computation will be in the 'abcd' register, which will
# be updated after every 64 bytes of input.
# The module can be reused for multiple Md5 computations by rerunning the
# above instructions for each computation.
@ PaddedMd5@ = *(Method@ reset, Method@ feed);

# PaddedMd5 -- 
#   The PaddedMd5 computation.
#
# Inputs:
#   a - The address of the 'A' value of the computed Md5.
#   b - The address of the 'B' value of the computed Md5.
#   c - The address of the 'C' value of the computed Md5.
#   d - The address of the 'D' value of the computed Md5.
#   byte - The address of the input byte passed to the feed program.
(Var@, Var@, Var@, Var@, Var@) { Module@<PaddedMd5@>; }
PaddedMd5 = Module5<PaddedMd5@>(Str|'Md5.PaddedMd5',
  (Var@ a, Var@ b, Var@ c, Var@ d, Var@ byte) {
    # Count of the number of 32-bit words of input that have been processed in
    # the current block.
    Var@ count <- DoAlloc<PaddedMd5@>(Int|4);

    # Space to assemble the next 32 bit word of input.
    Var@ word <- DoAlloc<PaddedMd5@>(Int|32);
    PackWord@ wpack <- DoInst<PackWord@, PaddedMd5@>(PackWord(word, byte));

    # Space to assemble the next block of 16 32-bit words of input.
    Var@ block <- DoAlloc<PaddedMd5@>(Mul(Int|16, Int|32));
    BlockOf@<Var@> blockof = BlockOf@<Var@>(
      Offset(block, Mul(Int|0, Int|32)), Offset(block, Mul(Int|1, Int|32)),
      Offset(block, Mul(Int|2, Int|32)), Offset(block, Mul(Int|3, Int|32)),
      Offset(block, Mul(Int|4, Int|32)), Offset(block, Mul(Int|5, Int|32)),
      Offset(block, Mul(Int|6, Int|32)), Offset(block, Mul(Int|7, Int|32)),
      Offset(block, Mul(Int|8, Int|32)), Offset(block, Mul(Int|9, Int|32)),
      Offset(block, Mul(Int|10, Int|32)), Offset(block, Mul(Int|11, Int|32)),
      Offset(block, Mul(Int|12, Int|32)), Offset(block, Mul(Int|13, Int|32)),
      Offset(block, Mul(Int|14, Int|32)), Offset(block, Mul(Int|15, Int|32)));

    Stmt@ doblock <- Do<Stmt@, PaddedMd5@>(DoBlock(a, b, c, d, blockof));

    # Note: the spec lists the initial values for A, B, C, and D low-order byte
    # first, but H takes high order byte first.
    Method@ reset <- DoMethod<PaddedMd5@>(Seq[
      Assign(count, Binary|0000, Int|4),
      Assign(a, Hex|67452301, Int|32),
      Assign(b, Hex|EFCDAB89, Int|32),
      Assign(c, Hex|98BADCFE, Int|32),
      Assign(d, Hex|10325476, Int|32),
      wpack.reset
    ]);

    Method@ feed <- DoMethod<PaddedMd5@>(Seq[
      wpack.feed,
      If(wpack.packed,
        Seq[
          Store(Int|4, Int|32, block, count, word),
          If(Eq(Var(count), Binary|1111, Int|4),
            doblock),
        IncI(Int|4, count)])
    ]);

    Return<PaddedMd5@>(@(reset, feed));
  });

# Md5@ -- 
#   Interface to an Md5 compute module.
#
# To use the Md5 compute module:
# 1. Run the 'reset' program
# 2. For each byte of the input in order, 
#   Set the 'input' register to the value of the byte.
#   Run the 'feed' program.
# 3. Run the 'finish' program.
#
# The result of the Md5 computation will be stored at the given output hash
# address as a sequence of 128 bits in order of the sequence of hex digits
# typically used to display an md5 hash. The module can be reused for multiple
# Md5 computations by rerunning the above instructions for each computation.
#
# Note that the 'finish' program may modified the 'input' register in
# unspecified ways.
@ Md5@ = *(Method@ reset, Method@ feed, Method@ finish);

# Md5 -- 
#   The Md5 computation.
#
# Inputs:
#   input - The address of the 8-bit input byte passed to the feed program.
#   hash - The address to store the 128 bit computed Md5 hash.
(Var@, Var@) { Module@<Md5@>; }
Md5 = Module2<Md5@>(Str|'Md5.Md5', (Var@ input, Var@ hash) {
  Var@ a <- DoAlloc<Md5@>(Int|32);
  Var@ b <- DoAlloc<Md5@>(Int|32);
  Var@ c <- DoAlloc<Md5@>(Int|32);
  Var@ d <- DoAlloc<Md5@>(Int|32);

  PaddedMd5@ padded <- DoInst<PaddedMd5@, Md5@>(PaddedMd5(a, b, c, d, input));

  # Count of the number of bits of input that have been processed.
  Var@ length <- DoAlloc<Md5@>(Int|64);

  # While padding, keeps track of how many bytes have been added to the final
  # block so far.
  Var@ padding <- DoAlloc<Md5@>(Int|6);

  Method@ reset <- DoMethod<Md5@>(Seq[
    Assign(length, Hex|0000000000000000, Int|64),
    padded.reset
  ]);

  Method@ feed <- DoMethod<Md5@>(Seq[
    padded.feed,

    # Increment the length by one bytes worth by incrementing all but the last
    # three bits by 1.
    IncI(Int|61, length)
  ]);

  Method@ finish <- DoMethod<Md5@>(Seq[
    # Start tracking how many bytes we've added to the final block.
    Assign(padding, Var(Offset(length, Int|55)), Int|6),

    # Feed byte 0x80
    Assign(input, Hex|80, Int|8),
    padded.feed,
    IncI(Int|6, padding),

    # Feed byte 0x00 until 8 bytes shy of end of block.
    Assign(input, Hex|00, Int|8),
    While(Ne(Var(padding), Binary|111000, Int|6), Seq[
      padded.feed,
      IncI(Int|6, padding)
    ]),

    # Feed length (in bits) as next 8 bytes, least significant byte first.
    Assign(input, Var(Offset(length, Int|56)), Int|8), padded.feed,
    Assign(input, Var(Offset(length, Int|48)), Int|8), padded.feed,
    Assign(input, Var(Offset(length, Int|40)), Int|8), padded.feed,
    Assign(input, Var(Offset(length, Int|32)), Int|8), padded.feed,
    Assign(input, Var(Offset(length, Int|24)), Int|8), padded.feed,
    Assign(input, Var(Offset(length, Int|16)), Int|8), padded.feed,
    Assign(input, Var(Offset(length, Int|8)), Int|8), padded.feed,
    Assign(input, Var(Offset(length, Int|0)), Int|8), padded.feed,

    # Extract the hash from a, b, c, d.
    # Note that the hash is output in order ABCD, least significant byte
    # first.
    Assign(Offset(hash, Int|0),   Var(Offset(a, Int|24)), Int|8),
    Assign(Offset(hash, Int|8),   Var(Offset(a, Int|16)), Int|8),
    Assign(Offset(hash, Int|16),  Var(Offset(a, Int|8)),  Int|8),
    Assign(Offset(hash, Int|24),  Var(Offset(a, Int|0)),  Int|8),
    Assign(Offset(hash, Int|32),  Var(Offset(b, Int|24)), Int|8),
    Assign(Offset(hash, Int|40),  Var(Offset(b, Int|16)), Int|8),
    Assign(Offset(hash, Int|48),  Var(Offset(b, Int|8)),  Int|8),
    Assign(Offset(hash, Int|56),  Var(Offset(b, Int|0)),  Int|8),
    Assign(Offset(hash, Int|64),  Var(Offset(c, Int|24)), Int|8),
    Assign(Offset(hash, Int|72),  Var(Offset(c, Int|16)), Int|8),
    Assign(Offset(hash, Int|80),  Var(Offset(c, Int|8)),  Int|8),
    Assign(Offset(hash, Int|88),  Var(Offset(c, Int|0)),  Int|8),
    Assign(Offset(hash, Int|96),  Var(Offset(d, Int|24)), Int|8),
    Assign(Offset(hash, Int|104), Var(Offset(d, Int|16)), Int|8),
    Assign(Offset(hash, Int|112), Var(Offset(d, Int|8)),  Int|8),
    Assign(Offset(hash, Int|120), Var(Offset(d, Int|0)),  Int|8)
  ]);

  Return<Md5@>(Md5@(reset, feed, finish));
});

@(Md5@, Md5);
