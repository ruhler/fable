
{ Unit%; @(Unit@, Unit); };
{ Bool%; @(Bool@, True, False); };
{ Maybe%; @(Maybe@, Just, Nothing, MapMaybe, For); };
{ Monoid%; @(Monoid@); };
{ List%; @(S@, S, Concat, FoldS, MapS, SeqS, ForS); };
{ Char%; @(Char@, newline); };
{ String%; @(Str@, Str); };

# A square is either filled with an 'X', filled with an 'O', 
# or is 'E'mpty.
@ Square@ = +(Unit@ X, Unit@ O, Unit@ E);

# A board is a 3x3 grid of squares.
@ Board@ = *(
    Square@ ul, Square@ uc, Square@ ur,    # Upper row.
    Square@ ml, Square@ mc, Square@ mr,    # Middle row.
    Square@ ll, Square@ lc, Square@ lr     # Lower row.
);

Board@ EmptyBoard = {
  Square@ E = Square@(E: Unit@());
  Board@(E, E, E, E, E, E, E, E, E);
};

# Position can be used to identify a specific square in the 3x3 grid.
@ Position@ = +(
    Unit@ UL, Unit@ UC, Unit@ UR,
    Unit@ ML, Unit@ MC, Unit@ MR,
    Unit@ LL, Unit@ LC, Unit@ LR
);

(Position@){ Maybe@<Position@>; } NextPosition = (Position@ p) {
  ?(p; UL: Just<Position@>(Position@(UC: Unit@())),
       UC: Just<Position@>(Position@(UR: Unit@())),
       UR: Just<Position@>(Position@(ML: Unit@())),
       ML: Just<Position@>(Position@(MC: Unit@())),
       MC: Just<Position@>(Position@(MR: Unit@())),
       MR: Just<Position@>(Position@(LL: Unit@())),
       LL: Just<Position@>(Position@(LC: Unit@())),
       LC: Just<Position@>(Position@(LR: Unit@())),
       LR: Nothing<Position@>);
};

# Returns the value of the square at position 'p' in board 'b'.
(Board@, Position@) { Square@; } GetSquare = (Board@ b, Position@ p) {
  ?(p; UL: b.ul, UC: b.uc, UR: b.ur,
       ML: b.ml, MC: b.mc, MR: b.mr,
       LL: b.ll, LC: b.lc, LR: b.lr);
};

# Sets the square at position 'p' in board 'b' to value 's'.
(Board@, Position@, Square@) { Board@; } SetSquare =
  (Board@ b, Position@ p, Square@ s) {
    ?(p;
        UL: Board@(   s, b.uc, b.ur, b.ml, b.mc, b.mr, b.ll, b.lc, b.lr),
        UC: Board@(b.ul,    s, b.ur, b.ml, b.mc, b.mr, b.ll, b.lc, b.lr),
        UR: Board@(b.ul, b.uc,    s, b.ml, b.mc, b.mr, b.ll, b.lc, b.lr),
        ML: Board@(b.ul, b.uc, b.ur,    s, b.mc, b.mr, b.ll, b.lc, b.lr),
        MC: Board@(b.ul, b.uc, b.ur, b.ml,    s, b.mr, b.ll, b.lc, b.lr),
        MR: Board@(b.ul, b.uc, b.ur, b.ml, b.mc,    s, b.ll, b.lc, b.lr),
        LL: Board@(b.ul, b.uc, b.ur, b.ml, b.mc, b.mr,    s, b.lc, b.lr),
        LC: Board@(b.ul, b.uc, b.ur, b.ml, b.mc, b.mr, b.ll,    s, b.lr),
        LR: Board@(b.ul, b.uc, b.ur, b.ml, b.mc, b.mr, b.ll, b.lc,    s));
  };

# Rotate a board 90 degrees clockwise
(Board@) { Board@; } RotateBoard = (Board@ b) {
  Board@(b.ll, b.ml, b.ul,
         b.lc, b.mc, b.uc,
         b.lr, b.mr, b.ur);
};

# Rotate a position 90 degrees clockwise
(Position@) { Position@; } RotatePosition = (Position@ p) {
  ?(p;
    UL: Position@(UR: Unit), UC: Position@(MR: Unit), UR: Position@(LR: Unit),
    ML: Position@(UC: Unit), MC: Position@(MC: Unit), MR: Position@(LC: Unit),
    LL: Position@(UL: Unit), LC: Position@(ML: Unit), LR: Position@(LL: Unit));
};

# Flip a board horizontally
(Board@) { Board@; } FlipBoard = (Board@ b) {
  Board@(b.ll, b.lc, b.lr,
         b.ml, b.mc, b.mr,
         b.ul, b.uc, b.ur);
};

# Flip a position horizontally
(Position@) { Position@; } FlipPosition = (Position@ p) {
  ?(p;
    UL: Position@(LL: Unit), UC: Position@(LC: Unit), UR: Position@(LR: Unit),
    ML: Position@(ML: Unit), MC: Position@(MC: Unit), MR: Position@(MR: Unit),
    LL: Position@(UL: Unit), LC: Position@(UC: Unit), LR: Position@(UR: Unit));
};

@ Player@ = +(Unit@ X, Unit@ O);

# Returns true if the square 's' is empty.
(Square@) { Bool@; } IsEmpty = (Square@ s) {
  ?(s; X: False, O: False, E: True);
};

# Returns the board resulting from player 'x' making a play at position 'p'
# of board 'b'. Returns Nothing if the square at position 'p' of board 'b' is
# not empty.
(Board@, Position@, Player@) { Maybe@<Board@>; } Move =
  (Board@ b, Position@ p, Player@ x) {
    ?(IsEmpty(GetSquare(b, p)) ; 
       true: Just<Board@>(SetSquare(b, p, ?(x; X: Square@(X: Unit@()), O: Square@(O: Unit@())))),
       false: Nothing<Board@>);
  };

# The status of a (valid) board is one of:
#  X: The player X has won.
#  O: The player O has won.
#  D: There is a draw.
#  E: The board has empty squares.
@ Status@ = +(Unit@ X, Unit@ O, Unit@ D, Unit@ E);

# Return the status of a single square.
(Square@) { Status@; } SquareStatus = (Square@ a) {
  ?(a ; X: Status@(X: Unit@()), O: Status@(O: Unit@()), E: Status@(E: Unit@()));
};

# Combine two Status using an 'and' operation.
(Status@, Status@){Status@;} AndStatus = (Status@ a, Status@ b) {
  ?(a ;
      X: ?(b ; X: a, O: Status@(D: Unit@()), D: b, E: b), 
      O: ?(b ; X: Status@(D: Unit@()), O: a, D: b, E: b),
      D: ?(b ; X: a, O: a, D: a, E: b),
      E: a);
};

# Combine two Status using an 'or' operation.
(Status@, Status@){Status@;} OrStatus = (Status@ a, Status@ b) {
  ?(a ; X: a, O: a, D: b, E: ?(b ; X: b, O: b, D: a, E: a));
};

# Compute the status for a given row of squares.
(Square@, Square@, Square@){Status@;} RowStatus = (Square@ a, Square@ b, Square@ c) {
  AndStatus(SquareStatus(a), AndStatus(SquareStatus(b), SquareStatus(c)));
};

# Compute the status for a board.
(Board@){Status@;} BoardStatus = (Board@ a) {
  OrStatus(
      OrStatus(
        OrStatus(RowStatus(a.ul, a.uc, a.ur), RowStatus(a.ml, a.mc, a.mr)),
        OrStatus(RowStatus(a.ll, a.lc, a.lr), RowStatus(a.ul, a.ml, a.ll))),
      OrStatus(
        OrStatus(RowStatus(a.uc, a.mc, a.lc), RowStatus(a.ur, a.mr, a.lr)),
        OrStatus(RowStatus(a.ul, a.mc, a.lr), RowStatus(a.ur, a.mc, a.ll))));
};

@ Result@ = +(Unit@ Win, Unit@ Draw, Unit@ Loss);

# Re-interpret the result from the perspective of the opposing player.
(Result@){Result@;} FlipResult = (Result@ r) {
  ?(r ; Win:  Result@(Loss: Unit@()),
        Draw: Result@(Draw: Unit@()),
        Loss: Result@(Win: Unit@()));
};

@ PositionResult@ = *(Position@ position, Result@ result);
@ BoardPositionResult@ = *(Board@ board, PositionResult@ pr);

(BoardPositionResult@) { BoardPositionResult@; }
RotateBPR = (BoardPositionResult@ bpr) {
  BoardPositionResult@(RotateBoard(bpr.board),
    PositionResult@(RotatePosition(bpr.pr.position), bpr.pr.result));
};

(BoardPositionResult@) { BoardPositionResult@; }
FlipBPR = (BoardPositionResult@ bpr) {
  BoardPositionResult@(FlipBoard(bpr.board),
    PositionResult@(FlipPosition(bpr.pr.position), bpr.pr.result));
};

# Produce all different symmetrically equivalent board position results of the
# given board position result.
(BoardPositionResult@) { S@<BoardPositionResult@>; }
AllSymmetries = (BoardPositionResult@ bpr) {
  BoardPositionResult@ b0 = bpr;
  BoardPositionResult@ b1 = RotateBPR(b0);
  BoardPositionResult@ b2 = RotateBPR(b1);
  BoardPositionResult@ b3 = RotateBPR(b2);
  BoardPositionResult@ f0 = FlipBPR(b0);
  BoardPositionResult@ f1 = RotateBPR(f0);
  BoardPositionResult@ f2 = RotateBPR(f1);
  BoardPositionResult@ f3 = RotateBPR(f2);
  S<BoardPositionResult@>([b0, b1, b2, b3, f0, f1, f2, f3]);
};

(PositionResult@, PositionResult@) { PositionResult@; } ChooseBestPosition =
  (PositionResult@ a, PositionResult@ b) {
    Result@ ra = a.result;
    Result@ rb = b.result;
    ?(ra; Win: a,
          Draw: ?(rb; Win: b, Draw: a, Loss: a),
          Loss: b);
  };

(Maybe@<PositionResult@>, Maybe@<PositionResult@>) { Maybe@<PositionResult@>; }
ChooseBestMaybePosition = (Maybe@<PositionResult@> a, Maybe@<PositionResult@> b) {
  ?(a; just:
        ?(b; just: Just<PositionResult@>(ChooseBestPosition(a.just, b.just)),
             nothing: a),
       nothing: b);
};

(Maybe@<PositionResult@>){ Bool@; } IsWinning = (Maybe@<PositionResult@> x) {
  ?(x; just: ?(x.just.result; Win: True, Draw: False, Loss: False),
       nothing: False);
};

# Map from Board to the best next move to make on that board and the expected
# game result from playing there.
@ MemoTable@ = +(Unit@ empty, PositionResult@ result, MemoMap@ map),
@ MemoMap@ = *(MemoTable@ x, MemoTable@ o, MemoTable@ e);

# Helper function to access a MemoMap from a MemoTable. Returns Nothing if the
# MemoTable is Empty. Otherwise applies the given function to the accessed
# MemoMap.
<@ A@>(MemoTable@, Square@, (MemoTable@){Maybe@<A@>;}){Maybe@<A@>;}
GetMap = <@ A@>(MemoTable@ memo, Square@ square, (MemoTable@){Maybe@<A@>;} f) {
  ?(memo;
      empty: Nothing<A@>,
      result: Nothing<A@>, 
      map: f(?(square; X: memo.map.x, O: memo.map.o, E: memo.map.e)));
};

(MemoTable@, Board@){ Maybe@<PositionResult@>; }
Lookup = (MemoTable@ memo, Board@ board) {
  MemoTable@ mul <- GetMap<PositionResult@>(memo, board.ul);
  MemoTable@ muc <- GetMap<PositionResult@>(mul, board.uc);
  MemoTable@ mur <- GetMap<PositionResult@>(muc, board.ur);
  MemoTable@ mml <- GetMap<PositionResult@>(mur, board.ml);
  MemoTable@ mmc <- GetMap<PositionResult@>(mml, board.mc);
  MemoTable@ mmr <- GetMap<PositionResult@>(mmc, board.mr);
  MemoTable@ mll <- GetMap<PositionResult@>(mmr, board.ll);
  MemoTable@ mlc <- GetMap<PositionResult@>(mll, board.lc);
  MemoTable@ mlr <- GetMap<PositionResult@>(mlc, board.lr);
  ?(mlr;
    empty: Nothing<PositionResult@>,
    result: Just<PositionResult@>(mlr.result),
    map: Nothing<PositionResult@>);
};

# Helper function to update a MemoTable map value.
# Accesses the given element from the given memo table and applies the
# function to it to determine its new value, providing a default empty value
# if necessary.
(MemoTable@, Square@, (MemoTable@){MemoTable@;}){MemoTable@;}
SetMap = (MemoTable@ memo, Square@ square, (MemoTable@){MemoTable@;} f) {
  MemoTable@ empty = MemoTable@(empty: Unit);
  MemoMap@ oldMap = ?(memo;
    empty: MemoMap@(empty, empty, empty),
    result: MemoMap@(empty, empty, empty),
    map: memo.map);
  MemoTable@ oldChild = ?(square; X: oldMap.x, O: oldMap.o, E: oldMap.e);
  MemoTable@ newChild = f(oldChild);
  MemoMap@ newMap = MemoMap@(
    ?(square; X: newChild, O: oldMap.x, E: oldMap.x), 
    ?(square; X: oldMap.o, O: newChild, E: oldMap.o), 
    ?(square; X: oldMap.e, O: oldMap.e, E: newChild));
  MemoTable@(map: newMap);
};

(MemoTable@, Board@, PositionResult@){MemoTable@;}
Insert = (MemoTable@ memo, Board@ board, PositionResult@ result) {
  MemoTable@ mul <- SetMap(memo, board.ul);
  MemoTable@ muc <- SetMap(mul, board.uc);
  MemoTable@ mur <- SetMap(muc, board.ur);
  MemoTable@ mml <- SetMap(mur, board.ml);
  MemoTable@ mmc <- SetMap(mml, board.mc);
  MemoTable@ mmr <- SetMap(mmc, board.mr);
  MemoTable@ mll <- SetMap(mmr, board.ll);
  MemoTable@ mlc <- SetMap(mll, board.lc);
  MemoTable@ mlr <- SetMap(mlc, board.lr);
  MemoTable@(result: result);
};

<@>@ MemoState@ = <@ T@>{ *(MemoTable@ memo, T@ data); };

# Return the expected result of the game for player 'x', assuming player 'x'
# has just moved and that both players play optimally.
(MemoTable@, Board@, Player@){MemoState@<Result@>;}
ExpectedResult = (MemoTable@ m, Board@ b, Player@ x) {
  ?(BoardStatus(b);
      X: MemoState@<Result@>(m,
          ?(x; X: Result@(Win: Unit@()), O: Result@(Loss: Unit@()))),
      O: MemoState@<Result@>(m,
          ?(x; X: Result@(Loss: Unit@()), O: Result@(Win: Unit@()))),
      D: MemoState@<Result@>(m, Result@(Draw: Unit@())),
      E: {
        Player@ o = ?(x; X: Player@(O: Unit@()), O: Player@(X: Unit@()));
        MemoState@<PositionResult@> move = ComputeBestMove(m, b, o);
        MemoState@<Result@>(move.memo, FlipResult(move.data.result));
      }
   );
},

# Return the expected result of player 'x' moving at position 'p' on board
# 'b'. Returns Nothing if the player 'x' cannot move at position 'p' on board
# 'b'.
(MemoTable@, Board@, Player@, Position@){MemoState@<Maybe@<PositionResult@>>;}
MoveResult = (MemoTable@ m, Board@ b, Player@ x, Position@ p) {
  Maybe@<Board@> moved = Move(b, p, x);
  ?(moved;
    just: {
      MemoState@<Result@> result = ExpectedResult(m, moved.just, x);
      MemoState@<Maybe@<PositionResult@>>(
        result.memo,
        Just<PositionResult@>(PositionResult@(p, result.data)));
    },
    nothing: MemoState@<Maybe@<PositionResult@>>(m, Nothing<PositionResult@>));
},

# Choose the best move for player 'x' on the given board.
# The results are undefined if there are no moves left to make.
(MemoTable@, Board@, Player@){MemoState@<PositionResult@>;}
ComputeBestMove = (MemoTable@ m, Board@ b, Player@ x) {
  Maybe@<PositionResult@> cached = Lookup(m, b);
  ?(cached;
    just: MemoState@<PositionResult@>(m, cached.just),
    nothing: {
      MemoState@<Maybe@<PositionResult@>> best =
        For<Position@, MemoState@<Maybe@<PositionResult@>>>(
          Position@(UL: Unit),
          MemoState@<Maybe@<PositionResult@>>(m, Nothing<PositionResult@>),
          NextPosition,
          (Position@ p, MemoState@<Maybe@<PositionResult@>> best) {
            MemoState@<Maybe@<PositionResult@>> curr = MoveResult(best.memo, b, x, p);
            MemoState@<Maybe@<PositionResult@>>(
              curr.memo,
              ChooseBestMaybePosition(best.data, curr.data));
        });

      MemoTable@ newMemo =
        ForS<BoardPositionResult@, MemoTable@>(
          AllSymmetries(BoardPositionResult@(b, best.data.just)),
          best.memo,
          (BoardPositionResult@ bpr, MemoTable@ m) {
            Insert(m, bpr.board, bpr.pr);
        });

      MemoState@<PositionResult@>(newMemo, best.data.just);
    });
};

@ GameStatus@ = +(Player@ Move, Player@ Win, Unit@ Draw); 
@ Output@ = *(Board@ board, GameStatus@ status);

(GameStatus@){Bool@;} GameIsOver = (GameStatus@ status) {
  ?(status; Move: False, Win: True, Draw: True);
};

# position: Make a move at the given position for the current player.
# computer: Have the computer make a move for the current player.
# reset: Reset the game.
@ Input@ = +(Position@ position, Unit@ computer, Unit@ reset);

(Input@){Bool@;} InputIsReset = (Input@ input) {
  ?(input; position: False, computer: False, reset: True);
};

(Input@){Bool@;} InputIsPosition = (Input@ input) {
  ?(input; position: True, computer: False, reset: False);
};

(Input@-, Output@+, MemoTable@){Unit@!;}
NewGameAI = (Input@- input, Output@+ output, MemoTable@ ai) {
  PlayGame(input, output, ai, EmptyBoard, Player@(X: Unit@()));
},
(Input@-, Output@+, MemoTable@, Board@, Player@){Unit@!;}
PlayGame = (Input@- input, Output@+ output, MemoTable@ ai, Board@ board, Player@ x) {
  GameStatus@ status := $(?(BoardStatus(board);
                          X: GameStatus@(Win: Player@(X: Unit@())),
                          O: GameStatus@(Win: Player@(O: Unit@())),
                          D: GameStatus@(Draw: Unit@()),
                          E: GameStatus@(Move: x)));
  Output@ ignored := output(Output@(board, status));
  Input@ in := input();
  ?(GameIsOver(status) ; 
      true:
      ?(in ; position: PlayGame(input, output, ai, board, x),
             computer: PlayGame(input, output, ai, board, x),
             reset: NewGameAI(input, output, ai)),
      false:
      ?(InputIsReset(in) ;
         true: NewGameAI(input, output, ai),
         false: {
          MemoState@<Position@> mp =
            ?(InputIsPosition(in) ;
                true: MemoState@<Position@>(ai, in.position),
                false: {
                  MemoState@<PositionResult@> mpr = ComputeBestMove(ai, board, x);
                  MemoState@<Position@>(mpr.memo, mpr.data.position);
                });
          Maybe@<Board@> nboard := $(Move(board, mp.data, x));
          ?(nboard ;
              just: PlayGame(input, output, mp.memo, nboard.just, ?(x; X: Player@(O: Unit@()), O: Player@(X: Unit@()))),
              nothing: PlayGame(input, output, mp.memo, board, x));
        }));
};

(Input@-, Output@+){Unit@!;} NewGame = (Input@- input, Output@+ output) {
  NewGameAI(input, output, MemoTable@(empty: Unit));
};

@ TestResult@ = +(Unit@ Passed, Unit@ Failed);

TestResult@ TestBoardStatus = {
  Status@ status = BoardStatus(Board@(
        Square@(X: Unit@()), Square@(O: Unit@()), Square@(O: Unit@()),
        Square@(E: Unit@()), Square@(O: Unit@()), Square@(X: Unit@()),
        Square@(O: Unit@()), Square@(X: Unit@()), Square@(X: Unit@())));
  ?(status ;
      X: TestResult@(Failed: Unit@()),
      O: TestResult@(Passed: Unit@()),
      D: TestResult@(Failed: Unit@()),
      E: TestResult@(Failed: Unit@()));
};
Unit@ TestBoardStatusPassed = TestBoardStatus.Passed;

@ PositionTestResult@ = +(Unit@ Passed, Position@ Failed);

PositionTestResult@ TestChooseBestMoveWin = {
  MemoState@<PositionResult@> mp = ComputeBestMove(MemoTable@(empty: Unit),
    Board@(
        Square@(X: Unit@()), Square@(X: Unit@()), Square@(E: Unit@()),
        Square@(O: Unit@()), Square@(O: Unit@()), Square@(E: Unit@()),
        Square@(E: Unit@()), Square@(E: Unit@()), Square@(E: Unit@())), Player@(X: Unit@()));
  Position@ position = mp.data.position;
  ?(position ;
      UL: PositionTestResult@(Failed: position), UC: PositionTestResult@(Failed: position), UR: PositionTestResult@(Passed: Unit@()),
      ML: PositionTestResult@(Failed: position), MC: PositionTestResult@(Failed: position), MR: PositionTestResult@(Failed: position),
      LL: PositionTestResult@(Failed: position), LC: PositionTestResult@(Failed: position), LR: PositionTestResult@(Failed: position));
};
Unit@ TestChooseBestMoveWinPassed = TestChooseBestMoveWin.Passed;

PositionTestResult@ TestChooseBestMoveNoLose = {
  MemoState@<PositionResult@> mp = ComputeBestMove(MemoTable@(empty: Unit),
    Board@(
        Square@(E: Unit@()), Square@(E: Unit@()), Square@(E: Unit@()),
        Square@(X: Unit@()), Square@(X: Unit@()), Square@(O: Unit@()),
        Square@(E: Unit@()), Square@(E: Unit@()), Square@(O: Unit@())), Player@(X: Unit@()));
  Position@ position = mp.data.position;
  ?(position ;
      UL: PositionTestResult@(Failed: position), UC: PositionTestResult@(Failed: position), UR: PositionTestResult@(Passed: Unit@()),
      ML: PositionTestResult@(Failed: position), MC: PositionTestResult@(Failed: position), MR: PositionTestResult@(Failed: position),
      LL: PositionTestResult@(Failed: position), LC: PositionTestResult@(Failed: position), LR: PositionTestResult@(Failed: position));
};
Unit@ TestChooseBestMoveNoLosePassed = TestChooseBestMoveNoLose.Passed;

(Unit@){Position@;} BenchmarkChooseBestMove = (Unit@ _) {
  ComputeBestMove(MemoTable@(empty: Unit),
    Board@(
        Square@(E: Unit@()), Square@(E: Unit@()), Square@(E: Unit@()),
        Square@(E: Unit@()), Square@(E: Unit@()), Square@(E: Unit@()),
        Square@(E: Unit@()), Square@(E: Unit@()), Square@(E: Unit@())), Player@(X: Unit@())).data.position;
};

@(NewGame, BenchmarkChooseBestMove);

# TODO:
# * Be able to easily combine multiple test cases
# * Use PositionEquals for test result, and report position when failed.

