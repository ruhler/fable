
@ Structure@ = /Structure%.Structure@;
<@>@ Structured@ = /Structured%.Structured@;

@ Unit@ = /Unit%.Unit@;
% Unit = /Unit%.Unit;

<@>@ Maybe@ = /Maybe%.Maybe@;
<@>% Nothing = /Maybe%.Nothing;
<@>% Just = /Maybe%.Just;

# Entry@ --
#   A key value pair stored on a Map@.
#
# Note:
#   We store the key along with the value so that we can easily iterate over
#   keys in the map. Another option would be to have a way to convert from
#   Structure@ back to key.
<@,@>@ Entry@ = <@ K@, @ V@> { *(K@ key, V@ value); };

# GetValue --
#   Gets the value from an optional Map entry.
<@ K@, @ V@>(Maybe@<Entry@<K@, V@>>) { Maybe@<V@>; }
GetValue = <@ K@, @ V@>(Maybe@<Entry@<K@, V@>> m) {
  m.?(just: Just<V@>(m.just.value), nothing: Nothing<V@>);
};

# Map@ --
#   A map from K@ to V@, using the Structure@ of K@ to locate the key value
#   entry in the map.
#
# Type Parameters:
#   K@ - the type of keys in the map.
#   V@ - the type of values in the map.
#
# Note: An empty map can be represented using the 'empty' tag, or using the
# 'map' tag with empty submaps. The 'empty' tag is needed to make the map
# finite, but sometimes it's convenient when removing elements from an
# existing map not to collapse the map back down to 'empty'.
<@,@>@ Map@ = <@ K@, @ V@> { +(Unit@ empty, MapP@<K@, V@> map); },

# MapP@ --
#   A (possibly empty) map from K@ to V@, using the Structure@ of K@ to locate
#   the key value entry in the map.
#
# Type Parameters:
#   K@ - the type of keys in the map.
#   V@ - the type of values in the map.
<@,@>@ MapP@ = <@ K@, @ V@> { 
  *(Maybe@<Entry@<K@, V@>> unit,
    *(Map@<K@, V@> a, Map@<K@, V@> b) either,
    Map@<Unit@, Map@<K@, V@>> pair
  );
};

# Empty --
#   A map without any entries.
#
# Type Parameters:
#   K@ - the type of keys in the map.
#   V@ - the type of values in the map.
#
# Example Use:
#   Empty<String@, Foo@>
Map@ Empty = <@ K@, @ V@> {
  Map@<K@, V@>(empty: Unit);
};

# EmptyP --
#   A MapP@ without any entries, used when inserting an entry into an empty
#   map.
#
# Type Parameters:
#   K@ - the type of keys in the map.
#   V@ - the type of values in the map.
MapP@ EmptyP = <@ K@, @ V@> {
  MapP@<K@, V@>(
    Nothing<Entry@<K@, V@>>,
    @(a: Empty<K@, V@>, b: Empty<K@, V@>),
    Empty<Unit@, Map@<K@, V@>>);
};

# LookupS --
#   Look up a value in a map given the Structure@ of the key.
#
# Type Parameters:
#   K@ - the type of keys in the map.
#   V@ - the type of values in the map.
#
# Inputs:
#   map - the map to look up the value in.
#   key - the structure of the key.
#
# Returns:
#   The value associated with the key with structure 's'. Nothing if the map
#   does not contain any such value.
<@ K@, @ V@>(Map@<K@, V@>, Structure@) { Maybe@<V@>; }
LookupS = <@ K@, @ V@>(Map@<K@, V@> map, Structure@ key) {
  map.?(
     empty: Nothing<V@>,
     map: {
       key.?(
          unit: GetValue<K@, V@>(map.map.unit),
          either: key.either.?(
                   a: LookupS<K@, V@>(map.map.either.a, key.either.a),
                   b: LookupS<K@, V@>(map.map.either.b, key.either.b)),
          pair: {
            Maybe@<Map@<K@, V@>> mm = LookupS<Unit@, Map@<K@, V@>>(map.map.pair, key.pair.a);
            mm.?(
                just: LookupS<K@, V@>(mm.just, key.pair.b),
                nothing: Nothing<V@>);
          });
     });
};

# Lookup --
#   Look up the value in a map for the given key.
#
# Type Parameters:
#   K@ - the type of keys in the map.
#   V@ - the type of values in the map.
#
# Inputs:
#   s - the Structured@ for the key used to get the structure of a key.
#   map - the map to look up the value in.
#   key - the structure of the key.
#
# Returns:
#   The value in the map associated with the key. Nothing if the map
#   does not contain any such value.
#
# Example Use:
#   % Lookup = /Map%.Lookup<String@>(/String/Structured%.Structured)<Foo@>;
#   Lookup(map, key);
#
#   % Lookup = /Map%.Lookup<String@>(/String/Structured%.Structured);
#   Lookup<Foo@>(mapToFoo, key);
#   Lookup<Bar@>(mapToBar, key);
<@ K@>(Structured@<K@>)<@ V@>(Map@<K@, V@>, K@) { Maybe@<V@>; }
Lookup = <@ K@>(Structured@<K@> s)<@ V@>(Map@<K@, V@> map, K@ key) {
  LookupS<K@, V@>(map, s(key));
};

# ModifyS --
#   Modify a value in a map, taking into account whatever existing value is
#   in the map for the given key, and with the option of inserting or removing
#   the value from the map. Uses the given Structure@ of the key to
#   locate the entry in the map.
#
# Type Parameters:
#   K@ - the type of keys in the map.
#   V@ - the type of values in the map.
#
# Inputs:
#   map - the map to insert the value into up the value in.
#   key - the value of the key to store with the map entry.
#   s - the structure to use to locate the map entry.
#   f - a function that returns the value to insert given the existing
#       value in the map, or Nothing to remove the entry from the map.
#
# Note:
#   's' is only the structure of 'key' at the top level call to ModifyS.
#   In recursive calls, 'key' will stay the same, but 's' will be adjusted for
#   whatever level of the map we are currently traversing.
<@ K@, @ V@>(Map@<K@, V@>, K@, Structure@, (Maybe@<V@>){ Maybe@<V@>; }) { Map@<K@, V@>; }
ModifyS = <@ K@, @ V@>(Map@<K@, V@> map, K@ key, Structure@ s, (Maybe@<V@>){ Maybe@<V@>; } f) {
  MapP@<K@, V@> p = map.?(empty: EmptyP<K@, V@>, map: map.map);
  Map@<K@, V@>(map: s.?(
    unit: MapP@<K@, V@>(
      {
        Maybe@<V@> nv = f(GetValue<K@, V@>(p.unit));
        nv.?(
          just: Just<Entry@<K@, V@>>(Entry@<K@, V@>(key, nv.just)),
          nothing: Nothing<Entry@<K@, V@>>);
      },
      p.either,
      p.pair
    ),

    either: s.either.?(
      a: MapP@<K@, V@>(p.unit, @(a: ModifyS<K@, V@>(p.either.a, key, s.either.a, f), b: p.either.b), p.pair),
      b: MapP@<K@, V@>(p.unit, @(a: p.either.a, b: ModifyS<K@, V@>(p.either.b, key, s.either.b, f)), p.pair)),

    pair: {
      MapP@<K@, V@>(p.unit, p.either,
        ModifyS<Unit@, Map@<K@, V@>>(p.pair, Unit, s.pair.a, (Maybe@<Map@<K@, V@>> mm) {
          Just<Map@<K@, V@>>(ModifyS<K@, V@>(mm.?(just: mm.just, nothing: Empty<K@, V@>), key, s.pair.b, f));
        }));
    }));
};

# InsertWith --
#   Insert a value into a map, taking into account whatever existing value is
#   in the map for the given key.
#
# Type Parameters:
#   K@ - the type of keys in the map.
#   V@ - the type of values in the map.
#
# Inputs:
#   s - the Structured@ for the key used to get the structure of a key.
#   map - the map to insert the value into up the value in.
#   key - the value of the key to store with the map entry.
#   with - a function that returns the value to insert given the existing
#          value in the map.
#
# Example Use:
#   % InsertWith = /Map%.InsertWith<String@>(/String/Structured%.Structured)<Int@>;
#   InsertWith(map, Str(Chars|foo), (Maybe@<Int@> mv) {
#     mv.?(just: Add(mv, value), nothing: value);
#   };
<@ K@>(Structured@<K@>)<@ V@>(Map@<K@, V@>, K@, (Maybe@<V@>){ V@; }) { Map@<K@, V@>; }
InsertWith = <@ K@>(Structured@<K@> s)<@ V@>(Map@<K@, V@> map, K@ key, (Maybe@<V@>) { V@; } with) {
  ModifyS<K@, V@>(map, key, s(key), (Maybe@<V@> v) { Just<V@>(with(v)); });
};

# Insert --
#   Insert a value into a map. Any existing value for the key in the map will
#   be overridden with the new value.
#
# Type Parameters:
#   K@ - the type of keys in the map.
#   V@ - the type of values in the map.
#
# Inputs:
#   s - the Structured@ for the key used to get the structure of a key.
#   map - the map to insert the value into up the value in.
#   key - the value of the key to store with the map entry.
#   value - the value to insert.
#
# Example Use:
#   % Insert = /Map%.Insert<String@>(/String/Structured%.Structured)<Int@>;
#   Insert(map, Str(Chars|foo), 4);
<@ K@>(Structured@<K@>)<@ V@>(Map@<K@, V@>, K@, V@) { Map@<K@, V@>; }
Insert = <@ K@>(Structured@<K@> s)<@ V@>(Map@<K@, V@> map, K@ key, V@ value) {
  ModifyS<K@, V@>(map, key, s(key), (Maybe@<V@> _) { Just<V@>(value); });
};

# Delete --
#   Remove a key and its value from the map, if present.
#
# Inputs:
#   s - the Structured@ for the key used to get the structure of a key.
#   map - the map to insert the value into up the value in.
#   key - the key of the value to delete from the map.
#
# Example Use:
#   % Delete = /Map%.Delete<String@>(/String/Structured%.Structured)<Int@>;
#   Delete(map, Str(Chars|foo));
<@ K@>(Structured@<K@>)<@ V@>(Map@<K@, V@>, K@) { Map@<K@, V@>; }
Delete = <@ K@>(Structured@<K@> s)<@ V@>(Map@<K@, V@> map, K@ key) {
  ModifyS<K@, V@>(map, key, s(key), (Maybe@<V@> _) { Nothing<V@>; });
};

# ForEach --
#   Iterate over entries of a map.
#
# Type Parameters:
#   K@ - the type of keys in the map.
#   V@ - the type of values in the map.
#   B@ - The type of value updated and returned by the foreach loop.
#
# Inputs:
#   map - the map to iterate over.
#   base - the initial value to update and return from the loop.
#   body - the body of the loop.
#
# Returns:
#   The result of applying the body consecutively to the base value, once for
#   each entry in the map.
#
# Conceptually:
#   B@ b = base
#   foreach (k, v) in map:
#     b = body(k, v, b)
#   return b
<@ K@, @ V@, @ B@>(Map@<K@, V@>, B@, (K@, V@, B@) { B@; }) { B@; }
ForEach = <@ K@, @ V@, @ B@>(Map@<K@, V@> map, B@ base, (K@, V@, B@) { B@ ;} body) {
  map.?(
    empty: base,
    map: {
      B@ b2 = map.map.unit.?(
        just: body(map.map.unit.just.key, map.map.unit.just.value, base),
        nothing: base);
      B@ b3 = ForEach<K@, V@, B@>(map.map.either.a, b2, body);
      B@ b4 = ForEach<K@, V@, B@>(map.map.either.b, b3, body);
      ForEach<Unit@, Map@<K@, V@>, B@>(map.map.pair, b4,
        (Unit@ _, Map@<K@, V@> v, B@ b) {
          ForEach<K@, V@, B@>(v, b, body);
      });
    });
};

@(Map@, Empty, Lookup, Insert, InsertWith, Delete, ForEach);
