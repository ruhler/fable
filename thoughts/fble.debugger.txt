Fble Debugger
=============
Features:
 - Set a breakpoint at a line in a file.
 - Step through code line by line.
 - Evaluate expressions in the context of the current scope and print the
   results.
 - Auto breakpoint at undefined behavior?
 - Any way we could do this just by using dwarf + gdb?

Times in the past I wished I have an fble debugger:
 - Debug why sudoku solver isn't working properly by stepping through a line
   at a time and printing intermediate values.

   Turns out it wasn't too hard to figure out the problem in this case without
   a debugger.

 - Debug why snake AI wasn't working.

   It turns out we were using the wrong direction. A debugger to step through
   code and print variable values would have found this more quickly than my
   guess and check approach, which was pretty tedious.

 - Debug why sat solver test is failing.
   Manual code inspection doesn't reveal the issue. I really want to trace the
   code to see which unexpected branch is being taken.

   Manually tracing through the code by profiling block led straight to the
   problem: bad implementation of boolean Eq.

 - Debug why List Eq test is failing. I want to step through again.
   Sigh. I definitely need a debugger.

   Turns out False was being defined as True instead of False. I figured that
   out by changing the body of ListEq to always return False and being
   surprised when the result was as if it returned True.

 - Debug why map equality is failing when show shows identical maps
   { (1,1) => 1; } vs. { (1,1) => 1; }

   Turns out it was a bug in map quality, not too hard to find by code
   inspection.

 - Debug where we're getting stuck in an infinite recursion in fble that
   exhibits as a fast memory leak followed by OOM kill.

   This turned out to be big memory use, not infinite recursion. I tracked it
   down by minimizing the test case enough to run it to completion, and using
   profiling to see how many times different functions were being called.

 - Debug wrong tag in fble tests, where the invariants for what the tag should
   be are a bit complicated.
   
   Ideally we can run until we hit the error, then get a stack trace in the
   debugger and have a way to look at local variables and the stack trace to
   figure out where things are going wrong.

   Turned out to be a flaw in the code. Identified by minimizing the test case
   and working out the issue on paper. It would have been much easier if I
   could have stepped through the code and printed values of local variables
   along the way.

 - Debug why drawing a line from (0, 0) to (-2, -2) actually draws a line from
   (-1, -1) to (-3, -3), ideally by stepping through the code and viewing
   local variables at each step.

   Walked through the code by hand on pen and paper to see that the code was
   doing exactly what I wanted it to, but what I wanted it to do was wrong.
   Being able to step through the code and view values of variables as we go
   would have been nicer than doing it on pen and paper.
 
---

It doesn't look like gdb can easily support languages that are far different
from C. Perhaps it's worth trying to develop a custom debugger for fble. I can
avoid any overhead/dependency on gdb that way. But it also means I have to
implement the entire thing myself.

There are guides online for how to add a new language to gdb, which requires
modifying the gdb source code. That includes ways to specify how to print
types and expressions and how to parse types and expressions.

Could we use dwarf to pretend we are executing C code, and encode structs and
unions in a way that gdb can understand? Then at least for structs we could
see all the fields, and for unions, perhaps we could see the names of tag?
That's about as good as we could do anyway, right?

Dealing with the stack will be challenging, given tail calls and the fact that
the stack is managed. Perhaps it would be simpler if I finish implementing my
plan to use native stacks. Or perhaps not.

I'm thinking it is at least worth a try to emit dwarf information. In that
process I'll see what we can encode in dwarf and how, and how useful gdb is in
that case.

Let's go a ways down this route and see where we get. Initial goals:
* Be able to set break points and step through .fble files.
* Be able to print data type values as structs/unions based on variables on
  the stack.

Don't worry about stack traces yet. And let's focus on debugging compiled
code, which I suspect would be easier.

What happens today if we try to run a compiled program and set a breakpoint
based on an fble source file and line number? It says no such source file.

The first step, then, should be to see how we can get my .fble files included
in the list from 'info sources'. Let's download the dwarf spec and see how
to start with that.

---

My sample assembly program passes the file using a '.file' assembly directive
at the top of the generated assembly:

.arch armv8-a
.file "foo.c"

Within the assembly, I also see directives of the form:

.file 1 "foo.c"

And:

.loc 1 9 3
.loc 1 13 12 discriminator 3
.loc 1 13 12 is_stmt 0
.loc 1 13 12 is_stmt 1

My guess is what we need is:
* .file 1 "foo.c" somewhere near the top of the generated assembly file.
* .loc 1 <line> <col> for each line, and after the last line.

What does the gnu assembly docs say about these?
* The plain .file "foo.c" directive is deprecated
* https://www.sourceware.org/binutils/docs/as/index.html seems to have decent
  documentation of the directives.

The .loc options are all related to the .debug_line state machine, which I can
probably read about in the dwarf spec, page 151:

* lines and cols start at '1'
* is_stmt is a recommended breakpoint location
* discriminator is used in case multiple blocks have the same line, column,
  and file.

My guess is I don't have to worry about any of the line number options.

So, plan is simple:
* At the top of the generated assembly, emit a .file 1 "foo.c" directive.
* At the start of each emitted instruction, ...

We have to decide and track somehow which code instructions should have line
numbers associated with them. Or at least, which are starts of statements. We
also need to start tracking line number information more generally in
FbleInstr.

I would say a statement is:
* let bindings, branch of case expression, expression in a block or 'stmt'
  form, union_select statement, function bind, proc_link, and proc_exec.

Other things are not statements.

Can we use our profiling block locations as statements? We already have that
information available in the code block, and it has the location information.

Let's try this: profile enter and profile replace emit locations which will
correspond to statements. Try that.

It works! I can now set breakpoints on .fble files. Stepping through doesn't
work too well at this point, but it's a good start.

Question also: the profile blocks are basic blocks, not statements. This means
we'll skip over let expressions and things like that. It would be good if we
could add statements there. Maybe we could add a fake kind of profile op to
mark the beginning of a statement?

---

Note: Turn off -O3 when debugging to get better info, hopefully.

How can I print the values of variables?

Maybe to start, can we list the available variables somehow in gdb? Perhaps
'info locals'?

And also, typing 'next' in gdb doesn't work at all. Would be nice if I could
fix that somehow. Perhaps because we don't have more statements in the same
block, and so it doesn't know where the statement ends?

Other things my sample assembly has:
.cfi_startproc
.cfi_def_cfa_offset 16
.cfi_endproc

And a .debug_info section.

---

I finally read through the dwarf5 spec in sufficient detail. My summary of
dwarf is:

Debugging information is represented as a tree of nodes. Nodes describe things
like programs, functions, call sites, declarations, etc. Each node has a tag
describing the type of the node and a collection of key,value pairs which are
attributes. The tree is flattened into a sequence of nodes stored in the
.debug_info section.

Along with the tree of nodes, there is a section for storing a mapping from
line numbers to machine addresses, stored in .debug_lines. There is also a
section for call frame information, stored in .debug_frame, that describes how
to unwind the stack and restore registers appropriately.

My guess is that the gnu assembler generates the .debug_lines section for me
based on my .loc directives, and it would generate the .debug_frames section
for me too if I add relevant cfi directives. I'll have to write the
.debug_info tree myself.

The dwarf spec has an appendix showing what all attributes you could expect
for various node types in the tree. I don't know what information gdb needs
for specific features, such as going to the next statement. But presumably if
I try to fill out the debug information tree with as much information as I
reasonably can that seems related, eventually I'll get to a place where gdb
can do good things.

Note that dwarf5 does support tagged unions. I think they call them variants.

What approach should I take for adding dwarf support? I would like to do it
well and complete. Not just hacky like I have so far. For example, statements
should include all the statements, not just the beginnings of blocks. Then it
should be fairly straight forward I think: start with a minimal compilation
unit debug tree, then slowly and recursively add more attributes until we get
to a place we are happy with.

A big challenge will be figuring out how to write tests for the generated
debug info.

Maybe libdwarf will be useful? Looks like it can do some sanity checks, and
dump to human readable format. So I could at least craft a particular .fble
file, dump the dwarf for it, and verify it has all the statements and
variables and types and such? Or perhaps objdump has some support?

dwarf.h and libdwarf.h exist on my computer, defining a bunch of the dwarf
contents. That will be useful.

For example, try objdump with --dwarf and see what it outputs. And it has
a --dwarf-check option too.

It looks like the assembler is generating a compilation unit entry for me. It
also says it is emitting dwarf2. Maybe I should start by generating dwarf2,
which is perhaps more widely supported than dwarf5 and simpler?

I think first step is to pick some attribute I want to add to the compilation
unit node. Figure out how to add that in the assembler. Next step is to figure
out how to add a broken attribute value and use objdump or dwarfdump to catch
the error. Then set up a dwarf test case that runs as part of build.

Once I have the infrastructure up and running to test dwarf, I guess I can
slowly start adding dwarf. For now we can just check for consistency in the
generated dwarf code.

