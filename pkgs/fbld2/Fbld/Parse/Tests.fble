
@ Decimal@ = /Core/Digits%.Decimal@;

<@>@ List@ = /Core/List%.List@;
<@>% List = /Core/List%.List;

@ String@ = /Core/String%.String@;
% Str = /Core/String%.Str;
% StrE = /Core/String%.StrE;
% Lines = /Core/String%.Lines;

@ Test@ = /Core/Test%.Test@;
@ TestResult@ = /Core/Test%.TestResult@;
% Test = /Core/Test%.Test;
% TestSuite = /Core/Test%.TestSuite;
<@>% AssertEquals = /Core/Test%.AssertEquals;

@ Unit@ = /Core/Unit%.Unit@;

@ Loc@ = /Fbld/Loc%.Loc@;

@ Markup@ = /Fbld/Markup%.Markup@;
@ Element@ = /Fbld/Markup%.Element@;
% Command = /Fbld/Markup%.Command;
% Plain = /Fbld/Markup%.Plain;
% M = /Fbld/Markup%.Markup;

<@>@ Result@ = /Fbld/Result%.Result@;
<@>% Ok = /Fbld/Result%.Ok;

% Parse = /Fbld/Parse%.Parse;

@ Text@ = /Fbld/Text%.Text@;

(List@<Decimal@>)(List@<Decimal@>) { Loc@; }
L = (List@<Decimal@> line)(List@<Decimal@> col) {
  Loc@(Str|'foo.fbld', /Core/Int/Lit%.Int(line), /Core/Int/Lit%.Int(col));
};

(List@<Decimal@>)(List@<Decimal@>)(String@)(List@<Markup@>) { Element@; }
C = (List@<Decimal@> line)(List@<Decimal@> col)(String@ name)(List@<Markup@> args) {
  Command(L(line)(col), name)(args);
};

(List@<Decimal@>)(List@<Decimal@>)(String@) { Text@; }
T = (List@<Decimal@> line)(List@<Decimal@> col)(String@ text) {
  Text@(L(line)(col), text);
};

(List@<Decimal@>)(List@<Decimal@>)(String@) { Element@; }
P = (List@<Decimal@> line)(List@<Decimal@> col)(String@ text) {
  Plain(L(line)(col), StrE(text));
};

(Result@<Markup@>, Result@<Markup@>) { TestResult@; }
AssertResultEquals = (Result@<Markup@> expected, Result@<Markup@> actual) {
  AssertEquals(
    /Fbld/Result/Eq%.Eq(/Fbld/Markup/Eq%.Markup),
    /Fbld/Result/Show%.Show(/Fbld/Markup/Show%.Markup),
    expected, actual);
};

Test@ Tests = TestSuite(Str|Parse, List[
  Test(Str|Unescape, (Unit@ _) {
    String@ text = Str|'a \\ \a\[\]bcd\@';
    String@ want = Str|'a \ a[]bcd@';

    Result@<Markup@> got = Parse[T|1|1(text)];
    Result@<Markup@> wnt = Ok(M[C|1|1|'.block'[M[P|1|1(want)]]]);
    AssertResultEquals(wnt, got);
  }),

  Test(Str|BasicInline, (Unit@ _) {
    String@ text = Str|'Inline @emph[text] with @SINGLE and @multi[abc][def] arg commands';

    Result@<Markup@> got = Parse[T|1|1(text)];
    Result@<Markup@> wnt = Ok(M[C|1|1|'.block'[M[
      P|1|1|'Inline ',
      C|1|9|'emph'[M[P|1|14|'text']],
      P|1|19|' with ',
      C|1|26|'SINGLE'[],
      P|1|32|' and ',
      C|1|38|'multi'[M[P|1|44|'abc'], M[P|1|49|'def']],
      P|1|53|' arg commands']]]);
    AssertResultEquals(wnt, got);
  }),

  Test(Str|BasicBlock, (Unit@ _) {
    String@ text = Lines[
      Str|'',
      Str|'@title A title',
      Str|'',
      Str|'Some intro text.',
      Str|'',
      Str|'@section[First Section]',
      Str|' With some text',
      Str|' spanning over lines.',
      Str|'',
      Str|' multiple lines actually.',
      Str|'',
      Str|'And some final text.'
    ];

    Result@<Markup@> got = Parse[T|1|1(text)];
    Result@<Markup@> wnt = Ok(M[
      C|1|2|'title'[M[P|2|8|'A title']],
      C|4|1|'.block'[M[P|4|1|'Some intro text.\n']],
      C|6|2|'section'[M[P|6|10|'First Section'], M[
        C|7|2|'.block'[M[P|7|2|'With some text\nspanning over lines.\n']],
        C|9|2|'.block'[M[P|9|2|'multiple lines actually.\n']]]],
      C|12|1|'.block'[M[P|4|1|'And some final text.\n']]]);
    AssertResultEquals(wnt, got);
  })

#  Test(Str|InlineLoc, (Unit@ _) {
#    # Regression test for when we failed to preserve internal locations when
#    # parsing arguments.
#    Text@ foo = Text(Str|'foo', Loc@(Str|'a.fbld', Int|1, Int|0));
#    Text@ hello = Text(Str|'hello', Loc@(Str|'b.fbld', Int|1, Int|0));
#    Text@ there = Text(Str|'there', Loc@(Str|'c.fbld', Int|1, Int|0));
#    Text@ hellothere = Append(hello, there);
#    Text@ in = /Fbld/Text%.Concat(Loc@(Str|'g.fbld', Int|1, Int|0), List[
#      Text(Str|'@', Loc@(Str|'d.fbld', Int|1, Int|0)),
#      foo,
#      Text(Str|'[', Loc@(Str|'e.fbld', Int|1, Int|0)),
#      hellothere,
#      Text(Str|']', Loc@(Str|'f.fbld', Int|1, Int|0))
#    ]);
#
#    Result@<List@<Command@>> wnt = Ok(List[
#      Command@(foo, List[hellothere])]);
#    Result@<List@<Command@>> got = Inline(in);
#
#    AssertEquals(
#      /Fbld/Eq%.Result(/Fbld/Eq%.Commands),
#      /Fbld/Show%.Result(/Fbld/Show%.Commands),
#      wnt, got);
#  }),
#
#  Test(Str|NestedInline, (Unit@ _) {
#    (String@, Int@) { Text@; } s = (String@ str, Int@ col) {
#      Text(str, Loc@(Str|'file.fbld', Int|1, col));
#    };
#
#    String@ text = Str|'Ab @c[de @f[gh] ij] kl';
#    Result@<List@<Command@>> wnt = Ok(List[
#      Command@(s(Str|'.inline', Int|1), List[s(Str|'Ab ', Int|1)]),
#      Command@(s(Str|'c', Int|5), List[s(Str|'de @f[gh] ij', Int|7)]),
#      Command@(s(Str|'.inline', Int|20), List[s(Str|' kl', Int|20)])]);
#    Result@<List@<Command@>> got = Inline(s(text, Int|1));
#    AssertEquals(
#      /Fbld/Eq%.Result(/Fbld/Eq%.Commands),
#      /Fbld/Show%.Result(/Fbld/Show%.Commands),
#      wnt, got);
#  }),
#
#  # Regression test for a default block that runs to the end of the file.
#  Test(Str|BlockToEndOfFile, (Unit@ _) {
#    (String@, Int@, Int@) { Text@; } s = (String@ str, Int@ line, Int@ col) {
#      Text(str, Loc@(Str|'file.fbld', line, col));
#    };
#
#    String@ text = Str|'Foo';
#    Result@<List@<Command@>> wnt = Ok(List[
#      Command@(s(Str|'.block', Int|1, Int|1), List[
#        s(Str|'Foo', Int|1, Int|1)])]);
#    Result@<List@<Command@>> got = Block(s(text, Int|1, Int|1));
#    AssertEquals(
#      /Fbld/Eq%.Result(/Fbld/Eq%.Commands),
#      /Fbld/Show%.Result(/Fbld/Show%.Commands),
#      wnt, got);
#  }),
#
#  Test(Str|NestedBlockLoc, (Unit@ _) {
#    (String@, Int@, Int@) { Text@; }
#    s = (String@ str, Int@ line, Int@ col) {
#      Text(str, Loc@(Str|'file.fbld', line, col));
#    };
#
#    String@ text = Str|'
#@foo
# @bar
#  @sludge
#';
#    List@<Command@> foo = Block(s(text, Int|1, Int|1)).ok;
#    Text@ foo_body = foo.cons.head.args.cons.head;
#
#    List@<Command@> bar = Block(foo_body).ok;
#    Text@ bar_body = bar.cons.head.args.cons.head;
#
#    List@<Command@> sludge = Block(bar_body).ok;
#    Loc@ wnt = Loc@(Str|'file.fbld', Int|4, Int|4);
#    Loc@ got = LocOf(sludge.cons.head.name);
#    AssertEquals(/Fbld/Eq%.Loc, /Fbld/Show%.Loc, wnt, got);
#  }),
#
#  Test(Str|Continuation, (Unit@ _) {
#    (String@, Int@, Int@) { Text@; }
#    s = (String@ str, Int@ line, Int@ col) {
#      Text(str, Loc@(Str|'file.fbld', line, col));
#    };
#
#    String@ text = Str|'
#@list[first][second]
# third
#@[fourth] fifth
#@ sixth
# seventh
#@ eigth
#@sludge
#';
#    Result@<List@<Command@>> wnt = Ok(List[
#      Command@(s(Str|'list', Int|2, Int|2), List[
#        s(Str|'first', Int|2, Int|7),
#        s(Str|'second', Int|2, Int|14),
#        s(Str|'third
#', Int|3, Int|2),
#        s(Str|'fourth', Int|4, Int|3),
#        s(Str|'fifth', Int|4, Int|11),
#        s(Str|'sixth', Int|5, Int|3),
#        s(Str|'seventh
#', Int|6, Int|2),
#        s(Str|'eigth', Int|7, Int|3)]),
#      Command@(s(Str|'sludge', Int|8, Int|2), Nil<Text@>)]);
#    Result@<List@<Command@>> got = Block(s(text, Int|1, Int|1));
#    AssertEquals(
#      /Fbld/Eq%.Result(/Fbld/Eq%.Commands),
#      /Fbld/Show%.Result(/Fbld/Show%.Commands),
#      wnt, got);
#  }),
#
#  Test(Str|Final, (Unit@ _) {
#    (String@, Int@, Int@) { Text@; }
#    s = (String@ str, Int@ line, Int@ col) {
#      Text(str, Loc@(Str|'file.fbld', line, col));
#    };
#
#    String@ text = Str|'
#@foo
# here is some stuff.
#@@
#@bar here is the end.
# Of all the rest.
#';
#    Result@<List@<Command@>> wnt = Ok(List[
#      Command@(s(Str|'foo', Int|2, Int|2), List[
#        s(Str|'here is some stuff.
#', Int|3, Int|2),
#        s(Str|'@bar here is the end.
# Of all the rest.
#', Int|5, Int|1)])]);
#    Result@<List@<Command@>> got = Block(s(text, Int|1, Int|1));
#    AssertEquals(
#      /Fbld/Eq%.Result(/Fbld/Eq%.Commands),
#      /Fbld/Show%.Result(/Fbld/Show%.Commands),
#      wnt, got);
#  })
]);

@(Tests);
