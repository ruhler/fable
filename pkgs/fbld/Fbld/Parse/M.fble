
@ Bool@ = /Core/Bool%.Bool@;
% True = /Core/Bool%.True;
% False = /Core/Bool%.False;

@ Char@ = /Core/Char%.Char@;
% IsNewline = /Core/Char/Type%.IsNewline;

@ Int@ = /Core/Int%.Int@;
% Incr = /Core/Int%.Incr;
% Int = /Core/Int/Lit%.Int;

<@>@ Maybe@ = /Core/Maybe%.Maybe@;
<@>% Just = /Core/Maybe%.Just;
<@>% Nothing = /Core/Maybe%.Nothing;

<@>@ List@ = /Core/List%.List@;
<@>% Cons = /Core/List%.Cons;

@ String@ = /Core/String%.String@;
% Str = /Core/String%.Str;
% Strs = /Core/String%.Strs;

@ Unit@ = /Core/Unit%.Unit@;
% Unit = /Core/Unit%.Unit;

@ Loc@ = /Fbld/Loc%.Loc@;
% Advance = /Fbld/Loc%.Advance;
% Unknown = /Fbld/Loc%.Unknown;

<@>@ Result@ = /Fbld/Result%.Result@;
<@>% Ok = /Fbld/Result%.Ok;
<@>% Err = /Fbld/Result%.Err;

@ Text@ = /Fbld/Text%.Text@;
% Text = /Fbld/Text%.Text;

# S@ - State for parser monad.
@ S@ = *(List@<Text@> input);

# R@ - Reader for parser monad.
@ R@ = *(S@ s, Int@ indent);

# State monad for parser monad.
<@>@ SM@ = <@ T@> { *(S@ s, T@ x); };

# M@ - A parser monad.
<@>@ M@ = <@ T@>(R@) { Result@<SM@<T@>>; };

# Return the given value.
<@ T@>(T@) { M@<T@>; }
Return = <@ T@>(T@ x)(R@ r) {
  Ok(SM@(r.s, x));
};

# Report a parse error.
<@ T@>(Loc@, String@) { M@<T@>; }
Error = <@ T@>(Loc@ l, String@ msg)(R@ _) {
  Err<SM@<T@>>(Text(l, msg));
};

# Monadic Do for the parser monad.
<@ A@>(M@<A@>)<@ B@>((A@) { M@<B@>; }) { M@<B@>; }
Do = <@ A@>(M@<A@> ma)<@ B@>((A@) { M@<B@>; } f)(R@ r) {
  Result@<SM@<A@>> ra = ma(r);
  ra.?(err: Err<SM@<B@>>(ra.err));
  f(ra.ok.x)(r.@(s: ra.ok.s));
};

# Returns the current indent level.
M@<Int@> GetIndent = (R@ r) {
  Ok(SM@(r.s, r.indent));
};

@ CharL@ = *(Char@ c, Loc@ l);

# Gets the next character in the input stream, advancing the parser state as
# appropriate. Fails if there are no more characters in the input stream.
M@<CharL@> GetL_ = (R@ r) {
  List@<Text@> in = r.s.input;
  in.?(nil: Err<SM@<CharL@>>(Text(Unknown, Str|'unexpected end of input')));
  in.cons.head.text.?(nil: GetL_(r.@(s: S@(in.cons.tail))));

  Char@ c = in.cons.head.text.cons.head;
  Loc@ l = in.cons.head.loc;
  Text@ head = Text(Advance(l, c), in.cons.head.text.cons.tail);
  Ok(SM@(S@(Cons(head, in.cons.tail)), @(c, l)));
};

# Parse an indented block of text.
# Single space indent is used. The indent characters will be skipped over and
# end of input will be returned when the indented text ends.
<@ T@>(M@<T@>) { M@<T@>; } Indented = <@ T@>(M@<T@> mx)(R@ r) {
  mx(r.@(indent: Incr(r.indent)));
};
  
# Try running a parser. If it succeeds, return the parsed value. If it fails,
# return Nothing.
<@ T@>(M@<T@>) { M@<Maybe@<T@>>; }
Try = <@ T@>(M@<T@> mx)(R@ r) {
  Result@<SM@<T@>> rx = mx(r);
  rx.?(err: Ok(SM@(r.s, Nothing<T@>)));
  Ok(SM@(rx.ok.s, Just(rx.ok.x)));
};

# Test if a parser would match at the current position, without consuming any
# input.
<@ T@>(M@<T@>) { M@<Maybe@<T@>>; }
Test = <@ T@>(M@<T@> mx)(R@ r) {
  Result@<SM@<T@>> rx = mx(r);
  rx.?(err: Ok(SM@(r.s, Nothing<T@>)));
  Ok(SM@(r.s, Just(rx.ok.x)));
};

# Runs a parser monad on the given input string.
<@ T@>(M@<T@>, List@<Text@>) { Result@<T@>; }
Run = <@ T@>(M@<T@> m, List@<Text@> input) {
  Result@<SM@<T@>> r = m(R@(S@(input), Int|0));
  r.?(err: Err<T@>(r.err));
  Ok(r.ok.x);
};

# Gets the next character in the input stream, advancing the parser state as
# appropriate. Fails if there are no more characters in the input stream.
# Takes account of the current indent level.
M@<CharL@> GetL = {
  CharL@ cl <- Do(GetL_);
  Int@ indent <- Do(GetIndent);

  /Core/Int/Eq%.Le(cl.l.col, indent).?(true: {
    IsNewline(cl.c).?(true: Return(cl));
    cl.c.?(' ': GetL);
    Error<CharL@>(cl.l, Str|'end of indented block');
  });

  Return(cl);
};

# Returns the location of the next input character.
M@<Loc@> Loc = {
  Maybe@<CharL@> mc <- Do(Test(GetL));
  Return(mc.?(just: mc.just.l, nothing: Unknown));
};

# Gets the next character in the input stream, advancing the parser state as
# appropriate. Fails if there are no more characters in the input stream.
M@<Char@> Get = {
  CharL@ cl <- Do(GetL);
  Return(cl.c);
};

# Same as Try, but discards the result of a successful match.
<@ T@>(M@<T@>) { M@<Bool@>; }
Try_ = <@ T@>(M@<T@> mx) {
  Maybe@<T@> r <- Do(Try(mx));
  Return(r.?(just: True, nothing: False));
};

# Parses either of the given arguments, returning the result of the first to
# pass. Fails if both parsers fails.
(M@<Unit@>, M@<Unit@>) { M@<Unit@>; }
Or = (M@<Unit@> ma, M@<Unit@> mb) {
  Bool@ a <- Do(Try_(ma));
  a.?(true: Return(Unit));
  mb;
};

# Test if a parser would match at the current position, without consuming any
# input, and ignoring the result of parsing.
<@ T@>(M@<T@>) { M@<Bool@>; }
Test_ = <@ T@>(M@<T@> mx) {
  Maybe@<T@> r <- Do(Test(mx));
  Return(r.?(just: True, nothing: False));
};

# Parse end of input. Fails if we have not reached the end of the input.
M@<Unit@> EndOfInput = {
  Loc@ l <- Do(Loc);
  Maybe@<Char@> mc <- Do(Test(Get));
  mc.?(nothing: Return(Unit));
  Error<Unit@>(l, Str|'expected end of input');
};

# Parse a specific string from the input stream. Fails if the input string
# does not match that string.
(String@) { M@<Unit@>; }
String = (String@ s) {
  s.?(nil: Return(Unit));
  Loc@ loc <- Do(Loc);
  Char@ c <- Do(Get);
  /Core/Char/Eq%.Eq(s.cons.head, c).?(
    true: String(s.cons.tail),
    false: Error<Unit@>(loc, Strs[
      Str|'Expected ''', Str[s.cons.head], Str|'''']));
};

@(M@, Return, Error, Do, Loc, Get, GetIndent, EndOfInput, Indented,
  Try, Try_, Test, Test_, Or, String,
  Run);
