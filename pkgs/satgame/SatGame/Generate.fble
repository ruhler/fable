
@ Bool@ = /Core/Bool%.Bool@;
% True = /Core/Bool%.True;
% False = /Core/Bool%.False;

@ Int@ = /Core/Int%.Int@;
% Add = /Core/Int%.Add;
% Sub = /Core/Int%.Sub;
% Incr = /Core/Int%.Incr;
% Decr = /Core/Int%.Decr;
% IsZero = /Core/Int/Eq%.IsZero;
% Le = /Core/Int/Eq%.Le;
% Div = /Core/Int/Div%.Div;
% Range = /Core/Int/Iter%.Range;
% CountUpTo = /Core/Int/Iter%.CountUpTo;
% Int = /Core/Int/Lit%.Int;

<<@>@>@ Monad@ = /Core/Monad%.Monad@;

<@>@ List@ = /Core/List%.List@;
<@>% Cons = /Core/List%.Cons;
<@>% Nil = /Core/List%.Nil;
<@>% List = /Core/List%.List;
% Take = /Core/List/Length%.Take;

@ VarId@ = /SatGame/Puzzle%.VarId@;
@ Var@ = /SatGame/Puzzle%.Var@;
@ Clause@ = /SatGame/Puzzle%.Clause@;
@ Params@ = /SatGame/Puzzle%.Params@;
@ Puzzle@ = /SatGame/Puzzle%.Puzzle@;

<<@>@>@ Random@ = /SatGame/Random%.Random@;

<@,@>@ Map@ = /Core/Map%.Map@;
% Empty = /Core/Map%.Empty<Int@, VarId@>;
% Lookup = /Core/Map%.Lookup<Int@>(/Core/Int/Ord%.Ord)<VarId@>;
% Insert = /Core/Map%.Insert<Int@>(/Core/Int/Ord%.Ord)<VarId@>;

# @func[Generate] Generates a random satgame puzzle.
#  @arg[<@>@][M@] Type of monad to use for random number generation.
#  @arg[Monad@<M@>][m] Monad to use for random number generation.
#  @arg[Random@<M@>][rand] Random number generator.
#  @arg[Params@][params] Parameters for the puzzle to generate.
#  @returns[M@<Puzzle@>] The generated puzzle.
<<@>@ M@>(Monad@<M@> m, Random@<M@> rand, Params@ params) {
  % RandInt = /SatGame/Random/Int%.RandInt(m, rand);
  <@>% Shuffle = /SatGame/Random/List%.Shuffle(m, rand);

  Le(params.num_vars, params.num_vars_per_clause).?(true: {
    # We can't generate a puzzle unless we have more vars to work with than
    # vars per clause.
    % TooFewVars = /Core/Undef%.Undef<M@<Puzzle@>>;
    TooFewVars.undefined;
  });

  Map@<Int@, VarId@> var_ids <- m.do({
    List@<VarId@> ordered = /Core/Iter%.For(CountUpTo(params.num_vars), Nil<VarId@>, Cons<VarId@>);
    List@<VarId@> shuffled <- m.do(Shuffle(ordered));
    @ S@ = *(Int@ i, Map@<Int@, VarId@> map);
    Map@<Int@, VarId@> map = /Core/List%.ForEach(shuffled, S@(Int|0, Empty),
      (VarId@ vid, S@ s) {
        S@(Incr(s.i), Insert(s.map, s.i, vid));
      }).map;
    m.return(map);
  });

  (Int@) { M@<VarId@>; } RandVarId = (Int@ max) {
    Int@ index <- m.do(RandInt(max));
    m.return(Lookup(var_ids, index).just);
  };

  (Int@) { M@<Var@>; } RandVar = (Int@ max) {
    Bool@ pos <- m.do(rand.bool);
    VarId@ id <- m.do(RandVarId(max));
    m.return(Var@(id, pos));
  };

  (Clause@, VarId@) { Bool@; }
  ContainsVarId = (Clause@ c, VarId@ id) {
    c.?(nil: False);
    /Core/Int/Eq%.Eq(c.cons.head.id, id).?(true: True);
    ContainsVarId(c.cons.tail, id);
  };

  # Generates a random clause with variable v and other variables with index
  # less than max.
  (Params@, Int@, Var@) { M@<Clause@>; } GenClause = (Params@ params, Int@ max, Var@ v) {
    # Adds N random variables with id less than max to the given clause.
    (Int@, Clause@) { M@<Clause@>; } AddVars = (Int@ n, Clause@ c) {
      IsZero(n).?(true: m.return(c));

      Var@ var <- m.do(RandVar(max));
      ContainsVarId(c, var.id).?(true: AddVars(n, c));
      AddVars(Decr(n), Cons(var, c));
    };

    Clause@ clause <- m.do(AddVars(Decr(params.num_vars_per_clause), List[v]));
    Shuffle(clause);
  };
    
  Int@ num_free_vars = Sub(params.num_vars, params.num_vars_per_clause);
  Int@ clauses_per_variable = Div(Decr(Add(params.num_clauses, num_free_vars)), num_free_vars).q;

  Puzzle@ puzzle <- m.do(/Core/Iter%.For(
    Range(params.num_vars_per_clause, params.num_vars), m.return(Nil<Clause@>),
    (Int@ i, M@<Puzzle@> mp) {
      Bool@ pos <- m.do(rand.bool);
      Var@ var = Var@(Lookup(var_ids, i).just, pos);
      /Core/Iter%.For(CountUpTo(clauses_per_variable), mp,
        (Int@ _, M@<Puzzle@> mp) {
          Puzzle@ tail <- m.do(mp);
          Clause@ clause <- m.do(GenClause(params, i, var));
          m.return(Cons(clause, tail));
        });
    }));
  Puzzle@ shuffled <- m.do(Shuffle(puzzle));
  m.return(Take(params.num_clauses, shuffled));
};
