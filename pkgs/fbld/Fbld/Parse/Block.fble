
@ Bool@ = /Core/Bool%.Bool@;
% False = /Core/Bool%.False;

@ Char@ = /Core/Char%.Char@;
% IsNewline = /Core/Char/Type%.IsNewline;

<@>@ List@ = /Core/List%.List@;
<@>% Cons = /Core/List%.Cons;
<@>% Nil = /Core/List%.Nil;
<@>% List = /Core/List%.List;
<@>% Reverse = /Core/List%.Reverse;
<@>% Concat = /Core/List%.Concat;
<@>% Append = /Core/List%.Append;

<@>@ Maybe@ = /Core/Maybe%.Maybe@;
<@>% Just = /Core/Maybe%.Just;
<@>% Nothing = /Core/Maybe%.Nothing;

% Str = /Core/String%.Str;

@ Unit@ = /Core/Unit%.Unit@;
% Unit = /Core/Unit%.Unit;

@ Command@ = /Fbld/Command%.Command@;
@ Loc@ = /Fbld/Loc%.Loc@;

@ Text@ = /Fbld/Text%.Text@;
% Text = /Fbld/Text%.Text;
% Head = /Fbld/Text%.Head;
% Tail = /Fbld/Text%.Tail;
% IsEmpty = /Fbld/Text%.IsEmpty;
% LocOf = /Fbld/Text%.LocOf;

<@>@ M@ = /Fbld/Parse/M%.M@;
<@>% Return = /Fbld/Parse/M%.Return;
<@>% Error = /Fbld/Parse/M%.Error;
<@>% Do = /Fbld/Parse/M%.Do;
% Peek = /Fbld/Parse/M%.Peek;
% Loc = /Fbld/Parse/M%.Loc;
% Get = /Fbld/Parse/M%.Get;
% Skip = /Fbld/Parse/M%.Skip;
% GetText = /Fbld/Parse/M%.GetText;
<@>% Try_ = /Fbld/Parse/M%.Try_;
<@>% Test_ = /Fbld/Parse/M%.Test_;
% String = /Fbld/Parse/M%.String;
% EmptyM = /Fbld/Parse/M%.EmptyM;
% ConsM = /Fbld/Parse/M%.ConsM;

% Name = /Fbld/Parse/Inline%.Name;
% InlineArgs = /Fbld/Parse/Inline%.Args;

M@<Unit@> SkipBlankLines = {
  Maybe@<Char@> mc <- Do(Peek);
  mc.?(nothing: Return(Unit));
  IsNewline(mc.just).?(true: {
    Unit@ _ <- Do(Skip);
    SkipBlankLines;
  });
  Return(Unit);
};

# Returns a block of plain text if any.
M@<Text@> Plain = {
  M@<Text@> plain = {
    Loc@ l <- Do(Loc);
    Maybe@<Char@> mc <- Do(Get);
    mc.?(nothing: EmptyM);
    Char@ c = mc.just;

    ConsM(c, l, {
      IsNewline(mc.just).?(true: {
        Maybe@<Char@> mc <- Do(Peek);
        mc.?(nothing: EmptyM);
        IsNewline(mc.just).?(true: EmptyM);
        plain;
      });
      plain;
    });
  };

  Maybe@<Char@> mc <- Do(Peek);
  mc.?(nothing: EmptyM);
  mc.just.?('@': EmptyM);
  plain;
};

M@<Maybe@<Text@>> SameLineArg = {
  M@<Text@> same_line_arg = {
    Loc@ l <- Do(Loc);
    Maybe@<Char@> mc <- Do(Get);
    mc.?(nothing: EmptyM);
    IsNewline(mc.just).?(true: EmptyM);
    ConsM(mc.just, l, same_line_arg);
  };

  Loc@ l <- Do(Loc);
  Maybe@<Char@> mc <- Do(Get);
  mc.?(nothing: Return(Nothing<Text@>));
  IsNewline(mc.just).?(true: Return(Nothing<Text@>));
  mc.just.?(' ': {
    Loc@ l <- Do(Loc);
    Text@ t <- Do(same_line_arg);
    Return(Just(t));
  });
  Error<Maybe@<Text@>>(Text(Str|'Expected space', l));
};

(Text@) { Bool@; } IsBlankLine = (Text@ t) {
  IsEmpty(t).?(true: False);
  IsNewline(Head(t)).?(false: False);
  IsEmpty(Tail(t));
};

M@<Maybe@<Text@>> NextLineArg = {
  # Parse starting from the start of a line.
  M@<Text@> start_of_line = {
    Loc@ l <- Do(Loc);
    Maybe@<Char@> mc <- Do(Peek);
    mc.?(nothing: EmptyM);

    IsNewline(mc.just).?(true: {
      Unit@ _ <- Do(Skip);
      Text@ tail <- Do(start_of_line);
      IsBlankLine(tail).?(true: Return(tail));
      Return(/Fbld/Text%.Cons(mc.just, l, tail));
    });

    mc.just.?(' ': {
      Unit@ _ <- Do(Skip);
      middle_of_line;
    });

    EmptyM;
  },

  # Parse starting from the middle of a line.
  M@<Text@> middle_of_line = {
    Loc@ l <- Do(Loc);
    Maybe@<Char@> mc <- Do(Get);
    mc.?(nothing: EmptyM);
    ConsM(mc.just, l, {
      IsNewline(mc.just).?(true: {
        Text@ tail <- Do(start_of_line);
        IsBlankLine(tail).?(true: EmptyM);
        Return(tail);
      });
      middle_of_line;
    });
  };

  Text@ t <- Do(start_of_line);
  IsEmpty(t).?(true: Return(Nothing<Text@>));
  IsBlankLine(t).?(true: Return(Nothing<Text@>));
  Return(Just(t));
};

# Flattens a list of maybes into a list of justs.
<@ T@>(List@<Maybe@<T@>>) { List@<T@>; }
Justs = <@ T@>(List@<Maybe@<T@>> in) {
  (List@<Maybe@<T@>>, List@<T@>) { List@<T@>; }
  mlist = (List@<Maybe@<T@>> l, List@<T@> r) {
    l.?(nil: Reverse(r));
    Maybe@<T@> head = l.cons.head;
    head.?(just: mlist(l.cons.tail, Cons(head.just, r)));
    mlist(l.cons.tail, r);
  };
  mlist(in, Nil<T@>);
};

# Parses all kinds of args for a block command.
M@<List@<Text@>> Args = {
  (List@<Text@>) { M@<List@<Text@>>; } parse_args = (List@<Text@> r) {
    List@<Text@> args <- Do(InlineArgs);
    Maybe@<Text@> same_line_arg <- Do(SameLineArg);
    Maybe@<Text@> next_line_arg <- Do(NextLineArg);
    List@<Text@> extra_args = Justs[same_line_arg, next_line_arg];
    List@<Text@> nr = Concat[r, args, extra_args];

    Bool@ continue <- Do(Test_(String|'@ '));
    continue.?(true: {
      Unit@ _ <- Do(Skip);
      parse_args(nr);
    });

    Bool@ continue <- Do(Test_(String|'@['));
    continue.?(true: {
      Unit@ _ <- Do(Skip);
      parse_args(nr);
    });

    Bool@ final <- Do(Try_(String|'@@
'));
    final.?(true: {
      Text@ last <- Do(GetText);
      Return(Append(nr, List[last]));
    });

    Return(nr);
  };

  parse_args[];
};

# Parses a command starting with @...
M@<Maybe@<Command@>> Command = {
  Maybe@<Char@> mc <- Do(Peek);
  mc.?(nothing: Return(Nothing<Command@>));
  mc.just.?('@': {
    Unit@ _ <- Do(Skip);
    Text@ name <- Do(Name);
    List@<Text@> args <- Do(Args);
    Return(Just(Command@(name, args)));
  });
  Return(Nothing<Command@>);
};

M@<List@<Command@>> Block = {
  # Parse block structured text.
  # Returns commands in reverse order.
  (List@<Command@>) { M@<List@<Command@>>; }
  block = (List@<Command@> rcmds) {
    Unit@ _ <- Do(SkipBlankLines);
    Text@ plain <- Do(Plain);
    IsEmpty(plain).?(false: {
      Command@ cmd = Command@(Text(Str|'.block', LocOf(plain)), List[plain]);
      block(Cons(cmd, rcmds));
    });

    Maybe@<Command@> command <- Do(Command);
    command.?(nothing: Return(rcmds));
    block(Cons(command.just, rcmds));
  };

  List@<Command@> rcmds <- Do(block(Nil<Command@>));
  Return(Reverse(rcmds));
};

@(Block);
