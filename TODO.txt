* [invaders] Implement space invaders game.
 - Figure out how they know when to move forward as a group.

* [compile] Figure out why Normal is called so often
 - See if we can fix that to reduce the now annoyingly long compile times.
 - Profiling said its all in TypeEquals. Maybe something pathological?

* [lang] Set up cindent properly for fble.vim
 - For example, so you can do newline in a comment block and have it auto add
   the comment character.

* [compile] Optimization: Avoid REF_INSTR if we aren't going to ever use it.
 - Maybe have a way to list free vars in an expression and use that to compute
   'recursive' ahead of time? Not sure.
 - gcov suggests we'll save on the order of 4 million instructions and 4
   million allocations in fble bench. Surely that's good for something.

* [bench] Optimize
 - game of life:
    40s step,
    14s transform draw, calling back into 'f'.
        x: 5s add, 3s mul, y: 3s add, 1s mul.
        Looks like add, mul the only opportunity for improvement?

* [profile] don't introduce an extra ! for bodies of expressions.
 - Maybe in general we want to support a CompileProcExpr that evaluates and
   compiles the expression in place. That would fix the extra !, save some
   instructions, and generally make some more sense.
 - Otherwise, for exec args, we actually want the extra ! to distinguish
   between what's executed on the parent thread versus what's executed on the
   child thread.

* [profile] Optimize profiling.
 - 30 seconds spent in enter/exit processing
 - 17 seconds spent in FbleProfileSample
 - 24 seconds spent in FbleProfileTick (without sampling)
 I'm not sure how to make it better though, besides turning it off.

* [cc] Implement .fble -> .o compiler
 - Goal is to significantly increase performance by removing the instruction
   fetch decode logic.

* [gc] Optimize gc. 
 - Experiments suggest gc is 28% overhead for fble bench today.

* [test] Add fble-heap-test for splitting cycles
   Test that we don't retain a cycle a->b->c by referencing a separate object
   d that used to be in the cycle a->b->c->d.

* [snake] Switch to a target 60 FPS?
* [snake] Test and fix bug when snake eats its tail.
* [snake] Ignore moves that aren't orthogonal to current snake direction.
* [snake] Keep track of and report score.
* [snake] Figure out why the background box gets lost some times.
* [pingpong] Render a static 3D table tennis scene.
* [gameoflife] Switch to a target 60 FPS?
* [invaders] Optimize space invaders game.
 - Figure out how I'm going to get to 60 FPS.
   Maybe try getting 60 FPS on the C implementation to see if it's reasonable?
 - Implement and test Alien simulation

* [lib] Add test coverage for the Int routines.
 - In particular, test Div and Mod.
* [lib] Separate Map from DataMap and EqMap.
* [lib] Add unit tests for /Map%.Equals.
* [lib] Separate List@ from S@ and P@ module wise.

* [api] Can fble-stdio check that the function has the right type?

* [compile] Consider tracking memory for proper cleanup?
  I wonder how much of what we allocate ends up unused. If we could track and
  clean up allocations when we are done with them, maybe we can save some
  memory.

* [compile] Is there a way to clean up compile.c, in terms of orders of setting fields
  of instructions vs scopes vs locals? It all seems very confused to me.
* [compile] Is there a way to avoid emitting instructions after a return/exit instruction?

* [compile] Test and fix error message for type of anonymous type let values.
 - The type should be the computed type for the value, not the introduced
   abstract type?

* [profile] Come up with a way to deal with irregular ticks.
 - For example, what if we block on user data. Then the ticks stop. Then the
   first sample afterwards gets charged a huge amount unfairly.

* [profile] I suspect there are still bugs around block id 0
 - test that calling into block 0 does the right thing. Though I'm not sure it
   makes much sense.

* [eval] Experiment with alternate garbage collection implementations.
 - For the purpose of improving memory and runtime performance.
* [eval] Make child thread execution fair.
  Children should be time multiplexed, where priority is assigned based on how
  far down the family tree the child belongs. The amount of time a family gets
  to spend evaluating should be independent of the number of children in the
  family.

* [lang] Can a module reference itself? Clarify in the spec and test this case.
* [lang] Add support for abstract types?
* [lang] Document the runtime memory model,
  - Including that tail recursive functions should not smash the stack.
* [lang] Document and test that put ports don't retain link values.

* [release] Better error messages on types that have the same name but different values?
* [release] Write man pages for fble and friends?
* [release] Better error message for importing something from a module that
  is not defined in the module?

* [heap] Change reference counting to be incrementally done on allocation.
  Maybe write a test that shows how something that should take no time gets
  charged for a big deallocation time today?

* [arena] Rethink arenas and documentation, because some cases appear to assume you
  have a bulk-free arena. Other cases its not well specified what is freed
  explicitly and what is expected to be freed implicitly.
  I claim a good model is: pass an arena to a function to say: the function
  allocates its result in this arena. The function creates and uses a separate
  arena for its intermediate allocations.

* [debugger] Implement an fble debugger. Features:
 - Set a breakpoint at a line in a file.
 - Step through code line by line.
 - Evaluate expressions in the context of the current scope and print the
   results.
 - Auto breakpoint at undefined behavior?
 
 Use cases:
 - Debug why sudoku solver isn't working properly by stepping through a line
   at a time and printing intermediate values.

   Turns out it wasn't too hard to figure out the problem in this case without
   a debugger.

 - Debug why snake AI wasn't working.

   It turns out we were using the wrong direction. A debugger to step through
   code and print variable values would have found this more quickly than my
   guess and check approach, which was pretty tedious.

