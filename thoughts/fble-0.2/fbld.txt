Fbld Improvements
=================

I'm happy with the syntax for fbld. The implementation needs work.

One idea is to try implementing fbld in fble. Partly as an excuse to write
more real world fble programs, partly because it almost feels nicer to use
fble than tcl given things like tracking error locations.

I see two big challenges with using fble for fbld:
1. How to make it easily extensible. Can users write their own front ends and
back ends? Would they have to write fble? Is that too much to ask? How can we
compose with other existing programs like groff?

2. How to deal with bootstrapping dependency of fble on fbld and fbld on fble?
It's a bit annoying, because it's just the help text for fble-stdio. Maybe
have an option to compile fble with and without that usage text and do a mini
bootstrap that way in the build system.

Big things I want to improve for fbld (regardless of what language we use to
implement it):
* Location tracking, so we can point to the exact place in a file where an
  error occurs.

* Composition: so we can easily implement commands directly in terms of other
  commands if we want to, instead of having to convert back into strings and
  re-parsing.

Both those things come down to this challenging aspect of fbld:

The commands have to parse args using fbld, the fbld parser has to execute
commands using the commands. That creates this cycle going back and forth
between the parser and commands where we have to keep track of and pass
location information back and forth. We can't just parse the whole thing all
at once and then execute commands all at once.

---

This should be pretty straight forward I think.

Assume some monad for computation/side effects.

We have generic commands that don't care about the monad. They can be
parametrized by it. The monad lets you call a sequence of commands.

Define fble functions that take typed (post-parsed) arguments.
Define a generic command map that takes non-typed List@<String@> arguments,
parses the arguments appropriately, and forwards that to the typed fble
functions.

The implementation of a command can call either the raw fble function it
wants, or invoke a command via the generic command map.

Typed fble functions for backends can work with specific monads. For example,
maybe we have an HtmlM@ for generating html documents.

We have a block parser and an inline parser that both work solely with generic
monad via the generic command map.

For composition, you create a command map that works for a particular
specialized HtmlM@ monad. You invoke the block parser, which causes all the
commands to be executed recursively in the monad. You can do what you want
with the results of that. Easy.

Note: instead of List@<String@>, we'll want List@<StringL@>, or some variation
that tracks locations for strings. And the block and inline parsers should
operate on StringL@ to maintain file location information.

I think this will be nice, straight forward, very composable. The two issues
I see are:

1. How to get the filename for what we are parsing.
Ideally we can open named files rather than just stdin. Then that's solved. We
want that for fble-md5 too.

2. How to let people write their own extensions to fbld without using fble.
They need some programming language to be flexible enough. For ease of use, it
would be nice to have a programming language with an interpreter. Some options
are: tcl, python, fble, some custom new fbld language. I think, let's not
worry about this now.

---

First step: add support for opening named files. Even before we start on fbld
implementation. We can do this on md5.

Goal is to change the command line interface to md5 by adding an option to
pass one or more file names on the command line (or '-').

Output format is:

<sum>  <filename>

Or, in case of a directory

fble-md5: <name>: Is a directory

Let me see if I can dig up my old thoughts on how to support file names:
* Skip ReadDir to start.
* (String@) { M@<Maybe@<IStream@>>; } Read;

Maybe it's that simple. Just need to implement it.

The return value should be True if all files are found. False if any are not
found.

---

Getting started on fbld, the tricky part is the knot in the middle.
* The parser needs to know how to invoke commands.
* The invoked commands want to call back into the parser.
* Neither parser nor individual command knows what the other commands are.
* You could get an error message at any point while invoking a command or
  running the parser.
* All of parsing and command invocation takes place in some monad M@, which is
  abstract for the parser and some commands, but may be concrete for other
  commands.

Access to the invoke function, possibility of error, and monad M@ are common
between invocation and parser. The string to parse and the state of that is
specific to the parser. I want some monad transformer Fbld@ that stores the
command invocation function and error handling.

Interface from within Fbld@:
  (Loc@, String@) { Fbld@<M@><Unit@>; } error - reports an error.
  (StringL@, List@<StringL@>) { Fbld@<M@><Unit@>; } invoke - invokes a command.
  <@ A@>(M@<A@>) { Fbld@<M@><A@>; } lift - execute an M@.

Is there anything simpler we could do? Like, commands take invoke as their
first argument and return an M@<Maybe@<String@>>? And parser takes invoke as
their first argument? No need for an Fbld@ transformer monad?

Result@ = +(Unit@ ok, String@ err);
Invoke@ = <<@>@ M@>(Invoke@<M@>, StringL@, List@<StringL@>){ M@<Result@>; };

<<@>@ M@>(Invoke@<M@>, StringL@) { M@<Result@>; } Block;
<<@>@ M@>(Invoke@<M@>, StringL@) { M@<Result@>; } Inline;

Cool. Easy.

---

Ugh. Parsing with locations is tedious. Can I make a little Parser@ monad to
help? I want to do things like:

* Get the next character from the input stream, have location advance
  automatically based on the character in question.
* Run a Parser@ computation to get some value at the beginning of the input,
  returning the rest of the input.

(Parser@<A@>, String@) { *(A@ x, String@ tail); } Run

And maybe it can do errors too. And this can be fully separate from M@, right?

Might be nice if we can have a running state though. So:

(Parser@<A@>, S@) { *(A@ x, S@ s); }

Where S@ stores info about the string, the location, errors, etc.

Things to write:
 * Parse a character.
 * Parse plain text before next @... command.
 * Parse to end of matching ']' character.
   - Could result in an error if unmatched.
 * Parse command name.
  
---

I bet I can entirely split the parser off from M@. Write code to parse inline
text into a sequence of commands and block text into a sequence of commands.
No need for M@ at all there.

---

I need to update the parse to pass around the current indent level and allow
parsing of indented strings. Otherwise we'll mess up column numbers when
parsing nested block structured text.

This brings up an interesting question. What should be the location for next
line arg in terms of column number? What if it's an empty line?

Loc@ needs an indent field, which defines what the column at the start of the
next line is. That's a separate issue.

Next line argument should be, for example, column 2. If it's a blank next
line, it should be... doesn't matter I don't think.

I need to come up with a test case to capture locations properly. Maybe, parse
a command. Extract the next line argument. Parse that, verify the locations
are set properly. Yeah.

