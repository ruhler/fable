
struct Unit();
union Bool(Unit true, Unit false);

func True( ; Bool) {
  Bool:true(Unit());
};

func False( ; Bool) {
  Bool:false(Unit());
};

# The following type is used to represent (unbounded) integers.
# Note that this representation allows multiple ways of representing each
# integer, because 2*0 = 0 and 2*(-1)+1 = -1.
# Functions that operate on integers should work for all the representations
# of various numbers. They should not assume the smallest representation for
# a number and in general need not produce the smallest representation for a
# number, though they should if all the arguments are in their most compact
# form.
union Integer(
   Unit 0,
   Unit minus_1,
   Integer double,
   Integer double_plus_1
);

func Eq(Integer a, Integer b; Bool) {
  # For now, just assume the args are both in canonical form.
  ?(a ;
      ?(b ; True(), False(), False(), False()),
      ?(b ; False(), True(), False(), False()),
      ?(b ; False(), False(), Eq(.double(a), .double(b)), False()),
      ?(b ; False(), False(), False(), Eq(.double_plus_1(a), .double_plus_1(b))));
};

# The integer 0
func Zero( ; Integer) {
  Integer:0(Unit());
};

# The integer (-1)
func Minus1( ; Integer) {
  Integer:minus_1(Unit());
};

# 2 * x
func Double(Integer x; Integer) {
  Integer doubled = Integer:double(x);
  ?(x ; Zero(), doubled, doubled, doubled);
};

# 2 * x + 1
func DoublePlus1(Integer x; Integer) {
  Integer doubled_plus_1 = Integer:double_plus_1(x);
  ?(x ; doubled_plus_1, Minus1(), doubled_plus_1, doubled_plus_1);
};

# a + 1
func Add1(Integer a; Integer) {
  ?(a ; 
    DoublePlus1(Zero()),            # 0 + 1 = 2*0+1
    Zero(),                         # -1 + 1 = 0
    DoublePlus1(.double(a)),          # 2*d + 1 = 2d*+1
    Double(Add1(.double_plus_1(a)))); # 2*d+1 + 1 = 2*(d+1)
};

# a - 1
func Sub1(Integer a; Integer) {
  ?(a ;
    Minus1(),                     # 0-1 = -1
    Double(Minus1()),             # -1-1 = 2*(-1)
    DoublePlus1(Sub1(.double(a))),  # 2*d-1 = 2*(d-1)+1
    Double(.double_plus_1(a)));     # 2*d+1-1 = 2*d
};

# a + b
func Add(Integer a, Integer b; Integer) {
  ?(a ;
     b,                                        # 0 + b = b
     ?(b;
       a,                                      # a + 0 = a
       Double(Minus1()),                       # -1 + -1 = 2*(-1)
       DoublePlus1(Add(.double(b), Minus1())),   # -1 + 2*d = 2*(d-1)+1
       Double(.double_plus_1(b))),               # -1 + (2*d+1) = 2*d
     ?(b;
       a,                                      # a + 0 = a
       DoublePlus1(Add(.double(a), Minus1())),   # 2*d + -1 = 2*(d-1)+1
       Double(Add(.double(a), .double(b))),        # 2*d + 2*e = 2*(d+e)
       DoublePlus1(Add(.double(a), .double_plus_1(b)))),# 2*d + 2*e+1 = 2*(d+e)+1
     ?(b;
       a,                                      # a + 0 = a
       Double(.double_plus_1(a)),                # 2*d+1 + -1 = 2*d
       DoublePlus1(Add(.double_plus_1(a), .double(b))), # 2*d+1 +2*e = 2*(d+e)+1
       Double(Add1(Add(.double_plus_1(a), .double_plus_1(b))))));  # 2*d+1 + 2*e+1 = 2*((d+e)+1)
};

# -a 
func Negate(Integer a; Integer) {
  ?(a ;
    Zero(),                                   # -0 = 0
    DoublePlus1(Zero()),                      # -(-1) = 2*0+1
    Double(Negate(.double(a))),                 # -(2*d) = 2*(-d)
    Sub1(Double(Negate(.double_plus_1(a)))));   # -(2*d+1) = 2*(-d)-1
};

# a - b 
func Sub(Integer a, Integer b; Integer) {
  # a - b = a + (-b)
  Add(a, Negate(b));
};

# a * b
func Mul(Integer a, Integer b; Integer) {
  ?(a ; 
    Zero(),       # 0 * b = 0
    Negate(b),    # -1 * b = -b
    ?(b ; 
      Zero(),                             # 2*x * 0 = 0
      Double(Negate(.double(a))),           # 2*x * -1 = 2*(-x)
      Double(Double(Mul(.double(a), .double(b)))), # 2*x * 2*y = 2*(2*(x*y))
      Add(Double(Double(Mul(.double(a), .double_plus_1(b)))),
          Double(.double(a)))),             # 2*x * (2*y+1) = 2*2*x*y + 2*x
    ?(b ;
      Zero(),         # (2*x+1) * 0 = 0
      Sub1(Double(Negate(.double_plus_1(a)))),  # (2*x+1) * -1 = 2*(-x) - 1
      Add(Double(Double(Mul(.double_plus_1(a), .double(b)))),
          Double(.double(b))),        # (2*x+1) * 2*y = 2*2*x*y + 2*y
      Add(    # (2*x+1) * (2*y+1) = 2*2*x*y + 2*x + (2*y +1)
       Add(
        Double(Double(Mul(.double_plus_1(a), .double_plus_1(b)))),
        Double(.double_plus_1(a))), b)));
};

# The Calculator machine has a stack of operands.
# Initially the stack is empty. The following instructions can be used to
# modify the stack.
union CalcInstr(
    # Pop the top two operands from the stack, add them together, and push
    # the result to the stack. If there are not enough operands on the stack,
    # 0 is used in place of the missing operands.
    Unit add,

    # Pop the top two operands from the stack. Subtract what was the top
    # operand on the stack from what was the operand just beneath the top
    # operand on the stack. Push the result to the stack. If there are not
    # enough operands on the stack, 0 is used in place of the missing
    # operands.
    Unit sub,

    # Pop the top two operands from the stack, multiply them together, and
    # push the result to the stack. If there are not enough operands on the
    # stack, 0 is used in place of the missing operands.
    Unit mul,

    # Clear the stack of all operands.
    Unit clear,

    # Push the given integer on top of the stack.
    Integer push
);

union CalcStack(Unit empty, CalcOperands nonempty);
struct CalcOperands(Integer top, CalcStack rest);

func Push(CalcStack stack, Integer operand; CalcStack) {
  CalcStack:nonempty(CalcOperands(operand, stack));
};

struct Pop1Result(Integer top, CalcStack rest);
func Pop1(CalcStack stack; Pop1Result) {
  ?(stack ; Pop1Result(Zero(), CalcStack:empty(Unit())),
            Pop1Result(.top(.nonempty(stack)), .rest(.nonempty(stack))));
};

struct Pop2Result(Integer top1, Integer top2, CalcStack rest);
func Pop2(CalcStack stack; Pop2Result) {
  Pop1Result p1 = Pop1(stack);
  Pop1Result p2 = Pop1(.rest(p1));
  Pop2Result(.top(p1), .top(p2), .rest(p2));
};

# Execute the given calculator instruction.
func ExecCalcInstr(CalcStack stack, CalcInstr instr; CalcStack) {
  ?(instr ;
      { Pop2Result p2 = Pop2(stack); Push(.rest(p2), Add(.top2(p2), .top1(p2))); },
      { Pop2Result p2 = Pop2(stack); Push(.rest(p2), Sub(.top2(p2), .top1(p2))); },
      { Pop2Result p2 = Pop2(stack); Push(.rest(p2), Mul(.top2(p2), .top1(p2))); },
      { CalcStack:empty(Unit()); },
      { Push(stack, .push(instr)); });
};

union CalcProgram(Unit empty, CalcInstrs nonempty);
struct CalcInstrs(CalcInstr instr, CalcProgram next);

# Execute a sequence of calculator instructions.
func ExecCalcInstrs(CalcStack stack, CalcProgram prg; CalcStack) {
  ?(prg ; stack,
          ExecCalcInstrs(ExecCalcInstr(stack, .instr(.nonempty(prg))),
                         .next(.nonempty(prg))));
};

# Run the calculator program and return the result on top of the stack. If
# the final stack is empty, the value 0 is returned.
func RunCalc(CalcProgram prg; Integer) {
  .top(Pop1(ExecCalcInstrs(CalcStack:empty(Unit()), prg)));
};


# ************ TESTS ****************
union TestName(
    Unit add_pos_pos,
    Unit add_pos_neg,
    Unit sub_gt_lt,
    Unit sub_lt_gt,
    Unit negate_pos,
    Unit negate_neg,
    Unit mul_pos_pos,
    Unit calc_prg_simple
);
union TL(Unit pass, FailedTestResult fail);
struct FailedTestResult(
    TestName name,
    Integer want,
    Integer got,
    TL rest
);

func Test(TestName name, Integer want, Integer got, TL list; TL) {
  ?(Eq(want, got) ; list, TL:fail(FailedTestResult(name, want, got, list)));
};

func main( ; TL) {
  Integer minus_five = DoublePlus1(DoublePlus1(Double(Minus1())));
  Integer minus_two = Double(Minus1());
  Integer two = Double(DoublePlus1(Zero()));
  Integer three = DoublePlus1(DoublePlus1(Zero()));
  Integer five = DoublePlus1(Double(DoublePlus1(Zero())));
  Integer fifteen = DoublePlus1(DoublePlus1(DoublePlus1(DoublePlus1(Zero()))));

  TL l0 = TL:pass(Unit());
  TL l1 = Test(TestName:add_pos_pos(Unit()), five, Add(two, three), l0);
  TL l2 = Test(TestName:add_pos_neg(Unit()), minus_two, Add(three, minus_five), l1);
  TL l3 = Test(TestName:sub_gt_lt(Unit()), two, Sub(five, three), l2);
  TL l4 = Test(TestName:sub_lt_gt(Unit()), minus_two, Sub(three, five), l3);
  TL l5 = Test(TestName:negate_pos(Unit()), minus_two, Negate(two), l4);
  TL l6 = Test(TestName:negate_neg(Unit()), two, Negate(minus_two), l5);
  TL l7 = Test(TestName:mul_pos_pos(Unit()), fifteen, Mul(three, five), l6);

  CalcProgram prg8 = CalcProgram:nonempty(
     CalcInstrs(CalcInstr:push(five), CalcProgram:nonempty(
     CalcInstrs(CalcInstr:push(five), CalcProgram:nonempty(
     CalcInstrs(CalcInstr:add(Unit()), CalcProgram:nonempty(
     CalcInstrs(CalcInstr:push(five), CalcProgram:nonempty(
     CalcInstrs(CalcInstr:add(Unit()), CalcProgram:empty(Unit())))))))))));
  TL l8 = Test(TestName:calc_prg_simple(Unit()),
      fifteen, RunCalc(prg8), l7);
  l8;
};
