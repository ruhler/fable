@doc Fbld
  @FbleVersion (@BuildStamp)

 @section Introduction
  Fbld is a lightweight markup language for structured text. It aims to
  balance the readibilty of markup languages like asciidoc and markdown with
  the extensibility and clarity of structure of markup languages like xml.
 
  Note: Fbld should not be confused with the predecessor to fble, which was
  also called fbld. We reuse the name @l[fbld] in this case to suggest the
  term "Fable Doc Language".
 
  @subsection Goals
   The primary design goals of fbld are:
 
   @item
    It should be easy to parse, by both human and computer. There should not
    be weird corner cases, ambiguity, or complex resolution rules for parsing
    like there are for markdown, for example.
 
   @item
    The main textual content should be easy to read from source by a human.
    It should not include excessive clutter from tags that overly distract
    from the contents of the text, as is the case with roff and xml, for
    example.
 
   @item
    It should be easy to provide custom processing of the document. For
    example, conversion to html, latex, roff, or anything you might like.
 
   @item
    It should support custom structure, allowing a user to define their own
    new kinds of structures and use those structures in their documents.
 
  @subsection Use Cases
   The original use cases motivating development of the fbld language are:
 
   @item
    Document functions in code and automatically generate man pages from it.
 
   @item
    Document command line usage and automatically generate both man page and
    help usage text from it.
 
   @item
    Mark up README files, tutorials, and language specifications to add
    clarity to structure and make it possible to generate books, webpages,
    etc. with that information.
 
  @subsection Alternatives
   There are many alternatives for document markup. Each of the ones I tried
   had their own issues. Some of the issues are subtle and quite subjective.
   Here are a list of alternatives I considered before deciding to develop my
   own markup language.

   @definition Markdown
    @item Subtleties in how to parse correctly.
    @item No support for custom structure components.

   @definition Asciidoc
    @item Complex to parse and provide custom processing of the document.
    @item Vim syntax highlighting doesn't work well, if at all.
    @item
     You have to know what particular symbols mean to understand the structure
     of a document. For example, @l[......] versus @l[////////].

   @definition XML
    @item Tags clutter the doc too much.

   @definition roff
    @item Tags clutter the doc too much.

   @definition tcl
    @item Too tedious to have nested inlined structure.

   @definition doxygen
    @item Not generally extensible to things beyond code documentation.

 @section Example
  This section provides an example of fbld markup text which will be
  referenced through the remainder of the fbld specification. It's a contrived
  document explaining the risks of using malloc:

  @code[fbld] @
   @title Malloc Reminder

   It's @emph[really] important to check the result of the @code[malloc]
   function in C, in case it returns @NULL. See @link[the malloc man
   page][https://manpages.org/malloc] for more details.

   @section[The Risks of Malloc]
    It's possible that @code[malloc] is unable to allocate memory. If that's
    the case, it will return @NULL. If you try to access the returned pointer,
    bad things can happen.

    So you should always check the result of @code[malloc] for @NULL.

   We have discussed that it's important to check the result of @code[malloc]
   for @NULL.

  Fbld documents are a mix of plain text and commands introduce with the @l{@}
  character. The syntax and interpretation of these commands are described in
  detail in the following sections.

 @section Document Structure
  Internally, fbld documents are represented as a mix of plain text and
  commands.
  
  A command has a name and zero or more arguments. For example,
  @l{@NULL} is a command with name @l[NULL] and no arguments.
  @l{@emph[really]} is a command with name @l[emph] and single argument
  @l{really}, and @l{@link[the malloc man page][https://manpages.org/malloc]}
  is a command with name @l{link} and two arguments.
  
  Arguments to commands are fbld markup which can themselves have
  additional commands in them.

  @subsection Abstract Syntax
   Here's an abstract syntax for fbld document structure:

   @code[text] @
    Text ::= (* A string of plain text characters *)

    Command ::=
        command (name : Text) (args : [Markup])
      ;

    Markup ::=
        plain (text : Text)
      | command (command : Command)
      | sequence (markups : [Markup])
      ;

 @section Document Syntax
  The syntax of fbld leverages whitespace and other punctuation to reduce the
  need for brackets around command arguments everywhere. The goal of the
  syntax is to make fbld documents easy to read while still providing clear
  rules for forming commands and arguments to commands.

  There are two main kinds of syntax in fbld: inline structured text and block
  structured text.

  @subsection Inline Structured Text
   Inline structured text is used for marking up paragraphs or short lines of
   text. Whitespace is preserved in inline structured text.

   @subsubsection Plain Text
    Inline structured text interleaves plain text and commands. Plain text is
    any text that comes between commands. It can be written directly. For
    example:

    @code[fbld] @
     Hello, how are you?

    The following escape sequences are supported in plain text:

    @def[@l{\\}] @l{\}
    @def[@l{\@}] @l{@}
    @def[@l{\[}] @l{[}
    @def[@l{\]}] @l{]}
    @def[@l{\n}] Newline

    Any other character following a backslash is considered reserved for
    future use and is not currently allowed. The escape sequences make it
    possible to include @l{@} in plain text, and make it possible to include
    @l{[}, @l{]}, and newline in plain text where they may not otherwise be
    allowed. For example:

    @code[fbld] @
     My email is ruhler\@degralder.com.

   @subsubsection Inline Args
    The standard way of supplying arguments to a command is using inline args.
    An inline arg is inline structured text in square brackets following a
    command or other inline arguments to a command.
    
    For example, the following @l{@emph} command has a single inline argument:

    @code[fbld] @
     @emph[You must check for @NULL!]

   @subsubsection Inline Literal Args
    Inline literal args are used to pass literal text as an argument. A
    literal inline arg is literal text in braces following a command or other
    inline arguments to a command. This is primarily useful for writing plain
    text with @l{@} characters without having to escape them. For example:

    @code[fbld] @
     @email{ruhler@degralder.com}

    There is no processing of escape sequences in inline literal args. The
    characters are read directly. Braces nest inside the literal argument, so
    you can include close braces in the literal text as long as there is a
    matching, properly nested open brace.

    For example, the following inline literal argument specifies an fble
    function type, which includes both @l{@} and @l[}] characters:

    @code[fbld] @
     @emph{(Bool@) { Bool@; }}

    The argument to the command in the following example includes the
    backslash characters:

    @code[fbld] @
     @emph{The escape sequences in fbld are: \\, \@, \[, \], and \n.}

 @section Old Stuff From Here on
  @subsection Lexical Details
   When parsing inline structure, all whitespace is preserved.
 
   Command names are a sequence of one or more alphanumeric or underscore
   characters. No other characters are allowed in command names.
 
 @section Block Structure
  Fbld parses block structured text into a sequence of commands using the same
  concepts as inline structure, with a few syntactic differences.
 
  The idea behind block structure is that we expect it to span one or more
  lines of text. Three things different about block structed text compared to
  inline structed text:

  @item Block commands start on a new line.
  @item Text on the same line after a block command is an additional argument.
  @item
   Text indented on the lines following the block command is an additional
   argument.

  @subsection Same Line Args
   Consider the following block structed text:
   
   @code[fbld] @
    @def[triangle] Has three sides
    @def[square] Has four sides

   This is a sequence of two commands, each with two arguments:

   @code[tcl] @
    def triangle "Has three sides"
    def square "Has four sides"

   The same line argument starts after a single space following the command
   and any explicit command arguments.

   If there is no space on the same line after the command and any explicit
   command arguments, no same line argument is passed to the command. For
   example:

   @code[fbld] @
    @item[first item]
    @item[second item]
   
   Is parsed as:

   @code[tcl] @
    item "first item"
    item "second item"
  
  @subsection Following Lines Arg
   Any indented lines following a block command are grouped together and
   passed as an additional argument to the block command. For example:

   @code[fbld] @
    @section[First Section]
     Contents of the first section.

     Spanning multiple lines.
    @section[Second Section]
     Contents of the second section.

   Is parsed as:
   
   @code[tcl] @
    section "First Section" "Contents of the first section.\n\nSpanning multiple lines.\n"
    section "Second Section" "Contents of the second section.\n"

   Indentation is a single space character at the beginning of each line. This
   space character is stripped from the line before it is passed in the
   following lines argument.

   Blank lines in the middle of an indented block are treated as blank lines
   in the following lines argument. Blank lines at the end of an indented
   block are removed.

   If there are no indented lines following the block command, no following
   lines argument is supplied.

  @subsection Argument Continuation
   If the line following a block command starts with @l[\@] without a command,
   it continues the arguments from the previous command. Commands can be
   continued with regular, same line, and next line arguments repeatedly. For
   example:

   @code[fbld] @
    @list[first arg][second arg] third arg
     fourth arg
    @[fifth arg][sixth arg] seventh arg
     eight arg
    @ ninth arg
     tenth arg

  @subsection Final Argument
   If the line following a block command consists of a single @l[\@\@], the
   entire remainder of the document is passed as the last argument to the
   command. For example:

   @code[fbld] @
    @list[first arg] second arg
     third arg
    @@
    fourth and final argument, which
    can span multiple lines.

    And beyond.

  @subsection Default Block Commands
   If a line starts with something other than a block command, then that line
   and all subsequent lines up until a blank line are grouped together and
   passed as a single argument to the default block command.

   For example:
   
   @code[fbld] @
    This is the first paragraph
    of a document.

    Here is the second.

   Parses as:

   @code[tcl] @
    default "This is the first paragraph\nof a document.\n"
    default "Here is the second.\n"

  @subsection Starting a Line with an Inline Command
   Sometimes you may want to start a paragraph with an inline command. To
   prevent the command from being treated as a block command, either pass it
   explicitly to the default command, or add a space before. For example:

   @code[fbld] @
    @default
     @emph[Yeah!]. Fbld is so great!

   In this case, @l[\@emph] is considered an inline command because the
   @l[\@default] command parses its argument as inline structed text instead of
   block structured text.


  @subsection A Bigger Example
   Here's an example demonstrating various uses of block structed text.
 
   @code[fbld] @
    @doc A Bigger Example
    
     Some introductory text here.
    
     @section[First Section]
      @paragraph
       Here is a paragraph in the first
       section of the doc.
    
      @list
       @item First item of a list.
       @item Second item of a list.
 
   The top level parses as a single doc command:

   @code[tcl] @
    doc "A Bigger Example" "Some introductory text here.\n\n@section..."

   The doc command itself can interpet its second argument as block structed
   text. In that case it parses into two commands:

   @code[tcl] @
    default "Some introductory text here.\n"
    section "First Section" "@paragraph\n Here is a paragraph in..."

   The section command parses its second argument as block structured text:

   @code[tcl] @
    paragraph "Here is a paragraph in the first\nsectionof the doc.\n"
    list "@item First item of a list.\n@item Second item of a list.\n"

   Finally, the list command parses its argument as block structured text:

   @code[tcl] @
    item "First item of a list."
    item "Second item of a list."

   Notice that block commands end up indented in practice, even though we said
   they have to start at the beginning of the line. This is because the indent
   is stripped away from the lines before the block command gets processed.

 @section Handling of Escape Characters
  The characters @l[\@], @l[\[], @l[\]], and @l[\\] are special and need to be
  escaped using @l[\\] to avoid being processed specially. At the end of the
  day, users will need to manually remove the escapes.
 
  For example, imagine we want to put an email address in a document that we
  convert to markdown:
 
  @code[fbld] @
   @block[Example]
    My email address is @bold[ruhler\@degralder.com].
 
  This gets parsed via block structured text as:
 
  @code[tcl] @
   block "Example" {My email address is @bold[ruhler\@degralder.com].}
 
  The second argument gets parsed as inline structured text as:
 
  @code[tcl] @
   default "My email address is "
   bold {ruhler\@degralder.com}
   default "."
 
  To actually display the text, the @l[\@bold] command should remove the
  backslash before rendering the text.
 
 @section TODO
  @item
   Is the following valid? @l[hello \] \[ \@there]. The square brackets are
   supposed to be special, but it's not within a command, so there shouldn't
   be any need to escape them, right? Only need to escape square brackets when
   parsing arguments? This would be a problem if it was within an argument.
   Maybe best to require escaping in all cases for consistency.
 
  @item
   Clarify behavior of end of input for block commands, after @l[\]].
