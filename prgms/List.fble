
@ Bool@ = /Bool%.Bool@;

<@,@>@ Lit@ = /Literal%.Lit@;

@ Unit@ = /Unit%.Unit@;
% Unit = /Unit%.Unit;

# P - A list of 1 or more elements: T+
# S - A list of 0 or more elements: T*
<@>@ P@ = <@ T@> { *(T@ head, S@<T@> tail); },
<@>@ S@ = <@ T@> { +(P@<T@> cons, Unit@ nil); };

<@ T@>(T@, S@<T@>){S@<T@>;} ConsS = <@ T@>(T@ a, S@<T@> l) {
  S@<T@>(cons: P@<T@>(a, l));
};

# Append list b to the end of list a.
<@ T@>(S@<T@>, S@<T@>){S@<T@>;} Append = <@ T@>(S@<T@> a, S@<T@> b) {
  a.?(cons: ConsS<T@>(a.cons.head, Append<T@>(a.cons.tail, b)), nil: b);
};

S@ S0 = <@ T@> {
  S@<T@>(nil: Unit);
};

<@ T@>(Lit@<T@>) { S@<T@>; } S = <@ T@>(Lit@<T@> lit) {
  lit<S@<T@>>(ConsS<T@>, S0<T@>);
};

# InitP - Return all but the last element in 'list'.
<@ T@>(P@<T@>){S@<T@>;} InitP = <@ T@>(P@<T@> list) {
  list.tail.?(cons: ConsS<T@>(list.head, InitP<T@>(list.tail.cons)), nil: S0<T@>);
};

# InitS - Return all but the last element in 'list'.
<@ T@>(S@<T@>){S@<T@>;} InitS = <@ T@>(S@<T@> list) {
  list.?(cons: InitP<T@>(list.cons), nil: S0<T@>);
};

# Concat: Flatten a list of lists into a single list of all the elements.
<@ T@>(S@<S@<T@>>){S@<T@>;} Concat = <@ T@>(S@<S@<T@>> x) {
  x.?(cons: Append<T@>(x.cons.head, Concat<T@>(x.cons.tail)), nil: S0<T@>);
};

<@ A@, @ B@>(S@<A@>, (A@){B@;}){S@<B@>;} MapS = <@ A@, @ B@>(S@<A@> a, (A@){B@;} f) {
  a.?(cons: S@<B@>(cons: MapP<A@, B@>(a.cons, f)), nil: S0<B@>);
},
<@ A@, @ B@>(P@<A@>, (A@){B@;}){P@<B@>;} MapP = <@ A@, @ B@>(P@<A@> a, (A@){B@;} f) {
  P@<B@>(f(a.head), MapS<A@, B@>(a.tail, f));
};

# Insert the element 'x' into 'l' at the sorted position based on the le
# comparision function.
<@ T@>((T@, T@){Bool@;}, T@, S@<T@>){P@<T@>;} SortInsert =
  <@ T@>((T@, T@){Bool@;} le, T@ x, S@<T@> l) {
    l.?(cons: le(x, l.cons.head).?(
                  true: P@<T@>(x, l),
                  false: P@<T@>(l.cons.head, S@<T@>(cons: SortInsert<T@>(le, x, l.cons.tail)))),
         nil: P@<T@>(x, S0<T@>));
  };

# Sort the given list of elements, using LE for the comparisons.
# TODO: Use something more efficient than an insertion sort.
<@ T@>((T@, T@){Bool@;}, S@<T@>){S@<T@>;} SortS =
  <@ T@>((T@, T@){Bool@;} le, S@<T@> l) {
    l.?(cons: S@<T@>(cons: SortP<T@>(le, l.cons)), nil: l);
  },
<@ T@>((T@, T@){Bool@;}, P@<T@>){P@<T@>;} SortP =
  <@ T@>((T@, T@){Bool@;} le, P@<T@> l) {
    SortInsert<T@>(le, l.head, SortS<T@>(le, l.tail));
  };

<@ A@, @ B@>(S@<A@>, B@, (A@, B@){B@;}){ B@;}
ForS = <@ A@, @ B@>(S@<A@> l, B@ base, (A@, B@){B@;} body) {
  l.?(cons: ForS<A@, B@>(l.cons.tail, body(l.cons.head, base), body),
      nil: base);
};

# ForS_
#  A process version of ForS.
#
# TODO: Pick a better name for this.
<@ A@, @ B@>(S@<A@>, B@, (A@, B@) { B@!; }){ B@!; }
ForS_ = <@ A@, @ B@>(S@<A@> l, B@ base, (A@, B@) { B@!; } body) {
  l.?(
    cons: {
      B@ nbase := body(l.cons.head, base);
      ForS_<A@, B@>(l.cons.tail, nbase, body);
    },
    nil: !(base));
};

@(S@,
  ConsS, Append, S0, S,
  InitS, Concat, MapS,
  SortS, ForS, ForS_);
