Fble 0.4 Release
================
What's the plan?

Big categories of work right now are:
* Performance
 - Better data value packing.
 - Function call inlining.
* Modular compilation
* Debugger
* Fbld in C.
* Fbld core library revision.
* Fble standard library.
* New apps.

My vote:
1. Start with fbld in C. That should give some performance baseline and also
improve build times a bunch.

Then go from there, whatever I feel like. We have a pretty solid list of
options for things to work on. There's more than enough here for a release.
What's nice is these big things are mostly orthogonal.

---

Tracking my current stack of work:

Improve performance.
=> Improve profiling.
=> Write an http server in fble.
=> Improve OS IO handling in fble.
=> Implement proper modular compilation support.

---

The content for the release is shaping up nicely. I think we can declare the
scope of release clearly now:
* [fbld] fbld in C
* [lang] modular compilation
* [lib] improved OS IO handling
* [lib] TCP sockets library
* [app] network test protocols
* [app] experimental profile viewer

We'll punt the following to a later release:
* Performance improvements
* Debugger
* Fbld core library revision

Cool. So, some more explanation to do to see how far I want to go with the
experimental profile viewer. The rest is cleanup and burndown.

Question: do I want to re-write profiling for this release? How about: give it
a try. If it turns out to be too difficult, we can punt to next release. Try
enough to get decent enough experience writing fble for the experimental
profile viewer. That's the most important part: using the language and
learning from that experience.

---

I hereby consider the release feature complete. Let's punt the profiling
rewrite to the next release. This one is big enough as is. The draft of my
pprof viewer in fble is good enough experience writing fble for this release.

---

* Remove /Core/Map/Tree%.

Who all is still using the original implementation?
* /Invaders/Aliens%, with Alient@ coordinates as the key.
* /Hwdg/Memory%, with Coord@ as the key.
* /App/Drawing/Test%, with Point@ as the key.
* /Games/GameOfLife%, with Coord@ as the key.
* /Games/TicTacToe/AI%, with Board@ as the key.
* /Sat/Id% with Int@ as the key. Provides an InsertWith function.
* (DONE) /SatGame/Generate% with Int@ as the key.
* /Core/Set%, with IsEmpty function.

Note: we have a Union function implemented for Tree Map, but apparently nobody
is using it?

I would say there's value to keeping a /Core/Map/Tree% implementation around,
because it's presumably easier to implement Ord@ for your custom type than it
is to implement Map@. If you don't care about performance, then TreeMap is
good enough. Maybe we also want ListMap and HashMap libraries you can choose
from, all if you don't want to implement your own custom map.

It seems a shame we would have to implement two identical versions of map for
*(Int@ x, Int@ y) and *(Int@ row, Int@ col).

---

* Rename /Debug/Native% to /Debug/Builtin%?

There's no point in having the gdb based trace anymore, now that we can use
builtin based trace. I think best to have people continue to use the
/Core/Debug% interface rather than access the raw underlying implementation.
Builtin is a better name than Native.

My biggest concern here is we don't give any choice over where the debugging
output goes. Changing the name doesn't make that better or worse. Before trace
was only implemented explicitly via gdb though. This change would make it
always on.

Who is using /Core/Debug today?

Nobody. Nobody is using it.

Let's do this: ditch the gdb part. Update the debugging guide. Add a test
case that things don't crash?

---

* Add helper macros for defining static FbleString and FbleModulePath?

Specific to static strings, so we set refcount to 1. The user needs to provide
the name of the thing and the value of the string. I can think of two
approaches.

What we have today:

  static FbleString Filename = { .refcount = 1, .magic = FBLE_STRING_MAGIC, .str = __FILE__, };
  static FbleString StrCore = { .refcount = 1, .magic = FBLE_STRING_MAGIC, .str = "Core", };
  static FbleString StrDebug = { .refcount = 1, .magic = FBLE_STRING_MAGIC, .str = "Debug", };

Option 1:

  static FbleString Filename = FBLE_STATIC_STRING(__FILE__);
  static FbleString StrCore = FBLE_STATIC_STRING("Core");
  static FbleString StrDebug = FBLE_STATIC_STRING("Debug");

Option 2:

  FBLE_STATIC_STRING(Filename, __FILE__);
  FBLE_STATIC_STRING(StrCore, "Core");
  FBLE_STATIC_STRING(StrDebug, "Debug");


Honestly I prefer option 1. You don't have to know the implementation of
FBLE_STATIC_STRING to understand what its doing.

How about FbleModulePath?

static FbleModulePath Path = {
  .refcount = 1,
  .magic = FBLE_MODULE_PATH_MAGIC,
  .loc = { .source = &Filename, .line = __LINE__, .col = 1 },
  .path = { .size = 3, .xs = PathEntries},
};

Ideally I would like something like:

static FbleModulePath Path = FBLE_STATIC_MODULE_PATH("/Debug/Core/Builtin%");

That's not going to happen in practice. We can't deal with the variable length
arguments, and it doesn't let us define the intermediate things we need.

So much of these builtin module implementations is boiler plate. How nice
would it be if the compiler generated all that for us? And if we did that, no
need to make static strings easier to define, right?

I'm not sure what I want to do for this right now.

---

* Reorder /Core/Stdio%.Main@ function args to: Stdio, List, Monad@?
  Seems more natural to compose by adding extra things to the front.
  See /Network/Apps/Client% for example.

<<@>@>@ Main@ = <<@>@ M@>(Monad@<M@>, Stdio@<M@>, List@<String@>) { M@<Bool@>; };

Main@ Main = <<@>@ M@>(Sockets@<M@> sockets, Monad@<M@> m, Stdio@<M@> stdio, List@<String@> argv) { ... }

The idea is, Stdio@<M@> is an extra interface, just like Sockets@<M@> is an
extra interface. If you think about it, List@<String@> args is an extra
interface. And returning Bool@ is an interface. So we are combining 4 things:

* Return status
* Command line args
* stdio
* sockets

The monad is just a way to glue all those things together. It seems like the
status code being part of the return type is difficult to move, but command
line, stdio, and sockets can all easily be made optional.

Right now, Stdio and sockets are provided as builtin modules. The real top
level type is:

@ Main@ = (List@<String@>) { IO@<Bool@>; };

Notice there is no Monad@ there, it's implicit. So, if we were to start there,
I would say:

1.  @ Main@ = (List@<String@>) { IO@<Bool@>; };
The actual top level interface.

2.  <<@>@>@ Main@ = <<@>@ M@>(Monad@<M@>, List@<String@>) { M@<Bool@>; };
Generalizing (1) to abstract monadic type.

3.  <<@>@>@ Main@ = <<@>@ M@>(Stdio@<M@>, Monad@<M@>, List@<String@>) { M@<Bool@>; };
Adding optional stdio interface.

4.  <<@>@>@ Main@ = <<@>@ M@>(Sockets@<M@>, Stdio@<M@>, Monad@<M@>, List@<String@>) { M@<Bool@>; };
Adding optional sockets interface.

Sounds reasonable to me. This suggests: Stdio, then Monad, then List. Shall I
give it a try?

While I'm at it, I think I should change the return type to Int@ to match
status code?

Here's what's part of C99:

  int main(void)
  int main(int argc, char* argv[])

That suggests Int@.

Returning int is equivalent to ending your program call with exit();
EXIT_SUCCESS and EXIT_FAILURE are options, otherwise it's all undefined. You
can't assume 0 / non-zero, etc.

In that case, honestly, I think Bool@ makes more sense. True for EXIT_SUCCESS,
False for EXIT_FAILURE. If nothing else is portable, why give more options?

An alternative approach I could take is make an exit builtin.

Exit@<M@>:
  (Bool@) { M@<Unit@>; }

That way we could remove it from the return value. Call it from within fble
code. I'm not sure how I feel about that. Is it better? It's certainly more
modular. What happens if you don't return anything though? Yeah, you need to
return something. This forces you to do that. Makes sense.

Anyway, proposal then is to switch to:

<<@>@>@ Main@ = <<@>@ M@>(Stdio@<M@>, Monad@<M@>, List@<String@>) { M@<Bool@>; };

The only real practical impact, besides having to reorder arguments in a bunch
of places, is ... nothing.

Based on all that, I don't think it's worth the churn at this point.

It would only really matter if I were to provide an option to run a program as
<<@>@ M@>(Monad@<M@>, List@<String@>) { M@<Bool@>; }

Then it would simplify the implementation of Run for the Stdio@ type.

Well, I have reason to believe it's better this way, let's try it. If it's too
painful, ditch the attempt. If it isn't, we've made things a little bit nicer.
Don't forget to update tutorials!

Another way to think about it: are we more likely to change the stdio
interface or the monad interface? Like how with Map@ we are more likely to
change the value type than the key type.

I can't really change the implementation of Monad@ without changing the
implementation of Stdio@. But you could imagine different implementations of
Stdio@ with the same implementation of Monad@. That's reason to suggest Stdio
comes first too I think.

Turned out to be not too difficult. Done.

---

* Install the C version of fbld, not the fble version.

C implementation:
* $::b/fbld/fbld.

Fble implementation:
* $::b/pkgs/fbld/bin/fbld
* $bindir/fbld
* $mandir/man1/fbld.1

I need a man page for the C version. Is it the same interface?

Well, it doesn't have any usage info at all. It doesn't accept --help. It
takes a list of input files is all.

It is the same interface though. Where should the man page live? Probably in
the fbld directory.

Neither of them accept help arguments. I should fix that eventually.

