
* Don't Release args in NewStruct function.
* Split apply instr into call and tail call instructions.
* Abort by reading through instructions instead of using NULL to know what we
  own on the stack.
* Split compile into typecheck and codegen.
* Avoid emitting ref/release for non-recursive variables.
* Figure out how to do better lifecycle analysis in the compiler
 - Don't retain/release a field of an object if you know the object is going
   to stay alive as long as you need the field anyway.

* [eval] Would it improve performance to merge statics into the locals array?
  We don't have to own them. Just copy them all over when we push a frame.
  Then we avoid the need to switch when looking up a value, and we can store a
  frame index in a single word.

* [eval] Have option to turn off checking for nulls and other runtime errors?

* Clean up how we track io activity?

* Allow zero-argument functions in the language spec?

* [profile] Remove special block 0
 - Add block data at the profile level representing 'total' and special case
   that way instead. So that literally it is impossible for anyone to call
   into the root block except via new profile thread.

* [profile] Cleanup
 - Switch to convention that caller is responsible for enter block?
 - Replace AutoExitBlock with ReplaceBlock?

* [type] Inline fields and args data into FbleType objects?

* [gc] Implement generational gc?

* [test] Check if 6.4-proc-exec/eval/propagate-abort-blocking test fails when
  unused 'true' variable definition is removed.

* [eval] Thread management cleanup
 - Use fair thread traversal by starting over from root when yield occurs.

* [app] Change App% back to drawing over the previous screen?
 - It can figure out how to double buffer appropriately on the implementation
   side, for example by drawing the last two updates to the buffer.
 - Because presumably, if not much has changed, that can be much more
   efficient? And if a lot has changed, we can optimize 'Over' to throw away
   the previous frame entirely if you start with a blank screen?

   Maybe more accurate is, if your point of view isn't changing, delta is
   better. If your point of view is changing, you probably have to redraw
   everything regardless and it would be nice to avoid drawing a bunch of
   stuff and then covering it up right away.

* [invaders] Implement space invaders game.
 - Add aliens to the game.

* [compile] Do proper memory tracking and cleanup for the abstract syntax?
 - Implement FbleFreeProgram function
 - Figure out who is going to own source filenames. Maybe refcount them?
 - Is there an issue supporting heap and stack allocated expressions?

* [compile] Figure out why Normal is called so often
 - See if we can fix that to reduce the now annoyingly long compile times.
 - Profiling said its all in TypeEquals. Maybe something pathological?

* [lang] Set up cindent (or whatever) properly for fble.vim
 - For example, so you can do newline in a comment block and have it auto add
   the comment character.

* [cc] Implement .fble -> .o compiler
 - Goal is to significantly increase performance by removing the instruction
   fetch decode logic.

* [snake] Switch to a target 60 FPS?
* [snake] Test and fix bug when snake eats its tail.
* [snake] Ignore moves that aren't orthogonal to current snake direction.
* [snake] Keep track of and report score.
* [snake] Figure out why the background box gets lost some times.
* [pingpong] Render a static 3D table tennis scene.
* [gameoflife] Switch to a target 60 FPS?
* [invaders] Optimize space invaders game.
 - Figure out how I'm going to get to 60 FPS.
   Maybe try getting 60 FPS on the C implementation to see if it's reasonable?
 - Implement and test Alien simulation

* [lib] Add test coverage for the Int routines.
 - In particular, test Div and Mod.
* [lib] Separate Map from DataMap and EqMap.
* [lib] Add unit tests for /Map%.Equals.
* [lib] Separate List@ from S@ and P@ module wise.

* [api] Can fble-stdio check that the function has the right type?

* [compile] Test and fix error message for type of anonymous type let values.
 - The type should be the computed type for the value, not the introduced
   abstract type?

* [eval] Make child thread execution fair.
  Children should be time multiplexed, where priority is assigned based on how
  far down the family tree the child belongs. The amount of time a family gets
  to spend evaluating should be independent of the number of children in the
  family.

* [lang] Can a module reference itself? Clarify in the spec and test this case.
* [lang] Add support for abstract types?
* [lang] Document the runtime memory model,
  - Including that tail recursive functions should not smash the stack.
* [lang] Document and test that put ports don't retain link values.

* [release] Better error messages on types that have the same name but different values?
* [release] Write man pages for fble and friends?
* [release] Better error message for importing something from a module that
  is not defined in the module?

* [arena] Rethink arenas and documentation, because some cases appear to assume you
  have a bulk-free arena. Other cases its not well specified what is freed
  explicitly and what is expected to be freed implicitly.
  I claim a good model is: pass an arena to a function to say: the function
  allocates its result in this arena. The function creates and uses a separate
  arena for its intermediate allocations.

* [debugger] Implement an fble debugger. Features:
 - Set a breakpoint at a line in a file.
 - Step through code line by line.
 - Evaluate expressions in the context of the current scope and print the
   results.
 - Auto breakpoint at undefined behavior?
 
 Use cases:
 - Debug why sudoku solver isn't working properly by stepping through a line
   at a time and printing intermediate values.

   Turns out it wasn't too hard to figure out the problem in this case without
   a debugger.

 - Debug why snake AI wasn't working.

   It turns out we were using the wrong direction. A debugger to step through
   code and print variable values would have found this more quickly than my
   guess and check approach, which was pretty tedious.

