
@ Bool@ = /Bool%.Bool@;
% Not = /Bool%.Not;

@ Int@ = /Int/Int%.Int@;
% Add = /Int/Int%.Add;
% Sub = /Int/Int%.Sub;
% Int = /Int/Int/Lit%.Int;
% Le = /Int/Int/Eq%.Le;

@ Heap@ = /Fblf/Heap%.Heap@;
% Copy = /Fblf/Heap%.Copy;
% Write = /Fblf/Heap%.Write;
% Equals = /Fblf/Heap%.Equals;
% Equal = /Fblf/Heap%.Equal;

@ Program@ = /Fblf/Program%.Program@;
@ ProcId@ = /Fblf/Program%.ProcId@;
@ Stmt@ = /Fblf/Program%.Stmt@;
@ Cond@ = /Fblf/Program%.Cond@;
@ Var@ = /Fblf/Program%.Var@;
% LookupProc = /Fblf/Program%.LookupProc;

<@>@ List@ = /List%.List@;
<@,@>% ForEach = /List%.ForEach;
<@,@>% Map = /List%.Map;

# Look up the value of a variable in scope.
(List@<Int@>, Var@) { Int@; } Var = (List@<Int@> args, Var@ var) {
  Le(var.id, Int|0).?(
    true: Add(args.cons.head, var.offset),
    false: Var(args.cons.tail, Var@(Sub(var.id, Int|1), var.offset)));
};

# Eval --
#   Evaluate a condition.
(List@<Int@>, Cond@, Heap@) { Bool@; }
Eval = (List@<Int@> args, Cond@ cond, Heap@ heap) {
  Bool@ equals = cond.a.?(
    var: cond.b.?(
      var: Equal(heap, Var(args, cond.a.var), Var(args, cond.b.var), cond.n),
      const: Equals(heap, Var(args, cond.a.var), cond.b.const, cond.n)),
    const: cond.b.?(
      var: Equals(heap, Var(args, cond.b.var), cond.a.const, cond.n),
      const: /Maybe%.Nothing<Bool@>.just  # TODO: Implement this case.
  ));

  cond.op.?(eq: equals, ne: Not(equals));
};

# ExecStmt --
#   Execute a statement on the given heap.
#
# Behavior is undefined if the heap is not big enough for the program.
(Program@, List@<Int@>, Stmt@, Heap@) { Heap@; }
ExecStmt = (Program@ prog, List@<Int@> args, Stmt@ stmt, Heap@ heap) {
  stmt.?(
    assign: {
      stmt.assign.value.?(
        var: Copy(heap, Var(args, stmt.assign.var), Var(args, stmt.assign.value.var), stmt.assign.n),
        const: Write(heap, Var(args, stmt.assign.var), stmt.assign.value.const, stmt.assign.n));
    },

    sequence: {
      ForEach<Stmt@, Heap@>(stmt.sequence, heap, (Stmt@ p, Heap@ h) {
        ExecStmt(prog, args, p, h);
      });
    },

    ifelse: {
      Eval(args, stmt.ifelse.condition, heap).?(
        true: ExecStmt(prog, args, stmt.ifelse.if_body, heap),
        false: ExecStmt(prog, args, stmt.ifelse.else_body, heap));
    },

    while: {
      Eval(args, stmt.while.condition, heap).?(
        true: ExecStmt(prog, args, stmt, ExecStmt(prog, args, stmt.while.body, heap)),
        false: heap);
    },

    call: {
      List@<Int@> call_args = Map<Var@, Int@>(stmt.call.args, (Var@ v) {
        Var(args, v);
      });
      Exec(prog, stmt.call.proc, call_args, heap);
    });
},

# Exec --
#   Execute a procedure from the given program.
#
# Behavior is undefined if the heap is not big enough for the program.
(Program@, ProcId@, List@<Int@>, Heap@) { Heap@; }
Exec = (Program@ prog, ProcId@ proc, List@<Int@> args, Heap@ heap) {
  ExecStmt(prog, args, LookupProc(proc, prog).just.body, heap);
};

@(Exec);
