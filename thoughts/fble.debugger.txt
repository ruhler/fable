Fble Debugger
=============
Features:
 - Set a breakpoint at a line in a file.
 - Step through code line by line.
 - Evaluate expressions in the context of the current scope and print the
   results.
 - Auto breakpoint at undefined behavior?
 - Any way we could do this just by using dwarf + gdb?

Times in the past I wished I have an fble debugger:
 - Debug why sudoku solver isn't working properly by stepping through a line
   at a time and printing intermediate values.

   Turns out it wasn't too hard to figure out the problem in this case without
   a debugger.

 - Debug why snake AI wasn't working.

   It turns out we were using the wrong direction. A debugger to step through
   code and print variable values would have found this more quickly than my
   guess and check approach, which was pretty tedious.

 - Debug why sat solver test is failing.
   Manual code inspection doesn't reveal the issue. I really want to trace the
   code to see which unexpected branch is being taken.

   Manually tracing through the code by profiling block led straight to the
   problem: bad implementation of boolean Eq.

 - Debug why List Eq test is failing. I want to step through again.
   Sigh. I definitely need a debugger.

   Turns out False was being defined as True instead of False. I figured that
   out by changing the body of ListEq to always return False and being
   surprised when the result was as if it returned True.

 - Debug why map equality is failing when show shows identical maps
   { (1,1) => 1; } vs. { (1,1) => 1; }

   Turns out it was a bug in map quality, not too hard to find by code
   inspection.

 - Debug where we're getting stuck in an infinite recursion in fble that
   exhibits as a fast memory leak followed by OOM kill.

   This turned out to be big memory use, not infinite recursion. I tracked it
   down by minimizing the test case enough to run it to completion, and using
   profiling to see how many times different functions were being called.

 - Debug wrong tag in fble tests, where the invariants for what the tag should
   be are a bit complicated.
   
   Ideally we can run until we hit the error, then get a stack trace in the
   debugger and have a way to look at local variables and the stack trace to
   figure out where things are going wrong.

   Turned out to be a flaw in the code. Identified by minimizing the test case
   and working out the issue on paper. It would have been much easier if I
   could have stepped through the code and printed values of local variables
   along the way.

 - Debug why drawing a line from (0, 0) to (-2, -2) actually draws a line from
   (-1, -1) to (-3, -3), ideally by stepping through the code and viewing
   local variables at each step.
 
---

It doesn't look like gdb can easily support languages that are far different
from C. Perhaps it's worth trying to develop a custom debugger for fble. I can
avoid any overhead/dependency on gdb that way. But it also means I have to
implement the entire thing myself.

There are guides online for how to add a new language to gdb, which requires
modifying the gdb source code. That includes ways to specify how to print
types and expressions and how to parse types and expressions.

Could we use dwarf to pretend we are executing C code, and encode structs and
unions in a way that gdb can understand? Then at least for structs we could
see all the fields, and for unions, perhaps we could see the names of tag?
That's about as good as we could do anyway, right?

Dealing with the stack will be challenging, given tail calls and the fact that
the stack is managed. Perhaps it would be simpler if I finish implementing my
plan to use native stacks. Or perhaps not.

I'm thinking it is at least worth a try to emit dwarf information. In that
process I'll see what we can encode in dwarf and how, and how useful gdb is in
that case.

Let's go a ways down this route and see where we get. Initial goals:
* Be able to set break points and step through .fble files.
* Be able to print data type values as structs/unions based on variables on
  the stack.

Don't worry about stack traces yet. And let's focus on debugging compiled
code, which I suspect would be easier.

What happens today if we try to run a compiled program and set a breakpoint
based on an fble source file and line number? It says no such source file.

The first step, then, should be to see how we can get my .fble files included
in the list from 'info sources'. Let's download the dwarf spec and see how
to start with that.

---

My sample assembly program passes the file using a '.file' assembly directive
at the top of the generated assembly:

.arch armv8-a
.file "foo.c"

Within the assembly, I also see directives of the form:

.file 1 "foo.c"

And:

.loc 1 9 3
.loc 1 13 12 discriminator 3
.loc 1 13 12 is_stmt 0
.loc 1 13 12 is_stmt 1

My guess is what we need is:
* .file 1 "foo.c" somewhere near the top of the generated assembly file.
* .loc 1 <line> <col> for each line, and after the last line.

What does the gnu assembly docs say about these?
* The plain .file "foo.c" directive is deprecated
* https://www.sourceware.org/binutils/docs/as/index.html seems to have decent
  documentation of the directives.

The .loc options are all related to the .debug_line state machine, which I can
probably read about in the dwarf spec, page 151:

* lines and cols start at '1'
* is_stmt is a recommended breakpoint location
* discriminator is used in case multiple blocks have the same line, column,
  and file.

My guess is I don't have to worry about any of the line number options.

So, plan is simple:
* At the top of the generated assembly, emit a .file 1 "foo.c" directive.
* At the start of each emitted instruction, ...

We have to decide and track somehow which code instructions should have line
numbers associated with them. Or at least, which are starts of statements. We
also need to start tracking line number information more generally in
FbleInstr.

I would say a statement is:
* let bindings, branch of case expression, expression in a block or 'stmt'
  form, union_select statement, function bind, proc_link, and proc_exec.

Other things are not statements.

Can we use our profiling block locations as statements? We already have that
information available in the code block, and it has the location information.

Let's try this: profile enter and profile replace emit locations which will
correspond to statements. Try that.

It works! I can now set breakpoints on .fble files. Stepping through doesn't
work too well at this point, but it's a good start.

Question also: the profile blocks are basic blocks, not statements. This means
we'll skip over let expressions and things like that. It would be good if we
could add statements there. Maybe we could add a fake kind of profile op to
mark the beginning of a statement?

