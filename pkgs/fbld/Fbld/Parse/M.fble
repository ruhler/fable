
@ Bool@ = /Core/Bool%.Bool@;
% True = /Core/Bool%.True;
% False = /Core/Bool%.False;

@ Char@ = /Core/Char%.Char@;

<@>@ Maybe@ = /Core/Maybe%.Maybe@;
<@>% Just = /Core/Maybe%.Just;
<@>% Nothing = /Core/Maybe%.Nothing;

@ String@ = /Core/String%.String@;
% Str = /Core/String%.Str;
% Strs = /Core/String%.Strs;

@ Unit@ = /Core/Unit%.Unit@;
% Unit = /Core/Unit%.Unit;

@ Loc@ = /Fbld/Loc%.Loc@;

<@>@ Result@ = /Fbld/Result%.Result@;
<@>% Ok = /Fbld/Result%.Ok;
<@>% Err = /Fbld/Result%.Err;

@ Text@ = /Fbld/Text%.Text@;
% Text = /Fbld/Text%.Text;
% IsEmpty = /Fbld/Text%.IsEmpty;
% Empty = /Fbld/Text%.Empty;
% LocOf = /Fbld/Text%.LocOf;
% Head = /Fbld/Text%.Head;
% Tail = /Fbld/Text%.Tail;
% Flatten = /Fbld/Text%.Flatten;

<@>@ S@ = <@ T@> { *(Text@ in, T@ x); };

# M@ - A parser monad.
<@>@ M@ = <@ T@>(Text@) { Result@<S@<T@>>; };

# Return the given value.
<@ T@>(T@) { M@<T@>; }
Return = <@ T@>(T@ x)(Text@ in) {
  Ok(S@(in, x));
};

# Report a parse error.
<@ T@>(Text@) { M@<T@>; }
Error = <@ T@>(Text@ msg)(Text@ _) {
  Err<S@<T@>>(msg);
};

# Monadic Do for the parser monad.
<@ A@>(M@<A@>)<@ B@>((A@) { M@<B@>; }) { M@<B@>; }
Do = <@ A@>(M@<A@> ma)<@ B@>((A@) { M@<B@>; } f)(Text@ in) {
  Result@<S@<A@>> ra = ma(in);
  ra.?(err: Err<S@<B@>>(ra.err));
  f(ra.ok.x)(ra.ok.in);
};

# Returns the next character in the input stream without changing the parser
# state.
M@<Maybe@<Char@>> Peek = (Text@ in) {
  Maybe@<Char@> mc = {
    IsEmpty(in).?(true: Nothing<Char@>);
    Just(Head(in));
  };
  Ok(S@(in, mc));
};

# Returns the current location.
M@<Loc@> Loc = (Text@ in) {
  Ok(S@(in, LocOf(in)));
};

# Gets the next character in the input stream, advancing the parser state as
# appropriate.
M@<Maybe@<Char@>> Get = (Text@ in) {
  IsEmpty(in).?(true: Ok(S@(in, Nothing<Char@>)));
  Char@ c = Head(in);
  Ok(S@(Tail(in), Just(c)));
};
  
# Skips the next character in the input stream, advancing the parser state as
# appropriate.
M@<Unit@> Skip = {
  Maybe@<Char@> _ <- Do(Get);
  Return(Unit);
};

# Gets all the rest of the input text.
M@<Text@> GetText = (Text@ in) {
  Ok(S@(Empty(LocOf(in)), in));
};

# Try running a parser. If it succeeds, return the parsed value. If it fails,
# return Nothing.
<@ T@>(M@<T@>) { M@<Maybe@<T@>>; }
Try = <@ T@>(M@<T@> mx)(Text@ in) {
  Result@<S@<T@>> r = mx(in);
  r.?(err: Ok(S@(in, Nothing<T@>)));
  Ok(S@(r.ok.in, Just(r.ok.x)));
};

# Same as Try, but discards the result of a successful match.
<@ T@>(M@<T@>) { M@<Bool@>; }
Try_ = <@ T@>(M@<T@> mx) {
  Maybe@<T@> r <- Do(Try(mx));
  Return(r.?(just: True, nothing: False));
};

# Like Try, but never consumes any input.
<@ T@>(M@<T@>) { M@<Maybe@<T@>>; }
Test = <@ T@>(M@<T@> mx)(Text@ in) {
  Result@<S@<T@>> r = mx(in);
  r.?(err: Ok(S@(in, Nothing<T@>)));
  Ok(S@(in, Just(r.ok.x)));
};

# Same as Test, but discards the result of a successful match.
<@ T@>(M@<T@>) { M@<Bool@>; }
Test_ = <@ T@>(M@<T@> mx) {
  Maybe@<T@> r <- Do(Test(mx));
  Return(r.?(just: True, nothing: False));
};

# Runs a parser monad on the given input string.
<@ T@>(M@<T@>, Text@) { Result@<T@>; }
Run = <@ T@>(M@<T@> m, Text@ in) {
  Result@<S@<T@>> r = m(Flatten(in));
  r.?(err: Err<T@>(r.err));
  Ok(r.ok.x);
};

# Parse a specific string from the input stream. Fails if the input string
# does not match that string.
(String@) { M@<Unit@>; }
String = (String@ s) {
  s.?(nil: Return(Unit));
  Loc@ loc <- Do(Loc);
  Maybe@<Char@> mc <- Do(Get);
  mc.?(nothing: Error<Unit@>(Text(Strs[Str|'Expected ', Str[s.cons.head]], loc)));
  /Core/Char/Eq%.Eq(s.cons.head, mc.just).?(
    true: String(s.cons.tail),
    false: Error<Unit@>(Text(Strs[Str|'Expected ', Str[s.cons.head]], loc)));
};

# Helper function for adding an initial character to subsequently parsed text.
(Char@, Loc@, M@<Text@>) { M@<Text@>; }
ConsM = (Char@ c, Loc@ l, M@<Text@> mtail) {
  Text@ tail <- Do(mtail);
  Return(/Fbld/Text%.Cons(c, l, tail));
};

@(M@, Return, Error, Do, Peek, Loc, Get, Skip,
  Try, Try_, Test, Test_, String, GetText, ConsM,
  Run);
