
{ Bool%; @(Bool@, True, False, And, Not); };
{ Char%; @(Char@, Chars); };
{ List%; @(S@, S, S0, ConsS, Append); };
{ Maybe%; @(Maybe@); };
{ String%; @(Str@, Str); };
{ Test%; @(Test@, TestResult@); };
{ Unit%; @(Unit@, Unit); };

{ Data%; @(Data@, Left, Right, DUnit: Unit); };
{ Data_Eq%; @(Eq); };
{ DataMap%; @(DataMap@, Empty, Lookup, Insert, For); };

S@<Test@> Tests = {
  (Str@){Str@;} name = (Str@ nm) {
    Append<Char@>(Str(Chars|'DataMap.'), nm);
  };

  Data@ A = Left(DUnit);
  Data@ B = Right(Left(DUnit));
  Data@ C = Right(Right(DUnit));

  S<Test@>([
    Test@(name(Str(Chars|'empty')), $({
      ?(Lookup<Unit@>(Empty<Unit@>, B);
         just: TestResult@(fail:
           Str(Chars|'Lookup found something in an empty map')),
         nothing: TestResult@(pass: Unit));
    })),

    Test@(name(Str(Chars|'not found')), $({
      DataMap@<Unit@> map = Insert<Unit@>(Empty<Unit@>, C, Unit);
      ?(Lookup<Unit@>(map, B);
         just: TestResult@(fail:
           Str(Chars|'Lookup found B in a map with only C')),
         nothing: TestResult@(pass: Unit));
    })),

    Test@(name(Str(Chars|'found')), $({
      DataMap@<Bool@> map = Insert<Bool@>(Insert<Bool@>(Insert<Bool@>(Empty<Bool@>,
        A, False),
        B, True),
        C, False);
      Maybe@<Bool@> mv = Lookup<Bool@>(map, B);
      ?(mv;
         just:
           ?(mv.just;
              true: TestResult@(pass: Unit),
              false: TestResult@(fail:
                Str(Chars|'Wrong value found for B.'))
            ),
         nothing: TestResult@(fail:
           Str(Chars|'Failed to find B in map.')));
    })),

    Test@(name(Str(Chars|'replace')), $({
      DataMap@<Bool@> map = Insert<Bool@>(Insert<Bool@>(Empty<Bool@>,
        B, False),
        B, True);
      Maybe@<Bool@> mv = Lookup<Bool@>(map, B);
      ?(mv;
         just:
           ?(mv.just;
              true: TestResult@(pass: Unit),
              false: TestResult@(fail:
                Str(Chars|'Wrong value found for B.'))
            ),
         nothing: TestResult@(fail:
           Str(Chars|'Failed to find B in map.')));
    })),

    Test@(name(Str(Chars|'for')), $({
      DataMap@<Bool@> map =
        Insert<Bool@>(
          Insert<Bool@>(
            Insert<Bool@>(Empty<Bool@>,
              B, True),
            A, True),
          B, False);
      @ Entry@ = *(Data@ key, Bool@ value);
      S@<Entry@> entries = For<Bool@, S@<Entry@>>(map, S0<Entry@>,
        (Data@ k, Bool@ v, S@<Entry@> l) {
          ConsS<Entry@>(Entry@(k, v), l);
        });

      ?(entries;
        cons:
          ?(entries.cons.tail;
            cons:
              ?(entries.cons.tail.cons.tail;
                cons: TestResult@(fail: Str(Chars|'Too many entries.')),
                nil: {
                  ?(Eq(A, entries.cons.head.key);
                    true: @(a: entries.cons.head, 
                            b: entries.cons.tail.cons.head),
                    false: @(a: entries.cons.tail.cons.head, 
                             b: entries.cons.head));
                  ?(And(And(Eq(A, a.key), Eq(B, b.key)),
                        And(a.value, Not(b.value)));
                    true: TestResult@(pass: Unit),
                    false: TestResult@(fail: Str(Chars|'key/value mismatch'))
                  );
                }),
            nil: TestResult@(fail: Str(Chars|'Only 1 entry iterated over.'))),
        nil: TestResult@(fail: Str(Chars|'No entries iterated over.')));
    }))
  ]);
};

@(Tests);
