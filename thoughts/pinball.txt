Pinball Game
============

There are so many different games we could redo as a pinball game. For
example:
* skiball
* bowling
* breakout
* space invaders
* soccer
* platformer, like mario brothers or celeste
* Air hockey.

Initial proposal:
* Have a half court with sloping sides and paddles with a single object at the
  top of the screen that goes back and forth left and right in a fixed
  pattern. You have a score multiplier. Hit the object, you score the number
  of points on the score multiplier and double the score multiplier. Hit the
  ceiling you reset the score multiplier to 1. The game ends when the ball
  drops down the drain.

  Ideally we can print a score on the screen and keep track of high score and
  all that stuff. No fancy graphics required.

Current challenge:
* With just a ball and fixed edges, it's going way too slow. Averaging 4
  frames per second. We want to get it up to 60 frames per second. So let's do
  some profiling to figure out what's up.

Without looking at profiles yet, what I expect is:
* Maybe collision detection is expensive, given the performance seems tied
  directly to the number of edges in the screen. Maybe we can add a fast path
  cutout?
* Maybe drawing the circle every frame. We could just cache the drawing and
  translate it instead?

* Making a compiled version of pinball helps a bit.

Pinball app benchmark profile says:
* 70% of the time is spent drawing the triangles for the edges.

Let's fix that. Maybe it's finally time to add the optimization of drawing
triangles that are tall and skinny.

Actually, no need to redraw the triangles. Do the background drawing once and
reuse it.

---

The next performance issue is the rational arithmetic, mostly Add and Sub for
Rat@, which involves calls to /Int/Int%.Mul. Those multiplications account for
70% of the time now.

Perhaps this is because we introduced 3/5, 4/5 as rational numbers and we
don't reduce Rat@, so the denominator goes up and up and up leading to large
multiplications?

---

Reducing Rat@ made a big difference. That fixed the issue with integer
multiplication taking up all the time.

Setting restitution to 1 so that the ball bounces forever, it's starting to
look pretty good, except that there is a pause every time we collide with an
edge.

Perhaps not surprisingly, now all of our time is spent normalizing rational
numbers? Though maybe changing the ball to bounce forever isn't the right way
to look at things, if the performance issue is when collisions actually occur.

In particular, it's when the ball bounces off the diagonal edge that it
noticeably lags. Bouncing off vertical or horizontal edges appear to be fine.

Less than 5% of the profile is time spent in collisions, which suggests the
profile is not terribly meaningful for understanding the lag at time of
collision.

I tried changing the world to do lots of collisions against the diagonal
walls, but then it didn't lag so much.

I want to try using integers instead of rational numbers and see if it makes a
noticeable difference. Have everything be scaled by a factor of 128 and see
how that goes.

---

Turns out, the collision lag issue goes away if we fix precision to 1/128 at
intermediate computations of rational numbers. In that case, why not use Int@
instead of Rat@?

I'm not more prominently running into the issue where the ball manages to
escape it's box. I was having that with Rat@ too, but it seems more likely to
happen now with the precision limits. Any easy way to address that?

Switching from Rat@ to Int@ is almost 4x improvement in benchmark performance.

---

Next issue is the details of collision to make sure the ball doesn't magically
get energy from hitting a corner and eventually runs out of energy, but is
still able to roll on an incline.

It seems to do a collision at the end corner of an edge and get significant
boost to velocity in the negative tangential direction.

It's not about hitting the end of an edge, because it happens even if the two
intersecting edges intersect in the middle. And it only appears to happen on
the left hand corner, not the right hand corner.

Specifically, this is the ball rolling left on the floor towards the left
slope. It gets to the left slope, then slides up the left slope.

The order in which we test for collision doesn't seem to matter.

Try this math:

pos = (-2325/128, -11678/128)
vel = (-126/128, -4/128)

Understand why we go to
pos = (-2616/128, -11507/128)
vel = (-38/128, 98/128)

And in particular, how we can jump to the left by 291 units at once when the
X velocity is somewhere between -126 and -38.

Checking the math suggests the issue may be that 3/5 and 4/5 don't divide 128
evenly, so rotating forward and then backwards leads to funny behavior at time
of collision.

Seems things are better if we avoid use of RotateFrom for computing the new X
position. I worry that could lead to the possibility of the ball sinking
through the wall over time, but maybe that's not the case. It looks okay.
Gravity pushes it down, it doesn't actually go down, then the velocity from
collision pushes it back up a little. I think we are okay.

