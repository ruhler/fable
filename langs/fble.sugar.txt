Fble Syntactic Sugar
--------------------
Things that are clunky to do in fble syntax today:

1. String and integer literals
------------------------------
For example, we have from Md5:
  Bit32@ t01 = H8(d, 7, 6, a, a, 4, 7, 8);

I haven't even started using strings, because I assume the same:
  String@ hello = S5(h, e, l, l, o);

Ideally we have something more like:
  Bit32@ t01 = 0xd76aa478;
  String@ hello = "hello";

Note:
* ideal syntax supports arbitrary length. Today we have to define a
  constructor for every different length, which is not reasonable.
* ideal syntax has no separator between characters in the raw literal.
* elements of the literal are raw characters, not fble expressions.

Actual Uses:
* Md5 for Bit32 literals.
* String names and output descriptions for tests.

More generally: any densely packed raw information of arbitrary length where
explicit separators between units of information would lead to a significant
amount of overhead.

Proposal:
* Allow any kind of name with '...' and '...'@
Where ... is any sequence of characters aside from single quote. But we can
escape single quote with single quote using ''

For example:  'don''t use single quote'
And that becomes an atomic name.
* Allow string literal "...", which is any character except double quote. But
  we can escape double quote using "".

For example: "The double quote, "", is good to avoid"

You specify a struct s for decoding the string literal. The mapping is as
follows. For each character c in the string, you use the value of the field
s.'c'. Then you have two special pre-named operations:
s.cons, s.nil.

Thus: s"do, not." is desugared to:
  s.cons(s.'d',
  s.cons(s.'o',
  s.cons(s.',',
  s.cons(s.' ', 
  s.cons(s.'n', 
  s.cons(s.'o', 
  s.cons(s.'t', 
  s.cons(s.'.', 
  s.nil))))))))

Sounds good to me. Only questions are: the precise syntax to use, and whether
'cons' and 'nil' are the right names to use for the combination.

Fundamentally we want a way to describe an atomic sequence of characters in
the input program that may contain funny characters. These sequences of
characters are used for names and for string literals. Some, possibly nicer
ways of doing this:

* Allow raw escapes in the program:
    Foo\.bar
* Allow quotes, like in bash:
    'Foo.bar'
    Foo'.'bar
    ''

Using quotes is nice, because it lets you describe the empty sequence, and to
give a dense specification of some kinds of funny characters. We probably want
some form of escape characters regardless, for things like newline and other
non-printable characters. Perhaps it makes sense to just allow a combination
of the two. Then we have the following categories:

* printable non-syntax characters: [a-z_A-Z0-9], etc.
* printable syntax characters: [@[],{}+-()], etc.
* non-printable characters: \n, \xXXX, etc.

Then we add escape sequences for printable syntax characters: precede them
with a \. Then an escaped printable syntax character is treated just like a
printable non-syntax character. An escaped non-printable character is treated
just like a printable non-syntax character. And, within single quotes, a
non-escaped printable syntax character is treated like a printable non-syntax
character. And maybe we want a way to have non-escaped non-printable
characters be treated like printable non-syntax characters (like you can in
tcl using {} instead of ""), but who knows.

Then we could introduce a special syntax for string literals. Perhaps:
Concrete Syntax:  '~' name

Then you could do something like:
    { StrLit; ~'hello there';}
    { IntLit; ~1149;}

Anything better than '~'?

    { StrLit; ^ 'hello there';}
    { IntLit; ^ 1149;}

    { StrLit; % 'hello there';}
    { IntLit; % 1149;}

    { StrLit; ~ 'hello there';}
    { IntLit; ~ 1149;}

    { StrLit; `'hello there';}
    { IntLit; `1149;}

    { StrLit; "'hello there';}
    { IntLit; "1149;}

    { StrLit; '"hello there";}
    { IntLit; '1149;}

I like the last combination the best. Single quote to introduce a literal,
double quotes for the word quote?

"Foo.Bar"@ "foo.bar" := ...

It's too bad we can't pass these as arguments to functions. Like, it would be
nice to be able to do something like:

   Int('1149), or Str('1149)

Unless, in general, we say { x; y;} and x(y) are always treated as equivalent?
So that x(y) for struct value x means evaluate y in the context of the
namespace of x?

No. That doesn't make sense. I propose instead:

String literal: expr '|' word

For example:
  x.'foo,bar'
  IntLit|1149
  StrLit|'hello, there'
  Int|1149
  Str|'hello, there'

Where expr is a struct that will be used as the prefix to the desugared
string. This way literals are more contained. There's no need to want them to
be in the current environment. We can always capture a literal in an object
and put that literal in the environment just as easily.

I wish I could use '~' as the character, because Int~1149 and
Str~'hello, there' look quite nice to me, but that would conflict with the
link syntax. Oh well. Vertical bar is probably fine too.

Note: integer literals will be hard if the only operator we have is a cons
operator. In practice we want to do a fold with some intermediate state, and
the direction of the fold should be flexible?

How to express integer literals using monadic bind:

 1049:

{ S(1); M(0); M(4); E(9));

E :: Digit -> Int -> Int
E d x = 10 * x + d

M :: Digit -> (Int -> Int) -> (Int -> Int)
M d f x = f (10 * x + d)

S :: Digit -> (Int -> Int) -> Int
S d f = f d

More generally, it all looks like M, except:

E d x = M d id x
S d f = M d f 0

It's a reader monad. You supply functions from Int to Int and they are chained
together using a combination operator. Organized another way:

F = Sum([I(1), I(0), I(4), I(9))
x = F 0

I :: Digit -> (Int -> Int)
I d x = 10 * x + d

Plus :: (Int -> Int) -> (Int -> Int) -> (Int -> Int)
Plus a b = \x -> b (a x)

Which is just function composition. Given a list of digits, this is just a map
and fold. But to get the final number you need to provide the initial value 0.
This means you need to specify two things for the literal: how to map from
name to digit, and how to combine the digits in the end.

For the purpose of the literal, we could say the digits are already the
functions:

  4 = \x -> 10 * x + 4

Another option would be to change the literal syntax to:

  | word

Where we would desugar "|abcd" into:
  ... that's where it breaks down. We need to provide a type for the elements,
even if we could otherwise hard code the list type for the sequence.

New Proposal:

A string literal is a list literal with additional data. A struct with the
following fields

 '?' - a struct with fields of type E@, each field a single char word.
 '(' - a function L@ -> T@ to convert the completed list to desired end value.
 ',' - a function E@ -> L@ -> L@ to cons an element to the list.
 ')' - a element L@ representing the empty list 

S|"abc" is desugared to list literal syntax:
  S(S.'?'.a, S.'?'.b, S.'?'.c)


2. Lists
--------
Today we have:
    S9(a, b, c, d, e, f, g, h, i);
or: A(a, A(b, A(c, A(d, ...))))

Ideally we have something more like:
  [a, b, c, d, e, f, g, h, i]

Note:
* ideal syntax supports arbitrary length.
* ideal syntax lets you add something in the middle of the list without having
  to change anything at the beginning or end of the list specification.
* elements of the list are expressions.

Actual Uses:
* When forming lists of test cases for a test.

Proposal:
* Ideally we get something for free when we work out the proposal for monadic
  syntactic sugar. But unfortunately, I fear something like:
  {T a; T b; T c; T d; T e; T f; T g;} is a bit too tedious still.

* Or, hard code a list literal for a specific type and let people convert from
  lists? I'd rather avoid hard coding anything for a specific type if
  possible, because presumably there are more general and flexible ways of
  doing such things.

  Perhaps something more fundamental is something based on induction. You
  provide an inductive case and some base cases, and it matches whatever it
  can for inductive and base cases. Maybe we want to allow the base case to
  require 4, or 3, or 2, or 1 args rather than assume the base case works with
  0 args. For example, for a non-empty list literal.

My vote is to keep things relatively simple and just desugar a list literal:
    [a, b, c, d, e]

To function calls with an expected name:
     \,(a, \,(b, \,(c, \,(d, \,(e, '[]')))))

In other words, pick a name for the cons function and a name for the nil
value, where the proposed names here were ',' and '[]'.

Question: does this work with type parameterized lists? You kind of wish you
could automatically infer the type of the list rather than have to explicitly
specify it. I guess you could always do:
  { @(',': ConsS<Foo@>, '[]': S0<Foo@>); [a, b, c, d, e]; }

or:
  { List<Foo@>; [a, b, c, d, e]; }

Which isn't too bad? Except it is a little sad to have everything done by name
lookup without concrete type checking?

We can do the exact same for string literals:
  ~'hello' desugars to:
  \,(h, \,(e, \,(l, \(l, \(o, '[]')))))

Maybe ',' and ']' would be good names to pick, corresponding to the sugar
a, b, ..., ]?

New Proposal, to go along with string literals and allow nice support for
variable length argument functions:

A list literal is defined using a struct with the following fields:

 '(' - a function L@ -> T@ to convert the completed list to desired end value.
 ',' - a function E@ -> L@ -> L@ to cons an element to the list.
 ')' - a element L@ representing the empty list 

Assuming l is a struct of such type, an expression l(x, y, z) is desugared to:
  l.'('(l.','(x, l.','(y, l.','(z, l.')')))))

There is still some question as to how strict to be when checking the type of
l in terms of checking for no extra fields and proper types ahead of
desugaring.
  

3. Traversals
-------------
Today we have:

func ChooseBestMove(Board b, Player x; Position) {
  MaybePositionResult ul = MoveResult(b, x, Position:UL(Unit()));
  MaybePositionResult uc = MoveResult(b, x, Position:UC(Unit()));
  MaybePositionResult ur = MoveResult(b, x, Position:UR(Unit()));
  MaybePositionResult ml = MoveResult(b, x, Position:ML(Unit()));
  MaybePositionResult mc = MoveResult(b, x, Position:MC(Unit()));
  MaybePositionResult mr = MoveResult(b, x, Position:MR(Unit()));
  MaybePositionResult ll = MoveResult(b, x, Position:LL(Unit()));
  MaybePositionResult lc = MoveResult(b, x, Position:LC(Unit()));
  MaybePositionResult lr = MoveResult(b, x, Position:LR(Unit()));
  MaybePositionResult best = 
    ChooseBestMaybePosition(
      ChooseBestMaybePosition(
        ChooseBestMaybePosition(
          ChooseBestMaybePosition(ul, uc),
          ChooseBestMaybePosition(ur, ml)),
        ChooseBestMaybePosition(
          ChooseBestMaybePosition(mc, mr),
          ChooseBestMaybePosition(ll, lc))),
      lr);
  best.Just.position;
};
 
Nicer would have been:
  Best $ do
    Pos@ p <- positions();
    MaybePositionResult pr <- MoveResult(b, x, p);
    ...

Or for sudoku we have:
    InitialRowConstraints(s1(), input.s1,
    InitialRowConstraints(s2(), input.s2,
    InitialRowConstraints(s3(), input.s3,
    InitialRowConstraints(s4(), input.s4,
    InitialRowConstraints(s5(), input.s5,
    InitialRowConstraints(s6(), input.s6,
    InitialRowConstraints(s7(), input.s7,
    InitialRowConstraints(s8(), input.s8,
    InitialRowConstraints(s9(), input.s9,
      S0<Constraint>())))))))));
  };

We want:
    row <- AllSymbols();
    col <- AllSymbols();
    cell <- input[row][col];  # guards on Maybe type
    EqConstraint(CellId(row, col), cell);

Or:
    for (row : AllSymbols) {
      for (col : AllSymbols) {
        for (cell : input[row][col]) {
          ...

Proposed syntax today is bind:
  Foo@ x <- f;
  body;

Which is sugar for f((Foo@ x) { body; })

Note some alternatives:
* Monads in haskell: you don't specify the combining function on each line,
  but have a single combining function for a sequence of statements. This way
  you could easily describe a list: List { a; b; c; d; e;}

  But we know there are issues with monad composition. So maybe that's not the
  best approach.

Another example came up. Given a list of tests, we want something like:

  List<TestName@> fails;
  for (T : Tests) {
    Print(T.name);
    Result r := T.test;
    if (r.fail) {
      Print("failed");
      fails.append(T.name);
    }
  }

There are three parts:
1. traversal - iterating over all elements in Tests.
2. body - the function to actually apply.
3. combination - to collect the failing tests into 'fails' as output.

The current proposal for bind gives traversal and body, but doesn't help with
combination. If we used a monad, the assumption is that traversal and
combination are the same data type. It's easier to specify, but less general.
Is there an easy way to describe the combination here too? You could add it to
the traversal I suppose:

List<TestName@> fails = {
 Test@ T <- forEachM(tests, catMaybes);
   Print(T.name);
   Result r := T.test;
   if (r.fail) {
     Print("fail");
     Just(T.name);
   } else {
     Nothing;
   }
}

Where the type of forEachM is:
 [a] -> ([b] -> c) -> (a -> b) -> c 

That makes sense, right? Or maybe:
 [a] -> (b -> b -> b) -> (a -> b) -> b

So you are given a list of elements a, a way to turn each element a into a b,
and a way to collapse all the b together into a single element.
  
Or make it another argument to the function? Provide the accumulation so far
to the body? Or a function to finish the accumulation?

 [a] -> (a -> b -> b) -> b

List<TestName@> fails = {
 Test@ T, List<TestName@> fails <- forEachM(tests);
   Print(T.name);
   Result r := T.test;
   if (r.fail) {
     Print("fail");
     ConsS<TestName@>(T.name, fails);
   } else {
     fails;
   }
}

Maybe I just need to be creative using the existing syntax options to start.
  
Practical Uses:
* tictactoe, sudoku, etc.

