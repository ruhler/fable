Native Stack
============
Currently we use a mix of native and managed stack. The managed stack comes
from the days when we had concurrency built in and we used garbage collection
on the stack. Now that we don't have that, I think we can almost get rid of
the managed stack. Everything except for tail
calls.

How could we do that? And why should we?

The why is for cleanup purposes and performance. No need to have a managed
stack if we can do it with a native stack. In the case of no tail calls, we
can avoid any managed stack allocations entirely. In the case of tail calls, I
think we still need some allocation, to pass arguments from the callee back to
the caller so it can do the tail call on behalf of the callee.

For the how we could do it, I think we can go a step at a time. Starting with
result and func fields, which I think should be easy to get rid of. Right?

Maybe let's start with the function. Where do we use that?
* In tail call, to know what function to call. In other words, seems like
  we'll want to keep that for the tail call stack anyway.

Okay, how about return value?
* FbleThreadReturn uses that to know where to save the result.

So we need to save result pointer to know where to store the result. How about
making it more like a function? As in, FbleRunFunction can return the
FbleValue* which is the result. We use some other mechanism to notify of tail
call or abort conditions.

Except we still want to make sure FbleThreadReturn is called, to do the
profile exit block call? No. That can be done in the FbleThreadCall function.

Proposal: return NULL for abort, FbleValue* for finished, and some special
sentinel value for 'continue'. In case of continue, we continue from the tail
call stack, which we will have saved the func and args to call.

So, user API is:
  FbleValue* FbleThreadCall(heap, thread, func, args);
    Calls the function, returns the result, or NULL in case of abort.
  FbleValue* FbleThreadTailCall(heap, thread, func, args)
    Arranges for func and args to be called by the caller (internally via the
    managed tail call stack)

There is no FbleThreadReturn function. You just directly return NULL or the
value or the result of FbleThreadTailCall in any of those cases.

Now then, how do we manage profiling blocks and ownership of func and args?

Version 1:
* FbleThreadCall does the first enter call.
* FbleThreadCall does replace calls as required for tail calls.
* FbleThreadCall does the final exit call.
* FbleThreadCall retains args. Callee is responsible for freeing args.

Version 2:
* FbleThreadCall does the first enter call.
* FbleThreadCall does replace calls as required for tail calls.
* FbleThreadCall does the final exit call.
* Callee is not responsible for freeing any args.
* return transfers ownership of return value from callee to caller.

Version 2 sounds good. Simpler. Maybe good to jump directly to it?

Proposed changes are:
* Move all profiling stuff to FbleThreadCall function.
* Change things to return FbleValue* directly.
* Callee doesn't have ownership of args.
* Callee responsible for allocating space for its own locals.

Two of these things we can separate: profiling stuff, and args versus locals.
The last bit is going to be harder to separate. I think better to do the last
bit all at once.

Let's see if I can do the profiling change first. Then think about locals
versus args.

Good. Works great.

Next step: let's work on some uses of locals. Where do we have num_locals not
matching num_args?
* generate-c, if FbleCode stores a different number of locals than args.
* generate-aarch64.c, if FbleCode stores a different number of locals than
  args.

Just those two cases. How should we track locals in general? Still via
FbleExecutable? I think there are two separate parts:
1. Passing num locals from compiler to codegen/interpreter.
2. Using num locals for generated code / interpreter.

Trouble is, currently we assume args and locals are contiguous. And maybe we
allow the compiler to reuse arg space for locals? In an instruction, we would
need to know whether an variable is in an arg versus in a local versus in a
static. That requires changes to instructions. It's not so easy to change. But
kind of a prerequisite for using the native stack, because the caller doesn't
know how much local variable space to allocate, but it does know how many args
to allocate.

I think this is a change worth doing, and before we try to make more use of
the native stack. It means working out the front end details:

* Add an FBLE_ARGS_FRAME_SECTION.
* Change FbleCode to have instrs and num_locals.
* Remove num_locals from FbleExecutable*.
...

The real question is whether there is an incremental path to implement this,
or if we just need to do it all in one big change.

I'm thinking this will be easiest as an all in one big change. Which isn't to
say it will be easy.

Okay. Let's brainstorm the list of changes to make all at once:
* Add an FBLE_ARGS_FRAME_SECTION.
* Update everywhere we refer to frame section to support this new case.
* Make sure to fix GET and GET_STRICT macros to handle all three cases of
  section.
* Update compiler to distinguish between args and locals.
* Rename 'locals' variable of run function to 'args'.
* Allocate local 'locals' variable in interpreter and generated c and aarch64
  code.
* Add num_locals field to FbleCode.
* Remove num_locals from FbleExecutable*.
* Update disassembler for these changes.

Wish me luck.

